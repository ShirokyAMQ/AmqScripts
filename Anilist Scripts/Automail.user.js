// ==UserScript==
// @name         Automail
// @namespace    http://tampermonkey.net/
// @version      10.2.1
// @description  Extra parts for Anilist.co
// @description:nn-NO Ekstradelar for Anilist.co
// @author       hoh
// @match        https://anilist.co/*
// @grant        GM_xmlhttpRequest
// @license      GPL-3.0-or-later
// ==/UserScript==
// SPDX-FileCopyrightText: 2019-2022 hoh and the Automail contributors
//
// SPDX-License-Identifier: GPL-3.0-or-later
(function(){
"use strict";
const scriptInfo = {
	"version" : "10.2.1",
	"name" : "Automail",
	"link" : "https://greasyfork.org/en/scripts/370473-automail",
	"repo" : "https://github.com/hohMiyazawa/Automail",
	"firefox" : "https://github.com/hohMiyazawa/Automail/releases",
	"chrome" : "NO KNOWN BUILDS",
	"author" : "hoh",
	"authorLink" : "https://anilist.co/user/hoh/",
	"license" : "GPL-3.0-or-later"
};
/*
	A collection of enhancements for Anilist.co
*/
/*
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	<https://www.gnu.org/licenses/>.
*/
/*
"useScripts" contains the defaults for the various modules. This is stored in the user's localStorage.
Many of the modules are closely tied to the Anilist API
Other than that, some data loaded from MyAnimelist is the only external resource

Optionally, a user may give the script privileges through the Anilist grant system, enabling some additional modules
*/
const script_type = "Automail"

/* GENERAL STRUCTURE:
 1. Settings
 2. CSS
 3. tools and helper functions
 4. The old modules, as individual callable functions
 5. The URL matcher, for making the modules run at the right sites
 6. Old module descriptions
 7. The new modules
*/
//begin "settings.js"
//this is not the code for the settings page! See /src/modules/settingsPage.js for that
try{
	localStorage.setItem("test","test");
	localStorage.removeItem("test");
}
catch(e){
	console.log("LocalStorage, required for saving settings, is not available. " + script_type + " may not work correctly.")
}

const notificationColourDefaults = {
	"ACTIVITY_LIKE":             {"colour":"rgb(250,122,122)","supress":false},
	"ACTIVITY_REPLY_LIKE":       {"colour":"rgb(250,122,122)","supress":false},
	"THREAD_COMMENT_LIKE":       {"colour":"rgb(250,122,122)","supress":false},
	"THREAD_LIKE":               {"colour":"rgb(250,122,122)","supress":false},
	"THREAD_COMMENT_REPLY":      {"colour":"rgb(61,180,242)", "supress":false},
	"ACTIVITY_REPLY":            {"colour":"rgb(61,180,242)", "supress":false},
	"ACTIVITY_MESSAGE":          {"colour":"rgb(123,213,85)", "supress":false},
	"FOLLOWING":                 {"colour":"rgb(123,213,85)", "supress":false},
	"ACTIVITY_MENTION":          {"colour":"rgb(123,213,85)", "supress":false},
	"THREAD_COMMENT_MENTION":    {"colour":"rgb(123,213,85)", "supress":false},
	"THREAD_SUBSCRIBED":         {"colour":"rgb(247,191,99)", "supress":false},
	"ACTIVITY_REPLY_SUBSCRIBED": {"colour":"rgb(247,191,99)", "supress":false},
	"RELATED_MEDIA_ADDITION":    {"colour":"rgb(247,191,99)", "supress":false},
	"MEDIA_DATA_CHANGE":         {"colour":"rgb(247,191,99)", "supress":false},
	"MEDIA_MERGE":               {"colour":"rgb(247,191,99)", "supress":false},
	"MEDIA_DELETION":            {"colour":"rgb(247,191,99)", "supress":false},
	"AIRING":                    {"colour":"rgb(247,191,99)", "supress":false}
};

//this is the legacy way of specifying default modules, use exportModule's isDefault instead.
let useScripts = {
	socialTab: true,
	socialTabFeed: true,
	forumMedia: true,
	staffPages: true,
	completedScore: true,
	droppedScore: false,
	studioFavouriteCount: true,
	CSSfavs: true,
	CSScompactBrowse: true,
	CSSgreenManga: true,
	CSSfollowCounter: true,
	CSSprofileClutter: false,
	CSSdecimalPoint: false,
	CSSverticalNav: false,
	CSSbannerShadow: true,
	CSSdarkDropdown: true,
	hideLikes: false,
	dubMarker: false,
	CSSsmileyScore: true,
	feedCommentFilter: false,
	feedCommentComments: 0,
	feedCommentLikes: 0,
	colourPicker: false,
	colourSettings: [],
	progressBar: false,
	noRewatches: false,
	hideCustomTags: false,
	titlecaseRomaji: false,
	shortRomaji: false,
	replaceNativeTags: true,
	draw3x3: true,
	newChapters: true,
	limitProgress8: false,
	limitProgress10: false,
	tagIndex: true,
	expandRight: false,
	timeToCompleteColumn: false,
	mangaGuess: true,
	settingsTip: true,
	MALscore: false,
	MALserial: false,
	MALrecs: false,
	entryScore: true,
	showRecVotes: true,
	activityTimeline: true,
	browseFilters: true,
	embedHentai: false,
	comparissionPage: true,
	noImagePolyfill: false,
	blockWord: false,
	showMarkdown: true,
	myThreads: false,
	dismissDot: true,
	statusBorder: false,
	moreImports: true,
	plussMinus: true,
	milestones: false,
	allStudios: false,
	termsFeedNoImages: false,
	customCSS: false,
	rightToLeft: false,
	subTitleInfo: false,
	customCSSValue: "",
	pinned: "",
	negativeCustomList: false,
	globalCustomList: false,
	betterListPreview: true,
	homeScroll: true,
	blockWordValue: "nsfw",
	hideGlobalFeed: false,
	cleanSocial: false,
	SFWmode: false,
	hideAWC: false,
	hideOtherThreads: false,
	forumPreviewNumber: 3,
	profileBackground: true,
	profileBackgroundValue: "inherit",
	viewAdvancedScores: true,
	betterReviewRatings: true,
	notificationColours: notificationColourDefaults,
	staffRoleOrder: "alphabetical",
	titleLanguage: "ROMAJI",
	dubMarkerLanguage: "English",
	accessToken: "",
	comparisionColourFilter: true,
	comparisionSystemFilter: false,
	annoyingAnimations: true,
	navbarDroptext: true,
	browseSubmenu: false,
	reinaDarkEnable: false,
	customDefaultListOrder: "",
	softBlock: [],
	partialLocalisationLanguage: "English"
};

let userObject;
let whoAmI = "";
let whoAmIid = 0;
try{
	userObject = JSON.parse(localStorage.getItem("auth"));
}
catch(err){
	console.warn("could not get userObject")
}
if(userObject){
	whoAmI = userObject.name
	useScripts.titleLanguage = userObject.options.titleLanguage;
	whoAmIid = userObject.id
}
else{
	try{
		whoAmI = document.querySelector(".nav .links .link[href^='/user/']").href.match(/\/user\/(.*)\//)[1]//looks at the navbar
	}
	catch(e){
		console.warn("could not get username")
	}
}

//Script is boneless: enable
//User is mod: enable
//user is hoh: enable
if(script_type !== "Boneless" && userObject && (userObject.donatorTier > 0 && (new Date()).valueOf() > (new Date('2020-09-01T03:24:00')).valueOf()) && userObject.name !== "hoh" && !userObject.moderatorStatus){
	alert("Sorry, " + script_type + " does not work for donators")
	return
}

if(document.hohTypeScriptRunning){
	console.warn("Duplicate script detected. Please make sure you don't have more than one instance of " + script_type + " or similar installed");
	return
}
document.hohTypeScriptRunning = script_type;

let forceRebuildFlag = false;

useScripts.save = function(){
	localStorage.setItem("hohSettings",JSON.stringify(useScripts))
};
const useScriptsSettings = JSON.parse(localStorage.getItem("hohSettings"));
if(useScriptsSettings){
	let keys = Object.keys(useScriptsSettings);
	keys.forEach(//this is to keep the default settings if the version in local storage is outdated
		key => useScripts[key] = useScriptsSettings[key]
	)
}
useScripts.save();
//end "settings.js"

//begin "alias.js"
const moreStyle = create("style");
moreStyle.id = "conditional-" + script_type.toLowerCase() + "-styles";
moreStyle.type = "text/css";

let createAlias = function(alias){
	if(alias[0] === "css/"){
		moreStyle.textContent += alias[1]
	}
	else{
		const dataSelect = `[href^="${alias[0]}"]`;
		const targetName = alias[1].substring(0,Math.min(100,alias[1].length));
		moreStyle.textContent += `
.title > a${dataSelect}
,a.title${dataSelect}
,.overlay > a.title${dataSelect}
,.media-preview-card a.title${dataSelect}
,.quick-search-results .el-select-dropdown__item a${dataSelect}> span
,.media-embed${dataSelect} .title
,.status > a.title${dataSelect}
,.role-card a.content${dataSelect} > .name{
	visibility: hidden;
	line-height: 0px;
}
.results.media a.title${dataSelect}
,.home .status > a.title${dataSelect}{
	font-size: 2%;
}

a.title${dataSelect}::before
,.quick-search-results .el-select-dropdown__item a${dataSelect} > span::before
,.role-card a.content${dataSelect} > .name::before
,.home .status > a.title${dataSelect}::before
,.media-embed${dataSelect} .title::before
,.overlay > a.title${dataSelect}::before
,.media-preview-card a.title${dataSelect}::before
,.title > a${dataSelect}::before{
	content:"${targetName}";
	visibility: visible;
}`;
	}
}

const shortRomaji = (useScripts.titlecaseRomaji ? [
["/anime/1535/","Death Note"],
["/anime/11061/","Hunter×Hunter (2011)"],
["/anime/20/","Naruto"],
["/anime/1735/","Naruto: Shippuuden"],
["/anime/21/","One Piece"],
["/anime/2167/","Clannad"],
["/anime/4059/","Clannad: Mou Hitotsu no Sekai, Tomoyo-hen"],
["/anime/6351/","Clannad: After Story - Mou Hitotsu no Sekai, Kyou-hen"],
["/anime/4181/","Clannad: After Story"],
["/anime/105333/","Dr. Stone"],
["/anime/6702/","Fairy Tail"],
["/anime/8074/","Highschool of the Dead"],
["/anime/9515/","Highschool of the Dead - Drifters of the Dead"],
["/anime/10793/","Guilty Crown"],
["/anime/13411/","Guilty Crown: Lost Christmas"],
["/anime/13561/","Guilty Crown: 4-koma Gekijou"],
["/anime/12419/","Guilty Crown Kiseki: Reassortment"],
["/anime/13601/","Psycho-Pass"],
["/anime/20513/","Psycho-Pass 2"],
["/anime/100388/","Banana Fish"],
["/anime/107660/","Beastars"],
["/anime/114194/","Beastars 2"],
["/anime/136880/","Beastars 3"],
["/anime/19/","Monster"],
["/anime/32/","Shin Seiki Evangelion: The End of Evangelion"],
["/anime/97980/","Re:Creators"],
["/anime/889/","Black Lagoon"],
["/anime/110349/","Great Pretender"],
["/anime/20812/","Shirobako"],
["/anime/20938/","Shirobako Specials"],
["/anime/101574/","Shirobako Movie"],
["/anime/16870/","The Last: Naruto the Movie"],
["/anime/21123/","Drifters"],
["/anime/97988/","Drifters OVA"],
["/anime/20607/","Ping Pong the Animation"],
["/anime/110350/","ID: Invaded"],
["/anime/140960/","Spy×Family"],
["/manga/30124/","Aqua"],
["/manga/30081/","Aria"],
["/anime/477/","Aria the Animation"],
["/anime/962/","Aria the Natural"],
["/anime/5244/","Aria the Natural: Sono Futatabi Deaeru Kiseki ni..."],
["/anime/2563/","Aria the OVA: Arietta"],
["/anime/3297/","Aria the Origination"],
["/anime/5196/","Aria the Origination Picture Drama"],
["/anime/4772/","Aria the Origination: Sono Choppiri Himitsu no Basho ni..."],
["/anime/21043/","Aria the Avvenire"],
["/anime/117556/","Aria the Crepuscolo"],
["/anime/130558/","Aria the Benedizione"],
["/anime/320/","Kite"],
["/anime/47/","Akira"],
["/manga/30001/","Monster"],
["/manga/30011/","Naruto"],
["/manga/30012/","Bleach"],
["/manga/30013/","One Piece"],
["/manga/30021/","Death Note"],
["/manga/30026/","Hunter×Hunter"],
["/manga/30149/","Blame!"],
["/manga/30598/","Fairy Tail"],
["/manga/30664/","Akira"],
["/manga/30745/","Pluto"],
["/manga/98587/","Beastars"],
["/manga/98416/","Dr. Stone"],
["/manga/108556/","Spy×Family"],
["/manga/114960/","Mashle"],
["/manga/85603/","Psycho-Pass"]
]
 : []).concat(
	(useScripts.shortRomaji ? [
["/anime/30/","Evangelion"],
["/anime/32/","End of Evangelion"],
["/anime/33/","Berserk"],
["/anime/44/","Rurouni Kenshin: Tsuioku-hen"],
["/anime/45/","Rurouni Kenshin"],
["/anime/400/","Outlaw Star"],
["/anime/513/","Laputa"],
["/anime/528/","Mewtwo no Gyakushuu"],
["/anime/530/","Sailor Moon"],
["/anime/532/","Sailor Moon S"],
["/anime/572/","Nausicaä"],
["/anime/740/","Sailor Moon R"],
["/anime/849/","Haruhi"],
["/anime/996/","Sailor Moon Sailor Stars"],
["/anime/949/","Gunbuster!"],
["/anime/1089/","Macross: Ai Oboete Imasu ka"],
["/anime/1239/","Sailor Moon SuperS"],
["/anime/1575/","Code Geass"],
["/anime/2001/","Gurren Lagann"],
["/anime/2025/","Darker than BLACK"],
["/anime/2904/","Code Geass R2"],
["/anime/4382/","Haruhi (2009)"],
["/anime/5114/","Fullmetal Alchemist: Brotherhood"],
["/anime/8074/","HIGHSCHOOL OF THE DEAD"],
["/anime/8769/","OreImo"],
["/anime/8795/","Panty & Stocking"],
["/anime/9756/","Madoka★Magica"],
["/anime/9989/","AnoHana"],
["/anime/10020/","OreImo Specials"],
["/anime/10620/","Mirai Nikki"],
["/anime/13659/","OreImo 2"],
["/anime/14741/","Chuunibyou!"],
["/anime/14813/","OreGairu"],
["/anime/20698/","OreGairu 2"],
["/anime/108489/","OreGairu 3"],
["/anime/16592/","Danganronpa"],
["/anime/16742/","WataMote"],
["/anime/17074/","Monogatari Second Season"],
["/anime/18671/","Chuunibyou! 2"],
["/anime/18677/","Yuushibu"],
["/anime/18857/","OreImo 2 Specials"],
["/anime/19221/","NouKome"],
["/anime/19603/","Unlimited Blade Works"],
["/anime/20474/","JoJo: Stardust Crusaders"],
["/anime/20799/","JoJo: Stardust Crusaders 2"],
["/anime/21450/","JoJo: Diamond wa Kudakenai"],
["/anime/102883/","JoJo: Ougon no Kaze"],
["/anime/131942/","JoJo: Stone Ocean"],
["/anime/20623/","Kiseijuu"],
["/anime/20792/","Unlimited Blade Works 2"],
["/anime/20910/","Shimoseka"],
["/anime/20920/","Danmachi"],
["/anime/21202/","Konosuba!"],
["/anime/21355/","Re:Zero"],
["/anime/108632/","Re:Zero 2"],
["/anime/119661/","Re:Zero 2 part 2"],
["/anime/21574/","Konosuba!: Kono Subarashii Choker ni Shufuku wo!"],
["/anime/21699/","Konosuba! 2"],
["/anime/20791/","Heaven’s Feel I. presage flower"],
["/anime/21718/","Heaven’s Feel II. lost butterfly"],
["/anime/21719/","Heaven’s Feel III. spring song"],
["/anime/21860/","Sukasuka"],
["/anime/97907/","Death March"],
["/anime/97938/","Boruto"],
["/anime/100182/","SAO: Alicization"],
["/anime/100183/","Gun Gale Online"],
["/anime/101166/","Danmachi: Orion no Ya"],
["/anime/101291/","Bunny Girl-senpai"],
["/anime/101921/","Kaguya-sama wa Kokurasetai"],
["/anime/104157/","Bunny Girl-senpai Movie"],
["/anime/105156/","Shinchou Yuusha"],
["/anime/108465/","Mushoku Tensei"],
["/anime/127720/","Mushoku Tensei 2"],
["/anime/108759/","SAO: War of Underworld"],
["/anime/114308/","SAO: War of Underworld 2"],
["/anime/112301/","Maou Gakuin no Futekigousha"],
["/anime/130588/","Maou Gakuin no Futekigousha 2"],
["/anime/130590/","Maou Gakuin no Futekigousha 2 part 2"],
["/anime/112641/","Kaguya-sama wa Kokurasetai 2"],
["/manga/86635/","Kaguya-sama wa Kokurasetai"],
["/manga/31517/","JoJo: Phantom Blood"],
["/manga/31630/","JoJo: Sentou Chouryuu"],
["/manga/30872/","JoJo: Stardust Crusaders"],
["/manga/33006/","JoJo: Diamond wa Kudakenai"],
["/manga/33008/","JoJo: Ougon no Kaze"],
["/manga/33009/","JoJo: Stone Ocean"],
["/manga/31706/","JoJo: Steel Ball Run"],
["/manga/55515/","JoJo: JoJolion"]
]
 : [])
);
//end "alias.js"

//a shared style node for all the modules. Most custom classes are prefixed by "hoh" to avoid collisions with native Anilist classes
let style = document.createElement("style");
style.id = "automail-styles";
style.type = "text/css";

//The default colour is rgb(var(--color-blue)) provided by Anilist, but rgb(var(--color-green)) is preferred for things related to manga
style.textContent = `
body{
	margin: 0px;
}
.markdown img{
	image-orientation: from-image;/*useful fix, but not universally supported*/
}
#hohSettings{
	margin-top: 20px;
	display: none;
}
.apps + #hohSettings{
	display: inline;
}
#hohSettings textarea,
#hohSettings input,
#hohSettings select,
.hohNativeInput{
	color: inherit;
	background-color: rgb(var(--color-foreground-grey));
	border-width: 1px;
	padding: 3px;
	border-radius: 3px;
}
.hohTime{
	position: absolute;
	right: 12px;
	top: 6px;
	font-size: 1.1rem;
}
.hohUnread{
	border-right: 8px;
	border-color: rgba(var(--color-blue));
	border-right-style: solid;
}
.hohNotification{
	margin-bottom: 10px;
	background: rgb(var(--color-foreground));
	border-radius: 4px;
	justify-content: space-between;
	line-height: 0;
	min-height: 72px;
	position: relative;
}
.hohNotification *{
	line-height: 1.15;
}
.hohUserImageSmall{
	display: inline-block;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	position: absolute;
	z-index: 10;
}
.hohUserImage{
	height: 72px;
	width: 72px;
	display: inline-block;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	position: absolute;
}
.hohMediaImage{
	height: 70px;
}
.hohMessageText{
	position: absolute;
	margin-top: 30px;
	margin-left: 80px;
}
.hohMediaImageContainer{
	vertical-align: bottom;
	margin-left: 400px;
	display: inline;
	position: relative;
	display: inline-block;
	min-height: 70px;
	width: calc(100% - 500px);
	text-align: right;
	padding-bottom: 1px;
}
.hohMediaImageContainer > a{
	height: 70px;
	line-height: 0!important;
	display: inline-block;
	z-index: 11;
	width: 50px;
	margin-right: 5px;
	background: rgb(var(--color-background),0.8);
	margin-top: 1px;
	margin-bottom: 1px;
}
span.hohMediaImageContainer{
	line-height: 0!important;
}
.hohBackgroundCover{
	height: 70px;
	width: 50px;
	display: inline-block;
	background-repeat: no-repeat;
	object-fit: cover;
	object-position: center;
	background-position: 50%;
	background-size: cover;
	line-height: 0;
}
.hohCommentsContainer{
	margin-top: 5px;
}
.hohCommentsArea{
	margin: 10px;
	display: none;
	padding-bottom: 2px;
	margin-top: 5px;
	width: 95%;
}
.hohCommentsContainer > a.link{
	font-size: 1.3rem;
}
.hohComments{
	float: right;
	display: none;
	margin-top: -21px;
	margin-right: 10px;
	cursor: pointer;
	margin-left: 600px;
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}
.hohCombined .hohComments{
	display: none!important;
}
.hohQuickCom{
	padding: 5px;
	background-color: rgb(var(--color-background));
	margin-bottom: 5px;
	position: relative;
}
.hohQuickComName{
	margin-right: 15px;
	color: rgb(var(--color-blue));
}
.hohThisIsMe{
	color: rgb(var(--color-green));
}
.hohILikeThis{
	color: rgb(var(--color-red));
}
.hohQuickComName::after{
	content: ":";
}
.hohQuickComContent{
	margin-right: 40px;
	display: block;
}
.hohQuickComContent > p{
	margin: 1px;
}
.hohQuickComLikes{
	position: absolute;
	right: 5px;
	bottom: 5px;
	display: inline-block;
}
.hohQuickComContent img {
	max-width: 100%;
}
.hohSpoiler::before{
	color: rgb(var(--color-blue));
	cursor: pointer;
	background: rgb(var(--color-background));
	border-radius: 3px;
	content: "Spoiler, click to view";
	font-size: 1.3rem;
	padding: 0 5px;
}
.hohSpoiler.hohClicked::before{
	display: none;
}
.hohSpoiler > span{
	display: none;
}
.hohMessageText > span > div.time{
	display: none;
}
.hohUnhandledSpecial > div{
	margin-top: -15px;
}
.hohMessageText a.link,
.hohNewMedia a{
	color: rgb(var(--color-blue));
}
.hohNewMedia a[href^="/manga/"]{
	color: rgb(var(--color-green));
}
.hohDataChange a{
	color: rgb(var(--color-blue));
}
.hohDataChange .expand-reason{
	display: none;
}

.hohMonospace{
	font-family: monospace;
}
.hohCode{
	font-family: monospace;
	background: rgb(var(--color-background));
	overflow-x: scroll;
	padding: 2px;
}
.hohStatsTrigger{
	cursor: pointer;
	border-radius: 3px;
	color: rgb(var(--color-text-lighter));
	display: block;
	font-size: 1.4rem;
	margin-bottom: 8px;
	margin-left: -10px;
	padding: 5px 10px;
	font-weight: 700;
}
.hohActive{
	background: rgba(var(--color-foreground),.8);
	color: rgb(var(--color-text));
	font-weight: 500;
}
.hohSlidePlayer{
	display: block;
	position: relative;
	width: 500px;
}
.hohSlide{
	position: absolute;
	top: 0px;
	font-size: 500%;
	height: 100%;
	display: flex;
	align-items: center;
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	opacity: 0.5;
}
.hohSlide:hover{
	background-color: rgba(0,0,0,0.4);
	cursor: pointer;
	opacity: 1;
}
.hohRightSlide{
	right: 0px;
	padding-left: 10px;
	padding-right: 20px;
}
.hohLeftSlide{
	left: 0px;
	padding-left: 20px;
	padding-right: 10px;
}
.hohShare{
	position: absolute;
	right: 12px;
	top: 30px;
	cursor: pointer;
	color: rgb(var(--color-blue-dim));
}
.activity-entry{
	position: relative;
}
.activity-entry.activity-text{
	border-right-width: 0px!important;
}
.hohEmbed{
	border-style: solid;
	border-color: rgb(var(--color-text));
	border-width: 1px;
	padding: 15px;
	position: relative;
}
.hohEmbed .avatar{
	border-radius: 3px;
	height: 40px;
	width: 40px;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	display: inline-block;
}
.hohEmbed .name{
	display: inline-block;
	height: 40px;
	line-height: 40px;
	vertical-align: top;
	color: rgb(var(--color-blue));
	font-size: 1.4rem;
	margin-left: 12px !important;
}
.hohEmbed .time{
	color: rgb(var(--color-text-lighter));
	font-size: 1.1rem;
	position: absolute;
	right: 12px;
	top: 12px;
}
#hoh-character-roles .view-media-character{
	grid-template-areas: "media character";
}
#hoh-character-roles .view-media-character .media{
	grid-area: media;
}
.hohRecsLabel{
	color: rgb(var(--color-blue)) !important;
}
.hohRecsItem{
	margin-top: 5px;
	margin-bottom: 10px;
}
.hohTaglessLinkException{
	display: block;
}
.hohTaglessLinkException::after{
	content: ""!important;
}
.hohStatValue{
	color: rgb(var(--color-blue));
}
.user-page-unscoped .markdown-editor{
	width: 100%;
}
.markdown-editor > [title="Image"],
.markdown-editor > [title="Youtube Video"],
.markdown-editor > [title="WebM Video"]{
	color: rgba(var(--color-red));
}
.markdown-editor > [title="Link"]{
	color: rgba(var(--color-blue));
}
[slug="Sakasama-no-Patema"] .cover-wrap-inner .cover:hover{
	transform: rotate(180deg);
}
[slug="Sakasama-no-Patema"] .cover-wrap-inner .cover{
	transition: .2s;
}
.hohBackgroundUserCover{
	height: 50px;
	width: 50px;
	display: inline-block;
	object-position: center;
	object-fit: cover;
	margin-top: 11px;
	margin-bottom: 1px;
}
.hohRegularTag{
	border-style: solid;
	border-width: 1px;
	border-radius: 3px;
	padding: 2px;
	margin-right: 3px;
}
.hohTableHider{
	cursor: pointer;
	margin: 4px;
	color: rgb(var(--color-blue));
}
.hohCross{
	cursor: pointer;
	margin-left: 2px;
	color: red;
}
.hohColourPicker{
	position: absolute;
	right: 60px;
	margin-top: 0px;
}
.hohColourPicker h2{
	color: #3db4f2;
	font-size: 1.6rem;
	font-weight: 400;
	padding-bottom: 12px;
}
.hohSecondaryRow{
	background-color: rgb(var(--color-background));
}
.hohSecondaryRow:hover{
	background-color: rgb(var(--color-foreground));
}
.hohSecondaryRow svg.repeat{
	margin-left: 15px;
}
.media-preview-card meter{
	width: 150px;
	margin-bottom: 5px;
}
.sidebar .tags .tag{
	min-height: 35px;
	margin-bottom: 5px !important;

}
.custom-lists .el-checkbox__label{
	display: inline !important;
	white-space: pre-wrap;
	white-space: -webkit-pre-wrap;
	white-space: normal;
	word-wrap: anywhere;
	word-break: break-word;
}
.hohStatusDot{
	position: absolute;
	width: 10px;
	height: 10px;
	border-radius: 50px;
}
.hohStatusDotRight{
	top: 2px;
	right: 2px;
}
.relations.hohRelationStatusDots .hohStatusDot{
	position: relative;
	transform: translate(-5px,-5px);
}
.relations.hohRelationStatusDots > div.grid-wrap{
	padding-top: 5px;
	padding-left: 5px;
}
.relations.hohRelationStatusDots > h2{
	margin-bottom: 5px;
}
.recommendation-card .cover{
	overflow: visible;
}
.recommendation-card .hohStatusDot{
	transform: translate(-5px,-5px);
}
.studio .container.header{
	position: relative;
}
.studio .favourite{
	position: absolute;
	top: 10px;
	right: 30px;
}
.filter .view-all{
	background-color: rgb(var(--color-foreground));
	height: 32px;
	border-radius: 3px;
	text-align: center;
	padding-top: 8px;
}
.title > a{
	line-height: 1.15!important;
}
.embed .title{
	line-height: 18px!important;
}
#dubNotice{
	font-size: 12px;
	font-weight: 500;
	text-align: center;
	text-transform: capitalize;
	background: rgb(var(--color-foreground));
	margin-top: 0em;
	margin-bottom: 16px;
	border-radius: 3px;
	padding: 8px 12px;
}
.media-manga #dubNotice{
	display: none;
}
#hohDraw3x3{
	margin-top: 5px;
	cursor: pointer;
}
.hohFeedFilter{
	position: absolute;
	top: 2px;
	font-size: 1.4rem;
	font-weight: 500;
}
.hohFeedFilter input{
	width: 45px;
	background: none;
	border: none;
	margin-left: 6px;
	color: rgb(var(--color-text));
}
.hohFeedFilter input::-webkit-outer-spin-button, 
.hohFeedFilter input::-webkit-inner-spin-button{
	opacity: 1;
}
[list="staffRoles"]::-webkit-calendar-picker-indicator{
	display: none;
}
[list="staffRoles"]{
	background: rgb(var(--color-foreground));
	background: rgb(var(--color-foreground));
	padding: 5px;
	border-width: 0px;
	border-radius: 2px;
	margin-left: 20px;
	color: rgb(var(--color-text));
}
.hohFeedFilter button{
	color: rgb(var(--color-text));
	cursor: pointer;
	background: none;
	border: none;
	margin-left: 10px;
}
.hohFeedFilter button:hover{
	color: rgb(var(--color-blue));
}
.noselect{
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}
.actions .list .add{
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}
.text div.markdown{
	scrollbar-width: thin;
}
.user .about > div.content-wrap{
	scrollbar-width: thin;
}
.list-wrap .section-name,
.quick-search input[placeholder="Search AniList"]{
	text-transform: none;
}
.list-wrap{
	counter-reset: animeCounter;
}
.results.studios{
	counter-reset: studioCounter;
}
.results.studios .studio > .name::before{
	counter-increment: studioCounter;
	content: counter(studioCounter);
	opacity: 0.2;
	font-size: 70%;
	margin-left: -12px;
	margin-right: 3px;
}
.medialist.table.compact .entry .title::before{
	counter-increment: animeCounter;
	content: counter(animeCounter);
	display: inline-block;
	margin-right: 4px;
	margin-left: -17px;
	opacity: 0.2;
	text-align: right;
	width: 25px;
	min-width: 25px;
	font-size: 70%;
}
.hohEnumerateStaff{
	position: absolute;
	margin-left: -12px;
	margin-top: 10px;
}
#hohMALscore .type,
#hohMALserialization .type{
	font-size: 1.3rem;
	font-weight: 500;
	padding-bottom: 5px;
	display: inline-block;
}
#app .tooltip{
	z-index: 9923;
}
#hohMALscore .value,
#hohMALserialization .value{
	color: rgb(var(--color-text-lighter));
	font-size: 1.2rem;
	line-height: 1.3;
	display: block;
}
.hohMediaScore{
	color: rgb(var(--color-text-lighter));
	font-size: 1.2rem;
	position: absolute;
	top: -10px;
	padding-left: 10px;
	padding-right: 10px;
	margin-left: -10px;
}
.forum-thread .like .button{
	margin-right: 0px!important;
}
.forum-thread .actions{
	user-select: none;
}
#hohFilters{
	margin-top: 5px;
	margin-bottom: 5px;
}
#hohFilters input{
	width: 55px;
	margin: 5px;
}
.hohCompare{
	margin-top: 10px;
	counter-reset: animeCounterComp;
	position: relative;
	overflow-x: scroll;
}
.hohCompare .hohUserRow,
.hohCompare .hohHeaderRow{
	background: rgb(var(--color-foreground));
}
.hohCompare table,
.hohCompare th,
.hohCompare td{
	border-top-width: 0px;
	border-bottom-width: 1px;
	border-right-width: 1px;
	border-left-width: 0px;
	border-style: solid;
	border-color: black;
	padding: 5px;
}
.hohCompare table{
	background: rgb(var(--color-foreground-grey));
	border-spacing: 0px;
	margin-top: 10px;
	border-right: none;
	border-bottom: none;
}
#graphiql{
	--color-blue: 61,180,242;
}
.list-stats{
	margin-bottom: 0px!important;
}
.activity-feed-wrap,
.activity-feed-wrap + div{
	margin-top: 25px;
}
.hohUserRow td,
.hohUserRow th{
	min-width: 120px;
	border-top-width: 1px;
	position: sticky;
	top: 3px;
	z-index: 1000;
	background: rgb(var(--color-foreground));
}
.hohHeaderRow td,
.hohHeaderRow th{
	border-top: none;
}
.hohUserRow input{
	width: 100px;
}
.hohUserRow img{
	width: 30px;
	height: 30px;
	border-radius: 2px;
}
tr.hohAnimeTable:nth-child(2n+1){
	background-color: rgb(var(--color-foreground));
}
.hohAnimeTable,
.hohAnimeTable td{
	position: relative;
}
.hohAnimeTable .hohStatusDot{
	top: calc(50% - 5px);
	right: 5px;
}
.hohHeaderRow .hohStatusDot{
	background: rgb(var(--color-background));
	top: calc(50% - 5px);
	right: 5px;
	cursor: pointer;
}
.hohStatusProgress{
	position: absolute;
	left: 60px;
	top: calc(50% - 5px);
	font-size: 60%;
}
.hohAnimeTable > td:nth-child(1)::before{
	counter-increment: animeCounterComp;
	content: counter(animeCounterComp) ". ";
	position: absolute;
	left: 1px;
	text-align: right;
	width: 40px;
	color: rgb(var(--color-blue));
}
.hohAnimeTable > td:nth-child(1){
	padding-left: 43px;
	border-left-width: 1px;
}
.hohUserRow > td:nth-child(1),
.hohHeaderRow > th:nth-child(1){
	border-left: solid;
	border-left-width: 1px;
	border-color: black;
}
.hohArrowSort{
	font-size: 3rem;
	cursor: pointer;
	margin-left: 4px;
	margin-right: 4px;
}
.hohFilterSort{
	cursor: pointer;
	border-width: 1px;
	border-style: solid;
	padding: 2px;
	border-radius: 4px;
}
.hohArrowSort:hover,
.hohFilterSort:hover{
	color: rgb(var(--color-blue));
}
.hohAnimeTableRemove{
	cursor: pointer;
	position: absolute;
	top: 0px;
	right: 0px;
}
.hohCheckbox.el-checkbox__input > span.el-checkbox__inner{
	background-color: rgb(var(--color-foreground));
	margin-right:10px;
	border-color: rgba(var(--color-text),.2);
}
.hohCheckbox input:checked + .el-checkbox__inner{
	background-color: #409eff;
	border-color: #409eff;
}
.hohCheckbox input:checked + .el-checkbox__inner::after{
	transform: rotate(45deg) scaleY(1);
}
.hohCheckbox input{
	display: none;
}
.hohCheckbox{
	margin-left: 2px;
}
.hohCheckbox .el-checkbox__inner::after {
	box-sizing: content-box;
	content: "";
	border: 1px solid #fff;
	border-left: 0;
	border-top: 0;
	height: 7px;
	left: 4px;
	position: absolute;
	top: 1px;
	transform: rotate(45deg) scaleY(0);
	width: 3px;
	transition: transform .15s ease-in .05s;
	transform-origin: center;
}
.hohCheckbox .el-checkbox__inner {
	display: inline-block;
	position: relative;
	border: 1px solid #dcdfe6;
	border-radius: 2px;
	box-sizing: border-box;
	width: 14px;
	height: 14px;
	z-index: 1;
	transition: border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46);
}
.hohCheckbox.el-checkbox__input{
	white-space: nowrap;
	cursor: pointer;
	outline: none;
	display: inline-block;
	line-height: 1;
	position: relative;
	vertical-align: middle;
}
.media-card .list-status[status="Repeating"]{
	background: violet;
}
.hohDismiss{
	cursor: pointer;
	transform: translate(20px,-11px);
	width: 10px;
	height: 5px;
	margin-left: -10px;
}
.substitution .media-roles:not(.substitution){
	display: none;
}
.substitution .character-roles{
	max-width: 1520px;
}
.hohButton{
	align-items: center;
	background: #3db4f2;
	border-radius: 4px;
	color: rgb(var(--color-text-bright));
	cursor: pointer;
	display: inline-flex;
	font-size: 1.3rem;
	margin-right: 10px;
	margin-top: 15px;
	padding: 10px 15px;
	transition: .2s;
	border-width: 0px;
}
.user-social .title::before{
	font-size: 1.6rem;
}
textarea{
	background: rgb(var(--color-foreground));
}
select{
	background: rgb(var(--color-foreground));
	padding: 5px;
	border-radius: 4px;
	border-width: 0px;
	margin: 4px;
	color: rgb(var(--color-text));
}
.hohPostLink{
	position: absolute;
	top: 50px;
}
.hohRec{
	position: relative;
	background: rgb(var(--color-foreground));
	padding: 10px;
	border-radius: 3px;
	margin-bottom: 15px;
}
.hohBlock{
	padding: 4px;
	border-width: 1px;
	border-style: solid;
	border-radius: 5px;
	margin: 2px;
}
.hohBlockSpec{
	padding-right: 15px;
}
.hohBlockCross{
	padding: 5px;
	color: red;
	cursor: pointer;
}
.medialist .filters .filter-group:first-child > span{
	position: relative;
}
.medialist .filters .filter-group:first-child > span .count{
	position: absolute;
	right: 0px;
}
.categories .category{
	text-transform: none;
	white-space: nowrap;
}
.media-preview-card.hohFallback{
	position: relative;
}
.media-preview-card .hohFallback{
	position: absolute;
	top: 5px;
	left: 5px;
	word-break: break-word;
	overflow-y: hidden;
	max-height: 110px;
	max-width: 75px;
}
.media-preview-card .cover{
	z-index: 3;
}
.home .review-card{/*prevents hiding the score for unbreakable text*/
	grid-template-columns: 100%;
}
.hohChangeScore{
	font-family: monospace;
	cursor: pointer;
	display: none;
}
.score[score="0"] .hohChangeScore,
.medialist .score[score="0"]{
	pointer-events: none;
}
.score[score="0"] .hohChangeScore{
	display: none!important;
}
.row:hover .hohChangeScore,
.hohMediaScore:hover .hohChangeScore{
	display: inline;
}
.activity-text .name[href="/user/Dunkan85/"]::after{
	/*https://upload.wikimedia.org/wikipedia/commons/e/e4/Twitter_Verified_Badge.svg*/
	background-image: url('data:image/svg+xml;utf8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;"><path fill="%231DA1F2" d="M512,268c0,17.9-4.3,34.5-12.9,49.7c-8.6,15.2-20.1,27.1-34.6,35.4c0.4,2.7,0.6,6.9,0.6,12.6c0,27.1-9.1,50.1-27.1,69.1c-18.1,19.1-39.9,28.6-65.4,28.6c-11.4,0-22.3-2.1-32.6-6.3c-8,16.4-19.5,29.6-34.6,39.7C290.4,507,273.9,512,256,512c-18.3,0-34.9-4.9-49.7-14.9c-14.9-9.9-26.3-23.2-34.3-40c-10.3,4.2-21.1,6.3-32.6,6.3c-25.5,0-47.4-9.5-65.7-28.6c-18.3-19-27.4-42.1-27.4-69.1c0-3,0.4-7.2,1.1-12.6c-14.5-8.4-26-20.2-34.6-35.4C4.3,302.5,0,285.9,0,268c0-19,4.8-36.5,14.3-52.3c9.5-15.8,22.3-27.5,38.3-35.1c-4.2-11.4-6.3-22.9-6.3-34.3c0-27,9.1-50.1,27.4-69.1c18.3-19,40.2-28.6,65.7-28.6c11.4,0,22.3,2.1,32.6,6.3c8-16.4,19.5-29.6,34.6-39.7C221.6,5.1,238.1,0,256,0c17.9,0,34.4,5.1,49.4,15.1c15,10.1,26.6,23.3,34.6,39.7c10.3-4.2,21.1-6.3,32.6-6.3c25.5,0,47.3,9.5,65.4,28.6c18.1,19.1,27.1,42.1,27.1,69.1c0,12.6-1.9,24-5.7,34.3c16,7.6,28.8,19.3,38.3,35.1C507.2,231.5,512,249,512,268z M245.1,345.1l105.7-158.3c2.7-4.2,3.5-8.8,2.6-13.7c-1-4.9-3.5-8.8-7.7-11.4c-4.2-2.7-8.8-3.6-13.7-2.9c-5,0.8-9,3.2-12,7.4l-93.1,140L184,263.4c-3.8-3.8-8.2-5.6-13.1-5.4c-5,0.2-9.3,2-13.1,5.4c-3.4,3.4-5.1,7.7-5.1,12.9c0,5.1,1.7,9.4,5.1,12.9l58.9,58.9l2.9,2.3c3.4,2.3,6.9,3.4,10.3,3.4C236.6,353.7,241.7,350.9,245.1,345.1z"/></svg>');
	background-size: 12px;
	display: inline-block;
	width: 12px;
	height: 12px;
	content: "";
	margin-left: 5px;
}
.hohSummableStatusContainer{
	float: right;
}
.hohSummableStatus{
	width: 16px;
	height: 16px;
	text-align: center;
	vertical-align: middle;
	border-radius: 16px;
	line-height: 16px;
	color: black;
	font-size: 10px;
	display: inline-block;
	margin-left: 2px;
	cursor: pointer;
}
.relations.small > div{
	margin-left: 5px;
}
.hohMyThreads{
	color: rgb(var(--color-text-lighter));
	padding: 5px 10px;
	font-size: 1.4rem;
	display: inline-block;
	padding-bottom: 20px;
}
.hohImport .el-checkbox__label{
	padding-left: 0px;
}
.hohImportEntry{
	width: 30%;
	display: inline-block;
	background-color: rgb(var(--color-foreground));
	padding: 5px;
	margin: 5px;
	border-radius: 2px;
}
.hohImportSelect{
	display: inline-table;
	width: 80%;
	padding: 5px;
}
.hohImportArrow{
	font-size: 40px;
}
.hohImportRow{
	margin: 10px;
	display: flex;
	align-items: center;
}
.results.characters + .hohThemeSwitch,
.results.staff + .hohThemeSwitch{
	display: none;
}
.hohThemeSwitch{
	align-items: center;
	background: rgb(var(--color-foreground));
	border-radius: 4px;
	display: flex;
	justify-content: space-between;
	padding: 10px 13px;
	width: 100px;
}
.hohThemeSwitch .active{
	color: rgb(var(--color-blue));
}
.hohThemeSwitch > span{
	cursor: pointer;
}
.studio .hohThemeSwitch{
	position: absolute;
	left: calc(50% - 65px);
	width: 130px;
	top: 120px;
}
.user-social.listView .user-follow .wrap,
.user-social.listView .hohSocialContent.user-follow{
	display: block!important;
}
.user-social.listView .user-follow .user{
	height: 50px;
	width: 50px;
	margin: 5px;
	overflow: visible;
	border-top-right-radius: 0px;
	border-bottom-right-radius: 0px;
}
.user-social.listView .user-follow .follow-card .name{
	width: 250px;
	margin-left: 80px !important;
	opacity: 1;
	padding-bottom: 35px;
}
.user-social.listView .user-follow .follow-card{
	margin: 2px;
}
.user-social.listView .user-follow .follow-card div.avatar{
	overflow: visible!important;
}
.user-social.listView .thread-card .body-preview,
.user-social.listView .thread-card .footer{
	display: none;
}
.user-social.listView .thread-card .title{
	margin-bottom: 0px;
}
.user-social.listView .thread-card{
	margin-bottom: 10px;
}
.user-social.listView .user-comments .header{
	display: none;
}
.user-social.listView .comment-wrap{
	margin-bottom: 5px;
}
.hohDownload{
	position: absolute;
	right: 10px;
	top: 305px;
	font-weight: bolder;
	font-size: 120%;
}
.media .hohDownload{
	top: 375px;
}
meter::-webkit-meter-optimum-value{
	background: rgb(var(--color-blue));
}
meter::-moz-meter-bar{
	background: rgb(var(--color-blue));
}
.input-wrap.manga input[placeholder="Status"],
.input-wrap.anime input[placeholder="Status"],
.input-wrap.anime .form.score input{
	width: 220px;
}
.substitution .role-card{
	background: rgb(var(--color-foreground));
	border-radius: 3px;
	display: inline-grid;
	grid-template-columns: 50% 50%;
	height: 80px;
	overflow: hidden;
}
.substitution .media-roles .role-card{
	grid-template-columns: 100%;
}
.substitution .role-card > div{
	display: inline-grid;
	grid-template-columns: 60px auto;
	grid-template-areas: "image content";
}
.substitution .cover{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	grid-area: image;
}
.substitution .grid-wrap .content{
	font-size: 1.2rem;
	grid-area: content;
	overflow: hidden;
	padding: 10px;
	position: relative;
}
.substitution .grid-wrap .content .name{
	display: block;
	height: 48px;
	line-height: 1.3;
}
.substitution .grid-wrap{
	display: grid;
	grid-column-gap: 30px;
	grid-row-gap: 15px;
	grid-template-columns: repeat(2,1fr);
}
.substitution .role{
	color: rgb(var(--color-text-lighter));
	font-size: 1.1rem;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	width: 100%;
}
.user-follow .follow-card{
	background-color: rgb(var(--color-foreground));
}
.recent-recommendations .switch .option{
	white-space: nowrap;
}
.media-staff .role-card .role:hover,
.media-roles.substitution .role-card .role:hover{
	overflow-x: auto;
	scrollbar-width: none;
	-ms-overflow-style: none;
}
.media-staff .role-card .role:hover::-webkit-scrollbar,
.media-roles.substitution .role-card .role:hover::-webkit-scrollbar{
	width: 0;
	height: 0;
}
.substitution .container{
	max-width: 1420px;
}
.tagIndex p{
	cursor: pointer;
	line-break: anywhere;
}
.tagIndex p:hover{
	cursor: pointer;
	color: rgb(var(--color-blue));
}
.tagIndex .count{
	font-size: small;
	float: right;
	opacity: 0.5;
}
.hohTable .row{
	display: grid;
	grid-template-columns: 40% repeat(auto-fill, 120px);
	padding: 5px;
	cursor: pointer;
}
.hohTable .row:nth-child(odd){
	background: rgba(var(--color-background-300), 0.5);
}
.hohTable .row.good{
	grid-template-columns: 40% repeat(auto-fill, 150px);
}
.hohTable .row > div{
	grid-row: 1;
}
.hohTable{
	padding: 20px;
	background: rgb(var(--color-foreground));
}
.hohTable .count{
	display: inline-block;
	min-width: 20px;
	font-size: 70%;
}
.hohTable .hohSummableStatusContainer{
	margin-right: 8px;
}
.hohTable .header.row{
	background: rgb(var(--color-background));
}
#regularAnimeTable,
#regularMangaTable,
#animeStaff,
#animeStudios,
#mangaStaff{
	display: none!important;
}
.user[type="anime"][page="tags"]:not(.hohSpecialPage) #regularAnimeTable,
.user[type="manga"][page="tags"]:not(.hohSpecialPage) #regularMangaTable,
.user[type="anime"][page="staff"]:not(.hohSpecialPage) #animeStaff,
.user[type="anime"][page="studios"]:not(.hohSpecialPage) #animeStudios,
.user[type="manga"][page="staff"]:not(.hohSpecialPage) #mangaStaff{
	display: block!important;
}
.user .hohMilestones .milestones .milestone:nth-child(2)::after{
	display: none;
}
#hohSettings .hohCategories{
	margin-bottom: 20px;
	padding-right: 0px;
	padding-left: 0px;
}
.hohCategory{
	display: inline-block;
	padding: 5px;
	color: rgb(var(--color-text));
}
.hohCategory.active{
	background: rgb(var(--color-blue));
	color: rgb(var(--color-text-bright));
}
.hohCategories{
	display: flex;
	flex-wrap: wrap;
	position: relative;
	text-align: center;
	margin: 0;
	padding: 0;
	box-shadow: none;
	background-color: rgb(var(--color-background));
	border-radius: 3px;
}
.hohCategory{
	border: none;
	line-height: inherit;
	font-size: 1.2rem;
	font-weight: 500;
	white-space: nowrap;
	flex-grow: 1;
	margin: 0;
	padding: 6px 10px;
	color: rgb(var(--color-text));
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	border-radius: 3px;
}
.hohCategory:hover{
	background-color: inherit;
	color: rgb(var(--color-blue));
}
.hohCategory.active,
.hohCategory:active,
.hohCategory:focus{
	font-weight: 500;
	background-color: rgb(var(--color-foreground-blue));
	color: rgb(var(--color-white));
	border-radius: 0;
}
.hohCategory:focus:hover {
	background-color: rgb(var(--color-foreground-blue));
}
.hohCategory:active:first-of-type,
.hohCategory:first-of-type.active,
.hohCategory:focus:first-of-type{
	border-radius: 3px 0 0 3px;
}
.hohCategory:active:last-of-type,
.hohCategory:last-of-type.active,
.hohCategory:focus:last-of-type{
	border-radius: 0 3px 3px 0;
}
#hohSettings .hohSetting{
	display: none;
	position: relative;
}
#hohSettings.all .hohSetting,
#hohSettings.Notifications .hohSetting.Notifications,
#hohSettings.Feeds .hohSetting.Feeds,
#hohSettings.Forum .hohSetting.Forum,
#hohSettings.Lists .hohSetting.Lists,
#hohSettings.Profiles .hohSetting.Profiles,
#hohSettings.Stats .hohSetting.Stats,
#hohSettings.Media .hohSetting.Media,
#hohSettings.Navigation .hohSetting.Navigation,
#hohSettings.Browse .hohSetting.Browse,
#hohSettings.Script .hohSetting.Script,
#hohSettings.NewlyAdded .hohSetting.NewlyAdded,
#hohSettings.Login .hohSetting.Login{
	display: block;
}
.noLogin .hohSetting.Login{
	opacity: 0.4;
}
.medialist.cards .entry-card .progress{
	width: 60%;
}
#titleAliasInput{
	max-width: 100%;
}
.hohAdvancedDollar{
	font-weight: bold;
	margin-left: 9px;
}
.social input[list="socialUsers"]{
	background: rgb(var(--color-foreground));
	border-width: 0px;
	padding: 5px;
	margin-right: 5px;
}
.reason-markdown{
	font-size: 1.3rem;
	line-height: 1.4;
}

.termsFeed{
	--color-blue: 61,180,242;
	--color-green: 123,213,85;
	--color-red: 232,93,117;
	--color-foreground: 39,44,56;
}
.hohFeed{
	margin-top: 10px;
	margin-bottom: 20px;
}
.hohFeed video{
	max-width: 100%;
}
.hohFeed .activity,
.hohFeed .activity .reply{
	min-height: 25px;
	position: relative;
	border-style: solid;
	border-width: 1px;
	border-bottom-width: 0px;
}
.hohFeed .activity .replies{
	margin-left: 60px;
	margin-top: 5px;
}
.hohFeed .activity:last-child{
	border-bottom-width: 1px;
}
.hohFeed a{
	text-decoration: none;
	color: rgb(var(--color-blue));
}
.hohFeed .hohButton{
	font-size: 1rem;
	color: initial;
	margin: 5px;
	filter: drop-shadow(1px 1px 2px black);
}
.hohFeed img{
	max-width: 500px;
}
.hohFeed .markdown_spoiler{
	background: rgb(31, 35, 45);
	color: rgb(31, 35, 45);
}
.hohFeed .markdown_spoiler:hover{
	color: rgb(159,173,189);
}
.hohFeed .markdown_spoiler img{
	filter: blur(10px) hue-rotate(60deg) brightness(0.7);
}
.hohFeed .markdown_spoiler:hover img{
	filter: none;
}
.hohFeed .markdown_spoiler::after{
	content: "Spoiler";
	color: rgb(159,173,189);
	margin-left: 2px;
}

.hohFeed .activity:hover::before{
	content: ">";
	position: absolute;
	left: -20px;
	top: 0px;
}
.hohLikeQuickView{
	position: absolute;
	bottom: 0px;
	left: 45px;
	font-size: 70%;
	white-space: nowrap;
	overflow: hidden;
	max-width: 270px;
}
.hohFeed .hohLikes:hover{
	color: rgb(var(--color-red));
	filter: saturate(50%);
}
.hohFeed .hohLikes:hover .hohLikeQuickView{
	filter: saturate(200%);
}
.hohFeed .hohLikes:hover .hohLikeQuickView{
	color:rgb(159,173,189);
}
.hohFeed .activity:hover > .time{
	color: rgb(var(--color-blue));
}

.hohSearchResult{
	width: 18.5%;
	display: inline-block;
	text-align: center;
	padding: 3px;
	height: 2.2em;
	overflow: hidden;
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	cursor: pointer;
	background-color: inherit;
	margin: 1px;
	position: relative
}
.hohSearchResult.anime{
	color: rgb(var(--color-blue));
}
.hohSearchResult.manga{
	color: rgb(var(--color-green));
}
.hohSearchResult.anime:hover{
	background-color: rgb(var(--color-blue),0.3);
}
.hohSearchResult.manga:hover{
	background-color: rgb(var(--color-green),0.3);
}
.hohSearchResult.anime.selected{
	background-color: rgb(var(--color-blue),0.3);
	cursor: initial;
}
.hohSearchResult.manga.selected{
	background-color: rgb(var(--color-green),0.3);
	cursor: initial;
}
.termsFeedEdit{
	cursor: pointer;
	font-size: small;
	position: absolute;
	right: 2px;
	top: 1px;
}
.termsFeedEdit:hover{
	color: rgb(var(--color-text));
}
.thisIsMe,
a.thisIsMe{
	color: rgb(var(--color-red));
}


.hohTable.hohNoPointer .row,
.hohNoPointer{
	cursor: unset;
}
.hohNewChapter{
	position: relative;
	padding-top: 8px;
	padding-bottom: 8px;
	margin-top: 0px;
	margin-bottom: 0px;
	padding-left: 10px;
}
.hohNewChapter:hover a::before{
	content: ">";
	position: absolute;
	margin-left: -10px;
	font-size: small;
}
.hohNewChapter:nth-child(odd){
	background: rgb(var(--color-foreground-grey),0.3);
}
.banMode .hohNewChapter{
	cursor: crosshair!important;
}
.banMode .hohNewChapter a{
	pointer-events: none;
}
.banMode .hohNewChapter:hover .hohDisplayBoxClose{
	display: none;
}
.hohSocialFeed{
	position: relative;
}
.hohReplaceFeed > *:not(.hohSocialFeed){
	display: none;
}
.hohSocialFeed .wrap{
	background: rgb(var(--color-foreground));
	border-radius: 4px;
	font-size: 1.3rem;
	overflow: hidden;
	position: relative;
	min-height: 55px !important;
}
.hohSocialFeed .activity-replies{
	margin: 20px;
}
.hohSocialFeed .reply-wrap time{
	font-size: 1.1rem;
}
.hohSocialFeed .cover{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
}
.hohSocialFeed .avatar{
	display: block;
	border-radius: 3px;
	height: 36px;
	margin-top: 9px;
	width: 36px;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
}
.hohSocialFeed .activity-entry{
	margin-bottom: 10px
}
.hohSocialFeed .details{
	min-width: 500px;
	padding: 10px 16px !important;
}
.hohSocialFeed .reply .avatar{
	display: inline-block;
	height: 25px;
	width: 25px;
	margin-top: 0;
}
.hohSocialFeed .reply .name{
	display: inline-block;
	line-height: 25px;
	margin-left: 6px;
	vertical-align: top;
}
.hohSocialFeed .activity-entry > .wrap > .actions{
	bottom: 12px;
	color: rgb(var(--color-blue-dim));
	position: absolute;
	right: 12px;
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	font-weight: 800;
}
.hohSocialFeed .activity-entry > .wrap .action{
	cursor: pointer;
	display: inline-block;
	padding-left: 5px;
	transition: .2s;
}
.hohSocialFeed .activity-entry > .wrap > .time{
	color: rgb(var(--color-text-lighter));
	font-size: 1.1rem;
	position: absolute;
	right: 12px;
	top: 12px;
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	font-weight: 800;
}
.hohSocialFeed .activity-entry > .reply-wrap .actions{
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	font-weight: 700;
}
.hohSocialFeed .activity-entry > .reply-wrap .action{
	padding-left: 5px;
	transition: .2s;
	cursor: pointer;
}
.hohSocialFeed .activity-entry > .reply-wrap .time{
	color: rgb(var(--color-text-lighter));
}
.hohSocialFeed .reply{
	background: rgb(var(--color-foreground));
	border-radius: 3px;
	font-size: 1.3rem;
	margin-bottom: 15px;
	padding: 14px;
	padding-bottom: 4px;
	position: relative;
}
.hohSocialFeed .reply .actions{
	color: rgb(var(--color-blue-dim));
	position: absolute;
	right: 12px;
	top: 12px;
}
.hohSocialFeed .activity-entry > .wrap > .time .action{
	cursor: pointer;
	opacity: 0;
	padding-right: 10px;
	transition: .2s;
}
.hohSocialFeed .activity-entry > .wrap > .time:hover .action{
	opacity: 1;
}
.hohSocialFeed .liked{
	color: rgb(var(--color-red));
}
.hohSocialFeed .name,
.hohSocialFeed .title{
	color: rgb(var(--color-blue));
}
.hohMilestones .stat .value{
	color: rgb(var(--color-blue));
	font-size: 1.4rem;
	font-weight: 700;
	padding-bottom: 8px;
}
.hohMilestones .stat .label{
	color: rgb(var(--color-text-light));
  	font-size: 1.1rem;
}
.hohMediaEmbed .embed{
	background: rgb(var(--color-background));
	border-radius: 3px;
	display: inline-grid;
	font-size: 14px;
	grid-template-columns: 50px auto;
	line-height: 18px;
	max-width: 550px;
	min-height: 64px;
	overflow: hidden;
	width: auto;
}
.hohMediaEmbed .wrap{
	color: rgb(var(--color-text-light));
	overflow: hidden;
	padding: 10px 16px 10px 12px;
	text-overflow: ellipsis;
}
.hohMediaEmbed .title{
	color: rgb(var(--color-blue));
	font-size: 1.3rem;
	font-weight: 500;
	margin-bottom: -10px;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}
.hohMediaEmbed .info{
	font-size: 1.2rem;
	position: relative;
}
.hohMediaEmbed .genres{
	min-height: 18px;
	min-width: 14px;
	opacity: 0;
	position: relative;
	top: 18px;
	transition: .2s;
}
.hohMediaEmbed .cover{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
}
.hohMediaEmbed .info > span{
	display: inline;
	transition: .2s;
	opacity: 1;
}
.hohMediaEmbed:hover .info > span{
	opacity: 0;
}
.hohMediaEmbed:hover .info > .genres:empty ~ span,
.embed:hover .info > .genres:empty ~ span{
	opacity: 1!important;
}
.hohMediaEmbed:hover .info > .genres{
	opacity: 1;
}
.hohGetMarkdown{
	cursor: pointer;
	opacity: 0;
	padding-right: 10px;
	transition: .2s;
}
.activity-entry:hover .hohGetMarkdown{
	color: rgb(var(--color-blue));
	opacity: 1;
}
.hohMarkdownSource{
	font-size: 1.4rem;
	line-height: 1.4;
	overflow-wrap: break-word;
	word-break: break-word;
}
.queryResults .message img{
	max-width: 100%;
}
.hohTimelineEntry{
	margin: 7px;
	position: relative;
	padding: 7px;
	border-radius: 2px;
	background: rgb(var(--color-foreground));
}
.hohImport .dropbox{
	align-items: center;
	background: rgba(var(--color-background),.6);
	border-radius: 4px;
	color: rgb(var(--color-text-lighter));
	cursor: pointer;
	display: inline-flex;
	font-size: 1.3rem;
	height: 200px;
	justify-content: center;
	line-height: 2rem;
	margin-right: 20px;
	outline-offset: -12px;
	outline: 2px dashed rgba(var(--color-text),.2);
	padding: 18px 20px;
	position: relative;
	transition: .2s;
	vertical-align: text-top;
	width: 200px;
}
.hohImport .dropbox p{
	font-size: 1.2em;
	padding: 50px 0;
	text-align: center;
}
.hohImport .dropbox .input-file{
	cursor: pointer;
	height: 200px;
	opacity: 0;
	overflow: hidden;
	position: absolute;
	width: 100%;
}
.hohImport label.el-checkbox{
	display: block;
	margin-top: 20px;
	margin-bottom: 10px;
}
.section.hohImport{
	margin-bottom: 50px;
}
.media-manga .external-links{
	position: relative;
}
.media-manga .external-links > h2{
	visibility: hidden;
}
.media-manga .external-links > h2::after{
	visibility: visible;
	position: absolute;
	left: 0px;
	top: 0px;
	content: "External & Reading links";
}
.hohButton.danger{
	background: rgba(var(--color-red),.8);
	color: rgb(var(--color-white));
}
.hohButton:disabled{
	opacity: 0.5;
	cursor: default;
}
.hohNameCel{
	margin-left: 50px;
	display: block;
}
.trailer{
	overflow: auto;
	resize: both;
}
.trailer .video{
	height: calc(99% - 30px);
}
.hohResizePearl{
	position: absolute;
	right: 2px;
	bottom: 2px;
	width: 20px;
	height: 20px;
	border: solid;
	border-radius: 10px;
	background: rgb(var(--color-foreground));
	cursor: se-resize;
}
.activity-entry > .wrap > .time:hover{
	background: rgb(var(--color-foreground));
	z-index: 60;
}
.activity-entry > .wrap > .time .action{
	margin-left: 5px;
	padding-right: 5px;
}
a.external::after{
	content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="12" height="12" viewBox="0 0 24 24"><path fill="%23fff" stroke="%2336c" d="M1.5 4.518h5.982V10.5H1.5z"/><path fill="%2336c" d="M5.765 1H11v5.39L9.427 7.937l-1.31-1.31L5.393 9.35l-2.69-2.688 2.81-2.808L4.2 2.544z"/><path fill="%23fff" d="M9.995 2.004l.022 4.885L8.2 5.07 5.32 7.95 4.09 6.723l2.882-2.88-1.85-1.852z"/></svg>');
	position: absolute;
}
.load-more:hover{
	color: rgb(var(--color-blue));
}
#hohListPreview .media-preview-card:hover .image-text{
	opacity: 0;
}
#hohListPreview .media-preview-card:hover .plus-progress{
	opacity: 1;
}
#hohListPreview .plus-progress{
	background: rgba(var(--color-overlay),.7);
	border-radius: 0 0 3px 3px;
	bottom: 0;
	color: rgba(var(--color-text-bright),.9);
	display: inline-block;
	font-size: 1.3rem;
	font-weight: 500;
	left: 0;
	letter-spacing: .2px;
	margin-bottom: 0;
	opacity: 0;
	padding-bottom: 8px;
	padding-top: 8px;
	position: absolute;
	transition: .3s;
	width: 100%;
}
#hohListPreview .content{
	background: rgb(var(--color-background));
	height: 100%;
	left: 100%;
	position: absolute;
	top: 0;
	opacity: 0;
	transition: opacity .3s;
	width: 212px;
	z-index: -1;
	border-radius: 0 3px 3px 0;
	padding: 12px;
}
#hohListPreview .info-left .content{
	border-radius: 3px 0 0 3px;
	left: auto !important;
	right: 100%;
	text-align: right;
}
#hohListPreview .media-preview-card:hover .content{
	opacity: 1;
	z-index: 5;
}
#hohListPreview .content:hover{
	opacity: 0!important;
	z-index: -1!important;
}
#hohListPreview .size-toggle{
	float: right;
	margin-top: -15px;
}
.site-theme-contrast .media-page-unscoped .header .description{
	color: rgb(var(--color-text));
}
.hohDeleteActivity{
	position: absolute;
	top: 2px;
	right: -21px;
	width: 10px;
	color: rgb(var(--color-red));
	cursor: pointer;
	display: none;
	padding-left: 5px;
	padding-right: 5px;
	background: rgb(39, 44, 56);
}
.hohFeed .activity:hover .hohDeleteActivity{
	display: inline;
}
input[list="socialUsers"]{
	color: rgb(var(--color-text));
}
.footer > .actions > .button.like > .like-wrap > .button.liked .icon{
	color: rgb(var(--color-peach));
}
.favourite.media{
	background-color: rgb(var(--color-background));
}
.favourites .favourite{
	background-color: rgb(var(--color-background));
}
.hohCharacter .role-card div{
	display: inline-grid;
}
.hohCharacter .role-card > div{
	display: inline-grid;
	grid-template-columns: 60px auto;
	grid-template-areas: "image content";
}
.hohCharacter .cover{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	grid-area: image;
}
.hohCharacter .content{
	font-size: 1.2rem;
	grid-area: content;
	overflow: hidden;
	padding: 10px;
}
.hohCharacter .staff .content{
	text-align: right;
}
.hohCharacter .name{
	display: block;
	height: 48px;
	line-height: 1.3;
}
.hohCharacter .role{
	color: rgb(var(--color-text-lighter));
	font-size: 1.1rem;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	width: 100%;
}
.hohCharacter .view-media-staff{
	grid-template-areas: "media staff";
}
.hohCharacter .view-media-staff .staff{
	grid-template-areas: "content image";
	grid-template-columns: auto 60px;
	grid-area: staff;
}
.hohCharacter .view-media-staff .media{
	grid-area: media;
}
.hohCharacter .role-card{
	background: rgb(var(--color-foreground));
	border-radius: 3px;
	display: inline-grid;
	grid-template-columns: 50% 50%;
	height: 80px;
	overflow: hidden;
}
.hohNoAWC .thread-card.small{
	margin-bottom: 15px;
	background: rgb(var(--color-foreground));
	border-radius: 3px;
	padding: 18px;
	position: relative;
}
.hohNoAWC .title{
	font-size: 1.4rem;
	display: block;
	margin-bottom: 12px;
	margin-right: 110px;
}
.hohNoAWC .footer{
	align-items: center;
	display: flex;
	flex-direction: row;
}
.hohNoAWC .avatar{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	border-radius: 3px;
	display: inline-block;
	height: 25px;
	vertical-align: text-top;
	width: 25px;
}
.hohNoAWC .name{
	display: inline-block;
	font-size: 1.3rem;
	padding-left: 10px;
}
.hohNoAWC .name span{
	color: rgb(var(--color-blue));
}
.hohNoAWC .categories{
	margin-left: auto;
	white-space: nowrap;
	max-width: 310px;
}
.hohNoAWC .category{
	border-radius: 100px;
	color: #fff;
	display: inline-block;
	font-size: 1.1rem;
	margin-left: 10px;
	padding: 4px 8px;
}
.hohNoAWC .category.default{
	text-transform: lowercase;
}
.hohNoAWC .category:hover{
	color: rgba(26,27,28,.6);
}
.hohNoAWC .info{
	color: rgb(var(--color-text-lighter));
	font-size: 1.2rem;
	position: absolute;
	right: 12px;
	top: 12px;
}
.hohNoAWC .info span{
	padding-left: 10px;
}

.hohYearHeading{
	grid-column: 1 / -1;
}
#hohMALserialization{
	padding-bottom: 14px;
}
#hohMALscore:empty,
#hohMALserialization:empty{
	display: none;
}
body.TMPreviewScore > .el-tooltip__popper{
	display: none;
}
:root .__ns__pop2top{/*no-script placeholder, messes with the search if there are blocked media elements in the feed*/
	z-index: initial!important;
}
.hohStudioSorter .selected{
	color: rgb(var(--color-blue));
}
.hohStudioSorter span{
	font-weight: normal;
	color: rgb(var(--color-text-lighter));
	display: inline;
	font-size: 1.2rem;
	padding: 4px 15px 5px 15px;
	border-radius: 3px;
	transition: .2s;
	background: none;
	cursor: pointer;
}
.hohStudioSorter span:hover{
	color: rgb(var(--color-blue));
}
.hohStudioSubstitute{
	margin-top: 25px;
	display: grid;
	grid-column-gap: 30px;
	grid-row-gap: 30px;
	grid-template-columns: repeat(3,1fr);
}
.hohRecsSwitch{
	min-width: 500px
}
.hohRecsSwitch .options{
	min-width: 500px;
	justify-content: space-around;
}
.hohRecsSwitch .options .option{
	border-radius: 30px;
	color: rgb(var(--color-text-light));
	cursor: pointer;
	font-size: 1.5rem;
	margin-right: 3px;
	padding: 3px 12px;
	text-transform: capitalize;
	transition: .25s ease;
}
.hohRecsSwitch .options .option.active{
	background: rgb(var(--color-blue));
	color: rgba(var(--color-white),.9);
}
.recommendations-wrap.substitute{
	display: grid;
	grid-gap: 60px 50px;
	grid-template-columns: repeat(auto-fill,330px);
	justify-content: center;
	margin-bottom: 60px;
}
.recommendations-wrap.substitute .recommendation-pair-card{
	background: rgb(var(--color-foreground));
	border-radius: 8px;
	box-shadow: 0 4px 4px rgba(var(--color-shadow-blue),.05);
	display: grid;
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	grid-gap: 20px;
	grid-template-columns: 130px 130px;
	justify-content: space-evenly;
	max-width: 100%;
	padding: 20px;
	padding-bottom: 35px;
	position: relative;
	transition: box-shadow .2s ease-in-out;
	vertical-align: top;
}
.recommendations-wrap.substitute .recommendation-pair-card:hover{
	box-shadow: 0 14px 20px rgba(var(--color-shadow-blue),.1),0 4px 4px rgba(var(--color-shadow-blue),.05);
}
.recommendations-wrap.substitute .cover{
	background-size: cover;
	border-radius: 4px;
	box-shadow: 0 4px 4px rgba(var(--color-shadow-blue),.05);
	display: grid;
	grid-template-rows: 1fr auto;
	height: 180px;
	margin-bottom: 10px;
	overflow: hidden;
	position: relative;
	width: 130px;
}
.recommendations-wrap.substitute .title{
	font-size: 1.3rem;
	font-weight: 600;
	line-height: 140%;
	white-space: normal;
}
.recommendations-wrap.substitute .rating-wrap{
	align-items: center;
	background: rgba(var(--color-overlay),.9);
	border-radius: 5px;
	bottom: -18px;
	box-shadow: 0 4px 4px rgba(var(--color-shadow-blue),.05);
	color: rgba(var(--color-white),.8);
	cursor: auto;
	display: flex;
	left: calc(50% - 65px);
	padding: 10px 13px;
	position: absolute;
	width: 130px;
}
.recommendations-wrap.substitute .rating{
	font-size: 1.5rem;
	font-weight: 900;
	margin-left: auto;
}
.recommendations-wrap.substitute .thumbs-down:hover{
	color: rgba(var(--color-red));
}
.recommendations-wrap.substitute .thumbs-up:hover{
	color: rgba(var(--color-green));
}
.recommendations-wrap.substitute .icon{
	display: inline-block;
	cursor: pointer;
	transition: color .25s ease-in-out;
}
.recommendations-wrap.substitute .recommendation-pair-card .media:first-child::after{
	content: "➡";
	top: 35%;
	position: absolute;
	right: 48%;
}
.review .actions .icon{
	opacity: 0.5;
	border: rgba(0, 0, 0, 0);
	border-width: 3px;
	border-style: solid;
}
.review .actions .icon:hover,.review .actions .icon.active{
	opacity: 1;
	border: rgb(var(--color-text));
	border-style: solid;
}
.home .activity-entry .actions{
	user-select: none;
}
.hohStaffPageData{
	position: absolute;
	right: 10px;
	top: 40%;
}
.hohSocialFeed .load-more{
	display: none;
	background: rgb(var(--color-foreground));
	border-radius: 4px;
	cursor: pointer;
	font-size: 1.4rem;
	margin-top: 20px;
	padding: 14px;
	text-align: center;
	transition: .2s;
}
.recent-recommendations > .header-wrap{
	grid-template-columns: 330px 0 auto;
	justify-content: space-between;
}
.media-page .header .cover-wrap{
	min-height: 340px;
}
#hohStaffTabFilter{
	display: none;
	position: absolute;
	right: 0px;
	top: -25px;
}
.media-staff + #hohStaffTabFilter{
	display: inline;
}
#hohStaffTabFilter > input{
	height: 20px;
	margin-left: 3px;
}
#hohFilterRemover{
	display: none;
}
#hohFilterRemover:hover{
	cursor: pointer;
}
#hohEntryScore{
	user-select: none;
}
.hohSorts{
	color: rgb(var(--color-gray-700));
	cursor: pointer;
	font-size: 1.3rem;
	font-weight: 600;
	padding: 8px 0;
	transition: color .2s ease;
}
.selects-wrap .icon-wrap.active{
	color: rgb(var(--color-blue));
}
.selects-wrap .icon-wrap:hover{
	color: rgb(var(--color-blue));
}
.range-wrap .handle{
	height: 18px;
}
.range-wrap .handle-0{
	background: rgba(var(--color-blue-600),.7);
	border-radius: 2px 2px 0px 20px;
	transform: translate(-13.5px,-4px);
}
.range-wrap .handle-1{
	border-radius: 0px 20px 2px 2px;
	transform: translate(1px,1px);
}
.range-wrap .handle-0:hover{
	transform: translate(-14px,-4px) scale(1.1);
}
.range-wrap .handle-1:hover{
	transform: translate(1.5px,1.5px) scale(1.1);
}
.range-wrap .handle:hover{
	background: rgba(var(--color-blue-600));
}
.range-wrap .active-region{
	border-radius: 0px;
}
.results.table{
	counter-reset: entryCounter;
}
.results.table .media-card:not(.has-rank)::before{
	counter-increment: entryCounter;
	content: counter(entryCounter);
	opacity: 0.5;
	font-size: 70%;
	margin-left: -21px;
	top: 2px;
	margin-right: 3px;
	position: absolute;
}
.results.cover .title{
	position: relative;
	padding-left: 15px;
	margin-left: -12px;
}
.results.cover .title .list-status.circle{
	visibility: visible;
	position: absolute;
	left: 0px;
	top: 3px;
}
.hohRoleLine{
	height: 7px;
	position: absolute;
	left: 0px;
	top: -8px;
	width: 80%;
	border-radius: 3px;
}
#hohMarkdownHelper{
	position: fixed;
	bottom: 20px;
	left: 20px;
	z-index: 999;
	cursor: pointer;
}
#hohMarkdownHelper:hover{
	font-weight: bold;
}
.hohGuideHeading,
.hohGuideHeading:visited{
	color: rgb(var(--color-blue));
}
.studio-page-unscoped.listView .grid-wrap{
	grid-template-columns: none;
	grid-template-columns: 1fr;
	grid-gap: 12px 30px;
}
.studio-page-unscoped.listView .media-card{
	backface-visibility: hidden;
	background: rgb(var(--color-background-100));
	border-radius: 2px;
	box-shadow: 0 14px 30px rgba(var(--color-shadow-blue),.15),0 4px 4px rgba(var(--color-shadow-blue),.05);
	display: inline-grid;
	grid-template-columns: 48px auto;
	position: relative;
	text-align: left;
	min-height: 80px;
	width: 100%;
}
.studio-page-unscoped.listView .cover{
	height: 81px;
	width: 54px;
	border-radius: 2px;
}
.studio-page-unscoped.listView .title{
	margin-left: 20px;
	color: rgb(var(--color-gray-900));
	display: block;
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 8px;
	margin-top: 16px;
}
.studio-page-unscoped.listView .media-card .hover-data{
	opacity: 1;
	left: 0px;
	background: none;
	box-shadow: none;
	padding: 10px;
}
.studio-page-unscoped.listView .media-card .hover-data .genres{
	position: absolute;
	left: 50px;
	top: 20px;
}
.studio-page-unscoped.listView .media-card .hover-data .info{
	position: absolute;
	right: 200px;
	top: 25px;
	width: 150px;
}
.studio-page-unscoped.listView .media-card .hover-data .score{
	position: absolute;
	right: 400px;
	top: 25px;
}
.studio-page-unscoped.listView .media-card .hover-data .date{
	position: absolute;
	right: 50px;
	top: 30px;
	width: 120px;
}
.studio-page-unscoped .hohThemeSwitch{
	width: 75px;
	position: absolute;
	top: 60px;
	left: 50%;
}
.studio .media-card.isMain{
	border-bottom: rgb(var(--color-blue));
	border-bottom-width: 1px;
	border-bottom-style: solid;
}
.hohInfoButton{
	position: absolute;
	right: 0px;
	top: 0px;
	cursor: pointer;
}
.anisong-entry{
	background: rgb(var(--color-foreground));
	margin-bottom: 5px;
	padding: 8px 10px;
	border-radius: 3px;
}
.anisongs .has-video {
	cursor: pointer;
	color: rgb(var(--color-text));
}
.anisongs .has-video:hover {
	transition: .15s;
	color: rgb(var(--color-blue));
}
.anisongs .anisong-entry video {
	cursor: auto;
	margin-top: 10px;
	max-width: 100%;
}
.search .filter > .icon{
	display: inline-block;
}
.sidebar .ranking{
	padding-left: 8px;
	padding-right: 8px;
}
.recommendations > .wrap{
	margin-left: 5px;
}
.substitution .character-roles > div:not(#hoh-character-roles){
	display: none;
}
[data-icon="notesTags"] text{
	fill: rgb(var(--color-foreground));
}
.list-editor .custom-lists{
	max-height: 400px;
	overflow-y: auto;
}
.list-editor .custom-lists:hover{
	margin-right: 0;
}
.forum-thread .comment .actions .like-wrap.hohHandledLike .users{
	width: max-content!important;
	max-width: 800px;
}
.forum-thread .body .actions .like-wrap.hohHandledLike .users{
	width: max-content!important;
	max-width: 800px;
}
/*no !importants here, since Erwin is styling this on his own:*/
.activity-feed .hohNoteSuffix:not(:empty),
.activity-feed .hohRewatchSuffix:not(:empty),
.activity-feed .hohScore:not(.hohSmiley){
	background-color: rgba(var(--color-black),0.5);
	padding: 0px 5px 1px 5px;
	border-radius: 3px;
	color: white;
}
.hohPinned{
	margin-bottom: 20px;
}
.hohPinned .wrap{
	background: rgb(var(--color-foreground));
	border-radius: 4px;
	font-size: 1.3rem;
	overflow: hidden;
	position: relative;
}
}
.hohPinned .text .header{
	display: flex;
	align-items: center;
}
.hohPinned .text .avatar{
	border-radius: 3px;
	height: 40px;
	width: 40px;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	display: inline-block;
}
.hohPinned .text .name{
	display: inline-block;
	height: 40px;
	line-height: 40px;
	margin-left: 12px;
	vertical-align: top;
	color: rgb(var(--color-blue));
	display: inline-block;
	font-size: 1.4rem;
}
.hohPinned .activity-markdown{
	font-size: 1.4rem;
	line-height: 1.4;
	overflow-wrap: break-word;
	word-break: break-word;
}
.hohPinned .markdown{
	margin-bottom: 14px;
	margin-top: 14px;
	max-height: 560px;
	overflow: hidden;
}
.hohPinned .text{
	padding: 20px;
}
.hohPinned .actions{
	bottom: 12px;
	color: rgb(var(--color-blue-dim));
	position: absolute;
	right: 12px;
	font-weight: 800;
}
.hohPinned .action{
	cursor: pointer;
	display: inline-block;
	padding-left: 5px;
	transition: .2s;
}
.hohPinned .time{
	color: rgb(var(--color-text-lighter));
	font-size: 1.1rem;
	position: absolute;
	right: 12px;
	top: 12px;
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	font-weight: 800;
}
.hohPinned .list{
	display: grid;
	grid-template-columns: 80px auto;
	height: 100%;
	min-height: 110px;
	font-size: 1.4rem;
}
.hohPinned .list .details{
	display: flex;
	flex-direction: column;
	justify-content: center;
	line-height: 1.4;
	min-height: 70px;
}
.hohPinned .status .title{
	color: rgb(var(--color-blue));
}
.hohPinned .cover{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
}
.hohSpinner.spinnerDone,
.spinnerDone{
	color: rgb(var(--color-green));
}
.hohSpinner.spinnerError,
.spinnerError{
	color: rgb(var(--color-red));
}
.user-social .filter-group > span{
	position: relative;
}
.hohCount{
	position: absolute;
	right: 1px;
	top: 0px;
}
.forum-thread .comments .nav{
	z-index: 2; /*the forum navigation should beat script UI elements*/
}
a.external-link.Official.Site[href*=".jp"]::after{
	content: "(JP)";
}
.forum-feed .filter-group [href^="/forum/subscribed"] + a[href="/forum/search"]::after{
	content: " 🔎";
}
.list-preview-wrap .size-toggle,
.feed-filter.el-dropdown-link{
	opacity: 1;
}
.medialist.table .entry:hover .cover .image{/*https://anilist.co/forum/thread/46727*/
	z-index: 1000;
}
.ilink:hover{
	color: rgb(var(--color-blue));
	cursor: pointer;
}
.forum-thread h1.title.locked ~ div .nav svg[data-icon="reply"]{/*letting people write out entire comments before telling them the thread is locked is cruel*/
	display: none;
}
.hohReverseTitle.status{
	display: flex!important;
}
.hohReverseTitle .title{
	order: -1;
	margin-right: 5px;
}
.medialist.table.compact .hohNeedsPositioning,
.medialist.table .hohNeedsPositioning{
	position: relative;
}
.medialist.cards .hohNeedsPositioning .hohChangeScore:last-of-type{
	right: 2px!important;
}
.hohNoSequelSetting{
	position: absolute;
	right: 0px;
	top: 10px;
}

.footer .links a{
	position:relative
}

.footer [href="https://discord.gg/TF428cr"]::before{
	content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" width="15" height="15"><g fill="%237289DA"><path d="M106.8,84.1 C101.1,84.1 96.6,89 96.6,95.1 C96.6,101.2 101.2,106.1 106.8,106.1 C112.5,106.1 117,101.2 117,95.1 C117,89 112.4,84.1 106.8,84.1 Z M70.3,84.1 C64.6,84.1 60.1,89 60.1,95.1 C60.1,101.2 64.7,106.1 70.3,106.1 C76,106.1 80.5,101.2 80.5,95.1 C80.6,89 76,84.1 70.3,84.1 Z"/> <path d="M155.4,0.9 L21.4,0.9 C10.1,0.9 0.9,10.1 0.9,21.4 L0.9,155.4 C0.9,166.7 10.1,175.9 21.4,175.9 L134.8,175.9 L129.5,157.6 L142.3,169.4 L154.4,180.5 L176,199.2 L176,21.4 C175.9,10.1 166.7,0.9 155.4,0.9 Z M116.8,130.4 C116.8,130.4 113.2,126.1 110.2,122.4 C123.3,118.7 128.3,110.6 128.3,110.6 C124.2,113.3 120.3,115.2 116.8,116.5 C111.8,118.6 107,119.9 102.3,120.8 C92.7,122.6 83.9,122.1 76.4,120.7 C70.7,119.6 65.8,118.1 61.7,116.4 C59.4,115.5 56.9,114.4 54.4,113 C54.1,112.8 53.8,112.7 53.5,112.5 C53.3,112.4 53.2,112.3 53.1,112.3 C51.3,111.3 50.3,110.6 50.3,110.6 C50.3,110.6 55.1,118.5 67.8,122.3 C64.8,126.1 61.1,130.5 61.1,130.5 C39,129.8 30.6,115.4 30.6,115.4 C30.6,83.5 45,57.6 45,57.6 C59.4,46.9 73,47.2 73,47.2 L74,48.4 C56,53.5 47.8,61.4 47.8,61.4 C47.8,61.4 50,60.2 53.7,58.6 C64.4,53.9 72.9,52.7 76.4,52.3 C77,52.2 77.5,52.1 78.1,52.1 C84.2,51.3 91.1,51.1 98.3,51.9 C107.8,53 118,55.8 128.4,61.4 C128.4,61.4 120.5,53.9 103.5,48.8 L104.9,47.2 C104.9,47.2 118.6,46.9 132.9,57.6 C132.9,57.6 147.3,83.5 147.3,115.4 C147.3,115.3 138.9,129.7 116.8,130.4 L116.8,130.4 Z"/></g></svg>');
	position: absolute;
	left: -10px;
}

.footer [href="https://twitter.com/AniListco"]::before{
	content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 244" height="15" width="15" version="1.1"><g transform="translate(-539.18 -568.86)"><path d="m633.9 812.04c112.46 0 173.96-93.168 173.96-173.96 0-2.6463-0.0539-5.2806-0.1726-7.903 11.938-8.6302 22.314-19.4 30.498-31.66-10.955 4.8694-22.744 8.1474-35.111 9.6255 12.623-7.5693 22.314-19.543 26.886-33.817-11.813 7.0031-24.895 12.093-38.824 14.841-11.157-11.884-27.041-19.317-44.629-19.317-33.764 0-61.144 27.381-61.144 61.132 0 4.7978 0.5364 9.4646 1.5854 13.941-50.815-2.5569-95.874-26.886-126.03-63.88-5.2508 9.0354-8.2785 19.531-8.2785 30.73 0 21.212 10.794 39.938 27.208 50.893-10.031-0.30992-19.454-3.0635-27.69-7.6468-0.009 0.25652-0.009 0.50661-0.009 0.78077 0 29.61 21.075 54.332 49.051 59.934-5.1376 1.4006-10.543 2.1516-16.122 2.1516-3.9336 0-7.766-0.38716-11.491-1.1026 7.7838 24.293 30.355 41.971 57.115 42.465-20.926 16.402-47.287 26.171-75.937 26.171-4.929 0-9.7983-0.28036-14.584-0.84634 27.059 17.344 59.189 27.464 93.722 27.464" fill="%231da1f2"/></g></svg>');
	position: absolute;
	left: -10px;
}

.footer [href="https://www.facebook.com/AniListco"]::before{
	content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 36 36" version="1.1"><rect fill="%233B5998" width="36" height="36"/><path fill="%23FFFFFF" d="M30.895,16.535l-0.553,5.23h-4.181v15.176h-6.28V21.766H16.75v-5.23h3.131v-3.149c0-4.254,1.768-6.796,6.796-6.796h4.181v5.23h-2.615c-1.952,0-2.081,0.736-2.081,2.1v2.615H30.895z"/></svg>');
	position: absolute;
	left: -10px;
}

.footer [href="https://github.com/AniList"]::before{
	content: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" width="15" height="15" version="1.1"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>');
	position: absolute;
	left: -10px;
}
.footer [href="/sitemap/index.xml"]::after{
	content: ".xml";
}

.hohDisplayBox{
	position: fixed;
	top: 80px;
	left: 200px;
	z-index: 999;
	padding: 20px;
	background-color: rgb(var(--color-foreground));
	border: solid 1px;
	border-radius: 4px;
	box-shadow: black 2px 2px 20px;
	overflow: hidden;
	filter: brightness(110%);
}
.hohDisplayBox .scrollableContent{
	overflow: auto;
	height: 100%;
	scrollbar-width: thin;
	margin-top: 5px;
	padding: 30px;
	padding-top: 35px;
	padding-left: 15px;
}
.hohDisplayBoxClose{
	position: absolute;
	right: 15px;
	top: 15px;
	cursor: pointer;
	background-color: red;
	border: solid;
	border-width: 1px;
	border-radius: 2px;
	color: white;
	border-color: rgb(var(--color-text));
	filter: drop-shadow(0 0 0.2rem crimson);
	z-index: 20;
}
}
.hohDisplayBoxClose:hover{
	filter: drop-shadow(0 0 0.75rem crimson);
}
.hohNewChapter .hohDisplayBoxClose{
	display: none;
	top: 7px;
}
.hohNewChapter:hover .hohDisplayBoxClose{
	display: inline;
}
.hohDisplayBoxTitle{
	position: absolute;
	top: 5px;
	left: 5px;
	font-weight: bold;
	font-size: 1.2em;
}

@media(max-width: 1540px){
	.substitution .container{
		max-width: 1200px;
	}
	.hohStudioSubstitute{
		grid-template-columns: repeat(2,1fr);
	}
}
@media(max-width: 1040px){
	.input-wrap.manga input[placeholder="Status"],
	.input-wrap.anime input[placeholder="Status"],
	.input-wrap.anime .form.score input{
		width: 100%;
	}
	.substitution .grid-wrap{
		grid-template-columns: 1fr;
	}
	.home .list-preview .media-preview-card:nth-child(5n+3) .content{
		text-align: left;
		right: unset;
	}
	.status{
		font-size: small;
	}
	.status > .name{
		padding: 5px;
	}
}
@media(max-width: 760px){
	#hohMALscore{
		padding-right: 25px;
	}
	#hohMALscore .type{
		font-weight: 400;
	}
	#hohMALscore .value{
		color: rgb(var(--color-text));
		font-size: 1.4rem;
	}
	.hohMediaImageContainer{
		position: absolute;
		right: -22px;
		max-height: 30px;
		width: 25px;
		overflow: scroll;
		scrollbar-width: thin;
	}
	.hohUserImageSmall{
		display: none;
	}
	.hohMessageText{
		margin-top: 30px!important;
	}
	.hohBackgroundUserCover{
		margin-top: 1px;
	}
	.hohMediaImageContainer > a{
		height: 20px;
	}
	.hohMediaImage{
		height: 20px;
		width: 20px;
		margin-right: 0px
	}
	.hohNotification{
		margin-right: 23px;
		font-size: 1.5rem;
	}
	.hohCommentsContainer{
		position: relative;
		top: 70px;
	}
	.hohComments{
		position: absolute;
		right: -5px;
		top: 5px;
	}
	.notifications-feed .filters p{
		display: inline;
		margin-left: 10px;
	}
	.activity-feed .actions,
	.activity-feed .actions .action .count{
		font-size: 1.6rem;
	}
	.hohDownload{
		top: 50px;
	}
	.media .hohDownload{
		top: 5px;
	}
	#dubNotice{
		margin: 0px;
	}
	.hohFeedFilter .hohDescription{
		display: none;
	}
	.forum-feed .create-btn + .filter-group > a{
		display: inline-block;
		width: 19%;
		padding-top: 40px;
		padding-bottom: 40px;
		text-align: center;
		border-style: solid;
		border-width: 1px;
		border-color: rgb(var(--color-foreground));
	}
	.hohExtraFilters{
		max-height: 250px;
		overflow: auto;
	}
	.recommendations-wrap .actions .thumbs-down{
		margin-right: 10px;
	}
	.relations.hohRelationStatusDots .hohStatusDot,
	.recommendation-card .hohStatusDot{
		position: relative;
		transform: none;
	}
	.hohCategories::after{
		display: block;
		color: rgb(var(--color-peach));
		content: "On mobile? The 'mobile friendly' setting will probably make the script a lot less broken";
	}
	.media .data-set a[href^="/studio/"]{
		margin-left: 5px;
	}
	.media p.description:empty{
		display: none;
	}
}
@media(max-width: 500px){
	.footer [href="https://anilist.co"],
	.footer [href="/sitemap/index.xml"]{
		display: none;
	}
	.footer .links{
		margin-left: -20px;
	}
	.markdown-editor{
		padding: 12px 2px!important;
	}
	.hohColourPicker{
		display: none;
	}
}


`;
let documentHead = document.querySelector("head");
if(documentHead && document.URL !== "https://anilist.co/graphiql"){
	documentHead.appendChild(style)
}
else{
	return//xml documents or something. At least it's not a place where the script can run
}
/* eslint-disable no-extend-native */

if(!String.prototype.includes){//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	String.prototype.includes = function(search,start){
		'use strict';
		if(search instanceof RegExp){
			throw TypeError('first argument must not be a RegExp');
		} 
		if(start === undefined){
			start = 0
		}
		return this.indexOf(search,start) !== -1;
	}
}

//https://github.com/JSmith01/broadcastchannel-polyfill
//The Unlicense
if(!window.BroadcastChannel){
    var channels = [];

    const BroadcastChannel = function(channel) {
        var $this = this;
        channel = String(channel);

        var id = '$BroadcastChannel$' + channel + '$';

        channels[id] = channels[id] || [];
        channels[id].push(this);

        this._name = channel;
        this._id = id;
        this._closed = false;
        this._mc = new MessageChannel();
        this._mc.port1.start();
        this._mc.port2.start();

        window.addEventListener('storage', function(e) {
            if (e.storageArea !== window.localStorage) return;
            if (e.newValue == null || e.newValue === '') return;
            if (e.key.substring(0, id.length) !== id) return;
            var data = JSON.parse(e.newValue);
            $this._mc.port2.postMessage(data);
        });
    }

    BroadcastChannel.prototype = {
        // BroadcastChannel API
        get name() {
            return this._name;
        },
        postMessage: function(message) {
            var $this = this;
            if (this._closed) {
                var e = new Error();
                e.name = 'InvalidStateError';
                throw e;
            }
            var value = JSON.stringify(message);

            // Broadcast to other contexts via storage events...
            var key = this._id + String(Date.now()) + '$' + String(Math.random());
            window.localStorage.setItem(key, value);
            setTimeout(function() {
                window.localStorage.removeItem(key);
            }, 500);

            // Broadcast to current context via ports
            channels[this._id].forEach(function(bc) {
                if (bc === $this) return;
                bc._mc.port2.postMessage(JSON.parse(value));
            });
        },
        close: function() {
            if (this._closed) return;
            this._closed = true;
            this._mc.port1.close();
            this._mc.port2.close();

            var index = channels[this._id].indexOf(this);
            channels[this._id].splice(index, 1);
        },

        // EventTarget API
        get onmessage() {
            return this._mc.port1.onmessage;
        },
        set onmessage(value) {
            this._mc.port1.onmessage = value;
        },
        addEventListener: function(/*type, listener , useCapture*/) {
            return this._mc.port1.addEventListener.apply(this._mc.port1, arguments);
        },
        removeEventListener: function(/*type, listener , useCapture*/) {
            return this._mc.port1.removeEventListener.apply(this._mc.port1, arguments);
        },
        dispatchEvent: function(/*event*/) {
            return this._mc.port1.dispatchEvent.apply(this._mc.port1, arguments);
        },
    };

    window.BroadcastChannel = window.BroadcastChannel || BroadcastChannel;
}

/**
 * Array.flat() polyfill
 * Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isArray_recursivity
 */
if (!Array.prototype.flat) {
	Array.prototype.flat = function(depth) {

		'use strict';

		// If no depth is specified, default to 1
		if (depth === undefined) {
			depth = 1;
		}

		// Recursively reduce sub-arrays to the specified depth
		var flatten = function (arr, depth) {

			// If depth is 0, return the array as-is
			if (depth < 1) {
				return arr.slice();
			}

			// Otherwise, concatenate into the parent array
			return arr.reduce(function (acc, val) {
				return acc.concat(Array.isArray(val) ? flatten(val, depth - 1) : val);
			}, []);

		};

		return flatten(this, depth);

	};
}

/* eslint-enable no-extend-native */


//begin "conditionalStyles.js"

function initCSS(){
moreStyle.textContent = "";

let aliasFlag = false;

if(useScripts.shortRomaji){
	shortRomaji.forEach(createAlias);
	aliasFlag = true
}

const titleAliases = JSON.parse(localStorage.getItem("titleAliases"));
if(titleAliases){
	aliasFlag = true;
	titleAliases.forEach(createAlias)
}

if(aliasFlag){
	moreStyle.textContent += `
a.title::before
,.quick-search-results .el-select-dropdown__item a > span::before{
	visibility: visible;
	line-height: 1.15;
	margin-right: 2px;
}
.medialist.table .title > a::before{
	visibility: visible;
	font-size: 1.5rem;
	margin-right: 2px;
}
.medialist.compact .title > a::before
,.medialist.cards .title > a::before
,.home .status > a.title::before
,.media-embed .title::before{
	visibility: visible;
	font-size: 1.3rem;
	margin-right: 2px;
}
.role-card a.content > .name::before{
	visibility: visible;
	font-size: 1.2rem;
}
.overlay > a.title::before
,.media-preview-card a.title::before{
	visibility: visible;
	font-size: 1.4rem;
	line-height: 1.15;
}
.role-card a.content > .name{
	line-height: 1.3!important;
}`
}
if(useScripts.CSSfavs){
/*adds a logo to most favourite studio entries. Add more if needed */
	const favStudios = [
[1,   "Studio-Pierrot",	"https://upload.wikimedia.org/wikipedia/commons/7/70/Studio_Pierrot_logo.svg"],
[2,   "Kyoto-Animation","https://upload.wikimedia.org/wikipedia/commons/b/bf/Kyoto_Animation_logo.svg"],
[3,   "GONZO",		"https://upload.wikimedia.org/wikipedia/commons/thumb/8/85/Gonzo_company.png/220px-Gonzo_company.png"],
[4,   "bones",		"https://i.stack.imgur.com/7pRQn.png"],
[5,   "Bee-Train",	"https://upload.wikimedia.org/wikipedia/commons/4/45/Bee_Train.svg"],
[6,   "Gainax",		"https://upload.wikimedia.org/wikipedia/commons/2/27/GAINAX.svg"],
[7,   "JC-Staff",	"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/J.C.Staff_Logo.svg/220px-J.C.Staff_Logo.svg.png"],
[8,   "Artland",	"https://upload.wikimedia.org/wikipedia/commons/7/75/Artland_studio_logo.png"],
[10,  "Production-IG",	"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Production_I.G_Logo.svg/250px-Production_I.G_Logo.svg.png"],
[11,  "MADHOUSE",	"https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Madhouse_studio_logo.svg/300px-Madhouse_studio_logo.svg.png"],
[13,  "Studio-4C",	"https://upload.wikimedia.org/wikipedia/en/e/ec/Studio_4C_logo.png"],
[14,  "Sunrise",	"https://upload.wikimedia.org/wikipedia/commons/6/60/Sunrise-Logo.svg"],
[17,  "Aniplex",	"https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Aniplex_logo.svg/220px-Aniplex_logo.svg.png"],
[18,  "Toei-Animation",	"https://i.stack.imgur.com/AjzVI.png",76,30],
[21,  "Studio-Ghibli",	"https://upload.wikimedia.org/wikipedia/en/thumb/c/ca/Studio_Ghibli_logo.svg/220px-Studio_Ghibli_logo.svg.png",76,30],
[22,  "Nippon-Animation","https://upload.wikimedia.org/wikipedia/en/thumb/b/b4/Nippon.png/200px-Nippon.png"],
[25,  "Milky-Animation-Label","https://files.catbox.moe/begz5e.jpg"],
[27,  "Xebec",		"https://upload.wikimedia.org/wikipedia/fr/b/bd/Logo_Xebec.svg"],
[28,  "Oriental-Light-and-Magic","https://i.stack.imgur.com/Sbllv.png"],
[29,  "VAP",		"https://upload.wikimedia.org/wikipedia/commons/7/75/VAP_logo.svg"],
[32,  "Manglobe",	"https://i.imgur.com/W8U74wO.png"],
[34,  "Hal-Film-Maker",	"https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Hal_film_maker_logo.gif/220px-Hal_film_maker_logo.gif"],
[35,  "Seven-Arcs",	"https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Seven_Arcs_logo.svg/320px-Seven_Arcs_logo.svg.png"],
[36,  "Studio-Gallop",	"https://upload.wikimedia.org/wikipedia/commons/3/37/Studio_Gallop.png"],
[37,  "Studio-DEEN",	"https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Studio_Deen_logo.svg/220px-Studio_Deen_logo.svg.png"],
[38,  "Arms",		"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Arms_Corporation.png/200px-Arms_Corporation.png"],
[39,  "Daume",		"https://upload.wikimedia.org/wikipedia/commons/3/3e/Daume_studio_logo.png",70,35],
[41,  "Satelight",	"https://i.stack.imgur.com/qZVQg.png",76,30],
[43,  "ufotable",	"https://upload.wikimedia.org/wikipedia/commons/1/19/Ufotable_Animaci%C3%B3n.png"],
[44,  "Shaft",		"https://i.stack.imgur.com/tuqhK.png"],
[45,  "Pink-Pineapple",	"https://i.stack.imgur.com/2NMQ0.png"],
[47,  "Studio-Khara",	"https://i.stack.imgur.com/2d1TT.png",76,30],
[48,  "AIC",		"https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/AIC_logo.png/220px-AIC_logo.png"],
[51,  "diomeda",	"https://i.stack.imgur.com/ZHt3T.jpg"],
[53,  "Dentsu",		"https://upload.wikimedia.org/wikipedia/commons/thumb/1/10/Dentsu_logo.svg/200px-Dentsu_logo.svg.png"],
[58,  "Square-Enix",	"https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Square_Enix_logo.svg/230px-Square_Enix_logo.svg.png"],
[65,  "Tokyo-Movie-Shinsha","https://upload.wikimedia.org/wikipedia/en/2/22/Tokyo_Movie_Shinsha.png"],
[66,  "Key",		"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Key_Visual_Arts_Logo.svg/167px-Key_Visual_Arts_Logo.svg.png",76,25],
[68,  "Mushi-Productions","https://i.stack.imgur.com/HmYdT.jpg"],
[73,  "TMS-Entertainment","https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/TMS_Entertainment_logo.svg/220px-TMS_Entertainment_logo.svg.png"],
[79,  "Genco",		"https://www.thefilmcatalogue.com/assets/company-logos/5644/logo_en.png"],
[86,  "Group-TAC",	"https://upload.wikimedia.org/wikipedia/commons/b/b7/Group_TAC.png"],
[91,  "feel",		"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/Feel_logo.png/320px-Feel_logo.png"],
[95,  "Doga-Kobo",	"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Doga_Kobo_Logo.svg/220px-Doga_Kobo_Logo.svg.png"],
[97,  "ADV-Films",	"https://upload.wikimedia.org/wikipedia/en/4/45/A.D._Vision_%28logo%29.png"],
[102, "FUNimation-Entertainment","https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Funimation_2016.svg/320px-Funimation_2016.svg.png"],
[103, "Tatsunoko-Production","https://upload.wikimedia.org/wikipedia/commons/thumb/7/7a/Tatsunoko_2016_logo.png/300px-Tatsunoko_2016_logo.png"],
[104, "Lantis",		"https://upload.wikimedia.org/wikipedia/commons/3/39/Lantis_logo.png"],
[108, "Media-Factory",	"https://i.stack.imgur.com/rR7yU.png",76,25],
[109, "Shochiku",	"https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Shochiku_logo_%28text%29.svg/320px-Shochiku_logo_%28text%29.svg.png"],
[112, "Brains-Base",	"https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Brain%27s_Base_logo.png/200px-Brain%27s_Base_logo.png"],
[113, "Kadokawa-Shoten","https://i.stack.imgur.com/ZsUDR.gif"],
[119, "Viz-Media",	"https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Viz_Media_2017_logo.svg/320px-Viz_Media_2017_logo.svg.png"],
[132, "PA-Works",	"https://i.stack.imgur.com/7kjSn.png"],
[143, "Mainichi-Broadcasting","https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Mainichi_Broadcasting_System_logo.svg/200px-Mainichi_Broadcasting_System_logo.svg.png"],
[144, "Pony-Canyon",	"https://i.stack.imgur.com/9kkew.png"],
[145, "TBS",		"https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/TBS_logo.svg/200px-TBS_logo.svg.png"],
[150, "Sanrio",		"https://upload.wikimedia.org/wikipedia/en/thumb/4/41/Sanrio_logo.svg/220px-Sanrio_logo.svg.png"],
[159, "Kodansha",	"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Kodansha.png/200px-Kodansha.png"],
[166, "Movic",		"https://upload.wikimedia.org/wikipedia/commons/f/f3/Movic_logo.png"],
[167, "Sega",		"https://upload.wikimedia.org/wikipedia/commons/1/13/SEGA_logo.svg"],
[169, "Fuji-TV",	"https://upload.wikimedia.org/wikipedia/en/thumb/e/e9/Fuji_TV_logo.svg/225px-Fuji_TV_logo.svg.png",76,30],
[193, "Idea-Factory",	"https://upload.wikimedia.org/wikipedia/en/e/eb/Idea_factory.gif"],
[196, "Production-Reed","https://upload.wikimedia.org/wikipedia/fr/7/7d/Production_Reed_Logo.png"],
[199, "Studio-Nue",	"https://i.stack.imgur.com/azzKH.png"],
[200, "Tezuka-Productions","https://upload.wikimedia.org/wikipedia/fr/f/fe/Tezuka_Productions_Logo.png"],
[238, "ATX",		"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/AT-X_logo.svg/150px-AT-X_logo.svg.png",76,30],
[247, "ShinEi-Animation","https://i.stack.imgur.com/b2lcL.png"],
[262, "Kadokawa-Pictures-USA","https://i.stack.imgur.com/ZsUDR.gif"],
[287, "David-Production","https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/David_Production_Logo.png/320px-David_Production_Logo.png",76,30],
[290, "Kinema-Citrus",	"https://upload.wikimedia.org/wikipedia/commons/c/c0/Kinema_Citrus_logo.png",76,25],
[288, "Kaname-Productions","https://share.wildbook.me/1vyXEPUyUGnAHEnT.webp",73,30],
[291, "CoMix-Wave",	"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Cwflogo.png/150px-Cwflogo.png"],
[292, "AIC-Plus",	"https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/AIC_logo.png/220px-AIC_logo.png"],
[300, "SILVER-LINK",	"https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Silver_Link_Logo.svg/220px-Silver_Link_Logo.svg.png"],
[309, "GoHands",	"https://i.stack.imgur.com/pScIZ.jpg"],
[314, "White-Fox",	"https://i.stack.imgur.com/lwG1T.png",76,30],
[333, "TYO-Animations",	"https://i.stack.imgur.com/KRqAp.jpg",76,25],
[334, "Ordet",		"https://i.stack.imgur.com/evr12.png",76,30],
[346, "Hoods-Entertainment","https://i.stack.imgur.com/p7S0I.png"],
[352, "Kadokawa-Pictures-Japan","https://i.stack.imgur.com/ZsUDR.gif"],
[365, "PoRO",		"https://i.stack.imgur.com/3rlAh.png"],
[372, "NIS-America-Inc","https://upload.wikimedia.org/wikipedia/en/e/e7/Nis.png"],
[376, "Sentai-Filmworks","https://i.stack.imgur.com/JV8R6.png",74,30],
[397, "Bridge",		"https://i.imgur.com/4Qn4EmK.png"],
[418, "Studio-Gokumi",	"https://i.stack.imgur.com/w1y22.png"],
[436, "AIC-Build",	"https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/AIC_logo.png/220px-AIC_logo.png"],
[437, "Kamikaze-Douga",	"https://files.catbox.moe/48mdqh.jpg"],
[456, "Lerche",		"https://i.stack.imgur.com/gRQPc.png"],
[459, "Nitroplus",	"https://upload.wikimedia.org/wikipedia/en/thumb/0/09/Nitroplus_logo.png/220px-Nitroplus_logo.png"],
[493, "Aniplex-of-America","https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Aniplex_logo.svg/220px-Aniplex_logo.svg.png"],
[503, "Nintendo-Co-Ltd","https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Nintendo.svg/220px-Nintendo.svg.png"],
[537, "SANZIGEN",	"https://i.stack.imgur.com/CkuqH.png",76,30],
[555, "Studio-Chizu",	"https://i.stack.imgur.com/h2RuH.gif"],
[561, "A1-Pictures",	"https://i.stack.imgur.com/nBUYo.png",76,30],
[569, "MAPPA",		"https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/MAPPA_Logo.svg/220px-MAPPA_Logo.svg.png"],
[681, "ASCII-Media-Works","https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/ASCII_Media_Works_logo.svg/220px-ASCII_Media_Works_logo.svg.png"],
[803, "Trigger",	"https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Trigger_Logo.svg/220px-Trigger_Logo.svg.png"],
[783, "GKids",		"https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/GKIDS_logo.svg/150px-GKIDS_logo.svg.png"],
[839, "LIDENFILMS",	"https://upload.wikimedia.org/wikipedia/commons/6/6e/LidenFilms.png",76,30],
[858, "Wit-Studio",	"https://i.stack.imgur.com/o3Rro.png",76,30],
[911, "Passione",	"https://i.stack.imgur.com/YyEGg.jpg"],
[4418,"8bit",		"https://upload.wikimedia.org/wikipedia/commons/a/a6/Eight_Bit_logo.png"],
[6069,"Studio-3Hz",	"https://i.stack.imgur.com/eD0oe.jpg"],
[6071,"Studio-Shuka",	"https://upload.wikimedia.org/wikipedia/commons/f/fa/Shuka_studio.jpg"],
[6077,"Orange",		"https://i.stack.imgur.com/ve9mm.gif"],
[6142,"Geno-Studio",	"https://upload.wikimedia.org/wikipedia/en/thumb/f/f4/Genostudio.jpg/220px-Genostudio.jpg",76,25],
[6145,"Science-SARU",	"https://i.stack.imgur.com/zo9Fx.png"],
[6148,"NUT",		"https://upload.wikimedia.org/wikipedia/commons/b/b0/NUT_animation_studio_logo.png"],
[6222,"CloverWorks",	"https://i.stack.imgur.com/9Fvr7.jpg"],
[6225,"TriF-studio",	"https://i.stack.imgur.com/lL85s.png",60,50],
[6283,"Studio-Durian",	"https://studio-durian.jp/images/ROGO2opa.png"]
]

	let favStudioString = "";
	if(useScripts.CSSfavs){
		favStudioString += `
.overview  .favourites > .favourites-wrap > div,
.overview  .favourites > .favourites-wrap > a{
/*make the spaces in the grid even*/
	margin-bottom: 0px!important;
	margin-right: 0px!important;
	column-gap: 10px!important;
}
.user .overview{
	grid-template-columns: 470px auto!important;
}
.overview .favourites > .favourites-wrap{
	display: grid!important;
	padding: 0px!important;
	display: grid;
	grid-gap: 10px;
	column-gap: 10px!important;
	grid-template-columns: repeat(auto-fill,85px);
	grid-template-rows: repeat(auto-fill,115px);
	background: rgb(0,0,0,0) !important;
	width: 470px;
}
.genre-overview .genre{
	display: inline!important;
}
.genre-overview .genre .name{
	font-size: small;
}
.overview .favourite.studio{
	cursor: pointer;
	min-height: 115px;
	font-size: 15px;
	display: grid;
	grid-gap: 10px;
	padding: 2px!important;
	padding-top: 8px!important;
	background-color: rgba(var(--color-foreground))!important;
	text-align: center;
	align-content: center;
}
.site-theme-dark .overview  .favourite.studio{
	background-color: rgb(49,56,68)!important;
}
.preview .favourite.media,
.preview .favourite.staff,
.preview .favourite.character{
	background-color: rgb(var(--color-foreground));
}
.overview .favourite.studio::after{
	display: inline-block;
	background-repeat: no-repeat;
	content:"";
	margin-left:5px;
	background-size: 76px 19px;
	width: 76px;
	height: 19px;
}`;
		favStudios.forEach(studio => {
			if(studio[2] !== ""){
				favStudioString += `.favourite.studio[href="/studio/${studio[0]}/${studio[1]}"]::after{background-image: url("${studio[2]}");`;
				if(studio.length === 5){
					favStudioString += `background-size: ${studio[3]}px ${studio[4]}px;width: ${studio[3]}px;height: ${studio[4]}px;`;
				}
				favStudioString += "}";
			}
		});
	}
	moreStyle.textContent += favStudioString;
}

if(useScripts.CSScompactBrowse){
	moreStyle.textContent += `
.results > .studio{
	counter-reset: ranking;
}
.studio .media-card.isMain{
	border-bottom: rgb(var(--color-blue));
	border-bottom-width: 1px;
	border-bottom-style: solid;
}
.search .results.cover .media-card,
.search .results .staff-card,
.search-landing .results:not(.table) .media-card{
	width: 150px;
}
.search .results.cover,
.search-landing .results:not(.table){
	grid-template-columns: repeat(auto-fill,150px);
	grid-gap: 25px 20px;
}
.search .results.table{
	grid-gap: 12px;
}
.search .results.table .cover{
	height: 81px;
	width: 54px;
}
.search .results.table .media-card{
	padding: 0px;
}
.search .results.cover .media-card .cover,
.search-landing .results:not(.table) .media-card .cover,
.search .results .staff-card .cover{
	height: 225px;
}
.search:not(.other-type) .landing-section:not(.top) .link{
	max-width: 1000px;
}

	`
}
if(!useScripts.CSSverticalNav && useScripts.slimNav){
	moreStyle.textContent += `
#nav.nav{
	height: 40px;
}
	`
}
if(useScripts.annoyingAnimations){
	moreStyle.textContent += `
.media-card .open-editor.circle{
	transition: unset;
}
.media-card:hover .hover-data{
	animation: none!important;
}
.cover.loading::before{
	display: none!important;
}
.activity-entry .like-wrap .users{
	transition: none;
}
.search .results .media-card{
	animation: none;
}`
}
if(useScripts.CSSprofileClutter){
	moreStyle.textContent += `
.overview .list-stats > .footer{
	display: none;
}
.overview > .section > .desktop:nth-child(2){
	display: none;
}
.overview > .section > .desktop:nth-child(3){
	display: none;
}
.overview > .section > .desktop.favourites{
	display: inherit;
}
	`
}
if(useScripts.CSSbannerShadow){
	moreStyle.textContent += `
.banner .shadow{
	display: none;
}
.banner-content h1.name{
	filter: drop-shadow(0px 0px 6px black);
}
	`
}
if(useScripts.betterListPreview && !(window.screen.availWidth && window.screen.availWidth <= 1040)){
	moreStyle.textContent += `
.home{
	grid-template-columns: auto 545px!important;
}
@media(min-width: 1040px) and (max-width: 1540px){
	.page-content > .container{
		max-width: 1300px;
	}
	.list-preview{
		gap: 15px!important;
	}
	.home{
		grid-template-columns: auto 525px!important;
	}
}
#hohListPreview + .list-previews .list-preview-wrap{
	display: none;
}
#hohListPreview + .list-previews .list-preview-wrap:last-child{
	display: block;
}
	`
}
if(useScripts.CSSgreenManga){
	moreStyle.textContent += `
.review-card:hover .banner[data-src*="/media/manga/"] + .content > .header{
	color: rgb(var(--color-green));
}
.review-card:hover .banner[data-src*="/media/anime/"] + .content > .header{
	color: rgb(var(--color-blue));
}
.user .review-card:hover .banner[data-src*="/media/anime/"] + .content > .header{
	color: rgb(61,180,242);
}
.activity-markdown a[href^="https://anilist.co/manga/"],
.activity-markdown a[href^="https://anilist.co/search/manga"],
.activity-markdown a[href^="/manga/"],
.reply-markdown a[href^="https://anilist.co/manga/"],
.reply-markdown a[href^="https://anilist.co/search/manga"],
.reply-markdown a[href^="/manga/"]{
	color: rgba(var(--color-green));
}
.hohDataChange a[href^="/manga/"]{
	color: rgba(var(--color-green));
}
.activity-manga_list > div > div > div > div > .title,
.hohPinned .list .title[href^="/manga/"]{
	color: rgba(var(--color-green))!important;
}
.media .relations .cover[href^="/manga/"] + div div{
	color: rgba(var(--color-green));
}
.media .relations .cover[href^="/anime/"] + div div{
	color: rgba(var(--color-blue));
}
.media .relations .cover[href^="/manga/"]{
	border-bottom-style: solid;
	border-bottom-color: rgba(var(--color-green));
	border-bottom-width: 2px;
}
.character-wrap .role-card:hover .title[href^="/anime/"]{
	color: rgb(var(--color-blue)) !important;
}
.character-wrap .role-card .title[href^="/manga/"],
.character-wrap .role-card:hover .title[href^="/manga/"],
.media-roles .media .content:hover[href^="/manga/"] .name{
	color: rgb(var(--color-green)) !important;
}
.media .relations.small .cover[href^="/manga/"]::after{
	position:absolute;
	left:1px;
	bottom:3px;
	content:"";
	border-style: solid;
	border-color: rgba(var(--color-green));
	border-width: 2px;
}
.media .relations .cover[href^="/anime/"]{
	border-bottom-style: solid;
	border-bottom-color: rgba(var(--color-blue));
	border-bottom-width: 2px;
}
.media .relations .cover div.image-text{
	margin-bottom: 2px!important;
	border-radius: 0px!important;
	padding-bottom: 8px!important;
	padding-top: 8px!important;
	font-weight: 500!important;
}
.media-embed[data-media-type="manga"] .title{
	color: rgba(var(--color-green));
}
.media-manga .actions .list{
	background: rgba(var(--color-green));
}
.media-manga .sidebar .review.button{
	background: rgba(var(--color-green));
}
.media-manga .container .content .nav .link{
	color: rgba(var(--color-green));
}
.hover-manga:hover{
	color: rgba(var(--color-green))!important;
}
.home .recent-reviews + div .cover[href^="/manga/"] + .content .info-header{
	color: rgba(var(--color-green));
}
.recommendations-wrap .recommendation-pair-card a[href^="/manga/"]:hover .title{
	color: rgba(var(--color-green));
}

	`
}
if(useScripts.CSSexpandFeedFilters && (!useScripts.mobileFriendly)){
	moreStyle.textContent += `
.home .activity-feed-wrap .section-header .el-dropdown-menu,
.user .activity-feed-wrap .section-header .el-dropdown-menu{
	background: none;
	position: static;
	display: inline !important;
	margin-right: 15px;
	box-shadow: none !important;
}
.home .activity-feed-wrap .section-header .el-dropdown-menu__item,
.user .activity-feed-wrap .section-header .el-dropdown-menu__item{
	font-weight: normal;
	color: rgb(var(--color-text-lighter));
	margin-left: -2px !important;
	display: inline;
	font-size: 1.2rem;
	padding: 4px 15px 5px 15px;
	border-radius: 3px;
	transition: .2s;
	background: none;
}
.home .activity-feed-wrap .section-header .el-dropdown-menu__item.active,
.user .activity-feed-wrap .section-header .el-dropdown-menu__item.active{
	background: none!important;
	color: rgb(var(--color-blue));
}
.home .activity-feed-wrap .section-header .el-dropdown-menu__item:hover,
.user .activity-feed-wrap .section-header .el-dropdown-menu__item:hover{
	background: none!important;
	color: rgb(var(--color-blue));
}
.home .feed-select .feed-filter,
.user .section-header > .el-dropdown > .el-dropdown-selfdefine{
	display: none;
}

	`
}
if(useScripts.showRecVotes){
	moreStyle.textContent += `
.recommendation-card .rating-wrap{
	opacity: 1;
}`
}
if(useScripts.CSSverticalNav && (!useScripts.mobileFriendly)){
	moreStyle.textContent += `
.media .sidebar .tags .add-icon{
	opacity: 1;
}
#hohListPreview .content{
	width: 240px;
}
.user .overview > .section:first-child{
	max-width: 555px;
}
.user .overview{
 	grid-template-columns: calc(25% + 200px) 55% !important;;
}
.media .activity-entry .cover{
	display: none;
}
.media .activity-entry .embed .cover{
	display: inline;
}
.media .activity-entry .details{
	min-width: 500px;
	margin-left: 30px;
}
.media .activity-entry .details > .avatar{
	position: absolute;
	top: 0px;
	left: 5px;
}
.media .activity-entry .list{
	min-height: 55px !important;
}
.media .activity-entry .replies .count,
.media .activity-entry .replies .count + svg{
	color: rgb(var(--color-red));
}
#app .tooltip.animate-position{
	transition: opacity .26s ease-in-out,transform 0s ease-in-out;
}
.studio .hohThemeSwitch{
	top: 30px;
}
.stats-wrap .stat-cards{
	grid-gap: 20px;
	grid-template-columns: repeat(auto-fill, 300px);
}
.stats-wrap .stat-cards.has-images{
	grid-gap: 20px;
	grid-template-columns: repeat(auto-fill, 600px);
}
.stats-wrap .stat-cards .stat-card{
	box-shadow: none;
	padding: 10px;
	padding-bottom: 0px;
}
.stats-wrap .stat-cards .stat-card > .title{
	font-size: 2rem;
}
.stats-wrap .stat-cards .stat-card.has-image > .wrap > .image{
	margin-top: -45px;
	height: 100px;
	width: 70px;
}
.stats-wrap .highlight .value{
	font-size: 2rem;
}
.stats-wrap .highlight .circle{
	box-shadow: none;
	height: 35px;
	width: 35px;
}
.stats-wrap .highlights{
	grid-gap: 30px 0px;
	margin-left: 1%;
	width: 98%;
	margin-top: 0px;
	grid-template-columns: repeat(6,1fr);	
	margin-bottom: 20px;
}
.stats-wrap .stat-cards .stat-card.has-image > .title{
	margin-left: 75px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap{
	padding: 5px 15px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .relations{
	transition: transform .1s ease-in-out;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .relation-card{
	margin-right: 5px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .relation-card .image{
	width: 70px;
	height: 100px;
}
.stats-wrap .stat-cards .stat-card .count.circle{
	top: 12px;
	right: 12px;
	height: 20px;
	width: 20px;
}
.text div.markdown{
	max-height: 660px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .detail .value{
	font-size: 1.4rem;
	font-weight: 700;
	color: rgb(var(--color-blue));
}
.stats-wrap .stat-cards .stat-card .inner-wrap .detail .label{
	font-size: 1.1rem;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .button{
	box-shadow: none;
	top: 40px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .button.previous{
	left: 18px;
}
.stats-wrap .stat-cards .stat-card .inner-wrap .relations-wrap .button.next{
	right: 18px;
}
.user .desktop .genre-overview.content-wrap{
	font-size: 1.3rem;
}
.forum-thread .comment-wrap{
	margin-bottom: 10px!important;
}
.forum-thread .comment-wrap .collapse{
	opacity: 1;
	border-left: 1px;
	border-left-style: solid;
	justify-content: left;
}
.forum-thread .comment-wrap .collapse .collapse-bar{
	width: 8px;
	border-radius: 0px 8px 8px 0px;
}
.forum-feed .overview-header{
	color: rgba(var(--color-blue))!important;
	font-size: 2rem!important;
}
.forum-feed .thread-card{
	margin-bottom: 10px!important;
}
.forum-feed .filter-group > a{
	margin-bottom: 2px!important;
}
.activity-entry > .wrap > .actions{
	bottom: 0px!important;
}
.page-content > .container,
.notifications-feed,
.page-content > .studio{
	margin-top: 25px !important;
}
.logo{
	margin-left: -60px!important;
/*the compact layout uses more of the space to the side, so we line up the logo to the left*/
}
.footer{
	margin-top: 0px !important;
/*less space wasted over the footer*/
}
.hohUserRow td,
.hohUserRow th{
	top: 44px;
}
.container{
	padding-left: 10px;
	padding-right: 0px;
}
.hide{
	top: 0px!important;
/*stop that top bar from jumping all over the place*/
}
.notification{
	margin-bottom: 10px!important;
}
/*Dropdown menus are site theme based*/
.quick-search .el-select .el-input .el-input__inner,
.quick-search .el-select .el-input.is-focus .el-input__inner,
.el-select-dropdown,
.el-dropdown-menu,
.el-dropdown-menu__item--divided::before{
	background: rgba(var(--color-foreground));
}
.el-select-dropdown__item.hover,
.el-select-dropdown__item:hover{
	background: rgba(159, 173, 189, .2);
}
.el-dropdown-menu__item--divided{
	border-color: rgba(var(--color-background));
}
.el-select-group__wrap:not(:last-of-type)::after{
	background: rgba(var(--color-foreground));
}
.el-popper[x-placement^="bottom"] .popper__arrow,
.el-popper[x-placement^="bottom"] .popper__arrow::after{
	border-bottom-color: rgba(var(--color-foreground));
}
.el-popper[x-placement^="top"] .popper__arrow,
.el-popper[x-placement^="top"] .popper__arrow::after{
	border-top-color: rgba(var(--color-foreground));
}
.wrap .link.router-link-exact-active.router-link-active,
.nav .link.router-link-exact-active.router-link-active,
.nav .browse-wrap.router-link-exact-active.router-link-active{
	background: rgba(var(--color-foreground-grey-dark));
	color: rgba(var(--color-blue));
}
/*--------------VERTICAL-NAV----------------*/
/*modified code from Kuwabara: https://userstyles.org/styles/161017/my-little-anilist-theme-can-not-be-this-cute*/
.hohDismiss{
	transform: translate(17.5px,-40px);
	margin-left: 0px!important;
}
#app > .nav {
	border-top: none !important;
}
#app div#nav.nav{
	width: 65px;
	height: 100%!important;
	position: fixed!important;
	top: 0!important;
	left: 0!important;
	transition: none!important;
}
.nav .wrap .links{
	font-size: 1rem;
	height: 355px!important;
	margin-left: 0px;
	padding-left: 0px;
	width: 65px;
	min-width: 65px !important;
	flex-direction: column;
}
#app #nav.nav .wrap .links a.link{
	width: 65px;
	padding: 5px 0px;
	margin-bottom: 10px;
	text-align: center;
	height: unset!important;
	transition: 0.3s;
	padding-left: 0px!important;
}
#app #nav.nav .browse-wrap{
	text-align: center;
	margin-bottom: 10px;
	padding-bottom: 5px;
	padding-top: 5px;
}
.browse-wrap.subMenuContainer .dropdown{
	display: none;
}
#app #nav.nav .browse-wrap .dropdown{
	z-index: 2000;
}
div#nav.nav .link.router-link-exact-active.router-link-active,
#nav > div > div.links > a:hover{
	border-bottom-width: 0px!important;
}
.nav .wrap .links > .link:hover,
.nav .wrap .links div .link:hover,
.nav .browse-wrap:hover{
	background: rgba(var(--color-blue),0.1);
}
.nav .wrap .links .link::before{
	display: block;
	content: "";
	height: 24px!important;
	width: 65px!important;
	background-size: 24px;
	margin-left: 0!important;
	margin-bottom: 3px!important;
	background-repeat: no-repeat;
	background-position: center;
	filter: grayscale(100%) brightness(1.4);
}
#app #nav.nav .subMenuContainer > a.link[href*="/user/"]{
	height: 48px !important;
}
.nav .link[href*="/user/"]:hover::before,
.nav .link[href^="/forum/"]:hover::before,
.nav .link[href="/login"]::before,
.nav .link[href="/social"]::before,
.nav .link[href^="/search/"]:hover::before,
.nav .link[href^="/home"]:hover::before,
.site-theme-contrast .nav .link.router-link-active::before{
	filter: grayscale(0%);
}
.logo-full{
	display: none;
}
.nav .link[href="/home"]::before,
.nav .link[href="/login"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><path d="m12 3l-10 9h3v8h5v-6h4v6h5v-8h3z" fill="rgb(61,180,242)"/></svg>');
}
.nav .link[href^="/user/"]::before,
.nav .link[href="/social"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><path d="M5 3h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2zM12 6a3 3 0 0 0 0 6a3 3 0 0 0 0 -6zM6 18h12v-1a6 3 0 0 0 -12 0z" fill="rgb(61,180,242)"/></svg>');
}
.nav .link[href*="/animelist"]::before,
.nav .link[href*="/mangalist"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><path d="M4 5h4v4h-4zM4 10h4v4h-4zM4 15h4v4h-4zM9 5h12v4h-12zM9 10h12v4h-12zM9 15h12v4h-12z" fill="rgb(61,180,242)"/></svg>');
}
.nav .link[href^="/search/"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><path d="M4 5h5v13h-5zM10 5h11v6h-11zM10 12h5v6h-5zM16 12h5v6h-5z" fill="rgb(61,180,242)"/></svg>');
}
.nav .link[href*="/forum"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><path d="M19 6h2a1 1 0 0 1 1 1v15l-4 -4h-11a1 1 0 0 1 -1 -1v-2h13zM3 2a1 1 0 0 0 -1 1v14l4 -4h10a1 1 0 0 0 1 -1v-9a1 1 0 0 0 -1 -1z" fill="rgb(61,180,242)"/></svg>');
}
.nav .link[href="/signup"]::before{
	background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 24 24"><g fill="rgb(61,180,242)"><circle cx="15" cy="8" r="3"/><path d="M9 18h12v-1a6 3 0 0 0 -12 0z"/><text x="2" y="14" font-weight="bold" font-size="70%">+</text></g></svg>');
}
.landing .link{
	margin-left: unset!important;
}
#nav > div.wrap.guest > div.links a.link.login,
#nav > div.wrap.guest > div.links a.link.signup{
	padding: 5px 0px!important;
}
#app{
	margin-top: 0;
	padding-left: 65px;
}
:root {
	--color-nav-hoh: #2b2d42;
}
.site-theme-dark{
	--color-nav-hoh: #152232;
}
#nav.transparent{
	background: var(--color-nav-hoh);
}
.nav .user{
	position: fixed;
	top: 0;
	display: grid;
	grid-gap: 40px;
	width: 65px;
	grid-template-rows: 50px 20px;
}
.nav .user-wrap .dropdown{
	left: -2px;
	z-index: 2000;
}
.nav .user-wrap .dropdown::before{
	left: 16px;
}
.search .dropdown.el-dropdown{
	font-size: 10px;
}
.search .el-dropdown-link svg{
	width: 65px;
	height: 23px;
	padding: 5px 0;
	background: rgba(0, 0, 0, 0.2);
}
.nav .search{
	width: 65px;
	margin: 0;
	text-align: center;
	position: fixed;
	top: 56px;
}
.quick-search-results{
	z-index: 999!important;
	top: 136px!important;
}
.user .avatar + .chevron{
	opacity: 0!important;
}
.hide{
	top:0px!important;
}
@media(max-width: 1040px){
	#app{
		padding-left: 0px;
	}
	.container{
		padding-left: 20px;
		padding-right: 20px;
	}
	.footer > .container{
		position: relative;
	}
	.hohColourPicker{
		top: 0px;
	}
	.hohDismiss{
		display: none;
	}
	.hohNotificationCake{
		margin-left: -9px;
	}
}
/*-------------------*/
::selection{
	background: rgba(var(--color-blue),0.4);
}
::-webkit-selection{
	background: rgba(var(--color-blue),0.4);
}
::-moz-selection{
	background: rgba(var(--color-blue),0.4);
}
::-webkit-scrollbar{
	width: 7px;
	height: 7px;
}
::-webkit-scrollbar-thumb{
	background: #4e4e4e!important;
}
.user .header-wrap{
	position: sticky;
	top: -332px;
	z-index: 100;
}
.list-stats{
	margin-bottom:0px!important;
}
.activity-feed-wrap{
	margin-top:25px;
}
.user .activity-feed{
	width: 100%;
}
.logo{
	position: absolute;
	margin-bottom: -500px;
	display:none!important;
	margin-left: 0px !important;
}
/*home stuff*/

.reply .header a.name[href="/user/Taluun/"]::after{
	content: "Best Friend";
	margin-left:10px;
	padding:3px;
	border-radius:2px;
	animation-duration: 20s;
	animation-iteration-count: infinite;
	animation-name: rainbow;
	animation-timing-function: ease-in-out;
	color: rgba(var(--color-white));
}
.details > .donator-badge{
	left:105px!important;
	padding:2px!important;
	top: 100%!important;
	-ms-transform: translate(0px, -34px);
	-webkit-transform: translate(0px, -34px);
	transform: translate(0px, -34px);
}
.activity-text > div > div > div > .donator-badge{
	position:relative!important;
	display:inline-block!important;
	left:0px!important;
	top:0px!important;
	-ms-transform: translate(0px, 0px);
	-webkit-transform: translate(0px, 0px);
	transform: translate(0px, 0px);
}
.activity-replies{
	margin-top:5px!important;
	margin-left:30px!important;
	margin-right:0px!important;
}
.page-content > .container > .activity-entry .activity-replies{
	margin-top: 15px !important;
}
.activity-entry{
	margin-bottom: 10px!important;
}
.list-preview{
	grid-gap: 10px!important;
	padding:0px!important;
	background: rgb(0,0,0,0)!important;
}
.home{
	grid-column-gap: 30px!important;
	margin-top: 20px!important;
	grid-template-columns: auto 470px!important;
}
.activity-feed .reply{
	padding: 8px!important;
	margin-bottom: 5px!important;
}
.list .details{
	padding-left:10px!important;
	padding-top:5px!important;
	padding: 10px 16px!important;
	padding-bottom: 7px !important;
}
.search{
	margin-top:0px!important;
}
.emoji-spinner{
	display:none!important;
}
.wrap{
	border-radius: 2px!important;
}
.name{
	margin-left: 0px!important;
}
.activity-text > div > div > div > .name,
.activity-message > div > div > div > .name{
	margin-left: 12px!important;
}
.button{
	margin-right: 5px!important;
}
.actions{
	margin-bottom: 5px!important;
}
.status{
	display: inline-block!important;
}
.avatar{
	display: block!important;
}

/*https://anilist.co/activity/29333544*/
.activity-entry .header a:nth-child(1){
	display: inline-block!important;
}
.wrap > .list{
	min-height: 80px!important;
	grid-template-columns: 60px auto!important;
}
.popper__arrow{
	display: none!important;
}
.media-preview{
	grid-gap: 10px!important;
	padding: 0px!important;
	background: rgb(0,0,0,0)!important;
}
.media-preview-card{
	display: inline-grid!important;
}
.replies > .count{
	color: rgba(var(--color-blue));
}
.action.likes{
	color: unset;
}
.like-wrap > .button:hover{
	color: rgba(var(--color-red));
}
.replies > svg:nth-child(2){
	color: rgba(var(--color-blue));
}
.actions{
	cursor: default;
}
.markdown-editor > [title="Image"],
.markdown-editor > [title="Youtube Video"],
.markdown-editor > [title="WebM Video"]{
	color: rgba(var(--color-red));
}
.markdown-editor > div > svg{
	min-width: 1em!important;
}
.feed-select .toggle > div.active{
	color: rgba(var(--color-blue))!important;
}
.home .details .status:first-letter,
.social .details .status:first-letter,
.activity-entry .details .status:first-letter{
	text-transform: lowercase;
}
.activity-edit .markdown-editor,
.activity-edit .input{
	margin-bottom: 10px!important;
}
.activity-edit .actions{
	margin-bottom: 25px!important;
}
.page-content .container .home.full-width{
	grid-template-columns: unset !important;
}
.activity-text .text {
	border-left: solid 5px rgba(var(--color-blue));
}
.section-header{
	padding-left:0px!important;
}
.cover[href="/anime/440/Shoujo-Kakumei-Utena/"] + .details{
	border-color: #eb609e;
	border-width: 4px;
	border-style: solid;
	border-left-width: 0px;
}
.sticky .avatar, .sticky .body-preview,
.sticky .categories, .sticky .name{
	display: none!important;
}
.search > .filter,
.search > .preview{
	margin-top: 20px;
}
.home .media-preview-card:nth-child(5n+3) .content{
	border-radius: 3px 0 0 3px;
	left: auto !important;
	right: 100%;
	text-align: right;
}
.home .media-preview-card:nth-child(5n+3) .content .info{
	right: 12px;
}
.link:hover .hohSubMenu{
	color: rgb(var(--color-text-bright));
}
.hohSubMenu{
	position: absolute;
	left: 64px;
	top: 0px;
	display: none;
	background: #152232;
	border-top-right-radius: 3px;
	border-bottom-right-radius: 3px;
	padding: 2px 0px;
}
.hohSubMenuLink{
	display: block;
	margin-left: 3px;
	padding: 4px;
	font-size: 130%;
	text-align: left;
	color: rgb(160, 177, 197);
	z-index: 1;
	position: relative;
}
.hohSubMenuLink:visited{
	color: rgb(160, 177, 197);
}
@media(max-width: 1540px){
	.container{
		max-width: 1200px;
	}
}
.media .activity-feed .donator-badge{
	transform: translate(-70px,-25px);
}
.media-page-unscoped .description{
	color: rgb(var(--color-text));
}
.user .list.small .avatar{
	display: none!important;
}
.el-slider[aria-valuemin="1950"] .el-slider__runway::after{
	content: "";
	width: 101%;
	margin-left: -0.3%;
	height: 20px;
	display: block;
	/*update stroke-dasharray every few years*/
	background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="200" height="20" viewBox="0 0 200 20"><g fill="rgb(61,180,242)" stroke="rgb(61,180,242)"><line stroke-width="27" x1="0" y1="20" x2="200" y2="20" stroke-dasharray="1 26.6"/><text font-size="8" x="141" y="19">00</text><text font-size="6" x="86" y="19">LAMU</text><text font-size="6" x="31" y="19">ATOM</text></g></svg>');
	background-size: cover;
}
.user .el-slider[aria-valuemin="1950"] .el-slider__runway::after{
	background-size: contain;
}
.medialist.table .row{
	border-bottom: solid;
	border-bottom-width: 1px;
	border-color: rgb(var(--color-text),0.1);
}
.markdown .markdown-spoiler.spoiler-visible i.hide-spoiler{
	right: -10px;
}
.hohNoSequelSetting{
	right: 100px;
	top: 50px;
}

`;
	if(useScripts.rightToLeft || useScripts.rightSideNavbar){
		moreStyle.textContent += `
#app{
	padding-right: 65px;
	padding-left: 0px!important;
}
.page-content{
	padding-left: 5px;
}
#app div#nav.nav{
	left: inherit !important;
	right: 0px;
}
#app div#nav.nav .links{
	border-left: none;
	border-right: 1px solid hsla(0,0%,93.3%,.16);
}
.subMenuContainer{
	margin-left: -172px;
}
.subMenuContainer > .link{
	margin-left: 86px;
}
.hohSubMenu{
	left: 0px;
	width: 86px;
	border-top-left-radius: 3px;
	border-bottom-left-radius: 3px;
	border-top-right-radius: 0px;
	border-bottom-right-radius: 0px;
}
.hohColourPicker{
	right: 70px;
}
#app .nav .user-wrap .dropdown{
	left: unset;
	right: 0px;
}
#app .nav .user-wrap .dropdown::before{
	left: unset;
	right: 16px;
}
.nav .browse-wrap .dropdown{
	left: -200px;
}
.user .header-wrap{
	margin-left: -5px;
}`
	}
}
if(useScripts.CSSdecimalPoint){
	moreStyle.textContent += `
.medialist.POINT_10_DECIMAL .score[score="10"]::after,
.medialist.POINT_10_DECIMAL .score[score="9"]::after,
.medialist.POINT_10_DECIMAL .score[score="8"]::after,
.medialist.POINT_10_DECIMAL .score[score="7"]::after,
.medialist.POINT_10_DECIMAL .score[score="6"]::after,
.medialist.POINT_10_DECIMAL .score[score="5"]::after,
.medialist.POINT_10_DECIMAL .score[score="4"]::after,
.medialist.POINT_10_DECIMAL .score[score="3"]::after,
.medialist.POINT_10_DECIMAL .score[score="2"]::after,
.medialist.POINT_10_DECIMAL .score[score="1"]::after{
	margin-left: -4px;
	content: ".0";
}
	`
}
if(useScripts.CSSdarkDropdown){
	moreStyle.textContent += `
.site-theme-dark .quick-search.el-select .el-input.el-input__inner,
.site-theme-dark .quick-search .el-select .el-input.is-focus .el-input__inner,
.site-theme-dark .el-select-dropdown,
.site-theme-dark .el-dropdown-menu,
.site-theme-dark .el-dropdown-menu__item--divided::before{
	background: rgba(17, 22, 29);
}
.site-theme-dark .el-select-group__wrap:not(:last-of-type)::after{
	background: rgba(17, 22, 29);
}
.site-theme-dark .el-popper[x-placement^="bottom"] .popper__arrow,
.site-theme-dark .el-popper[x-placement^="bottom"] .popper__arrow::after{
	border-bottom-color: rgba(17, 22, 29);
	opacity: 1;
}
.site-theme-dark .el-popper[x-placement^="top"] .popper__arrow,
.site-theme-dark .el-popper[x-placement^="top"] .popper__arrow::after{
	border-top-color: rgba(17, 22, 29);
	opacity: 1;
}
	`
}
if(useScripts.CSSsmileyScore){
	moreStyle.textContent += `
.fa-frown{
	color: red;
}
.fa-smile{
	color: green;
}
.fa-meh{
	color: rgb(var(--color-orange));
}
	`
}
if(useScripts.limitProgress8){
	moreStyle.textContent += `
.home:not(.full-width) .media-preview-card:nth-child(n+9){
	display:none!important;
}
	`
}
else if(useScripts.limitProgress10){
	moreStyle.textContent += `
.home:not(.full-width) .media-preview-card:nth-child(n+11){
	display:none!important;
}
	`
}
if(parseInt(useScripts.forumPreviewNumber) === 0){
	moreStyle.textContent += `
.home .recent-threads{
	display: none!important;
}
	`
}
if(useScripts.SFWmode){
	moreStyle.textContent += `
.forum-thread .no-comments::after{
	content: "No replies yet";
	visibility: visible;
	margin-left: -250px;
}
.forum-thread .no-comments{
	visibility: hidden;
}
.list-preview .cover,
.favourites .cover{
	background-image: none!important;
}
.logo{
	display: none!important;
}
.user .banner,
.media .banner{
	background-image: none!important;
	height: 200px;
}
.review-card .banner{
	display: none;
}
.home .review-card,.home .review-card .content{
	min-height: 120px;
}
.donator-badge{
	animation-name: none!important;
	display: none;
}
.list-editor .header,
.review .banner{
	background-image: none !important;
}
.list-editor .cover{
	display: none;
}
.emoji-spinner{
	display:none!important;
}
.avatar[style*=".gif"]{
	background-image: none!important;
}
img[src*=".gif"],
video,
.youtube{
	filter: contrast(0);
}
img[src*=".gif"]:hover,
video:hover,
.youtube:hover{
	filter: contrast(1);
}
.activity-entry .cover{
	filter: contrast(0.1) brightness(0.5);
}
.activity-entry .cover:hover{
	filter: none;
}
.activity-markdown img{
	max-width: 30%;
}
.recent-reviews + div{
	display: none;
}
.favourite.studio::after{
	background-image: none!important;
}
.hohDownload{
	display: none;
}
.history-day.lv-1{
	background: rgba(var(--color-green),.2)!important;
}
.history-day.lv-3{
	background: rgba(var(--color-green),.5)!important;
}
.history-day.lv-5{
	background: rgba(var(--color-green),.9)!important;
}
.history-day.lv-7{
	background: rgba(var(--color-green))!important;
}
.history-day.lv-9{
	background: rgba(var(--color-green))!important;
}
.percentage-bar{
	display: none!important;
}
.medialist.compact .cover .image,
.medialist.table .cover .image{
	opacity: 0;
}
.hohCencor .header img.cover,
.hohCencor .relations .cover,
.hohCencor .character .cover{
	filter: contrast(0);
}
.hohCencor .header img.cover:hover,
.hohCencor .relations .cover:hover,
.hohCencor .character .cover:hover{
	filter: contrast(1);
}
.categories > span{
	position: relative;
}
.category[href="/forum/recent?category=1"],
.category[href="/forum/recent?category=1"]:hover{
	color: rgb(78, 163, 230);
}
.category[href="/forum/recent?category=1"]:hover::after{
	color: rgba(26,27,28,.6);
}
.category[href="/forum/recent?category=1"]::after{
	content: "View";
	color: #fff;
	left: 20px;
	position: absolute;
}
.category[href="/forum/recent?category=2"],
.category[href="/forum/recent?category=2"]:hover{
	color: rgb(76, 175, 80);
}
.category[href="/forum/recent?category=2"]:hover::after{
	color: rgba(26,27,28,.6);
}
.category[href="/forum/recent?category=2"]::after{
	content: "Read";
	color: #fff;
	left: 20px;
	position: absolute;
}
.avatar[style*="/default.png"]{
	background-image: url("https://i.stack.imgur.com/TRuSD.png")!important;
}

	`;
	if(useScripts.CSSverticalNav){
		moreStyle.textContent += `
#nav .link[href*="/animelist"]{
	visibility: hidden;
}
#nav .link[href*="/animelist"]::after{
	content: "View List";
	visibility: visible;
	left: 0;
	right: 0;
	position: absolute;
	margin-left: auto;
	margin-right: auto;
}
#nav .link[href*="/animelist"]::before{
	visibility: visible;
}
#nav .link[href*="/mangalist"]{
	visibility: hidden;
}
#nav .link[href*="/mangalist"]::after{
	content: "Read List";
	visibility: visible;
	left: 0;
	right: 0;
	position: absolute;
	margin-left: auto;
	margin-right: auto;
}
#nav .link[href*="/mangalist"]::before{
	visibility: visible;
}`
	}
}
if(useScripts.cleanSocial){
	moreStyle.textContent += `
.social .activity-feed + div{
	display: flex;
	flex-direction: column;
}
.social .activity-feed + div > div:first-child{
	order: 2;
	margin-top: 25px;
}`
}
if(useScripts.statusBorder){
	moreStyle.textContent += `
.home .activity-text .wrap{
	border-right-width: 0px !important;
	margin-right: 0px !important;
}`
}
if(useScripts.rightToLeft){
	moreStyle.textContent += `
.favourites-wrap.anime,
.favourites-wrap.manga,
.favourites-wrap.staff,
.favourites-wrap.characters,
.favourites-wrap.studios{
	direction: rtl;
}
.genre-overview .genres{
	direction: rtl;
}
.genre-overview .percentage-bar{
	direction: rtl;
}
.milestones{
	direction: rtl;
}
.milestones + .progress{
	transform: scale(-1);
}
.list-preview{
	direction: rtl;
}
#hohListPreview .list-preview{
	width: 100%;
}
.media-preview-card .hohFallback,
.media-preview-card .content{
	direction: ltr;
}
.media-preview-card .content meter{
	direction: rtl;
}
.banner-content{
	direction: rtl;
}
.banner-content .actions{
	margin-right: auto;
	margin-left: inherit!important;
}
#hohListPreview .info-left .content {
    border-radius: 3px 0 0 3px;
    left: auto !important;
    right: 100%;
    text-align: right;
}
#app .home{
	grid-template-columns: 470px auto !important;
}
.home > .activity-feed-wrap + div{
	grid-row: 1;
}
.recent-reviews .review-wrap{
	direction: rtl;
}
.recent-reviews .review-card{
	direction: ltr;
}
.recent-reviews + div .media-preview{
	direction: rtl;
}
#app > .progress{
	transform: scale(-1);
}
.hohColourPicker{
	margin-right: 20px;
}
.home .activity-feed-wrap .section-header{
	direction: rtl;
}
.home .activity-feed-wrap .section-header .feed-select{
	margin-right: auto;
	margin-left: inherit;
}
.home .activity-feed-wrap .section-header .feed-select .el-dropdown{
	direction: ltr;
	margin-left: 20px;
}
.hohSubMenuLink{
	text-align: right;
}
.quick-search .input{
	direction: rtl;
}
.quick-search .results{
	direction: rtl;
}
.quick-search .results .result{
	direction: ltr;
}
.quick-search .results .result-col h3.title{
	right: 0px;
}
.home .section-header{
	text-align: right;
}
.home .list-previews .section-header{
	direction: rtl;
}
.user .nav-wrap{
	direction: rtl;
}
.user .medialist{
	direction: rtl;
}
.medialist .filters .filter-group:first-child > span .count{
	left: 0px;
	right: inherit;
}
.medialist.table .entry .title a{
	margin-left: auto;
	margin-right: 10px;
	direction: ltr;
}
.medialist .lists > .actions{
	left: 0px;
	right: inherit;
}
.list-editor-wrap .header .content{
	direction: rtl;
}

	`
}
if(script_type !== "Boneless"){
	moreStyle.textContent += `
.user[type="anime"][page="tags"] .increase-stats::after,
.user[type="manga"][page="tags"] .increase-stats::after,
.user[type="anime"][page="staff"] .increase-stats::after,
.user[type="anime"][page="studios"] .increase-stats::after,
.user[type="manga"][page="staff"] .increase-stats::after{
	content: "Or view the full list below:";
	display: block;
}
.rules-notice{
	display: none;
}
.sense-wrap{
	display: none;
}`
}
moreStyle.textContent += `
.settings .nav a[href="/settings/apps"]::after{
	content: " & ${script_type}";
}
`
if(useScripts.partialLocalisationLanguage === "Português" || useScripts.partialLocalisationLanguage === "Español"){
	moreStyle.textContent += `
#app #nav.nav .wrap .links a.link{
	text-transform: none;
}`
}
}initCSS();

documentHead.appendChild(moreStyle);
let customStyle = create("style");
let currentUserCSS = "";
customStyle.id = "customCSS-" + script_type.toLowerCase() + "-styles";
customStyle.type = "text/css";
documentHead.appendChild(customStyle);


let aliases = new Map();
shortRomaji.concat(
	JSON.parse(
		localStorage.getItem("titleAliases")
	) || []
).forEach(alias => {
	let matches = alias[0].match(/^\/(anime|manga)\/(\d+)\/$/);
	if(matches){
		aliases.set(parseInt(matches[2]),alias[1])
	}
});
//end "conditionalStyles.js"

//begin "localisation.js"
const languageFiles = {
	"English": {
	"info": {
		"language": "English",
		"language_english": "English",
		"locale": "en-UK",
		"fallback": [],
		"maintainer": "hoh",
		"maintainer_link": "https://anilist.co/user/hoh/",
		"discussion_link": "",
		"notes": "This is the default language of Automail. This key should have all the translation keys, while other translations don't have to. I'm not a native speaker, but I try to stick to British English here (feel free to britpick!). You can make translation files for other version of English too if you want, name it something like 'English (US)', and put 'English' in the fallback array. You need only include the keys that are different.",
		"translators": ["hoh"]
	},
	"keys": {
"$meta_scriptDescription": "Extra parts for Anilist.co",
"$loading": "Loading...",
"$searching": "Searching...",
"$load_more": "Load More",
"$time_now": "Just now",
"$time_1second": "1 second ago",
"$time_Msecond": "{0} seconds ago",
"$time_1minute": "1 minute ago",
"$time_Mminute": "{0} minutes ago",
"$time_1hour": "1 hour ago",
"$time_Mhour": "{0} hours ago",
"$time_1day": "1 day ago",
"$time_Mday": "{0} days ago",
"$time_1week": "1 week ago",
"$time_Mweek": "{0} weeks ago",
"$time_1month": "1 month ago",
"$time_Mmonth": "{0} months ago",
"$time_1year": "1 year ago",
"$time_Myear": "{0} years ago",
"$time_medium_second": "second",
"$time_medium_minute": "minute",
"$time_medium_hour": "hour",
"$time_medium_day": "day",
"$time_medium_week": "week",
"$time_medium_month": "month",
"$time_medium_year": "year",
"$time_medium_Msecond": "seconds",
"$time_medium_Mminute": "minutes",
"$time_medium_Mhour": "hours",
"$time_medium_Mday": "days",
"$time_medium_Mweek": "weeks",
"$time_medium_Mmonth": "months",
"$time_medium_Myear": "years",
"$time_short_second": "s",
"$time_short_minute": "m",
"$time_short_hour": "h",
"$time_short_day": "d",
"$time_short_week": "w",
"$time_short_month": "m",
"$time_short_year": "y",
"$language_English": "English",
"$language_German": "German",
"$language_Italian": "Italian",
"$language_Spanish": "Spanish",
"$language_French": "French",
"$language_Korean": "Korean",
"$language_Portuguese": "Portuguese",
"$language_Hebrew": "Hebrew",
"$language_Hungarian": "Hungarian",
"$language_Chinese": "Chinese",
"$language_Japanese": "Japanese",
"$language_Arabic": "Arabic",
"$language_Filipino": "Filipino",
"$language_Catalan": "Catalan",
"$language_Polish": "Polish",
"$language_Norwegian": "Norwegian",
"$default_filename": "File from Anilist.co",
"$generic_anime": "Anime",
"$generic_manga": "Manga",
"$page": "Page {0}",
"$dubMarker_notice": "{0} dub exists",
"$button_submit": "Submit",
"$button_search": "Search",
"$button_run": "Run",
"$button_add": "Add",
"$button_reset": "Reset",
"$button_resetAll": "Reset all",
"$button_defaultSettings": "Default Settings",
"$missing_N/A_data": "-",
"$button_next": "Next →",
"$button_previous": "← Previous",
"$button_refresh": "Refresh",
"$button_edit": "Edit",
"$button_publish": "Publish",
"$button_cancel": "Cancel",
"$placeholder_status": "Write a status...",
"$placeholder_reply": "Write a reply...",
"$placeholder_message": "Write a message...",
"$placeholder_forum": "Write a forum post...",
"$forumMedia_backlink": "Add a link back to a work's database page on its forum feed",
"$settings_title": "Automail Settings",
"$profile_title": "{0}'s profile",
"$notImplemented": "Sorry, not implemented yet",
"$settings_version": "Version: ",
"$settings_homepage": "Homepage: ",
"$settings_repository": "Repository: ",
"$settings_moreInfo_tooltip": "More info",
"$settings_category_Notifications": "Notifications",
"$settings_category_Feeds": "Feeds",
"$settings_category_Forum": "Forum",
"$settings_category_Lists": "Lists",
"$settings_category_Profiles": "Profiles",
"$settings_category_Stats": "Stats",
"$settings_category_Media": "Media",
"$settings_category_Navigation": "Navigation",
"$settings_category_Browse": "Browse",
"$settings_category_Script": "Script",
"$settings_category_Login": "Login",
"$settings_category_Newly Added": "Newly Added",
"$settings_button_export": "Export settings",
"$settings_export_description": "Might come in handy to keep a backup if you do stuff like wiping your browser cache/storage, which will wipe your Automail settings too",
"$settings_import": "Import settings:",
"$settings_experimental_suffix": "[EXPERIMENTAL]",
"$settings_partialLocalisationLanguage_description": "Automail language",
"$settings_CSSadd": "Add custom CSS to your profile. This will be visible to others with the script.",
"$settings_CSSlinkTip": "(You can also use a direct link to a stylesheet)",
"$settings_pinnedActivity": "Add a pinned activity to your profile",
"$settings_notificationDotColour": "Notification Dot Colours",
"$setting_notifications": "Improve notifications",
"$setting_moreStats": "Show an additional tab on the stats page",
"$setting_compare": "Replace the native comparison feature",
"$setting_CSSsmileyScore": "Give smiley ratings distinct colours",
"$setting_tweets": "Embed linked tweets",
"$setting_CSSgreenManga": "Green titles for manga",
"$setting_CSSbannerShadow": "Remove banner shadows",
"$setting_CSSmobileTags": "Don't hide tag voting from media pages on mobile",
"$setting_infoTable": "Use a two-column table layout for info on media pages",
"$setting_reinaDark": "Add a High Contrast Dark site theme [by Reina]",
"$setting_MALserial": "Add MAL serialisation info to manga",
"$setting_MALscore": "Add MAL scores to media",
"$setting_MALrecs": "Add MAL recs to media",
"$cssTooBig": "Custom CSS is over 1MB. Make it smaller, or use a link instead.",
"$jsonTooBig": "Profile JSON is over 1MB",
"$debug_tip": "(Hey, it would be nice if you include this file when you report bugs. Makes my life easier)",
"$profileBackground_help1": "Set a profile background, examples:",
"$profileBackground_help2": "Tip: Use a colour with transparency, to work better with both light and dark themes. Example:",
"$profileBackground_help3": "Tip2: Do you want a faded image, staying fixed in place, and filling the screen? This is how:",
"$mediaStatus_current": "current",
"$mediaStatus_watching": "watching",
"$mediaStatus_reading": "reading",
"$mediaStatus_completed": "completed",
"$mediaStatus_completedWatching": "completed",
"$mediaStatus_completedReading": "completed",
"$mediaStatus_not": "Add to List",
"$mediaStatus_repeating": "repeating",
"$mediaStatus_rewatching": "rewatching",
"$mediaStatus_rereading": "rereading",
"$mediaStatus_paused": "paused",
"$mediaStatus_dropped": "dropped",
"$mediaStatus_planning": "planning",
"$mediaStatus_planning_time": "planned {0}",
"$mediaReleaseStatus_finished": "Finished",
"$mediaReleaseStatus_releasing": "Releasing",
"$mediaReleaseStatus_notYetReleased": "Not Yet Released",
"$mediaReleaseStatus_cancelled": "Cancelled",
"$mediaReleaseStatus_hiatus": "Hiatus",
"$mediaReleaseStatusManga_finished": "Finished",
"$mediaReleaseStatusManga_releasing": "Releasing",
"$mediaReleaseStatusManga_notYetReleased": "Not Yet Released",
"$mediaReleaseStatusManga_cancelled": "Cancelled",
"$mediaReleaseStatusManga_hiatus": "Hiatus",
"$mediaReleaseStatusAnime_finished": "Finished",
"$mediaReleaseStatusAnime_releasing": "Releasing",
"$mediaReleaseStatusAnime_notYetReleased": "Not Yet Released",
"$mediaReleaseStatusAnime_cancelled": "Cancelled",
"$mediaReleaseStatusAnime_hiatus": "Hiatus",
"$listActivity_MreadChapter": "read chapter {0} of ",
"$listActivity_MwatchedEpisode": "watched episode {0} of ",
"$listActivity_MreadChapter_known": "read chapter {0}",
"$listActivity_MwatchedEpisode_known": "watched episode {0}",
"$listActivity_planningManga": "plans to read ",
"$listActivity_planningAnime": "plans to watch ",
"$listActivity_planningManga_known": "plans to read",
"$listActivity_planningAnime_known": "plans to watch",
"$listActivity_completedManga": "completed ",
"$listActivity_completedAnime": "completed ",
"$listActivity_completedManga_known": "completed",
"$listActivity_completedAnime_known": "completed",
"$listActivity_repeatedManga": "reread ",
"$listActivity_repeatedAnime": "rewatched ",
"$listActivity_repeatedManga_known": "reread",
"$listActivity_repeatedAnime_known": "rewatched",
"$listActivity_pausedManga": "paused reading ",
"$listActivity_pausedAnime": "paused watching ",
"$listActivity_pausedManga_known": "paused reading",
"$listActivity_pausedAnime_known": "paused watching",
"$listActivity_droppedManga": "dropped ",
"$listActivity_droppedAnime": "dropped ",
"$listActivity_droppedManga_known": "dropped",
"$listActivity_droppedAnime_known": "dropped",
"$listActivity_MdroppedManga": "dropped {0} of ",
"$listActivity_MdroppedAnime": "dropped {0} of ",
"$listActivity_MdroppedManga_known": "dropped {0}",
"$listActivity_MdroppedAnime_known": "dropped {0}",
"$listActivity_MrepeatingManga": "reread chapter {0} of ",
"$listActivity_MrepeatingAnime": "rewatched episode {0} of ",
"$listActivity_MrepeatingManga_known": "reread chapter {0}",
"$listActivity_MrepeatingAnime_known": "rewatched episode {0}",
"$notification_likeActivity_1person_1activity": " liked your activity.",
"$notification_likeActivity_1person_Mactivity": " liked your activities.",
"$notification_likeActivity_2person_1activity": " liked your activity.",
"$notification_likeActivity_2person_Mactivity": " liked your activities.",
"$notification_likeActivity_Mperson_1activity": " liked your activity.",
"$notification_likeActivity_Mperson_Mactivity": " liked your activities.",
"$notification_likeReply_1person_1reply": " liked your reply.",
"$notification_likeReply_1person_Mreply": " liked your replies.",
"$notification_likeReply_2person_1reply": " liked your reply.",
"$notification_likeReply_2person_Mreply": " liked your replies.",
"$notification_likeReply_Mperson_1reply": " liked your reply.",
"$notification_likeReply_Mperson_Mreply": " liked your replies.",
"$notification_reply_1person_1reply": " replied to your activity.",
"$notification_reply_1person_Mreply": " replied to your activities.",
"$notification_reply_2person_1reply": " replied to your activity.",
"$notification_reply_2person_Mreply": " replied to your activities.",
"$notification_reply_Mperson_1reply": " replied to your activity.",
"$notification_reply_Mperson_Mreply": " replied to your activities.",
"$notification_replyReply_1person_1reply": " replied to activity you're subscribed to.",
"$notification_newMedia": "was recently added to the site.",
"$notification_airing": "Episode {0} of {1} aired.",
"$notification_message": " sent you a message.",
"$notification_mention": " mentioned you in their activity.",
"$notification_follow": " started following you.",
"$notification_forumCommentLike": " liked your comment, in the forum thread ",
"$notification_forumMention": " mentioned you, in the forum thread ",
"$notifications_softBlock": "Soft block users",
"$notifications_softBlock_description1": "Hide notifications from specific people. A much less drastic solution than blocking them entirely (if that's what you actually want, go to their profile and click the little down arrow beside the 'Follow' button).",
"$notifications_softBlock_description2": "The notifications aren't gone, just hidden. 'Show default notifications' will make them visible. Un-soft-blocking will also bring them back. You may also be interested in the 'Notification Dot Colours' and 'Block stuff in the home feed' sections on the settings page.",
"$notifications_softBlock_description3": "Soft blocked users will still show up in grouped notifications, since that's not extra spam.",
"$notifications_hideLike": "Hide like notifications",
"$notifications_showHoh": "Show hoh notifications",
"$notifications_showDefault": "Show default notifications",
"$notifications_comments": "comments",
"$notifications_button_reset": "Mark all as read",
"$documentTitle_notifications": "Notifications · AniList",
"$documentTitle_home": "Home · AniList",
"$documentTitle_forum": "Forum - Anime & Manga Discussion · AniList",
"$documentTitle_forum_prefix": "Forum",
"$documentTitle_appSettings": "App & Automail Settings · AniList",
"$preview_animeSection_title": "Anime in Progress",
"$preview_mangaSection_title": "Manga in Progress",
"$preview_airingSection_title": "Airing",
"$preview_1behind": "1 episode behind",
"$preview_Mbehind": "{0} episodes behind",
"$preview_progress": "Progress:",
"$publishingReply": "Publishing reply...",
"$anisongs_openings": "Openings",
"$anisongs_opening": "Opening",
"$anisongs_endings": "Endings",
"$anisongs_ending": "Ending",
"$anisongs_noSongs": "No songs to show",
"$menu_home": "home",
"$menu_profile": "profile",
"$menu_animelist": "Anime List",
"$menu_mangalist": "Manga List",
"$menu_browse": "browse",
"$menu_forum": "forum",
"$submenu_stats": "Stats",
"$submenu_social": "Social",
"$submenu_reviews": "Reviews",
"$submenu_favourites": "Favourites",
"$submenu_submissions": "Submissions",
"$submenu_anime": "Anime",
"$submenu_manga": "Manga",
"$submenu_staff": "Staff",
"$submenu_characters": "Characters",
"$submenu_recommendations": "Recommendations",
"$submenu_relations": "Relations",
"$submenu_threads": "Threads",
"$submenu_statusDistribution": "Status Distribution",
"$submenu_scoreDistribution": "Score Distribution",
"$mainMenu_notifications": "Notifications",
"$mainMenu_profile": "Profile",
"$mainMenu_settings": "Settings",
"$timeline_search_description": "Looking for the activities of someone else?",
"$noScrollPosts_description": "Display all status posts in full regardless of their length",
"$ALbuttonReload_description": "Make the 'AL' button reload the feeds on the homepage",
"$timeline_title": "Activity Timeline",
"$filter_replies": "Has Replies",
"$filter_following": "Following",
"$input_user_placeholder": "User",
"$error_userNotFound": "User not found",
"$error_connection": "Connection error",
"$hideSequels": "Hide Sequels",
"$myThreads_link": "My Threads",
"$piracy_message": "THIS BE BAD LINK, IT'S NOW VEWY DISPOSED OF OwO (click the report button to call the mods on this naughty user)",
"$compare_default": "Show default compare",
"$compare_hoh": "Show hoh compare",
"$compare_minRatings": "Min. ratings:",
"$compare_individualRatings": "Individual rating systems:",
"$compare_normalizeRatings": "Normalise ratings:",
"$compare_colourCell": "Colour entire cell:",
"$compare_listStatus": "any list status\nclick to toggle",
"$404_private_or_noUser": "{0} does not exist or has a private profile",
"$404_private": "{0} has a private profile",
"$404_noUser": "{0} does not exist",
"$404_blocked": "{0} has blocked you",
"$recs_forYou": "For You",
"$download_banner_tooltip": "Download banner",
"$recs_description": "Each pair is one you like + one you haven't started\nBest match first",
"$module_unicodifier_description": "Convert emojis so they work on anilist",
"$module_unicodifier_extendedDescription": "Anilist doesn't handle some Unicode characters correctly, leading to truncated posts. This module coverts them to HTML entity escape codes instead, which the site can handle (they can easily do this themselves if they want to)\nOriginal idea by the great GoBusto: https://files.kiniro.uk/unicodifier.html",
"$rewatch_suffix_1": "[rewatch]",
"$rewatch_suffix_M": "[rewatch {0}]",
"$reread_suffix_1": "[reread]",
"$reread_suffix_M": "[reread {0}]",
"$reviewLike_tooltip": "{0} out of {1} liked this review",
"$review_reviewTitle": "Review of {0} by\u00a0{1}",
"$updates_noNewManga": "No new items found :(",
"$staff_filter_placeholder": "Filter by title, role, etc.",
"$relations_following_only": "Following Only",
"$relations_followers_only": "Followers Only",
"$relations_mutuals": "Mutuals",
"$relations_shared_following": "Shared Following",
"$relations_shared_followers": "Shared Followers",
"$relations_description": "Add separate tabs on the social page for various types of followers",
"$additionalTranslation_description": "Translate additional parts of the Anilist UI",
"$twoColumnFeed_description": "Split the home feed into two columns",
"$markdown_help_title": "Markdown help",
"$markdown_help_description": "Add a markdown helper to the bottom left corner",
"$markdown_help_images_header": "Images",
"$markdown_help_imageUpload": "(you must upload it somewhere else to get a link)",
"$markdown_help_imageSize": "Adjusting size:",
"$markdown_help_links_header": "Links",
"$markdown_help_formatting_header": "Formatting",
"$markdown_help_infixOr": "or",
"$navigation_profileLink": "{0}'s profile",
"$MAL_score": "MAL Score",
"$MAL_serialization": "Serialisation",
"$adjustColours_title": "Adjust Colours",
"$button_newChapters": "New Chapters",
"$scanning": "Scanning...",
"$noResults": "No results found",
"$filters": "Filters",
"$filters_lists": "Lists",
"$filters_year": "Year",
"$heading_anime": "Anime:",
"$heading_manga": "Manga:",
"$heading_similarFavs": "Similar favs:",
"$stats_animeOnList": "Anime on list: ",
"$stats_mangaOnList": "Manga on list: ",
"$stats_animeRated": "Anime rated: ",
"$stats_mangaRated": "Manga rated: ",
"$stats_averageScore": "Average score: ",
"$stats_onlyOne": "Only one score given: ",
"$stats_medianScore": "Median score: ",
"$stats_globalDifference": "Global difference: ",
"$stats_globalDeviation": "Global deviation: ",
"$stats_ratingEntropy": "Rating Entropy: ",
"$stats_mostCommonScore": "Most common score: ",
"$stats_timeWatched": "Time watched: ",
"$stats_totalChapters": "Total chapters: ",
"$stats_totalVolumes": "Total volumes: ",
"$stats_TVEpisodesWatched": "TV episodes watched: ",
"$stats_TVEpisodesRemaining": "TV episodes remaining for current shows: ",
"$stats_firstLoggedAnime": "First logged anime: ",
"$stats_firstLoggedAnime_note": "(users can freely change start dates)",
"$stats_weightComment_duration": " (duration weighted)",
"$stats_weightComment_chapers": " (chapter weighted)",
"$stats_globalDifference_comment": " (average difference from global average)",
"$stats_globalDeviation_comment": " (standard deviation from the global average of each entry)",
"$stats_ratingEntropy_comment": " bits/rating (higher number = more fine-grained ratings. Usually between 1 - 6)",
"$stats_moreStats_title": "More Stats",
"$stats_genresTags_title": "Genres & Tags",
"$stats_genre": "Genre",
"$stats_tag": "Tag",
"$stats_count": "Count",
"$stats_name": "Name",
"$stats_siteStats_title": "Site Stats",
"$stats_anime_heading": "Anime stats for {0}",
"$stats_manga_heading": "Manga stats for {0}",
"$stats_loadingAnime": "loading anime list...",
"$stats_loadingManga": "loading manga list...",
"$stats_instances": "({0} instances)",
"$stats_instances_unique": "no two scores alike",
"$stats_longestTime": "{0}% is {1}",
"$stats_varousStats_heading": "Various statistics",
"$stats_longest_watching": "Currently watching.",
"$stats_longest_paused": "On hold.",
"$stats_longest_dropped": "Dropped.",
"$stats_longest_1rewatch": "Rewatched once.",
"$stats_longest_2rewatch": "Rewatched twice.",
"$stats_longest_Mrewatch": "Rewatched {0} times.",
"$stats_longest_1rewatching": "First rewatch in progress.",
"$stats_longest_2rewatching": "Second rewatch in progress.",
"$stats_longest_Mrewatching": "Rewatch number {0} in progress.",
"$stats_longest_1rewatchPaused": "First rewatch on hold.",
"$stats_longest_2rewatchPaused": "Second rewatch on hold.",
"$stats_longest_MrewatchPaused": "Rewatch number {0} on hold.",
"$stats_longest_1rewatchDropped": "Dropped on first rewatch.",
"$stats_longest_2rewatchDropped": "Dropped on second rewatch.",
"$stats_longest_MrewatchDropped": "Dropped on rewatch number {0}.",
"$stats_regularTags": "Regular tags to include (applied on reload): ",
"$stats_meanScore": "Mean Score",
"$stats_customTagsAnime": "Custom Anime Tags",
"$stats_customTagsManga": "Custom Manga Tags",
"$stats_chapters": "Chapters",
"$stats_volumes": "Volumes",
"$characterBrowseTooltip": "Favourites",
"$make3x3": "Make 3x3",
"$make3x3_title": "Click this button, then 9 entries on your list",
"$forum_preview_reply": "replied ",
"$forum_singleThread": "You're viewing a single comment. View the entire thread?",
"$staff_filterHelp": "Filter help",
"$staff_hoursWatched": "Hours Watched: ",
"$staff_chaptersRead": " Chapters Read: ",
"$staff_volumesRead": " Volumes Read: ",
"$staff_meanScore": " Mean Score: ",
"$staff_sort": "Sort",
"$sort_alphabetical": "Alphabetical",
"$sort_newest": "Newest",
"$sort_oldest": "Oldest",
"$sort_length": "Length",
"$sort_popularity": "Popularity",
"$sort_score": "Score",
"$sort_myScore": "My Score",
"$sort_myProgress": "My Progress",
"$milestones_totalVolumes": "Total Volumes",
"$milestones_totalEpisodes": "Total Episodes",
"$milestones_daysWatched": "{0} Days Watched",
"$milestones_chaptersRead": "{0} Chapters Read",
"$colour_transparent": "Transparent",
"$colour_blue": "Blue",
"$colour_white": "White",
"$colour_black": "Black",
"$colour_red": "Red",
"$colour_peach": "Peach",
"$colour_orange": "Orange",
"$colour_yellow": "Yellow",
"$colour_green": "Green",
"$terms_description": "Add a low bandwidth feed to the https://anilist.co/terms page",
"$terms_privacyPolicy": "View Privacy Policy instead",
"$terms_privacyPolicy_title": "This page usually shows the privacy policy of Anilist. Click to get the default view",
"$terms_signin": "This module does not work without signing in to Automail",
"$terms_signin_link": "Sign in with the script",
"$terms_option_global": "Global",
"$terms_option_text": "Text posts",
"$terms_option_replies": "Has replies",
"$terms_option_forum": "Forum",
"$terms_option_reviews": "Reviews",
"$terms_option_user": "User",
"$terms_option_media": "Media",
"$mediaStaff_filter": "Filter",
"$socialTab_tooManyChapters": "Most likely the database total has been updated",
"$socialTab_users": "Users",
"$socialTab_shortAverage": "Avg",
"$query_firstActivity": "First Activity",
"$query_autorecs": "Autorecs",
"$query_autorecs_collecting": "Collecting list data...",
"$query_autorecs_processing": "Processing...",
"$query_autorecs_info": "Top picks, based on your ratings, the ratings of others, and the recommendation database. Best matches on top",
"$mobileFriendly_description": "Mobile Friendly mode. Disables some modules not working properly on mobile, and adjusts others",
"$hideLikes_description": "Hide like notifications. Will not affect the notification count",
"$settingsTip_description": "Show a notice on the notification page for where the script settings can be found",
"$settings_errorInvalidJSON": "Invalid profile JSON",
"$settings_errorInvalidActivity": "must be a direct link to an activity or an activity ID",
"$settings_errorInvalidActivity2": "activity not found!",
"$dismissDot_description": "Show a spec to dismiss notifications when signed in",
"$socialTab_description": "Media social tab average score, progress and notes",
"$socialTabFeed_description": "Media social tab feed filters",
"$socialTabFeed_noActivities": "No matching activities",
"$forumMedia_description": "Add the tagged media to the forum preview on the home page",
"$mangaBrowse_description": "Make browse default to manga",
"$dblclickZoom_description": "Double click activities to zoom",
"$draw3x3_description": "Add a button to lists to create 3x3's from list entries. Click the button, and then select nine entries",
"$subTitleInfo_description": "Add basic data below the title on media pages",
"$entryScore_description": "Add your score and progress to media pages",
"$activityTimeline_description": "Link your activities in the social tab of media, and between individual activities",
"$CSSfollowCounter_description": "Follow count on social page",
"$completedScore_description": "Show the score on the activity when people complete something",
"$droppedScore_description": "Show the score on the activity when people drop something",
"$replaceNativeTags_description": "Full lists for tags, staff and studios in stats",
"$hideGlobalFeed_description": "Hide the global feed",
"$CSScompactBrowse_description": "Make the browse section more compact",
"$cleanSocial_description": "Place 'following' before 'forum threads' on media social tabs",
"$CSSverticalNav_description": "Alternative browse mode [with vertical navbar by Kuwabara]",
"$nonJumpScroll_description": "Stop activity content from jumping around when using scrollbars [by Reina]",
"$blockWord_description": "Hide status posts containing this word:",
"$statusBorder_description": "Colour code the right border of activities by media status",
"$betterReviewRatings_description": "Add the total number of ratings to reviews on the home page",
"$browseFilters_description": "Add more sorting options to browse",
"$tagIndex_description": "Show an index of custom tags on anime and manga lists",
"$dubMarker_description": "Add a notice on top of the other data on an anime page if a dub is available",
"$mangaGuess_description": "Make a guess for the number of chapters for releasing manga",
"$allStudios_description": "Include companies that aren't animation studios in the extended studio stats table",
"$noRewatches_description": "Don't include progress from rewatches/rereads in stats",
"$hideCustomTags_description": "Hide the custom tag tables by default",
"$negativeCustomList_description": "Add an entry in the custom tag tables with all media not on a custom list",
"$globalCustomList_description": "Add an entry in the custom tag tables with all media",
"$timeToCompleteColumn_description": "Add a 'time to complete' column to the tag tables",
"$feedCommentFilter_description": "Add filter options to the feeds to hide posts with few comments or likes",
"$browseSubmenu_description": "Replace the native 'browse' submenu when using the vertical nav",
"$annoyingAnimations_description": "Remove annoying UI animations",
"$customCSS_description": "Enable custom profile CSS and replacement pinned activities",
"$pinned": "Pinned",
"$dblclickZoom_extendedDescription": "There are likely better browser accessibility addons for this.",
"$staff_animeRoles": "Anime Staff Roles",
"$staff_mangaRoles": "Manga Staff Roles",
"$staff_voiceRoles": "Character Voice Roles",
"$forumHeading_recentlyActive": "Recently Active Threads",
"$forumHeading_releaseDiscussion": "Release Discussion Threads",
"$forumHeading_newThreads": "Newly Created Threads",
"$home_reviewLink": "Recent Reviews",
"$home_forumLink": "Forum Activity",
"$home_trendingAnime": "Trending Anime",
"$home_trendingManga": " & Manga",
"$home_newAnime": "Newly Added Anime",
"$home_newManga": "Newly Added Manga",
"$footer_siteTheme": "Site Theme",
"$footer_addData": "Add Data",
"$footer_moderators": "Moderators",
"$footer_contact": "Contact",
"$footer_terms": "Terms & Privacy",
"$footer_siteMap": "Site Map",
"$theme_default": "Default",
"$theme_dark": "Dark",
"$theme_highContrast": "High Contrast",
"$theme_highContrastDark": "High Contrast Dark",
"$feed_header": "Activity",
"$feedSelect_all": "All",
"$feedSelect_text": "Text Status",
"$feedSelect_list": "List Progress",
"$feedSelect_status": "Status",
"$feedSelect_message": "Messages",
"$mediaFormat_TV" : "TV",
"$mediaFormat_TV_SHORT" : "TV Short",
"$mediaFormat_MOVIE" : "Movie",
"$mediaFormat_SPECIAL" : "Special",
"$mediaFormat_OVA" : "OVA",
"$mediaFormat_ONA" : "ONA",
"$mediaFormat_MUSIC" : "Music",
"$mediaFormat_MANGA" : "Manga",
"$mediaFormat_NOVEL" : "Light Novel",
"$mediaFormat_ONE_SHOT" : "One Shot",
"$forumCategory_1": "Anime",
"$forumCategory_2": "Manga",
"$forumCategory_3": "Light Novels",
"$forumCategory_4": "Visual Novels",
"$forumCategory_5": "Release Discussion",
"$forumCategory_7": "General",
"$forumCategory_8": "News",
"$forumCategory_9": "Music",
"$forumCategory_10": "Gaming",
"$forumCategory_11": "Site Feedback",
"$forumCategory_12": "Bug Reports",
"$forumCategory_13": "Site Announcements",
"$forumCategory_14": "List Customisation",
"$forumCategory_15": "Recommendations",
"$forumCategory_16": "Forum Games",
"$forumCategory_17": "Misc",
"$forumCategory_18": "AniList Apps",
"$menu_overview": "Overview"
	}
}
,
	"Português": {
	"info": {
		"language": "Português",
		"language_english": "Portuguese",
		"locale": "pt",
		"fallback": ["English"],
		"maintainer": "samOAK",
		"maintainer_link": "https://anilist.co/user/samOAK/",
		"discussion_link": "https://github.com/hohMiyazawa/Automail/issues/69",
		"notes": "tentei usar português europeu",
		"translators": ["samOAK"]
	},
	"keys": {
"$meta_scriptDescription": "Partes extras para Anilist.co",
"$loading": " A cargar…",
"$searching": "A buscar…",
"$load_more": "Cargar Mais",
"$time_now": "Agora",
"$time_1second": "há 1 segundo",
"$time_Msecond": "há {0} segundos",
"$time_1minute": "há 1 minuto",
"$time_Mminute": "há {0} minutos",
"$time_1hour": "há 1 hora",
"$time_Mhour": "há {0} horas",
"$time_1day": "há 1 dia",
"$time_Mday": "há {0} dias",
"$time_1week": "há 1 semana",
"$time_Mweek": "há {0} semanas",
"$time_1month": "há 1 mês",
"$time_Mmonth": "há {0} meses",
"$time_1year": "há 1 ano",
"$time_Myear": "há {0} anos",
"$time_medium_second": "segundo",
"$time_medium_minute": "minuto",
"$time_medium_hour": "hora",
"$time_medium_day": "dia",
"$time_medium_week": "semana",
"$time_medium_month": "mês",
"$time_medium_year": "ano",
"$time_medium_Msecond": "segundos",
"$time_medium_Mminute": "minutos",
"$time_medium_Mhour": "horas",
"$time_medium_Mday": "dias",
"$time_medium_Mweek": "semanas",
"$time_medium_Mmonth": "meses",
"$time_medium_Myear": "anos",
"$time_short_second": "s",
"$time_short_minute": "m",
"$time_short_hour": "h",
"$time_short_day": "d",
"$time_short_week": "sem",
"$time_short_month": "mes",
"$time_short_year": "a",
"$language_English": "Inglês",
"$language_German": "Alemão",
"$language_Italian": "Italiano",
"$language_Spanish": "Espanhol",
"$language_French": "Francês",
"$language_Korean": "Coreano",
"$language_Portuguese": "Português",
"$language_Hebrew": "Hebraico",
"$language_Hungarian": "Húngaro",
"$language_Chinese": "Chinês",
"$language_Japanese": "Japonês",
"$language_Arabic": "Árabe",
"$language_Filipino": "Filipino",
"$language_Catalan": "Catalão",
"$language_Polish": "Polaco",
"$language_Norwegian": "Norueguês",
"$default_filename": "Ficheiro de Anilist.co",
"$generic_anime": "Anime",
"$generic_manga": "Manga",
"$page": "Página {0}",
"$dubMarker_notice": "Dobrado em {0}",
"$button_submit": "Enviar",
"$button_search": "Buscar",
"$button_run": "Executar",
"$button_add": "Adicionar",
"$button_reset": "Restaurar",
"$button_resetAll": "Restaurar tudo",
"$button_defaultSettings": "Definições Padrão",
"$missing_N/A_data": "-",
"$button_next": "Seguinte →",
"$button_previous": "← Anterior",
"$button_refresh": "Recargar",
"$button_edit": "Editar",
"$button_publish": "Enviar",
"$button_cancel": "Cancelar",
"$placeholder_status": "Escreve um post…",
"$placeholder_reply": "Escreve uma resposta…",
"$placeholder_message": "Escreve uma mensagem…",
"$placeholder_forum": "Escreve um fio no foro…",
"$forumMedia_backlink": "Põe um link à página da obra em seu feed do foro",
"$settings_title": "Definições de Automail",
"$profile_title": "Perfil de {0}",
"$notImplemented": "Perdão, ainda não implementado",
"$settings_version": "Versão: ",
"$settings_homepage": "Página inicial: ",
"$settings_repository": "Repositório: ",
"$settings_moreInfo_tooltip": "Mais info",
"$settings_category_Notifications": "Notificações",
"$settings_category_Feeds": "Feeds",
"$settings_category_Forum": "Foro",
"$settings_category_Lists": "Listas",
"$settings_category_Profiles": "Perfis",
"$settings_category_Stats": "Estat.",
"$settings_category_Media": "Mídia",
"$settings_category_Navigation": "Navegação",
"$settings_category_Browse": "Explorar",
"$settings_category_Script": "Script",
"$settings_category_Login": "Sessão",
"$settings_category_Newly Added": "Novas",
"$settings_button_export": "Exportar definições",
"$settings_export_description": "Pode ser útil ter uma cópia de segurança se costumas limpar cache/cookies, que também limpará as definições de Automail",
"$settings_import": "Importar definições:",
"$settings_experimental_suffix": "[EXPERIMENTAL]",
"$settings_partialLocalisationLanguage_description": "Língua de Automail",
"$settings_CSSadd": "Aplicar CSS personalizado a teu perfil. Poderão ver quem tiver o script.",
"$settings_CSSlinkTip": "(Também podes usar um link a um ficheiro CSS)",
"$settings_pinnedActivity": "Pôr ao teu perfil uma atividade fixada",
"$settings_notificationDotColour": "Cor dos Pontos de Notificação",
"$setting_notifications": "Melhorar notificações",
"$setting_moreStats": "Mostrar uma aba extra em Estatísticas",
"$setting_compare": "Substituir função nativa de comparação",
"$setting_CSSsmileyScore": "Cores distintas às notas smiley",
"$setting_tweets": "Embutir tuítes ligados",
"$setting_CSSgreenManga": "Títulos de manga verdes",
"$setting_CSSbannerShadow": "Remover sombra da capa",
"$setting_CSSmobileTags": "Não ocultar voto de tags na página da obra no telemóvel",
"$setting_infoTable": "Tabela de duas colunas nos dados da obra",
"$setting_reinaDark": "Tema de Alto Contraste Escuro [por Reina]",
"$setting_MALserial": "Dado de seriação do MAL a mangas",
"$setting_MALscore": "Notas do MAL à obra",
"$setting_MALrecs": "Recomendações do MAL à obra",
"$cssTooBig": "CSS personalizado excede 1MB. Reduze-o ou usa um link.",
"$jsonTooBig": "JSON de perfil excede 1MB",
"$debug_tip": "(Ei, seria bom incluires este ficheiro ao relatar erros. Facilita minha vida)",
"$profileBackground_help1": "Definir um fundo de perfil, exemplo:",
"$profileBackground_help2": "Dica: Usa cor transparente pois funciona bem nos temas Claro e Escuro. Exemplo:",
"$profileBackground_help3": "Dica2: Queres uma imagem desbotada, fixa e a preencher o ecrã? Eis como:",
"$mediaStatus_current": "em curso",
"$mediaStatus_watching": "vendo",
"$mediaStatus_reading": "lendo",
"$mediaStatus_completed": "concluído",
"$mediaStatus_completedWatching": "visto",
"$mediaStatus_completedReading": "lido",
"$mediaStatus_not": "Pôr à Lista",
"$mediaStatus_repeating": "repetindo",
"$mediaStatus_rewatching": "revendo",
"$mediaStatus_rereading": "relendo",
"$mediaStatus_paused": "pausado",
"$mediaStatus_dropped": "largado",
"$mediaStatus_planning": "planejado",
"$mediaStatus_planning_time": "planejou {0}",
"$mediaReleaseStatus_finished": "Terminado",
"$mediaReleaseStatus_releasing": "Lançando",
"$mediaReleaseStatus_notYetReleased": "Ainda não Lançado",
"$mediaReleaseStatus_cancelled": "Cancelado",
"$mediaReleaseStatus_hiatus": "Em Hiato",
"$mediaReleaseStatusManga_finished": "Terminado",
"$mediaReleaseStatusManga_releasing": "Publicando",
"$mediaReleaseStatusManga_notYetReleased": "Ainda não Publicado",
"$mediaReleaseStatusManga_cancelled": "Cancelado",
"$mediaReleaseStatusManga_hiatus": "Em Hiato",
"$mediaReleaseStatusAnime_finished": "Terminado",
"$mediaReleaseStatusAnime_releasing": "Transmitindo",
"$mediaReleaseStatusAnime_notYetReleased": "Ainda não Transmitindo",
"$mediaReleaseStatusAnime_cancelled": "Cancelado",
"$mediaReleaseStatusAnime_hiatus": "Em Hiato",
"$listActivity_MreadChapter": "leu capítulo {0} de ",
"$listActivity_MwatchedEpisode": "viu episódio {0} de ",
"$listActivity_MreadChapter_known": "leu capítulo {0}",
"$listActivity_MwatchedEpisode_known": "viu episódio {0}",
"$listActivity_planningManga": "planeja ler ",
"$listActivity_planningAnime": "planeja ver ",
"$listActivity_planningManga_known": "planeja ler",
"$listActivity_planningAnime_known": "planeja ver",
"$listActivity_completedManga": "concluiu ",
"$listActivity_completedAnime": "concluiu ",
"$listActivity_completedManga_known": "lido",
"$listActivity_completedAnime_known": "visto",
"$listActivity_repeatedManga": "releu ",
"$listActivity_repeatedAnime": "reviu ",
"$listActivity_repeatedManga_known": "releu",
"$listActivity_repeatedAnime_known": "reviu",
"$listActivity_pausedManga": "pausou ler ",
"$listActivity_pausedAnime": "pausou ver ",
"$listActivity_pausedManga_known": "pausou ler",
"$listActivity_pausedAnime_known": "pausou ver",
"$listActivity_droppedManga": "largou ",
"$listActivity_droppedAnime": "largou ",
"$listActivity_droppedManga_known": "largou",
"$listActivity_droppedAnime_known": "largou",
"$listActivity_MdroppedManga": "largou {0} de ",
"$listActivity_MdroppedAnime": "largou {0} de ",
"$listActivity_MdroppedManga_known": "largou {0}",
"$listActivity_MdroppedAnime_known": "largou {0}",
"$listActivity_MrepeatingManga": "releu capítulo {0} de ",
"$listActivity_MrepeatingAnime": "reviu episódio {0} de ",
"$listActivity_MrepeatingManga_known": "releu capítulo {0}",
"$listActivity_MrepeatingAnime_known": "reviu episódio {0}",
"$notification_likeActivity_1person_1activity": " curtiu tua atividade.",
"$notification_likeActivity_1person_Mactivity": " curtiu tuas atividades.",
"$notification_likeActivity_2person_1activity": " curtiram tua atividade.",
"$notification_likeActivity_2person_Mactivity": " curtiram tuas atividades.",
"$notification_likeActivity_Mperson_1activity": " curtiram tua atividade.",
"$notification_likeActivity_Mperson_Mactivity": " curtiram tuas atividades.",
"$notification_likeReply_1person_1reply": " curtiu tua resposta.",
"$notification_likeReply_1person_Mreply": " curtiu tuas respostas.",
"$notification_likeReply_2person_1reply": " curtiram tua resposta.",
"$notification_likeReply_2person_Mreply": " curtiram tuas respostas.",
"$notification_likeReply_Mperson_1reply": " curtiram tua resposta.",
"$notification_likeReply_Mperson_Mreply": " curtiram tuas respostas.",
"$notification_reply_1person_1reply": " respondeu tua atividade.",
"$notification_reply_1person_Mreply": " respondeu tuas atividades.",
"$notification_reply_2person_1reply": " responderam tua atividade.",
"$notification_reply_2person_Mreply": " responderam tuas atividades.",
"$notification_reply_Mperson_1reply": " responderam tua atividade.",
"$notification_reply_Mperson_Mreply": " responderam tuas atividades.",
"$notification_replyReply_1person_1reply": " respondeu à atividade que subscreveste.",
"$notification_newMedia": "foi recém-incluído no sítio.",
"$notification_airing": "Episódio {0} de {1} exibido.",
"$notification_message": " enviou-te uma mensagem.",
"$notification_mention": " mencionou-te em sua atividade.",
"$notification_follow": " passou a seguir-te.",
"$notification_forumCommentLike": " curtiu teu comentário no fio do foro ",
"$notification_forumMention": " mencionou-te no fio do foro ",
"$notifications_softBlock": "'Semibloquear' usuários",
"$notifications_softBlock_description1": "Ocultar notificações de gente específica. Muito menos radical que totalmente bloquear (se é o que de fato queres, vai a um perfil e toca na setinha para baixo junto ao botão 'Seguir').",
"$notifications_softBlock_description2": "As notificações não se foram, só estão ocultas. 'Mostrar notificações padrão' as farão visíveis. Des-semibloquear também as devolverá. Também pode interessar-te as seções 'Cor dos Pontos de Notificação' e 'Block stuff in the home feed' na página de definições.",
"$notifications_softBlock_description3": "Usuários semibloqueados ainda estarão nas notificações agrupadas, por não serem spam extra.",
"$notifications_hideLike": "Ocultar notificação de curtida",
"$notifications_showHoh": "Mostrar notificações hoh",
"$notifications_showDefault": "Mostrar notificações padrão",
"$notifications_comments": "comentários",
"$notifications_button_reset": "Marcar tudo como lido",
"$documentTitle_notifications": "Notificações · AniList",
"$documentTitle_home": "Início · AniList",
"$documentTitle_forum": "Foro - Debate de Anime e Manga · AniList",
"$documentTitle_forum_prefix": "Foro",
"$documentTitle_appSettings": "Definições de App e Automail · AniList",
"$preview_animeSection_title": "Anime em Progresso",
"$preview_mangaSection_title": "Manga em Progresso",
"$preview_airingSection_title": "No Ar",
"$preview_1behind": "1 episódio atrasado",
"$preview_Mbehind": "{0} episódios atrasados",
"$preview_progress": "Progresso:",
"$publishingReply": "A enviar resposta…",
"$anisongs_openings": "Aberturas",
"$anisongs_opening": "Abertura",
"$anisongs_endings": "Encerramentos",
"$anisongs_ending": "Encerramento",
"$anisongs_noSongs": "Sem sons para mostrar",
"$menu_home": "Início",
"$menu_profile": "Perfil",
"$menu_animelist": "Lista de Anime",
"$menu_mangalist": "Lista de Manga",
"$menu_browse": "Explorar",
"$menu_forum": "Foro",
"$submenu_stats": "Estatíst.",
"$submenu_social": "Social",
"$submenu_reviews": "Resenhas",
"$submenu_favourites": "Favoritos",
"$submenu_submissions": "Envios",
"$submenu_anime": "Anime",
"$submenu_manga": "Manga",
"$submenu_staff": "Pessoal",
"$submenu_characters": "Personagens",
"$submenu_recommendations": "Recomendações",
"$submenu_relations": "Relações",
"$submenu_threads": "Fios",
"$submenu_statusDistribution": "Distribuição de Estado",
"$submenu_scoreDistribution": "Distribuição de Nota",
"$mainMenu_notifications": "Notificações",
"$mainMenu_profile": "Perfil",
"$mainMenu_settings": "Definições",
"$timeline_search_description": "Buscas atividades de alguém?",
"$noScrollPosts_description": "Não encurtar posts, inobstante o tamanho",
"$ALbuttonReload_description": "Fazer botão 'AL' recargar os feeds em Início",
"$timeline_title": "Cronologia de Atividade",
"$filter_replies": "Há Resposta",
"$filter_following": "Seguindo",
"$input_user_placeholder": "Usuário",
"$error_userNotFound": "Usuário não encontrado",
"$error_connection": "Erro de Conexão",
"$myThreads_link": "Meus Fios",
"$piracy_message": "ISTO É UM LINK MAL, JÁ FOI ELIMINADO OwO (toca o botão Report para relatar aos mods esse usuário travesso)",
"$compare_default": "Mostrar comparação padrão",
"$compare_hoh": "Mostrar comparação hoh",
"$compare_minRatings": "Notas mín.:",
"$compare_individualRatings": "Sistemas de nota individuais:",
"$compare_normalizeRatings": "Normalizar notas:",
"$compare_colourCell": "Pintar célula toda:",
"$compare_listStatus": "qualquer estado da lista\ntoca para mudar",
"$404_private_or_noUser": "{0} não existe ou é um perfil privado",
"$404_private": "{0} tem um perfil privado",
"$404_noUser": "{0} não existe",
"$404_blocked": "{0} bloqueou-te",
"$recs_forYou": "Para Ti",
"$download_banner_tooltip": "Guardar capa",
"$recs_description": "Cada par é um que gostas + não viste\nMelhor primeiro",
"$module_unicodifier_description": "Converter emojis para usar no anilist",
"$module_unicodifier_extendedDescription": "Anilist não maneja uns carateres Unicode bem, gerando posts truncados. Este módulo converte-os a 'HTML entity escape codes', que o sítio aceita (eles mesmos o podem fazer facilmente se quiserem)\nIdeia original do grão GoBusto: https://files.kiniro.uk/unicodifier.html",
"$rewatch_suffix_1": "[reviu]",
"$rewatch_suffix_M": "[reviu {0}]",
"$reread_suffix_1": "[releu]",
"$reread_suffix_M": "[releu {0}]",
"$reviewLike_tooltip": "{0} de {1} curtiram esta resenha",
"$review_reviewTitle": "Resenha de {0} por\u00a0{1}",
"$updates_noNewManga": "Nada novo encontrado :(",
"$staff_filter_placeholder": "Filtrar por título, função etc.",
"$relations_following_only": "Só Seguidos",
"$relations_followers_only": "Só Seguidores",
"$relations_mutuals": "Mútuo",
"$relations_shared_following": "Seguidos Partilhados",
"$relations_shared_followers": "Seguidores Partilhados",
"$relations_description": "Separar em abas vários tipos de seguidores em Social",
"$additionalTranslation_description": "Traduzir partes extras da IU de Anilist",
"$twoColumnFeed_description": "Partir feed inicial em duas colunas",
"$markdown_help_title": "Ajuda para Markdown",
"$markdown_help_description": "Pôr ao canto inferior esquerdo uma ajuda de Markdown",
"$markdown_help_images_header": "Imagens",
"$markdown_help_imageUpload": "(deves enviá-la algures para obter o link)",
"$markdown_help_imageSize": "Ajustar tamanho:",
"$markdown_help_links_header": "Links",
"$markdown_help_formatting_header": "Formatação",
"$markdown_help_infixOr": "ou",
"$navigation_profileLink": "Perfil de {0}",
"$MAL_score": "Nota no MAL",
"$MAL_serialization": "Seriação",
"$adjustColours_title": "Ajustar Cores",
"$button_newChapters": "Novos Capítulos",
"$scanning": "A examinar…",
"$noResults": "Sem resultados",
"$filters": "Filtros",
"$filters_lists": "Listas",
"$filters_year": "Ano",
"$heading_anime": "Anime:",
"$heading_manga": "Manga:",
"$heading_similarFavs": "Favs similares:",
"$stats_animeOnList": "Animes na lista: ",
"$stats_mangaOnList": "Mangas na lista: ",
"$stats_animeRated": "Animes avaliados: ",
"$stats_mangaRated": "Mangas avaliados: ",
"$stats_averageScore": "Nota média: ",
"$stats_onlyOne": "Dada uma nota só: ",
"$stats_medianScore": "Nota mediana: ",
"$stats_globalDifference": "Diferença global: ",
"$stats_globalDeviation": "Deviação global: ",
"$stats_ratingEntropy": "Entropia de Nota: ",
"$stats_mostCommonScore": "Nota mais comum: ",
"$stats_timeWatched": "Tempo visto: ",
"$stats_totalChapters": "Total de capítulos: ",
"$stats_totalVolumes": "Total de volumes: ",
"$stats_TVEpisodesWatched": "Episódios de TV vistos: ",
"$stats_TVEpisodesRemaining": "Episódios restando de séries em curso: ",
"$stats_firstLoggedAnime": "Primeiro anime: ",
"$stats_firstLoggedAnime_note": "(usuários podem mudar datas de início livremente)",
"$stats_weightComment_duration": " (medido por duração)",
"$stats_weightComment_chapers": " (medido por capítulos)",
"$stats_globalDifference_comment": " (diferença média da média global)",
"$stats_globalDeviation_comment": " (desvio padrão da média global em cada obra)",
"$stats_ratingEntropy_comment": " bits/nota (número maior = notas mais refinadas. De 1 a 6 em geral)",
"$stats_moreStats_title": "Mais Estatísticas",
"$stats_genresTags_title": "Gêneros e Tags",
"$stats_genre": "Gênero",
"$stats_tag": "Tag",
"$stats_count": "Quantia",
"$stats_name": "Nome",
"$stats_siteStats_title": "Estatísticas do Sítio",
"$stats_anime_heading": "Estatísticas de anime de {0}",
"$stats_manga_heading": "Estatísticas de manga de {0}",
"$stats_loadingAnime": "a cargar lista de anime…",
"$stats_loadingManga": "a cargar lista de manga…",
"$stats_instances": "({0} instâncias)",
"$stats_instances_unique": "sem duas notas iguais",
"$stats_longestTime": "{0}% é {1}",
"$stats_varousStats_heading": "Várias estatísticas",
"$stats_longest_watching": "A ver.",
"$stats_longest_paused": "Pausado.",
"$stats_longest_dropped": "Largado.",
"$stats_longest_1rewatch": "Revisto uma vez.",
"$stats_longest_2rewatch": "Revisto duas vezes.",
"$stats_longest_Mrewatch": "Revisto {0} vezes.",
"$stats_longest_1rewatching": "Primeira repetição em curso.",
"$stats_longest_2rewatching": "Segunda repetição em curso.",
"$stats_longest_Mrewatching": "Repetição n.º {0} em curso.",
"$stats_longest_1rewatchPaused": "Primeira repetição em pausa.",
"$stats_longest_2rewatchPaused": "Segunda repetição em pausa.",
"$stats_longest_MrewatchPaused": "Repetição n.º {0} em pausa.",
"$stats_longest_1rewatchDropped": "Largado na primeira repetição.",
"$stats_longest_2rewatchDropped": "Largado na segunda repetição.",
"$stats_longest_MrewatchDropped": "Largado na repetição n.º {0}.",
"$stats_regularTags": "Tags regulares para incluir (aplicado ao recargar): ",
"$stats_meanScore": "Nota Média",
"$stats_customTagsAnime": "Tags de Anime Personalizadas",
"$stats_customTagsManga": "Tags de Manga Personalizadas",
"$stats_chapters": "Capítulos",
"$stats_volumes": "Volumes",
"$characterBrowseTooltip": "Favoritos",
"$make3x3": "Fazer 3x3",
"$make3x3_title": "Toca este botão, depois 9 itens de tua lista",
"$forum_preview_reply": "respondeu ",
"$forum_singleThread": "Estás a ver um comentário só. Ver o fio todo?",
"$staff_filterHelp": "Ajuda para filtro",
"$staff_hoursWatched": "Horas a Ver: ",
"$staff_chaptersRead": " Capítulos Lidos: ",
"$staff_volumesRead": " Volumes Lidos: ",
"$staff_meanScore": " Nota Média: ",
"$staff_sort": "Ordenar",
"$sort_alphabetical": "Alfabético",
"$sort_newest": "Novos",
"$sort_oldest": "Velhos",
"$sort_length": "Longura",
"$sort_popularity": "Popular",
"$sort_score": "Nota",
"$sort_myScore": "Minha Nota",
"$sort_myProgress": "Meu Progresso",
"$milestones_totalVolumes": "Volumes Totais",
"$milestones_totalEpisodes": "Episódios Totais",
"$milestones_daysWatched": "{0} Dias a Ver",
"$milestones_chaptersRead": "{0} Capítulos Lidos",
"$colour_transparent": "Transparente",
"$colour_blue": "Azul",
"$colour_white": "Branco",
"$colour_black": "Preto",
"$colour_red": "Vermelho",
"$colour_peach": "Pêssego",
"$colour_orange": "Laranja",
"$colour_yellow": "Amarelo",
"$colour_green": "Verde",
"$terms_description": "Pôr um feed para redes lentas a https://anilist.co/terms",
"$terms_privacyPolicy": "Ver Política de Privacidade",
"$terms_privacyPolicy_title": "Esta página mostrava a política de privacidade do Anilist. Toca para ir à vista padrão",
"$terms_signin": "Este módulo só funciona iniciando sessão no Automail",
"$terms_signin_link": "Iniciar sessão com o script",
"$terms_option_global": "Global",
"$terms_option_text": "Posts de texto",
"$terms_option_replies": "Há resposta",
"$terms_option_forum": "Foro",
"$terms_option_reviews": "Resenhas",
"$terms_option_user": "Usuário",
"$terms_option_media": "Mídia",
"$mediaStaff_filter": "Filtro",
"$socialTab_tooManyChapters": "Possivelmente o total da base de dados atualizou-se",
"$socialTab_users": "Usuários",
"$socialTab_shortAverage": "Média",
"$query_firstActivity": "Primeira Atividade",
"$query_autorecs": "Autorecs",
"$query_autorecs_collecting": "A coletar dados de lista…",
"$query_autorecs_processing": "A processar…",
"$query_autorecs_info": "Top escolhas, segundo tuas notas, as de outros, e a base de dados de sugestões. Destaques no topo",
"$mobileFriendly_description": "Modo para Móvel. Desativa módulos falhos no telemóvel e ajusta outros",
"$hideLikes_description": "Ocultar notificações de curtida. Não afetará sua contagem",
"$settingsTip_description": "Informar em Notificações onde estão as definições de script",
"$settings_errorInvalidJSON": "JSON de perfil inválido",
"$settings_errorInvalidActivity": "deve ser um link direto a uma atividade ou seu ID",
"$settings_errorInvalidActivity2": "atividade não encontrada!",
"$dismissDot_description": "Mostrar rol para dispensar notificações ao iniciar sessão",
"$socialTab_description": "Nota média, progresso e anotações da obra em Social",
"$socialTabFeed_description": "Fitros de feed da obra em Social",
"$socialTabFeed_noActivities": "Sem correspondências",
"$forumMedia_description": "Pôr obra citada à prévia do foro em Início",
"$mangaBrowse_description": "Fazer manga padrão em Explorar",
"$dblclickZoom_description": "Toque duplo para ampliar atividade",
"$draw3x3_description": "Pôr às listas um botão de criar 3x3 com itens da lista. Toca o botão, então escolhe nove itens",
"$subTitleInfo_description": "Pôr dados básicos sob o título na página da obra",
"$entryScore_description": "Pôr tua nota e progresso à página da obra",
"$activityTimeline_description": "Ligar tuas atividades na aba Social da obra, e entre atividades individuais",
"$CSSfollowCounter_description": "Quantia de seguidores em Social",
"$completedScore_description": "Mostrar na atividade a nota quando alguém conclui algo",
"$droppedScore_description": "Mostrar na atividade a nota quando alguém larga algo",
"$replaceNativeTags_description": "Listas completas para tags, pessoal e estúdios em Estat.",
"$hideGlobalFeed_description": "Ocultar o feed global",
"$CSScompactBrowse_description": "Fazer seção Explorar mais compacta",
"$cleanSocial_description": "Pôr 'Following' antes de 'Forum Threads' na aba Social da obra",
"$CSSverticalNav_description": "Modo alternativo de navegação [com barra vertical por Kuwabara]",
"$nonJumpScroll_description": "Parar de pular conteúdo da atividade ao usar elevadores [por Reina]",
"$blockWord_description": "Ocultar posts contendo esta palavra:",
"$statusBorder_description": "Colorir a borda direita de atividades por estado de obra",
"$betterReviewRatings_description": "Pôr ao Início o total de avaliações a resenhas",
"$browseFilters_description": "Mais opções de ordenação em Explorar",
"$tagIndex_description": "Mostrar um índice de tags personalizadas em listas de anime e mangá",
"$dubMarker_description": "Informar acima dos dados na página da obra se há dobragem",
"$mangaGuess_description": "Supôr número de capítulos para mangás em circulação",
"$allStudios_description": "Incluir empresas não estúdios de animação na tabela expandida de estatísticas de estúdios",
"$noRewatches_description": "Não incluir progresso de repetições nas estatísticas",
"$hideCustomTags_description": "Ocultar tabelas de tag personalizada por padrão",
"$negativeCustomList_description": "Pôr às tabelas de tag personalizada uma coluna com obras fora de listas personalizadas",
"$globalCustomList_description": "Pôr às tabelas de tag personalizada uma coluna com todas as obras",
"$timeToCompleteColumn_description": "Pôr às tabelas de tags a coluna 'time to complete' ",
"$feedCommentFilter_description": "Pôr aos feeds opções de filtro para ocultar posts com poucos comentários ou curtidas",
"$browseSubmenu_description": "Substituir submenu Explorar nativo ao usar navegação vertical",
"$annoyingAnimations_description": "Remover animações IU chatas",
"$customCSS_description": "Ativar CSS de perfil personalizado e atividades fixadas",
"$dblclickZoom_extendedDescription": "Talvez haja melhores extensões de acessibilidade no navegador.",
"$staff_animeRoles": "Papéis em Anime",
"$staff_mangaRoles": "Papéis em Manga",
"$staff_voiceRoles": "Papéis de voz",
"$forumHeading_recentlyActive": "Fios Recém-ativos",
"$forumHeading_releaseDiscussion": "Fios a Debater o Lançamento",
"$forumHeading_newThreads": "Fios Recém-criados",
"$home_reviewLink": "Novas Resenhas",
"$home_forumLink": "Atividade no Foro",
"$home_trendingAnime": "Animes e ",
"$home_trendingManga": "Mangas em Alta",
"$home_newAnime": "Animes Recém-incluídos",
"$home_newManga": "Mangas Recém-incluídos",
"$footer_siteTheme": "Tema do Sítio",
"$footer_addData": "Adicionar Dados",
"$footer_moderators": "Moderatores",
"$footer_contact": "Contato",
"$footer_terms": "Termos e Privacidade",
"$footer_siteMap": "Mapa do Sítio",
"$theme_default": "Padrão",
"$theme_dark": "Escuro",
"$theme_highContrast": "Alto Contraste",
"$theme_highContrastDark": "Alto Contraste Escuro",
"$feed_header": "Atividade",
"$feedSelect_all": "Tudo",
"$feedSelect_text": "Post Texto",
"$feedSelect_list": "Progresso Lista",
"$feedSelect_status": "Posts",
"$feedSelect_message": "Mensagens",
"$mediaFormat_TV" : "TV",
"$mediaFormat_TV_SHORT" : "TV Curta",
"$mediaFormat_MOVIE" : "Filme",
"$mediaFormat_SPECIAL" : "Especial",
"$mediaFormat_OVA" : "OVA",
"$mediaFormat_ONA" : "ONA",
"$mediaFormat_MUSIC" : "Música",
"$mediaFormat_MANGA" : "Manga",
"$mediaFormat_NOVEL" : "Light Novel",
"$mediaFormat_ONE_SHOT" : "One Shot",
"$forumCategory_1": "Animes",
"$forumCategory_2": "Mangas",
"$forumCategory_3": "Light Novels",
"$forumCategory_4": "Visual Novels",
"$forumCategory_5": "Debate de Lançamento",
"$forumCategory_7": "Geral",
"$forumCategory_8": "Notícias",
"$forumCategory_9": "Música",
"$forumCategory_10": "Jogos",
"$forumCategory_11": "Comentário ao Sítio",
"$forumCategory_12": "Relatos de Erro",
"$forumCategory_13": "Anúncios do Sítio",
"$forumCategory_14": "Personalização de Listas",
"$forumCategory_15": "Recomendações",
"$forumCategory_16": "Jogos de foro",
"$forumCategory_17": "Outros",
"$forumCategory_18": "Apps de AniList",
"$menu_overview": "Resumo",
"$role_Original Creator": "Criador Original",
"$role_Creator": "Criador",
"$role_Music": "Música",
"$role_Key Animation": "Animação-Chave",
"$role_Key Animation Assistance": "Assistência de Animação-Chave",
"$role_In-Between Animation": "Animação de Intervalação",
"$role_Animator": "Animador",
"$role_Animation": "Animação",
"$role_Main Animator": "Animador Principal",
"$role_Opening Animation": "Animação de Abertura",
"$role_Art": "Arte",
"$role_Illustration": "Ilustração",
"$role_End Card": "Cartão Final",
"$role_Original Concept": "Conceito Original",
"$role_Story Concept": "Conceito da Estória",
"$role_Original Story": "Estória Original",
"$role_Story": "Estória",
"$role_Official Writer": "Escritor Oficial",
"$role_Story & Art": "Estória e Arte",
"$role_Director": "Diretor",
"$role_CG Director": "Diretor de CG",
"$role_Character Design": "Design de Personagem",
"$role_Original Character Design": "Design de Personagem Original",
"$role_Animation Director": "Diretor de Animação",
"$role_Assistant Episode Director": " Diretor de Episodio Assistente",
"$role_Assistant Animation Director": "Diretor de Animação Assistente",
"$role_Assistant Director": "Diretor Assistente",
"$role_Chief Animation Director": "Diretor-Chefe de Animação",
"$role_Episode Director": "Diretor de Episódio",
"$role_Sound Director": "Diretor de Som",
"$role_Chief Director": "Diretor-Chefe",
"$role_Unit Director": "Diretor de Unidade",
"$role_Art Director": "Diretor de Arte",
"$role_Art Design": "Design de Arte",
"$role_Chief Unit Director": "Diretor-Chefe de Unidade",
"$role_Planning Producer": "Produtor de Planejamento",
"$role_Producer": "Produtor",
"$role_Co-Producer": "Coprodutor",
"$role_Production Coordination": "Coordenação de Produção",
"$role_Production Generalization": "Generalização de Produção",
"$role_Executive Director": "Diretor Executivo",
"$role_Executive Producer": "Produtor Executivo",
"$role_Animation Producer": "Produtor de Animação",
"$role_Creative Producer": "Produtor Criativo",
"$role_Production Assistant": "Assistente de Produção",
"$role_Production Assistance": "Assistência de Produção",
"$role_Photography Assistance": "Assistência de Fotografia",
"$role_Director of Photography": "Diretor de Fotografia",
"$role_Photography": "Fotografia",
"$role_Camera": "Câmera",
"$role_Advertising": "Publicidade",
"$role_Finishing": "Acabamento",
"$role_Recording": "Gravação",
"$role_Recording Assistant": "Assistente de Gravação",
"$role_Dialogue Recording": "Gravação de Diálogos",
"$role_3D Works": "Trabalhos 3D",
"$role_CG Animation": "Animação CG",
"$role_Color Design": "Design de Cores",
"$role_Color Coordination": "Coordenação de Cores",
"$role_Insert Song Lyrics": "Letra de Música Incidental",
"$role_Theme Song Lyrics": "Letra da Música Tema",
"$role_Theme Song Composition": "Estruturação da Música Tema",
"$role_Theme Song Performance": "Performance da Música Tema",
"$role_Theme Song Arrangement": "Arranjo da Música Tema",
"$role_Music Piano Performance": "Performance da Música de Piano",
"$role_Conductor": "Maestro",
"$role_Special Thanks": "Agradecimento Especial",
"$role_Material Texture": "Textura de Materiais",
"$role_Original Plan": "Plano Original",
"$role_Editing": "Edição",
"$role_PV Production": "Produção de PV",
"$role_Title Design": "Design de Título",
"$role_Title Logo Design": "Design de Logo do Título",
"$role_Visual Effects": "Efeitos Visuais",
"$role_Digital Effects": "Efeitos Digitais",
"$role_Prop Design": "Design de Objeto",
"$role_Firearms Design": "Design de Armas",
"$role_ADR Script": "Guião de Dobragem",
"$role_ADR Scriptwriter": "Guionista de Dobragem",
"$role_ADR Script Adaptation": "Adaptação de Guião de Dobragem",
"$role_Layout": "Layout",
"$role_Layout Composition": "Estruturação de Layout",
"$role_Scene Design": "Design de Cenas",
"$role_Mechanical Design": "Design Mecânico",
"$role_Background Art": "Arte de Fundo",
"$role_In-Betweens Check": "Verificação de Intervalação",
"$role_Animation Check": "Verificação de Animação",
"$role_Series Composition": "Estruturação de Série",
"$role_Animation Supervisor": "Supervisor de Animação",
"$role_Supervisor": "Supervisor",
"$role_Supervision": "Supervisão",
"$role_Planning": "Planejamento",
"$role_Title": "Título",
"$role_Script": "Guião",
"$role_Screenplay": "Roteiro",
"$role_Setting": "Cenário",
"$role_Storyboard": "Esboço Sequencial",
"$role_Translator": "Tradutor",
"$role_Assistant": "Assistente",
"$role_Main": "Principal",
"$role_Supporting": "Apoio",
"$role_Background": "Fundo"
	}
}
,
	"Deutsch": {
	"info": {
		"language": "Deutsch",
		"language_english": "German",
		"locale": "de-DE",
		"fallback": ["English"],
		"maintainer": "Koopz",
		"maintainer_link": "https://anilist.co/user/Koopz/",
		"discussion_link": "",
		"notes": "",
		"translators": ["Koopz","danieldamn"]
	},
	"keys": {
"$meta_scriptDescription": "Erweiterungen für Anilist.co",
"$loading": "Lädt...",
"$searching": "Sucht...",
"$load_more": "Mehr laden",
"$time_medium_second": "Sekunde",
"$time_medium_minute": "Minute",
"$time_medium_hour": "Stunde",
"$time_medium_day": "Tag",
"$time_medium_week": "Woche",
"$time_medium_month": "Monat",
"$time_medium_year": "Jahr",
"$time_medium_Msecond": "Sekunden",
"$time_medium_Mminute": "Minuten",
"$time_medium_Mhour": "Stunden",
"$time_medium_Mday": "Tage",
"$time_medium_Mweek": "Wochen",
"$time_medium_Mmonth": "Monate",
"$time_medium_Myear": "Jahre",
"$time_short_second": "s",
"$time_short_minute": "m",
"$time_short_hour": "h",
"$time_short_day": "d",
"$time_short_week": "w",
"$time_short_month": "m",
"$time_short_year": "y",
"$language_English": "Englisch",
"$language_German": "Deutsch",
"$language_Italian": "Italienisch",
"$language_Spanish": "Spanisch",
"$language_French": "Französisch",
"$language_Korean": "Koreanisch",
"$language_Portuguese": "Portugiesisch",
"$language_Hebrew": "Hebräisch",
"$language_Hungarian": "Ungarisch",
"$language_Chinese": "Chinesisch",
"$language_Japanese": "Japanisch",
"$language_Arabic": "Arabisch",
"$language_Filipino": "Philippinisch",
"$language_Catalan": "Katalanisch",
"$language_Polish": "Polnisch",
"$language_Norwegian": "Norwegisch",
"$default_filename": "Datei von Anilist.co",
"$generic_anime": "Anime",
"$generic_manga": "Manga",
"$page": "Seite {0}",
"$dubMarker_notice": "{0} Synchronisation vorhanden",
"$button_resetAll": "Alle zurücksetzen",
"$button_defaultSettings": "Standard Einstellungen",
"$button_next": "Nächste →",
"$button_previous": "← Vorherige",
"$button_refresh": "Aktualisieren",
"$button_edit": "Bearbeiten",
"$button_publish": "Veröffentlichen",
"$button_cancel": "Abbrechen",
"$placeholder_status": "Schreibe einen Status...",
"$placeholder_reply": "Schreibe eine Antwort...",
"$placeholder_message": "Schreibe eine Nachricht...",
"$placeholder_forum": "Erstelle einen Forum Beitrag...",
"$forumMedia_backlink": "Füge einen Link zurück zur Datenbank eines Werks im Forum Feed hinzu",
"$notImplemented": "Sorry, noch nicht hinzugefügt",
"$settings_CSSadd": "Benutzerdefiniertes CSS zum Profil hinzufügen (sichtbar für andere Automail Nutzer)",
"$settings_CSSlinkTip": "(Links zu Stylesheets funktionieren auch)",
"$settings_pinnedActivity": "Aktivität im Profil anpinnen",
"$settings_notificationDotColour": "Farbe der Benachrichtigungsanzeige",
"$setting_notifications": "Bessere Benachrichtigungen",
"$time_now": "gerade eben",
"$time_1second": "vor einer Sekunde",
"$time_Msecond": "vor {0} Sekunden",
"$time_1minute": "vor einer Minute",
"$time_Mminute": "vor {0} Minuten",
"$time_1hour": "vor einer Stunde",
"$time_Mhour": "vor {0} Stunden",
"$time_1day": "gestern",
"$time_Mday": "vor {0} Tagen",
"$time_1week": "letzte Woche",
"$time_Mweek": "vor {0} Wochen",
"$time_1month": "letzten Monat",
"$time_Mmonth": "vor {0} Monaten",
"$time_1year": "letztes Jahr",
"$time_Myear": "vor {0} Jahren",
"$button_submit": "Senden",
"$button_search": "Suchen",
"$button_run": "Ausführen",
"$button_add": "Hinzufügen",
"$button_reset": "Zurücksetzen",
"$settings_title": "Automail Einstellungen",
"$settings_version": "Version: ",
"$settings_homepage": "Homepage: ",
"$settings_repository": "Quellcode: ",
"$settings_moreInfo_tooltip": "Mehr Informationen",
"$settings_category_Notifications": "Benachrichtigungen",
"$settings_category_Feeds": "Feeds",
"$settings_category_Forum": "Forum",
"$settings_category_Lists": "Listen",
"$settings_category_Profiles": "Profile",
"$settings_category_Stats": "Statistiken",
"$settings_category_Media": "Medien",
"$settings_category_Navigation": "Navigation",
"$settings_category_Browse": "Browse",
"$settings_category_Script": "Skript",
"$settings_category_Login": "Login",
"$settings_category_Newly Added": "Neu hinzugefügt",
"$settings_button_export": "Einstellungen exportieren",
"$settings_export_description": "Könnte hilfreich sein, ein Backup zu haben, wenn du den Browser Cache/Storage leerst, was dazu führt, dass alle Automail Einstellungen verloren gehen",
"$settings_import": "Einstellungen importieren:",
"$settings_experimental_suffix": "[EXPERIMENTELL]",
"$settings_partialLocalisationLanguage_description": "Automail Sprache",
"$stats_moreStats_title": "Mehr Statistiken",
"$stats_genresTags_title": "Genres & Tags",
"$stats_siteStats_title": "Seiten-Statistiken",
"$stats_anime_heading": "Anime Statistiken für {0}",
"$stats_manga_heading": "Manga Statistiken für {0}",
"$notification_likeActivity_1person_1activity": " gefiel deine Aktivität.",
"$notification_likeActivity_1person_Mactivity": " gefiel deine Aktivitäten.",
"$notification_likeActivity_2person_1activity": " gefielen deine Aktivität.",
"$notification_likeActivity_2person_Mactivity": " gefielen deine Aktivitäten.",
"$notification_likeActivity_Mperson_1activity": " gefielen deine Aktivität.",
"$notification_likeActivity_Mperson_Mactivity": " gefielen deine Aktivitäten.",
"$notification_likeReply_1person_1reply": " gefiel deine Antwort.",
"$notification_likeReply_1person_Mreply": " gefiel deine Antworten.",
"$notification_likeReply_2person_1reply": " gefielen deine Antwort.",
"$notification_likeReply_2person_Mreply": " gefielen deine Antworten.",
"$notification_likeReply_Mperson_1reply": " gefielen deine Antwort.",
"$notification_likeReply_Mperson_Mreply": " gefielen deine Antworten.",
"$notification_reply_1person_1reply": " hat auf deine Aktivität geantwortet.",
"$notification_reply_1person_Mreply": " hat auf deine Aktivitäten geantwortet.",
"$notification_reply_2person_1reply": " haben auf deine Aktivität geantwortet.",
"$notification_reply_2person_Mreply": " haben auf deine Aktivitäten geantwortet.",
"$notification_reply_Mperson_1reply": " haben auf deine Aktivität geantwortet.",
"$notification_reply_Mperson_Mreply": " haben auf deine Aktivitäten geantwortet.",
"$notification_replyReply_1person_1reply": " hat auf einer von dir verfolgten Aktivität geantwortet.",
"$notification_newMedia": "wurde vor Kurzem zur Seite hinzugefügt.",
"$notification_message": " hat dir eine Nachricht gesendet.",
"$notification_mention": " hat dich in ihrer Aktivität erwähnt.",
"$notification_follow": " folgt dir jetzt.",
"$notification_forumCommentLike": " gefiel dein Kommentar im Forumthread ",
"$notification_forumMention": " erwähnte dich im Forumthread ",
"$notifications_softBlock": "Softblocke Benutzer",
"$notifications_hideLike": "Verstecke 'Gefällt mir' Benachrichtigungen",
"$preview_animeSection_title": "Aktueller Anime",
"$preview_mangaSection_title": "Aktueller Manga",
"$preview_airingSection_title": "Ausstrahlend",
"$preview_1behind": "1 Episode hinterher",
"$preview_Mbehind": "{0} Episoden hinterher",
"$preview_progress": "Fortschritt:",
"$timeline_search_description": "Suchst du nach den Aktivitäten eines anderen Benutzers?",
"$timeline_title": "Aktivitäten Zeitleiste",
"$filter_replies": "Hat Antworten",
"$filter_following": "Gefolgte",
"$input_user_placeholder": "Benutzer",
"$error_userNotFound": "Benutzer nicht gefunden",
"$myThreads_link": "Meine Threads",
"$piracy_message": "DAS IST EIN PÖSER LINK, ER WIRD NUN SEHR BESEITIGT OwO (Klicke auf den Melde-Button, um die Moderatoren auf diesen bösartigen Benutzer aufmerksam zu machen)",
"$compare_default": "Zeige Standard-Vergleich",
"$compare_hoh": "Zeige hoh-Vergleich",
"$404_private_or_noUser": "{0} existiert nicht oder hat ein privates Profil",
"$404_private": "{0} hat ein privates Profil",
"$404_noUser": "{0} existiert nicht",
"$404_blocked": "{0} hat dich geblockt",
"$recs_forYou": "Für dich",
"$recs_description": "Paare bestehen aus Medien, die du magst + Medien, die du noch nicht angefangen hast\nBeste Übereinstimmungen zuerst",
"$module_unicodifier_description": "Konvertiert Emojis, damit sie auf Anilist funktionieren",
"$module_unicodifier_extendedDescription": "Anilist verarbeitet einige Unicode Zeichen inkorrekt, was zum Abschneiden von Posts führt. Dieses Modul konvertiert sie zu sog. 'HTML entity escape codes', mit denen die Seite umgehen kann. (Dies könnten sie selber tun, wenn sie wollten)\nOriginale Idee vom großartigen GoBusto: https://files.kiniro.uk/unicodifier.html",
"$rewatch_suffix_1": "[Rewatch]",
"$rewatch_suffix_M": "[Rewatch {0}]",
"$reread_suffix_1": "[Reread]",
"$reread_suffix_M": "[Reread {0}]"
	}
}
,
	"日本語": {
	"info": {
		"language": "日本語",
		"language_english": "Japanese",
		"locale": "jp-JP",
		"fallback": ["English"],
		"maintainer": "SoulBlade17",
		"maintainer_link": "https://anilist.co/user/SoulBlade17/",
		"discussion_link": "https://github.com/hohMiyazawa/Automail/issues/69",
		"notes": "Japanese is not my first language, so errors may be present in the translation. Please let me know if you find any errors.",
		"translators": ["SoulBlade17","hoh"]
	},
	"keys": {
"$loading": "読み込んでいます...",
"$searching": "検索しています",
"$load_more": "もっと読み込み",
"$button_next": "次へ →",
"$button_previous": "前へ",
"$button_refresh": "更新する",
"$button_edit": "編集",
"$button_search": "検索",
"$button_submit": "送信",
"$button_publish": "著す",
"$button_cancel": "キャンセル",
"$button_add": "加える",
"$button_run": "動く",
"$placeholder_status": "ステータスを書く",
"$placeholder_reply": "返事を書く",
"$placeholder_message": "メッセージを書く",
"$placeholder_forum": "フォーラムポストを書く",
"$settings_title": "Automail設定",
"$notImplemented": "申し訳ありませんが、まだ実装されていません。",
"$settings_version": "バージョン: ",
"$settings_homepage": "ホームページ: ",
"$settings_repository": "レポジトリ: ",
"$settings_category_Notifications": "通知",
"$settings_category_Feeds": "フィード",
"$settings_category_Forum": "フォーラム",
"$settings_category_Lists": "リスト",
"$settings_category_Profiles": "プロフィール",
"$settings_category_Stats": "スタッツ",
"$settings_category_Media": "メディア",
"$settings_category_Navigation": "ナビゲーション",
"$settings_category_Browse": "閲覧",
"$settings_category_Script": "スクリプト",
"$settings_category_Login": "ログイン",
"$settings_category_Newly Added": "新規追加",
"$settings_button_export": "エクスポート設定",
"$settings_import": "インポート設定:",
"$settings_experimental_suffix": "[実験的]",
"$settings_partialLocalisationLanguage_description": "Automail言語",
"$settings_notificationDotColour": "通知ドットの色",
"$setting_notifications": "通知の改善",
"$setting_tweets": "リンクされたツイートを埋め込む",
"$setting_CSSgreenManga": "漫画の緑のタイトル",
"$setting_CSSbannerShadow": "バナーの影を消す",
"$setting_MALserial": "漫画にMALの連載情報を追加",
"$setting_MALscore": "メディアにMALの点数を追加",
"$setting_MALrecs": "メディアにMALの推奨事項を追加",
"$settings_moreInfo_tooltip": "もっと見る",
"$settings_export_description": "ブラウザのキャッシュやストレージを消去するような場合、バックアップをとっておくと便利かもしれません。Automailの設定も消去されます。",
"$settings_CSSadd": "プロフィールにカスタムCSSを追加します。これはスクリプトで他の人にも見えるようになります。",
"$settings_CSSlinkTip": "(スタイルシートへの直接リンクも使用できます）",
"$settings_pinnedActivity": "プロフィールにピン留めされたアクティビティを追加する",
"$setting_moreStats": "統計ページで追加のタブを表示する",
"$setting_compare": "ネイティブ比較機能を置き換える",
"$setting_CSSsmileyScore": "スマイリーのレーティングに明確な色を付ける",
"$setting_CSSmobileTags": "モバイルのメディアページでタグ投票を非表示にしない",
"$setting_infoTable": "メディアページの情報は2カラムのテーブルレイアウトを使用する",
"$setting_reinaDark": "ハイコントラストダークサイトテーマを追加する 【Reinaによる】",
"$cssTooBig": "カスタムCSSが1MBを超えています。小さくするか、リンクで代用して下さい。",
"$jsonTooBig": "プロファイルのJSONが1MBを超える",
"$debug_tip": "(おい、バグを報告するときにこのファイルを添付してくれると助かるんだけどな。私の生活が楽になります)",
"$profileBackground_help1": "プロフィールの背景を設定する、例:",
"$profileBackground_help2": "ヒント：透明度の高い色を使用すると、明るいテーマと暗いテーマの両方でより効果的に機能します。例:",
"$profileBackground_help3": "ヒント2：色あせた画像を固定したまま、画面いっぱいに表示させたい？これはその方法です。",
"$mediaStatus_current": "現在",
"$mediaStatus_watching": "視聴している",
"$mediaStatus_reading": "読んでいる",
"$mediaStatus_completed": "完成",
"$mediaStatus_completedWatching": "完成",
"$mediaStatus_completedReading": "完成",
"$mediaStatus_repeating": "繰り返している",
"$mediaStatus_rewatching": "再視聴",
"$mediaStatus_rereading": "再読",
"$mediaStatus_paused": "休止中",
"$mediaStatus_dropped": "ドロップした",
"$mediaStatus_planning": "志している",
"$listActivity_MreadChapter": "　の第 {0} 章を読みました。",
"$listActivity_MwatchedEpisode": " の第 {0} 話を見ました。",
"$listActivity_planningManga": " を読む予定です。",
"$listActivity_planningAnime": "　を見る予定です。",
"$listActivity_completedManga": " を完成させました。",
"$listActivity_completedAnime": " を完成させました。",
"$listActivity_repeatedManga": " を再読しました。",
"$listActivity_repeatedAnime": "　を再視聴しました。",
"$listActivity_pausedManga": " 読むのを一時中断しました。",
"$listActivity_pausedAnime": " 見るのを一時中断しました。",
"$listActivity_droppedManga": " をドロップしました。",
"$listActivity_droppedAnime": " をドロップしました。",
"$listActivity_MdroppedManga": " の {0} をドロップしました。",
"$listActivity_MdroppedAnime": " の {0} をドロップしました。",
"$listActivity_MrepeatingManga": " の第 {0} 章を再読しました。",
"$listActivity_MrepeatingAnime": " の第 {0} 章を再視聴しました。",
"$notification_likeActivity_1person_1activity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeActivity_1person_Mactivity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeActivity_2person_1activity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeActivity_2person_Mactivity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeActivity_Mperson_1activity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeActivity_Mperson_Mactivity": " は貴方のアクティビティを気に入っていました。",
"$notification_likeReply_1person_1reply": " は貴方の返事を気に入っていました。",
"$notification_likeReply_1person_Mreply": " は貴方の返事を気に入っていました。",
"$notification_likeReply_2person_1reply": " は貴方の返事を気に入っていました。",
"$notification_likeReply_2person_Mreply": " は貴方の返事を気に入っていました。",
"$notification_likeReply_Mperson_1reply": " は貴方の返事を気に入っていました。",
"$notification_likeReply_Mperson_Mreply": " は貴方の返事を気に入っていました。",
"$notification_reply_1person_1reply": " は貴方のアクティビティに返信しました。",
"$notification_reply_1person_Mreply": " は貴方のアクティビティに返信しました。",
"$notification_reply_2person_1reply": " は貴方のアクティビティに返信しました。",
"$notification_reply_2person_Mreply": " は貴方のアクティビティに返信しました。",
"$notification_reply_Mperson_1reply": " は貴方のアクティビティに返信しました。",
"$notification_reply_Mperson_Mreply": " は貴方のアクティビティに返信しました。",
"$notification_replyReply_1person_1reply": " は貴方が申し込んだアクティビティに返信しました。",
"$notification_newMedia": " が最近追加されました。",
"$notification_airing": "{1}の{0}話が放送されました。",
"$notification_message": " 貴方にメッセージを送りました。",
"$notification_mention": " のアクティビティで貴方をメンションしました。",
"$notification_follow": " が貴方のフォローを開始しました。",
"$notifications_softBlock": "ソフトブロックユーザー",
"$notifications_hideLike": "「いいね！」通知を隠す",
"$notifications_showDefault": "デフォルトの通知を表示する",
"$notifications_comments": "コメント",
"$notifications_button_reset": "全て既読にする",
"$notifications_showHoh": "代替の通知を表示する",
"$notification_forumCommentLike": " フォーラムスレッドで、は貴方のコメントが気に入りました。",
"$notification_forumMention": " フォーラムスレッドで、は貴方にメンションしました。,",
"$timeline_search_description": "誰かのアクティビティを探していますか？",
"$noScrollPosts_description": "長さに関係なく、すべてのステータスポストをフルで表示する",
"$ALbuttonReload_description": "「AL」ボタンでトップページのフィードを再読み込みする",
"$piracy_message": "これは悪いリンクです、現在処分です （通報ボタンをクリックして、このいたずらなユーザーをモデレーターで呼び出します）",
"$recs_description": "各ペアは、自分の好きなもの＋始めていないもの\nベストマッチを先にする",
"$module_unicodifier_description": "絵文字をAnilistで使えるように変換する",
"$module_unicodifier_extendedDescription": "Anilistは一部のUnicode文字を正しく扱えないため、投稿が切り捨てられることがあります。このモジュールはそれらをHTMLエンティティエスケープコードに変換し、サイトが扱えるようにします。（やろうと思えば簡単に自分でできます）\n創意は偉大なGoBustoによるものです: https://files.kiniro.uk/unicodifier.html",
"$query_autorecs_info": "貴方の評価、他の人の評価、レコメンデーションデータベースを基にしたトップピックです。ベストマッチが上位に表示されます。",
"$mobileFriendly_description": "モバイルフレンドリーモード。モバイルで正常に動作しない一部のモジュールを無効化し、その他のモジュールを調整します。",
"$compare_hoh": "代替の比較を表示する",
"$documentTitle_notifications": "通知 · AniList",
"$documentTitle_home": "ホーム · AniList",
"$documentTitle_forum": "フォーラム - アニメ・マンガの議論 · AniList",
"$documentTitle_forum_prefix": "フォーラム",
"$documentTitle_appSettings": "アプリとAutomailの設定 · AniList",
"$preview_airingSection_title": "放映中",
"$preview_1behind": "1話遅れ",
"$preview_Mbehind": "{0}話遅れ",
"$preview_progress": "進捗状況:",
"$publishingReply": "出版返信...",
"$anisongs_openings": "アニメ OP",
"$anisongs_opening": "アニメ OP",
"$anisongs_endings": "アニメ ED",
"$anisongs_ending": "アニメ ED",
"$submenu_stats": "スタッツ",
"$submenu_social": "社会的",
"$submenu_reviews": "レビュー",
"$submenu_favourites": "お気に入り",
"$submenu_submissions": "投稿",
"$submenu_staff": "スタッフ",
"$submenu_characters": "キャラクター",
"$submenu_recommendations": "おすすめ",
"$mainMenu_notifications": "通知",
"$mainMenu_profile": "プロフィール",
"$mainMenu_settings": "設定",
"$timeline_title": "アクティビティタイムライン",
"$filter_replies": "返信あり",
"$filter_following": "フォロー中",
"$input_user_placeholder": "ユーザー",
"$error_userNotFound": "ユーザーが見つかりません",
"$error_connection": "接続エラー",
"$myThreads_link": "私のスレッド",
"$compare_default": "デフォルトの比較を表示する",
"$compare_minRatings": "最低レーティング:",
"$compare_individualRatings": "個別レーティングシステム:",
"$compare_normalizeRatings": "レーティングをノーマライズする:",
"$compare_colourCell": "セル全体をカラー化:",
"$compare_listStatus": "任意のリストの状態\nクリックして切り替える",
"$404_private_or_noUser": "{0} は存在しないか、プライベートなプロファイルを持っています。",
"$404_private": "{0} はプライベートなプロフィールです。",
"$404_noUser": "{0} は存在しません。",
"$404_blocked": "{0} が貴方をブロックしました。",
"$recs_forYou": "貴方へ",
"$download_banner_tooltip": "ダウンロードバナー",
"$rewatch_suffix_1": "[再視聴]",
"$rewatch_suffix_M": "[再視聴 {0}]",
"$reread_suffix_1": "[再読]",
"$reread_suffix_M": "[再読 {0}]",
"$reviewLike_tooltip": "{1}人中{0}人がこのレビューを気に入りました。",
"$review_reviewTitle": "{1} による {0} のレビュー",
"$updates_noNewManga": "新しいアイテムは見つかりませんでした。 :(",
"$staff_filter_placeholder": "タイトルや役割などによる絞り込み",
"$relations_following_only": "フォロー中のみ",
"$relations_followers_only": "フォロワーのみ",
"$relations_mutuals": "共通",
"$relations_shared_following": "共通フォロー中",
"$relations_shared_followers": "共通フォロワー",
"$relations_description": "ソーシャルページに様々なタイプのフォロワーに対応した個別のタブを追加",
"$additionalTranslation_description": "Anilist UI の追加部分を翻訳する",
"$twoColumnFeed_description": "ホームフィードを2列に分割する",
"$markdown_help_title": "マークダウンヘルプ",
"$markdown_help_description": "左下にマークダウンヘルパーを追加する",
"$markdown_help_images_header": "イメージ",
"$markdown_help_imageUpload": "(リンクを得るにはどこかにアップロードする必要があります)",
"$markdown_help_imageSize": "サイズ調整:",
"$markdown_help_links_header": "リンク",
"$markdown_help_formatting_header": "書式設定",
"$markdown_help_infixOr": "または",
"$navigation_profileLink": "{0}のプロフィール",
"$MAL_score": "MALのスコア",
"$MAL_serialization": "連載",
"$adjustColours_title": "色を調整する",
"$button_newChapters": "新しい章",
"$scanning": "スキャニング...",
"$noResults": "結果は見つかりませんでした。",
"$filters": "フィルター",
"$filters_lists": "リスト",
"$filters_year": "年",
"$heading_anime": "アニメ:",
"$heading_manga": "漫画:",
"$heading_similarFavs": "類似のお気に入り:",
"$stats_animeRated": "アニメ評価: ",
"$stats_mangaRated": "漫画評価: ",
"$stats_averageScore": "平均スコア: ",
"$stats_onlyOne": "1点のみ採点: ",
"$stats_medianScore": "スコア中央値: ",
"$stats_globalDifference": "世界的差異: ",
"$stats_globalDeviation": "世界偏差値: ",
"$stats_ratingEntropy": "評価エントロピー: ",
"$stats_mostCommonScore": "最も多いスコア: ",
"$stats_timeWatched": "視聴時間: ",
"$stats_totalChapters": "全チャプター: ",
"$stats_totalVolumes": "全巻共通: ",
"$stats_TVEpisodesWatched": "視聴したテレビエピソード: ",
"$stats_TVEpisodesRemaining": "現在放送中の番組の残りエピソード: ",
"$stats_firstLoggedAnime": "初ログしたアニメ: ",
"$stats_firstLoggedAnime_note": "(開始日はユーザーが自由に変更可能です）",
"$stats_weightComment_duration": " (期間加重)",
"$stats_weightComment_chapers": " (チャプター加重)",
"$stats_globalDifference_comment": " (世界平均との平均差)",
"$stats_globalDeviation_comment": " (各エントリーの世界平均からの標準偏差)",
"$stats_ratingEntropy_comment": " ビット／レーティング（数字が大きいほど細かいレーティングです。 通常は1〜6までです。）",
"$stats_moreStats_title": "その他の統計情報",
"$stats_genresTags_title": "ジャンル＆タグ",
"$stats_genre": "ジャンル",
"$stats_tag": "タグ",
"$stats_count": "回数",
"$stats_name": "名前",
"$stats_siteStats_title": "サイトスタッツ",
"$stats_anime_heading": "{0}のアニメのスタッツ",
"$stats_manga_heading": "{0}漫画のスタッツ",
"$stats_loadingAnime": "アニメリストを読み込んでいます...",
"$stats_loadingManga": "マンガリストを読み込んでいます...",
"$stats_instances": "({0} 回)",
"$stats_longestTime": "{0}% は {1}",
"$stats_varousStats_heading": "各種統計",
"$stats_longest_watching": "現在視聴中。",
"$stats_longest_paused": "保留中。",
"$stats_longest_dropped": "ドロップした。",
"$stats_longest_1rewatch": "一度再視聴した。",
"$stats_longest_2rewatch": "2回再視聴した。",
"$stats_longest_Mrewatch": "{0} 回再視聴した。",
"$stats_longest_1rewatching": "初めての再視聴中。",
"$stats_longest_2rewatching": "2回目の再視聴中。",
"$stats_longest_Mrewatching": "{0} 回目の再視聴中。",
"$stats_longest_1rewatchPaused": "初めての再視聴は保留。",
"$stats_longest_2rewatchPaused": "2回目の再視聴は保留。",
"$stats_longest_MrewatchPaused": "{0} 回目の再視聴は保留。",
"$stats_longest_1rewatchDropped": "1回目の再視聴でドロップした。",
"$stats_longest_2rewatchDropped": "2回目の再視聴でドロップした。",
"$stats_longest_MrewatchDropped": "{0} 回目の再視聴でドロップした。",
"$stats_animeOnList": "アニメのリスト数: ",
"$stats_mangaOnList": "漫画のリスト数: ",
"$stats_instances_unique": "同じスコアが2つとない",
"$time_now": "今",
"$time_1second": "1秒前",
"$time_Msecond": "{0}秒前",
"$time_1minute": "1分前",
"$time_Mminute": "{0}分前",
"$time_1hour": "1時間前",
"$time_Mhour": "{0}時間前",
"$time_1day": "1日前",
"$time_Mday": "{0}日前",
"$time_1week": "1週間前",
"$time_Mweek": "{0}週間前",
"$time_1month": "1ヶ月前",
"$time_Mmonth": "{0}ヶ月前",
"$time_1year": "1年前",
"$time_Myear": "{0}年前",
"$time_medium_Mday": "日前",
"$time_short_second": "秒",
"$time_short_minute": "分",
"$time_short_hour": "時間",
"$time_short_day": "日",
"$time_short_week": "週間",
"$time_short_month": "ヶ月",
"$time_short_year": "年",
"$language_English": "英語",
"$language_German": "ドイツ語",
"$language_Italian": "イタリア語",
"$language_Spanish": "スペイン語",
"$language_French": "フランス語",
"$language_Korean": "朝鮮語",
"$language_Portuguese": "ポルトガル語",
"$language_Hebrew": "ヘブライ語",
"$language_Hungarian": "ハンガリー語",
"$language_Chinese": "中国語",
"$language_Japanese": "日本語",
"$language_Arabic": "アラビア語",
"$language_Filipino": "フィリピン語",
"$language_Catalan": "カタルーニャ語",
"$language_Polish": "ポーランド語",
"$language_Norwegian": "ノルウェー語",
"$default_filename": "Anilist.coからのファイル",
"$page": "{0}ページ",
"$dubMarker_notice": "{0}ダビングがあります",
"$button_reset": "リセットする",
"$button_resetAll": "全てをリセットする",
"$button_defaultSettings": "デフォルト設定",
"$menu_animelist": "アニメリスト",
"$menu_mangalist": "マンガリスト",
"$preview_animeSection_title": "進行中のアニメ",
"$preview_mangaSection_title": "進行中のマンガ",
"$characterBrowseTooltip": "お気に入り",
"$make3x3": "3×3を作る",
"$make3x3_title": "このボタンをクリックして、リストにある9つのエントリーをクリックします。",
"$forum_preview_reply": " 返事した",
"$staff_filterHelp": "フィルターヘルプ",
"$staff_hoursWatched": "視聴時間数: ",
"$staff_chaptersRead": " 読まれた章: ",
"$staff_volumesRead": " 読了巻数: ",
"$staff_meanScore": " 平均スコア: ",
"$staff_sort": "ソート",
"$sort_alphabetical": "アルファベット順",
"$sort_newest": "最新",
"$sort_oldest": "最高齢",
"$sort_length": "長さ",
"$sort_popularity": "人気",
"$sort_score": "スコア",
"$sort_myScore": "私のスコア",
"$sort_myProgress": "私の進歩",
"$milestones_totalVolumes": "全巻共通",
"$milestones_totalEpisodes": "全話数",
"$milestones_daysWatched": "{0} 視聴日数",
"$milestones_chaptersRead": "{0} 章を読んだ",
"$colour_transparent": "透明",
"$colour_blue": "青",
"$colour_white": "白い",
"$colour_black": "黒",
"$colour_red": "赤",
"$colour_peach": "ピーチカラー",
"$colour_orange": "オレンジ",
"$colour_yellow": "黄",
"$colour_green": "緑",
"$terms_description": "https://anilist.co/terms ページに低帯域のフィードを追加する",
"$terms_privacyPolicy": "代わりにプライバシーポリシーを見る",
"$terms_privacyPolicy_title": "このページは通常Anilistのプライバシーポリシーを表示しています。クリックするとデフォルトの表示になります。",
"$terms_signin": "このモジュールは、Automailにサインインしていないと動作しません",
"$terms_signin_link": "スクリプトでサインイン",
"$terms_option_global": "世界的",
"$terms_option_text": "テキストポスト",
"$terms_option_replies": "返信あり",
"$terms_option_forum": "フォーラム",
"$terms_option_reviews": "レビュー",
"$terms_option_user": "ユーザー",
"$terms_option_media": "メディア",
"$mediaStaff_filter": "フィルター",
"$socialTab_tooManyChapters": "データベースが更新された可能性が高いです。",
"$socialTab_users": "ユーザー",
"$socialTab_shortAverage": "平均",
"$query_firstActivity": "最初のアクティビティ",
"$query_autorecs": "自動のおすすめ",
"$query_autorecs_collecting": "リストデータを収集する...",
"$query_autorecs_processing": "処理中...",
"$hideLikes_description": "「いいね！」を非表示にします。通知回数には影響しません",
"$settingsTip_description": "通知ページでスクリプトの設定がどこにあるか通知を表示します",
"$settings_errorInvalidJSON": "無効なプロファイルJSON",
"$settings_errorInvalidActivity": "はアクティビティまたはアクティビティIDへの直接リンクでなければなりません",
"$settings_errorInvalidActivity2": "アクティビティが見つかりませんでした",
"$dismissDot_description": "サインイン時に通知を解除する仕様を表示します",
"$socialTab_description": "メディアソーシャルタブの平均スコア、進捗、メモ",
"$socialTabFeed_description": "メディアソーシャルタブフィードフィルター",
"$forumMedia_description": "トップページのフォーラムプレビューにタグ付けされたメディアを追加する",
"$mangaBrowse_description": "閲覧のデフォルトを漫画にする",
"$dblclickZoom_description": "アクティビティをダブルクリックすると拡大表示されます",
"$dblclickZoom_extendedDescription": "ブラウザのアクセシビリティアドオンにはもっと良いものがありそうです。",
"$staff_animeRoles": "アニメスタッフの役割",
"$staff_mangaRoles": "漫画スタッフの役割",
"$staff_voiceRoles": "声優の役割",
"$forumHeading_recentlyActive": "最近アクティブなスレッド",
"$forumHeading_releaseDiscussion": "リリースに関するディスカッションスレッド",
"$forumHeading_newThreads": "新規作成スレッド",
"$forumMedia_backlink": "フォーラムフィードに作品のデータベースページへのリンクバックを追加する",
"$home_reviewLink": "最近のレビュー",
"$home_forumLink": "フォーラムアクティビティ",
"$home_trendingAnime": "トレンドアニメ",
"$home_trendingManga": " & 漫画",
"$home_newAnime": "新規追加アニメ",
"$home_newManga": "新規追加漫画",
"$footer_siteTheme": "サイトテーマ",
"$theme_default": "デフォルト",
"$theme_dark": "ダーク",
"$theme_highContrast": "ハイコントラスト",
"$theme_highContrastDark": "ハイコントラストダーク",
"$feed_header": "アクティビティ",
"$feedSelect_all": "全て",
"$feedSelect_text": "テキストステータス",
"$feedSelect_list": "リストの進捗",
"$feedSelect_status": "ステータス",
"$feedSelect_message": "メッセージ",
"$mediaFormat_NOVEL" : "ライトノベル",
"$mediaFormat_TV" : "テレビ",
"$mediaFormat_TV_SHORT" : "テレビショート",
"$mediaFormat_MOVIE" : "映画",
"$mediaFormat_SPECIAL" : "スペシャル",
"$mediaFormat_OVA" : "OVA",
"$mediaFormat_ONA" : "ONA",
"$mediaFormat_MUSIC" : "音楽",
"$mediaFormat_MANGA" : "漫画",
"$mediaFormat_ONE_SHOT" : "１コマ",
"$forumCategory_1": "アニメ",
"$forumCategory_2": "漫画",
"$forumCategory_3": "ライトノベル",
"$forumCategory_4": "ビジュアルノベル",
"$forumCategory_9": "音楽",
"$forumCategory_5": "リリースディスカッション",
"$forumCategory_7": "一般",
"$forumCategory_8": "ニュース",
"$forumCategory_10": "ゲーミング",
"$forumCategory_11": "サイトフィードバック",
"$forumCategory_12": "バグレポート",
"$forumCategory_13": "サイト告知",
"$forumCategory_14": "リストカスタマイズ",
"$forumCategory_15": "おすすめ",
"$forumCategory_16": "フォーラムゲーム",
"$forumCategory_17": "その他",
"$forumCategory_18": "AniList アップ",
"$submenu_anime": "アニメ",
"$submenu_manga": "漫画",
"$menu_home": "ホーム",
"$menu_profile": "プロフィール",
"$menu_browse": "閲覧",
"$menu_forum": "フォーラム",
"$generic_anime": "アニメ",
"$generic_manga": "漫画",

"$role_Animation Director": "アニメーション監督",
"$role_Director": "監督",
"$role_Assistant Director": "助監督",
"$role_Key Animation": "原画",
"$role_In-Between Animation": "動画",
"$role_Storyboard": "絵コンテ",
"$role_Planning": "企画",
"$role_Music": "音楽",
"$role_Color": "カラー",
"$role_Color Coordination": "色指定",
"$role_Art Director": "美術監督",
"$role_Theme Song Arrangement": "テーマ曲のアレンジ",
"$role_Theme Song Lyrics": "テーマ曲の歌詞",
"$role_Chief Producer": "チーフプロデューサー",
"$role_Episode Director": "エピソード監督",
"$role_Theme Song Performance (OP)": "テーマ曲演奏（OP）",
"$role_Theme Song Performance (ED)": "テーマ曲演奏（ED）",
"$role_Character Design": "キャラクターデザイン",
"$role_Sound Director": "音響監督",
"$role_Chief Animation Director": "総作画監督",
	}
}
,
	"Åarjelsaemie": {
	"info": {
		"language": "Åarjelsaemie",
		"language_english": "Southern Sami",
		"locale": "sma",
		"fallback": ["Norsk","Svenska","English"],
		"maintainer": "hoh",
		"maintainer_link": "https://anilist.co/user/hoh/",
		"discussion_link": "",
		"notes": ""
	},
	"keys": {
"$button_search": "Ohtsh",
"$settings_experimental_suffix": "[PRYÖVENASSE]",
"$settings_partialLocalisationLanguage_description": "Automailen gïele",
"$stats_moreStats_title": "Vielie Deahpadimmieh",
"$stats_siteStats_title": "Sijjien Deahpadimmieh",
"$stats_longestTime": "{1} {0}% lea",
"$stats_mostCommonScore": "Sïejhmemes: ",
"$stats_name": "Nomme",
"$settings_title": "Automailen bïjre",
"$settings_version": "Versjovne: ",
"$settings_homepage": "Gaskeviermesne: ",
"$settings_category_Feeds": "Galkijh",
"$settings_category_Newly Added": "Orre",
"$notification_likeActivity_1person_1activity": " dov aatem lyjhki.",
"$notification_likeActivity_1person_Mactivity": " dov aath lyjhki.",
"$notification_likeActivity_2person_1activity": " dov aatem lyjhkigan.",
"$notification_likeActivity_2person_Mactivity": " dov aath lyjhkigan.",
"$notification_likeActivity_Mperson_1activity": " dov aatem lyjhkin.",
"$notification_likeActivity_Mperson_Mactivity": " dov aath lyjhkin.",
"$notification_message": " prieviem seedti.",
"$menu_home": "gåetie",
"$menu_profile": "manne",
"$menu_animelist": "animelæstoe",
"$menu_mangalist": "mangalæstoe",
"$menu_browse": "ohtsh",
"$menu_forum": "digkie",
"$filters_year": "Jaepie",
"$markdown_help_images_header": "Guvvieh",
"$markdown_help_infixOr": "jallh",
"$preview_animeSection_title": "Dov Anime",
"$preview_mangaSection_title": "Dov Manga",
"$preview_airingSection_title": "Saadtegh",
"$profile_title": "{0}en sæjroe",
"$recs_forYou": "Dutnjien",
"$colour_transparent": "Tjaetsie",
"$colour_blue": "Plaave",
"$colour_white": "Veelkes",
"$colour_black": "Tjeehpes",
"$colour_red": "Rööpses",
"$colour_peach": "Peersika",
"$colour_orange": "Rööps-viskes",
"$colour_yellow": "Viskes",
"$colour_green": "Kruana",
"$mediaFormat_ONE_SHOT" : "Oktegh"
	}
}
,
	"Norsk": {
	"info": {
		"language": "Norsk",
		"language_english": "Norwegian",
		"locale": "nn-NO",
		"fallback": ["Svenska","English"],
		"maintainer": "hoh",
		"maintainer_link": "https://anilist.co/user/hoh/",
		"discussion_link": "https://github.com/hohMiyazawa/Automail/issues/69",
		"notes": "",
		"translators": ["hoh"]
	},
	"keys": {
"$meta_scriptDescription": "Ekstradelar for Anilist.co",
"$loading": "Lastar...",
"$searching": "Søker",
"$load_more": "Last Meir",
"$time_now": "No",
"$time_1second": "1 sekund sida",
"$time_Msecond": "{0} sekund sida",
"$time_1minute": "1 minutt sida",
"$time_Mminute": "{0} minutt sida",
"$time_1hour": "1 time sida",
"$time_Mhour": "{0} timar sida",
"$time_1day": "1 dag sida",
"$time_Mday": "{0} dagar sida",
"$time_1week": "1 veke sida",
"$time_Mweek": "{0} veker sida",
"$time_1month": "1 månad sida",
"$time_Mmonth": "{0} månadar sida",
"$time_1year": "1 år sida",
"$time_Myear": "{0} år sida",
"$time_medium_second": "sekund",
"$time_medium_minute": "minutt",
"$time_medium_hour": "hour",
"$time_medium_day": "dag",
"$time_medium_week": "veke",
"$time_medium_month": "månad",
"$time_medium_year": "år",
"$time_medium_Msecond": "sekund",
"$time_medium_Mminute": "minutt",
"$time_medium_Mhour": "timar",
"$time_medium_Mday": "dagar",
"$time_medium_Mweek": "veker",
"$time_medium_Mmonth": "månadar",
"$time_medium_Myear": "år",
"$time_short_second": "s",
"$time_short_minute": "m",
"$time_short_hour": "t",
"$time_short_day": "d",
"$time_short_week": "v",
"$time_short_month": "m",
"$time_short_year": "å",
"$language_English": "engelsk",
"$language_German": "tysk",
"$language_Italian": "italiensk",
"$language_Spanish": "spansk",
"$language_French": "fransk",
"$language_Korean": "koreansk",
"$language_Portuguese": "portugisisk",
"$language_Hebrew": "hebraisk",
"$language_Hungarian": "ungarsk",
"$language_Chinese": "kinesisk",
"$language_Japanese": "japansk",
"$language_Arabic": "arabisk",
"$language_Filipino": "filippinsk",
"$language_Catalan": "katalansk",
"$language_Polish": "polsk",
"$language_Norwegian": "norsk",
"$default_filename": "Fil frå Anilist.co",
"$generic_anime": "Anime",
"$generic_manga": "Manga",
"$page": "Side {0}",
"$dubMarker_notice": "Har {0} tale",
"$button_submit": "Send inn",
"$button_search": "Søk",
"$button_next": "Neste →",
"$button_previous": "← Forrige",
"$button_refresh": "Last på nytt",
"$button_add": "Legg til",
"$button_edit": "Endra",
"$button_run": "Køyr",
"$button_reset": "Nullstill",
"$button_resetAll": "Nullstill alle",
"$button_defaultSettings": "Nullstill alle innstillingar",
"$button_publish": "Post",
"$button_cancel": "Avbryt",
"$placeholder_status": "Skriv ein post...",
"$placeholder_reply": "Skriv eit svar...",
"$placeholder_message": "Skriv ei melding...",
"$placeholder_forum": "Skriv ein forumtråd...",
"$forum_singleThread": "Vis heile forumtråden",
"$profile_title": "{0} si side",
"$publishingReply": "Postar svar...",
"$settings_title": "Innstillingar for Automail",
"$settings_version": "Versjon: ",
"$settings_homepage": "Heimeside: ",
"$settings_repository": "Kjeldekode: ",
"$settings_moreInfo_tooltip": "Meir info",
"$settings_category_Notifications": "Meldingar",
"$settings_category_Feeds": "Straumar",
"$settings_category_Forum": "Forum",
"$settings_category_Lists": "Lister",
"$settings_category_Profiles": "Profilar",
"$settings_category_Stats": "Statistikk",
"$settings_category_Media": "Media",
"$settings_category_Navigation": "Navigering",
"$settings_category_Browse": "Leit",
"$settings_category_Script": "Skript",
"$settings_category_Login": "Innlogging",
"$settings_category_Newly Added": "Nytt",
"$settings_experimental_suffix": "[UNDER UTRPROVING]",
"$settings_CSSadd": "Skriv CSS til profilen din. Andre med skriptet vil sjå dette.",
"$settings_CSSlinkTip": "(Du kan og nytta ei lenkje til ei CSS-fil)",
"$settings_notificationDotColour": "Meldingsdottfargar",
"$setting_MALserial": "Publiseringsinfo frå MAL",
"$setting_MALscore": "Snittvurdering frå MAL",
"$setting_MALrecs": "Tildrådingar frå MAL",
"$setting_reinaDark": "Lett til eit mørkt kontrastfargetema [av Reina]",
"$setting_CSSmobileTags": "Ikkje skjul emner på mobilsida",
"$setting_infoTable": "Bruk dobbel kolonne for infoboksen på mediasider",
"$cssTooBig": "Meir enn 1MB CSS. Gjer det mindre, eller nytt ei lenkje.",
"$jsonTooBig": "Profil-JSON er over 1MB",
"$settings_errorInvalidJSON": "Ugyldig profil-JSON",
"$noScrollPosts_description": "Ikkje kort ned tekstpostar, uansett kor lange dei er",
"$notImplemented": "Ikkje implementert",
"$socialTabFeed_noActivities": "Ingen treff",
"$rewatch_suffix_1": "[sett oppatt]",
"$reread_suffix_1": "[lese oppatt]",
"$reread_suffix_M": "[oppattlesing {0}]",
"$settings_partialLocalisationLanguage_description": "Automailspråk",
"$additionalTranslation_description": "Omset meir av Anilist",
"$button_newChapters": "Nye Kapittel",
"$stats_anime_heading": "Animestatistikk for {0}",
"$stats_manga_heading": "Mangastatistikk for {0}",
"$stats_moreStats_title": "Meir Statistikk",
"$stats_genresTags_title": "Sjangrar & Emne",
"$stats_genre": "Sjanger",
"$stats_tag": "Emne",
"$stats_count": "Tal",
"$stats_name": "Namn",
"$stats_globalDifference": "Global skilnad: ",
"$stats_globalDeviation": "Globalt avvik: ",
"$stats_siteStats_title": "Sidestatistikk",
"$stats_averageScore": "Gjennomsnitt: ",
"$stats_weightComment_duration": " (vekta etter lengd)",
"$stats_weightComment_chapers": " (vekta etter lengd i kapittel)",
"$stats_medianScore": "Median: ",
"$stats_mostCommonScore": "Mest vanleg: ",
"$stats_ratingEntropy": "Entropi: ",
"$stats_ratingEntropy_comment": " bit/vurdering (større tal = meir finkorna. Vanlegvis mellom 1 - 6)",
"$stats_firstLoggedAnime": "Fyrste anime: ",
"$stats_firstLoggedAnime_note": "(folk kan fritt endra datoen)",
"$staff_filterHelp": "Filterhjelp",
"$stats_loadingAnime": "lastar animelista...",
"$stats_loadingManga": "lastar mangalista...",
"$stats_instances": "({0} gongar)",
"$stats_longestTime": "{0}% er {1}",
"$stats_totalChapters": "Kapittel: ",
"$stats_totalVolumes": "Band: ",
"$stats_varousStats_heading": "Anna statistikk",
"$stats_longest_watching": "Ser no.",
"$stats_longest_paused": "Stogga.",
"$stats_longest_dropped": "Droppa.",
"$stats_longest_1rewatch": "Sett to gongar.",
"$stats_longest_2rewatch": "Sett tre gongar.",
"$stats_longest_Mrewatch": "Sett på nytt {0} gongar.",
"$stats_longest_1rewatching": "Ser oppatt for fyrste gong.",
"$stats_longest_2rewatching": "Ser oppatt for andre gong.",
"$stats_longest_Mrewatching": "Ser oppatt gong nummer {0}.",
"$stats_longest_1rewatchPaused": "Fyrste oppattsjåing stogga.",
"$stats_longest_2rewatchPaused": "Andre oppattsjåing stogga.",
"$stats_longest_MrewatchPaused": "Oppattsjåing {0} stogga.",
"$stats_instances_unique": "ingen like",
"$stats_onlyOne": "Berre ei vurdering: ",
"$stats_TVEpisodesWatched": "TV-episodar sett: ",
"$stats_TVEpisodesRemaining": "TV-episodar som står att: ",
"$stats_animeOnList": "Anime på lista: ",
"$stats_mangaOnList": "Manga på lista: ",
"$stats_animeRated": "Anime med vurdering: ",
"$stats_mangaRated": "Manga med vurdering: ",
"$stats_meanScore": "Snitt",
"$stats_customTagsAnime": "Eigne Animeemner",
"$stats_customTagsManga": "Custom Mangaemner",
"$stats_chapters": "Chapters",
"$stats_volumes": "Volumes",
"$scanning": "Leitar...",
"$heading_similarFavs": "Like favorittar:",
"$socialTab_tooManyChapters": "Talet i databasen har nok endra seg",
"$socialTab_shortAverage": "Snitt",
"$socialTab_users": "Fylgjer",
"$profileBackground_help1": "Lag ein profilbakgrunn, døme:",
"$profileBackground_help2": "Tips: Bruk ein gjennomsiktig farge, så han fungerer for både det ljose og mørke fargetemaet. Døme:",
"$profileBackground_help3": "Tips2: Fast heildekkjande bilete med falmande gradient:",
"$MAL_score": "MAL-vurdering",
"$MAL_serialization": "Blad",
"$filters": "Filter",
"$filters_lists": "Lister",
"$filters_year": "År",
"$markdown_help_links_header": "Lenkjer",
"$markdown_help_imageSize": "Endra storleik:",
"$markdown_help_imageUpload": "(du må lasta opp biletet ein anna stad for å få ein link)",
"$markdown_help_formatting_header": "Formatering",
"$stats_timeWatched": "Tid sett: ",
"$setting_notifications": "Betre meldingssystem",
"$adjustColours_title": "Fargejustering",
"$settings_import": "Importer innstillingar:",
"$setting_moreStats": "Legg til ei ekstra fane på statistikksida",
"$setting_compare": "Betre listesamanlikning",
"$compare_listStatus": "kva status som helst\nklikk for å endra",
"$compare_normalizeRatings": "Normalisert skala:",
"$heading_anime": "Anime:",
"$heading_manga": "Manga:",
"$submenu_stats": "Statistikk",
"$submenu_anime": "Anime",
"$submenu_manga": "Manga",
"$mainMenu_notifications": "Meldingar",
"$mainMenu_profile": "Profil",
"$mainMenu_settings": "Innstillingar",
"$mediaStaff_filter": "Filtrer",
"$dblclickZoom_description": "Dobbelklikk ein post for å zooma",
"$relations_shared_following": "De fylgjer begge",
"$relations_shared_followers": "Fylgjer dykk begge",
"$compare_individualRatings": "Eigen skala:",
"$notification_likeActivity_1person_1activity": " likte posten din.",
"$notification_likeActivity_1person_Mactivity": " likte postane dine.",
"$notification_likeActivity_2person_1activity": " likte posten din.",
"$notification_likeActivity_2person_Mactivity": " likte postane dine.",
"$notification_likeActivity_Mperson_1activity": " likte posten din.",
"$notification_likeActivity_Mperson_Mactivity": " likte postane dine.",
"$notification_likeReply_1person_1reply": " likte svaret ditt.",
"$notification_likeReply_1person_Mreply": " likte svara dine.",
"$notification_likeReply_2person_1reply": " likte svaret ditt.",
"$notification_likeReply_2person_Mreply": " likte svara dine.",
"$notification_likeReply_Mperson_1reply": " likte svaret ditt.",
"$notification_likeReply_Mperson_Mreply": " likte svara dine.",
"$notification_reply_1person_1reply": " svarte på posten din.",
"$notification_reply_1person_Mreply": " svarte på postane dine.",
"$notification_reply_2person_1reply": " svarte på posten din.",
"$notification_reply_2person_Mreply": " svarte på postane dine.",
"$notification_reply_Mperson_1reply": " svarte på posten din.",
"$notification_reply_Mperson_Mreply": " svarte på postane dine.",
"$notification_replyReply_1person_1reply": " svarte på ein tinga post.",
"$notification_newMedia": "vart nyleg lagt til.",
"$notification_airing": "Episode {0} av {1} sendt.",
"$notification_message": " sende deg ei melding.",
"$notification_mention": " nemde deg.",
"$notification_forumCommentLike": " likte kommentaren din, i forumtråden ",
"$notification_forumMention": " nemde deg, i forumtråden ",
"$notification_follow": " fylgjer deg.",
"$notifications_button_reset": "Merk alt som lese",
"$notifications_showHoh": "Vis hoh-meldingsstraum",
"$notifications_showDefault": "Vis vanleg meldingsstraum",
"$notifications_comments": "svar",
"$notifications_softBlock": "Mjukblokk",
"$notifications_hideLike": "Skjul alle 'likte […]'",
"$setting_CSSgreenManga": "Grøne mangatitlar",
"$mediaStatus_reading": "les",
"$mediaStatus_watching": "ser",
"$mediaStatus_dropped": "droppa",
"$mediaStatus_planning": "planlegg",
"$mediaStatus_paused": "stogga",
"$mediaStatus_completed": "ferdig",
"$mediaStatus_completedWatching": "ferdig",
"$mediaStatus_completedReading": "ferdig",
"$mediaStatus_current": "på gang",
"$mediaStatus_repeating": "på nytt",
"$mediaStatus_rewatching": "ser oppatt",
"$mediaStatus_rereading": "les oppatt",
"$mediaStatus_planning_time": "planla {0}",
"$mediaReleaseStatus_finished": "Ferdig",
"$mediaReleaseStatus_notYetReleased": "Komande",
"$mediaReleaseStatusManga_notYetReleased": "Komande",
"$mediaReleaseStatusAnime_notYetReleased": "Komande",
"$listActivity_MreadChapter": "las kapittel {0} av ",
"$listActivity_MwatchedEpisode": "såg episode {0} av ",
"$listActivity_MrepeatingManga": "las oppatt kapittel {0} av ",
"$listActivity_MrepeatingAnime": "såg oppatt episode {0} av ",
"$listActivity_MreadChapter_known": "las kapittel {0}",
"$listActivity_MwatchedEpisode_known": "såg episode {0}",
"$listActivity_MrepeatingManga_known": "las oppatt kapittel {0}",
"$listActivity_MrepeatingAnime_known": "såg oppatt episode {0}",
"$listActivity_completedManga": "las ferdig ",
"$listActivity_completedAnime": "såg ferdig ",
"$listActivity_completedManga_known": "las ferdig",
"$listActivity_completedAnime_known": "såg ferdig",
"$listActivity_droppedManga": "droppa ",
"$listActivity_droppedAnime": "droppa ",
"$listActivity_droppedManga_known": "droppa",
"$listActivity_droppedAnime_known": "droppa",
"$listActivity_MdroppedManga": "droppa {0} av ",
"$listActivity_MdroppedAnime": "droppa {0} av ",
"$listActivity_MdroppedManga_known": "droppa {0}",
"$listActivity_MdroppedAnime_known": "droppa {0}",
"$listActivity_planningManga": "vil lesa ",
"$listActivity_planningAnime": "vil sjå ",
"$listActivity_planningManga_known": "vil lesa",
"$listActivity_planningAnime_known": "vil sjå",
"$listActivity_repeatedManga": "las oppatt ",
"$listActivity_repeatedAnime": "såg oppatt ",
"$listActivity_repeatedManga_known": "las oppatt",
"$listActivity_repeatedAnime_known": "såg oppatt",
"$listActivity_pausedManga": "stoppa lesa ",
"$listActivity_pausedAnime": "stoppa sjå ",
"$listActivity_pausedManga_known": "stoppa lesa",
"$listActivity_pausedAnime_known": "stoppa sjå",
"$preview_1behind": "1 episode bakpå",
"$preview_Mbehind": "{0} episodar bakpå",
"$preview_progress": "Framgang:",
"$settings_pinnedActivity": "Fest ein post til profilstraumen din",
"$settings_errorInvalidActivity": "må vera ei lenkje til posten, eller ein ID",
"$settings_errorInvalidActivity2": "fann ikkje posten!",
"$menu_home": "heim",
"$menu_profile": "profil",
"$menu_animelist": "Animeliste",
"$menu_mangalist": "Mangaliste",
"$menu_browse": "leit",
"$menu_forum": "forum",
"$submenu_social": "Sosialt",
"$submenu_favourites": "Favorittar",
"$submenu_submissions": "Database",
"$submenu_staff": "Roller",
"$submenu_reviews": "Omtalar",
"$submenu_characters": "Karakterar",
"$submenu_recommendations": "Tilrådingar",
"$reviewLike_tooltip": "{0} av {1} likte omtalen",
"$review_reviewTitle": "Omtale av {0} -\u00a0{1}",
"$documentTitle_appSettings": "App & Automailinnstillingar · AniList",
"$documentTitle_home": "Heim · AniList",
"$documentTitle_notifications": "Meldingar · AniList",
"$documentTitle_forum": "Forum - Anime- & Mangadiskusjon · AniList",
"$documentTitle_forum_prefix": "Forum",
"$404_private_or_noUser": "{0} finst ikkje eller har ein privat profil",
"$404_private": "{0} har ein privat profil",
"$404_noUser": "{0} finst ikkje",
"$404_blocked": "{0} har blokka deg",
"$preview_animeSection_title": "Anime på gang",
"$preview_mangaSection_title": "Manga på gang",
"$preview_airingSection_title": "På Lufta",
"$forum_preview_reply": "svarte ",
"$module_unicodifier_description": "Gjer om emojiar automatisk så dei fungerer på anilist",
"$timeline_title": "Tidslinje",
"$input_user_placeholder": "Namn",
"$error_userNotFound": "Fann ikkje brukarnamnet",
"$timeline_search_description": "Ser du etter ein anna person?",
"$recs_forYou": "For Deg",
"$recs_description": "Kvart par er noko du liker + noko du ikkje har sett enno\nBest fyrst",
"$mobileFriendly_description": "Mobiljusteringar. Gjer naudsynte endringar for at skriptet skal virka greit på telefonar",
"$ALbuttonReload_description": "Gjer at 'AL'-logoen lastar oppatt straumen på hovudsida",
"$markdown_help_description": "Legg til formateringshjelp i nedre venstre hjørne",
"$markdown_help_title": "Formateringshjelp",
"$markdown_help_images_header": "Bilete",
"$markdown_help_infixOr": "eller",
"$navigation_profileLink": "Profilen til {0}",
"$filter_replies": "Med svar",
"$filter_following": "Fylgjer",
"$staff_sort": "Sorter",
"$staff_filter_placeholder": "Filtrer etter tittel, rolle, osb.",
"$sort_alphabetical": "Alfabetisk",
"$sort_newest": "Nytt",
"$sort_oldest": "Gamalt",
"$sort_myProgress": "Min Framgang",
"$sort_length": "Lengd",
"$sort_myScore": "Mi Vurdering",
"$sort_score": "Vurderingar",
"$sort_popularity": "Popularitet",
"$download_banner_tooltip": "Last ned bakgrunnsbilete",
"$piracy_message": "TEIT LENKJE, BORT MED HO! OwO (klikk på 'report'-knappen for å varsla moderatorane)",
"$updates_noNewManga": "Fann ikkje noko nytt :(",
"$twoColumnFeed_description": "Del heimestraumen i to kolonnar",
"$compare_colourCell": "Farg heile ruta:",
"$compare_default": "Sjå den vanlege samanlikninga",
"$compare_hoh": "Sjå hoh-samanlikninga",
"$colour_transparent": "Blank",
"$colour_blue": "Blå",
"$colour_white": "Kvit",
"$colour_black": "Svart",
"$colour_red": "Rau",
"$colour_peach": "Pære",
"$colour_orange": "Branngul",
"$colour_yellow": "Gul",
"$colour_green": "Grøn",
"$terms_description": "Lag ein reservestraum for trege nettverk hjå https://anilist.co/terms",
"$terms_privacyPolicy": "Vis personvernerklæringa",
"$setting_CSSbannerShadow": "Fjern skuggen under bakgrunnsbileta",
"$settings_button_export": "Last ned innstillingane",
"$settings_export_description": "Kjekt å ha ein tryggingskopi. Viss du slettar cache/cookies kan Automailinnstillingane også bli borte",
"$error_connection": "Koplingsfeil",
"$hideGlobalFeed_description": "Skjul globalstraumen",
"$terms_option_global": "Global",
"$terms_option_text": "Tekst",
"$terms_option_reviews": "Omtalar",
"$terms_option_user": "Namn",
"$terms_option_replies": "Med svar",
"$terms_option_forum": "Forum",
"$terms_option_media": "Media",
"$noResults": "Ingen treff",
"$query_firstActivity": "Fyrste post",
"$query_autorecs": "Autotilråingar",
"$query_autorecs_collecting": "Skaffar listedata...",
"$query_autorecs_processing": "Reknar...",
"$staff_animeRoles": "Animeroller",
"$staff_mangaRoles": "Mangaroller",
"$staff_voiceRoles": "Røyster",
"$staff_hoursWatched": "timar sett: ",
"$staff_chaptersRead": " kapittel lese: ",
"$staff_volumesRead": " band lese: ",
"$staff_meanScore": " snittvurdering: ",
"$milestones_totalVolumes": "Band",
"$milestones_totalEpisodes": "Episodar",
"$milestones_daysWatched": "{0} dagar sett",
"$milestones_chaptersRead": "{0} kapittel lese",
"$characterBrowseTooltip": "Favorittar",
"$make3x3": "Lag 3x3",
"$make3x3_title": "Klikk knappen, og så 9 ting på lista",
"$myThreads_link": "Mine Trådar",
"$forumHeading_recentlyActive": "Aktive Trådar",
"$forumHeading_newThreads": "Nye Trådar",
"$forumHeading_releaseDiscussion": "Episodediskusjonar",
"$footer_siteTheme": "Fargetema",
"$footer_addData": "Bidra med data",
"$footer_moderators": "Moderatorar",
"$footer_contact": "Kontakt",
"$footer_terms": "Vilkår og Personvern",
"$footer_siteMap": "Sidekart",
"$theme_default": "Lyst",
"$theme_dark": "Mørkt",
"$theme_highContrast": "Kontrast",
"$theme_highContrastDark": "Mørk Kontrast",
"$home_reviewLink": "Omtalar",
"$home_forumLink": "Forum",
"$home_trendingAnime": "Populære Anime",
"$home_trendingManga": " & Manga",
"$home_newAnime": "Ny Anime",
"$home_newManga": "Ny Manga",
"$setting_CSSsmileyScore": "Fargelegg smilefjesvurderingar",
"$feed_header": "Straum",
"$feedSelect_all": "Alt",
"$feedSelect_text": "Tekst",
"$feedSelect_list": "Liste",
"$feedSelect_status": "Tekst",
"$feedSelect_message": "Meldingar",
"$setting_tweets": "Ta med lenkja twitterlenkjer i postar",
"$anisongs_openings": "Introar",
"$anisongs_opening": "Intro",
"$anisongs_endings": "Utroar",
"$anisongs_ending": "Utro",
"$anisongs_noSongs": "Ingen songar",
"$mediaFormat_TV" : "TV",
"$mediaFormat_TV_SHORT" : "TV-snutt",
"$mediaFormat_MOVIE" : "Film",
"$mediaFormat_SPECIAL" : "Spesial",
"$mediaFormat_OVA" : "OVA",
"$mediaFormat_ONA" : "ONA",
"$mediaFormat_MUSIC" : "Musikk",
"$mediaFormat_MANGA" : "Manga",
"$mediaFormat_NOVEL" : "Lettroman",
"$mediaFormat_ONE_SHOT" : "Enkeltvis",
"$forumCategory_1": "Anime",
"$forumCategory_2": "Manga",
"$forumCategory_3": "Lettromanar",
"$forumCategory_4": "Animespel",
"$forumCategory_5": "Slippdiskusjon",
"$forumCategory_7": "Generelt",
"$forumCategory_8": "Nyheiter",
"$forumCategory_9": "Musikk",
"$forumCategory_10": "Spel",
"$forumCategory_11": "Tilbakemeldingar",
"$forumCategory_12": "Feil",
"$forumCategory_13": "Kunngjeringar",
"$forumCategory_14": "Listetilpassing",
"$forumCategory_15": "Tilrådingar",
"$forumCategory_16": "Forumleik",
"$forumCategory_17": "Diverse",
"$forumCategory_18": "Program og Utvidingar",
"$forumMedia_backlink": "Legg til ei lenkje til databasen på forumstraumen til eit verk",
"$debug_tip": "(Legg ved denne fila når du melder frå om feil)",
"$menu_overview": "Oversyn",

"$role_Original Creator": "Skapar",
"$role_Creator": "Skapar",
"$role_Music": "Musikk",
"$role_Key Animation": "Teiknar",
"$role_Key Animation Assistance": "Teiknehjelp",
"$role_In-Between Animation": "Mellomteiknar",
"$role_Animator": "Teiknar",
"$role_Animation": "Teiknar",
"$role_Main Animator": "Hovudteiknar",
"$role_Opening Animation": "Opningsteiknar",
"$role_Art": "Teiknar",
"$role_Illustration": "Teikningar",
"$role_End Card": "Sluttkort",
"$role_End card": "Sluttkort",
"$role_Original Concept": "Idé",
"$role_Story Concept": "Idé",
"$role_Original Story": "Skapar",
"$role_Story": "Forfattar",
"$role_Official Writer": "Forfattar",
"$role_Story & Art": "Forfattar og Teiknar",
"$role_Director": "Regi",
"$role_CG Director": "CG Regi",
"$role_Character Design": "Karakterutsjånad",
"$role_Original Character Design": "Opphaveleg Karakterutsjånad",
"$role_Animation Director": "Animasjonsregi",
"$role_Assistant Episode Director": "Assisterande Episoderegi",
"$role_Assistant Animation Director": "Assisterande Animasjonsregi",
"$role_Assistant Director": "Assisterande Regi",
"$role_Chief Animation Director": "Leiar Animasjonsregi",
"$role_Episode Director": "Episoderegi",
"$role_Sound Director": "Lydregi",
"$role_Chief Director": "Hovudregi",
"$role_Unit Director": "Einingsregi",
"$role_Art Director": "Illustrasjonsregi",
"$role_Art Design": "Illustrasjonsdesign",
"$role_Chief Unit Director": "Leiar Einingsregi",
"$role_Planning Producer": "Planprodusent",
"$role_Producer": "Produsent",
"$role_Co-Producer": "Produsent",
"$role_Production Coordination": "Samkøyring",
"$role_Production Generalization": "Samkøyring",
"$role_Executive Director": "Ansvarleg Regi",
"$role_Executive Producer": "Ansvarleg Produsent",
"$role_Animation Producer": "Animasjonsprodusent",
"$role_Creative Producer": "Kreativ Produsent",
"$role_Production Assistant": "Produksjonshjelp",
"$role_Production Assistance": "Produksjonshjelp",
"$role_Photography Assistance": "Fotografihjelp",
"$role_Director of Photography": "Fotoregi",
"$role_Photography": "Foto",
"$role_Camera": "Kamera",
"$role_Advertising": "Reklame",
"$role_Finishing": "Finpuss",
"$role_Recording": "Lydopptak",
"$role_Recording Assistant": "Lydopptaksassistent",
"$role_Dialogue Recording": "Replikklydopptak",
"$role_3D Works": "3D-arbeid",
"$role_CG Animation": "Datagrafikk",
"$role_Color Design": "Farge",
"$role_Color Coordination": "Fargehandsaming",
"$role_Insert Song Lyrics": "Songtekst",
"$role_Theme Song Lyrics": "Songtekst",
"$role_Theme Song Composition": "Songskriving",
"$role_Theme Song Performance": "Song",
"$role_Theme Song Arrangement": "Songarrangement",
"$role_Music Piano Performance": "Piano",
"$role_Conductor": "Dirigent",
"$role_Special Thanks": "Takk",
"$role_Material Texture": "Tekstur",
"$role_Original Plan": "Plan",
"$role_Editing": "Klipp",
"$role_PV Production": "Førehandsvisning",
"$role_Title Design": "Logo",
"$role_Title Logo Design": "Logo",
"$role_Visual Effects": "Spesialeffektar",
"$role_Digital Effects": "Digitale effektar",
"$role_Prop Design": "Våpendesign",
"$role_Firearms Design": "Rekvisittdesign",
"$role_ADR Script": "Dubbeskript",
"$role_ADR Scriptwriter": "Dubbeskript",
"$role_ADR Script Adaptation": "Dubbetilpassing",
"$role_Layout": "Bladbunad",
"$role_Layout Composition": "Bladbunad",
"$role_Endcard": "Postkort",
"$role_Scene Design": "Omgjevnad",
"$role_Mechanical Design": "Mekanisk Design",
"$role_Background Art": "Bakgrunn",
"$role_In-Betweens Check": "Teiknesjekk",
"$role_Animation Check": "Teiknesjekk",
"$role_Series Composition": "Samansetjing",
"$role_Animation Supervisor": "Teikneoversyn",
"$role_Supervisor": "Oversyn",
"$role_Supervision": "Oversyn",
"$role_Planning": "Planlegging",
"$role_Title": "Tittel",
"$role_Script": "Skript",
"$role_Screenplay": "Manus",
"$role_Setting": "Sett",
"$role_Storyboard": "Dreiebok",
"$role_Translator": "Omsetjar",
"$role_Assistant": "Assistent",
"$role_Main": "Hovudrolle",
"$role_Supporting": "Siderolle",
"$role_Background": "Bakgrunnsrolle"
	}
}
,
	"Svenska": {
	"info": {
		"language": "Svenska",
		"language_english": "Swedish",
		"locale": "sv-SE",
		"fallback": ["Norsk","English"],
		"maintainer": "no maintainer",
		"maintainer_link": "",
		"discussion_link": "",
		"notes": ""
	},
	"keys": {
"$settings_homepage": "Hemesida: ",
"$settings_repository": "Källkod: ",
"$button_search": "Sök",
"$language_English": "engelska",
"$language_German": "tyska",
"$language_Italian": "italienska",
"$language_Spanish": "spanska",
"$language_French": "franska",
"$language_Korean": "koreanska",
"$language_Portuguese": "portugisiska",
"$language_Hebrew": "hebreiska",
"$language_Hungarian": "ungerska",
"$language_Chinese": "kinesiska",
"$language_Japanese": "japanska",
"$language_Arabic": "arabiska",
"$language_Filipino": "filipino",
"$language_Catalan": "katalanska",
"$language_Polish": "polska",
"$language_Norwegian": "norska",
"$mediaFormat_NOVEL": "Lättroman"
	}
}
,
	"English (US)": {
	"info": {
		"language": "English (US)",
		"language_english": "English (US)",
		"variation_of": "English",
		"locale": "en-US",
		"fallback": ["English"],
		"maintainer": "hoh",
		"maintainer_link": "https://anilist.co/user/hoh/",
		"discussion_link": "",
		"notes": "There's in general no need to translate all the keys, since the default fallback is English."
	},
	"keys": {
"$setting_CSSsmileyScore": "Give smiley ratings distinct colors",
"$profileBackground_help2": "Tip: Use a color with transparancy, to work better with both light and dark themes. Example:",
"$compare_colourCell": "Color entire cell:",
"$adjustColours_title": "Adjust Colors",
"$settings_notificationDotColour": "Notification Dot Colors",
"$statusBorder_description": "Color code the right border of activities by media status",
"$submenu_favourites": "Favorites",
"$characterBrowseTooltip": "Favorites",
"$MAL_serialization": "Serialization",
"$compare_normalizeRatings": "Normalize ratings:",
"$setting_MALserial": "Add MAL serialization info to manga",
"$forumCategory_14": "List Customization"
	}
}
,
	"English (short)": {
	"info": {
		"language": "English (short)",
		"language_english": "English (short)",
		"variation_of": "English",
		"locale": "en-UK",
		"fallback": [],
		"maintainer": "hoh",
		"maintainer_link": "https://anilist.co/user/hoh/",
		"discussion_link": "",
		"notes": "Less is more"
	},
	"keys": {
"$load_more": "More",
"$time_now": "Now",
"$time_1second": "1 second",
"$time_Msecond": "{0} seconds",
"$time_1minute": "1 minute",
"$time_Mminute": "{0} minutes",
"$time_1hour": "1 hour",
"$time_Mhour": "{0} hours",
"$time_1day": "1 day",
"$time_Mday": "{0} days",
"$time_1week": "1 week",
"$time_Mweek": "{0} weeks",
"$time_1month": "1 month",
"$time_Mmonth": "{0} months",
"$time_1year": "1 year",
"$time_Myear": "{0} years",
"$default_filename": "Anilist file",
"$page": "{0}",
"$dubMarker_notice": "{0} dub",
"$button_next": "→",
"$button_previous": "←",
"$placeholder_status": "status",
"$placeholder_reply": "reply",
"$placeholder_message": "message",
"$placeholder_forum": "forum post",
"$forumMedia_backlink": "Link to media from forum category",
"$notImplemented": "not implemented",
"$settings_moreInfo_tooltip": "More",
"$settings_category_Newly Added": "New",
"$settings_export_description": " ",
"$settings_CSSadd": "Custom CSS for rofile.",
"$settings_CSSlinkTip": "(stylesheet links allowed)",
"$settings_pinnedActivity": "Pin activity",
"$setting_moreStats": "More stats",
"$setting_compare": "Replace comparison feature",
"$setting_CSSsmileyScore": "Smiley rating colours",
"$setting_tweets": "Embed tweets",
"$setting_CSSgreenManga": "Green manga",
"$setting_CSSbannerShadow": "No banner shadows",
"$setting_CSSmobileTags": "Mobile tags",
"$setting_infoTable": "Two-column media info",
"$setting_reinaDark": "High Contrast Dark [by Reina]",
"$setting_MALserial": "MAL serialisation info",
"$setting_MALscore": "AL scores",
"$setting_MALrecs": "MAL recs",
"$cssTooBig": "Custom CSS is over 1MB.",
"$debug_tip": "(attach to bug reports)",
"$profileBackground_help1": "Profile background:",
"$profileBackground_help2": "Transparency:",
"$profileBackground_help3": "More complex example:",
"$listActivity_MreadChapter": "read {0} of ",
"$listActivity_MwatchedEpisode": "watched {0} of ",
"$listActivity_planningManga": "plans ",
"$listActivity_planningAnime": "plans ",
"$listActivity_MrepeatingManga": "reread {0} of ",
"$listActivity_MrepeatingAnime": "rewatched {0} of ",
"$notification_replyReply_1person_1reply": " replied to subscribed activity.",
"$notification_newMedia": "added to the site.",
"$notification_message": " sent a message.",
"$notification_mention": " mentioned you.",
"$notification_follow": " follows you.",
"$notification_forumCommentLike": " liked your comment, in the thread ",
"$notification_forumMention": " mentioned you, in the thread ",
"$notifications_softBlock": "Soft block",
"$notifications_hideLike": "Hide likes",
"$notifications_button_reset": "Read all",
"$preview_animeSection_title": "Anime",
"$preview_mangaSection_title": "Manga",
"$preview_progress": " ",
"$mediaReleaseStatus_notYetReleased": "Not Released",
"$publishingReply": "Publishing...",
"$menu_animelist": "anime",
"$menu_mangalist": "manga",
"$timeline_search_description": "User search",
"$noScrollPosts_description": "Display all status posts in full",
"$compare_default": "default compare",
"$compare_hoh": "hoh compare",
"$download_banner_tooltip": "Download",
"$reviewLike_tooltip": "{0} of {1}",
"$updates_noNewManga": "None found :(",
"$additionalTranslation_description": "Translate more of Anilist",
"$twoColumnFeed_description": "Two column home feed",
"$adjustColours_title": "Colours",
"$stats_averageScore": "Average: ",
"$stats_medianScore": "Median: ",
"$stats_ratingEntropy": "Entropy: ",
"$stats_mostCommonScore": "Most common: ",
"$stats_timeWatched": "Time: ",
"$stats_totalChapters": "Chapters: ",
"$stats_totalVolumes": "Volumes: ",
"$stats_TVEpisodesWatched": "TV episodes: ",
"$stats_TVEpisodesRemaining": "TV episodes remaining: ",
"$stats_firstLoggedAnime_note": " ",
"$stats_ratingEntropy_comment": " bits/rating",
"$stats_loadingAnime": "loading anime...",
"$stats_loadingManga": "loading manga...",
"$stats_longest_watching": "Watching.",
"$make3x3": "3x3",
"$staff_hoursWatched": "Hours: ",
"$staff_chaptersRead": " Chapters: ",
"$staff_volumesRead": " Volumes: ",
"$milestones_totalVolumes": "Volumes",
"$milestones_totalEpisodes": "Episodes",
"$milestones_daysWatched": "{0} Days",
"$milestones_chaptersRead": "{0} Chapters",
"$terms_description": "Add a low bandwidth feed to https://anilist.co/terms",
"$terms_privacyPolicy": "Privacy Policy",
"$terms_option_text": "Text",
"$terms_option_replies": "Replies",
"$staff_animeRoles": "Anime Roles",
"$staff_mangaRoles": "Manga Roles",
"$staff_voiceRoles": "Voice Roles",
"$forumHeading_recentlyActive": "Active Threads",
"$forumHeading_releaseDiscussion": "Release Threads",
"$forumHeading_newThreads": "New Threads",
"$home_reviewLink": "Reviews",
"$home_forumLink": "Forum",
"$home_newAnime": "New Anime",
"$home_newManga": "New Manga",
"$footer_siteTheme": "Theme",
"$theme_highContrast": "Contrast",
"$theme_highContrastDark": "Contrast Dark",
"$feedSelect_text": "Text",
"$feedSelect_list": "List",
"$forumCategory_5": "Release",
"$forumCategory_11": "Feedback",
"$forumCategory_12": "Bugs",
"$forumCategory_13": "Announcements",
"$forumCategory_18": "Apps",
"$forum_singleThread": "View thread"
	}
}
,
	"Español": {
	"info": {
		"language": "Español",
		"language_english": "Spanish",
		"locale": "es",
		"fallback": ["English"],
		"maintainer": "MrJako2001",
		"maintainer_link": "https://anilist.co/user/MrJaco/",
		"discussion_link": "https://github.com/hohMiyazawa/Automail/issues/69",
		"notes": "",
		"translators": ["MrJako2001"]
	},
	"keys": {
"$meta_scriptDescription": "Partes extra para Anilist.co",
"$loading": "Cargando...",
"$searching": "Buscando...",
"$load_more": "Cargar más",
"$time_now": "Ahora",
"$time_1second": "Hace 1 segundo",
"$time_Msecond": "Hace {0} segundos",
"$time_1minute": "Hace 1 minuto",
"$time_Mminute": "Hace {0} minutos",
"$time_1hour": "Hace 1 hora",
"$time_Mhour": "Hace {0} horas",
"$time_1day": "Hace 1 día",
"$time_Mday": "Hace {0} días",
"$time_1week": "Hace 1 semana",
"$time_Mweek": "Hace {0} semanas",
"$time_1month": "Hace 1 mes",
"$time_Mmonth": "Hace {0} meses",
"$time_1year": "Hace 1 año",
"$time_Myear": "Hace {0} años",
"$time_medium_Mday": "días",
"$time_short_second": "s",
"$time_short_minute": "min",
"$time_short_hour": "h",
"$time_short_day": "d",
"$time_short_week": "sem",
"$time_short_month": "mes",
"$time_short_year": "a",
"$time_medium_second": "segundo",
"$time_medium_minute": "minuto",
"$time_medium_hour": "hora",
"$time_medium_day": "día",
"$time_medium_week": "semana",
"$time_medium_month": "mes",
"$time_medium_year": "año",
"$time_medium_Msecond": "segundos",
"$time_medium_Mminute": "minutos",
"$time_medium_Mhour": "horas",
"$time_medium_Mweek": "semanas",
"$time_medium_Mmonth": "meses",
"$time_medium_Myear": "años",
"$language_English": "Inglés",
"$language_German": "German",
"$language_Italian": "Italiano",
"$language_Spanish": "Español",
"$language_French": "Francés",
"$language_Korean": "Koreano",
"$language_Portuguese": "Portugués",
"$language_Hebrew": "Hebreo",
"$language_Hungarian": "Húngaro",
"$language_Chinese": "Chino",
"$language_Japanese": "Japonés",
"$language_Arabic": "Árabe",
"$language_Filipino": "Filipino",
"$language_Catalan": "Catalán",
"$language_Polish": "Polaco",
"$language_Norwegian": "Noruego",
"$default_filename": "Archivo de Anilist.co",
"$generic_anime": "Anime",
"$generic_manga": "Manga",
"$page": "Página {0}",
"$dubMarker_notice": "{0} doblajes disponibles",
"$button_submit": "Enviar",
"$button_search": "Buscar",
"$button_run": "Ejecutar",
"$button_add": "Añadir",
"$button_reset": "Restablecer",
"$button_resetAll": "Restablecer todo",
"$button_defaultSettings": "Configuración predeterminada",
"$missing_N/A_data": "...",
"$button_next": "Siguente →",
"$button_previous": "← Anterior",
"$button_refresh": "Actualizar",
"$button_edit": "Editar",
"$button_publish": "Publicar",
"$button_cancel": "Cancelar",
"$placeholder_status": "Escribe un estado...",
"$placeholder_reply": "Escribe una respuesta...",
"$placeholder_message": "Escribe un mensaje...",
"$placeholder_forum": "Escribe un mensaje en el foro...",
"$forumMedia_backlink": "Incluir un enlace a la página de la base de datos en el feed de su foro",
"$settings_title": "Configuración de Automail",
"$notImplemented": "Lo siento, se implementará en el futuro",
"$settings_version": "Versión: ",
"$settings_homepage": "Página: ",
"$settings_repository": "Repositorio: ",
"$settings_moreInfo_tooltip": "Más información",
"$settings_category_Notifications": "Notificaciones",
"$settings_category_Feeds": "Feeds",
"$settings_category_Forum": "Foro",
"$settings_category_Lists": "Listas",
"$settings_category_Profiles": "Perfiles",
"$settings_category_Stats": "Estadísticas",
"$settings_category_Media": "Media",
"$settings_category_Navigation": "Navegación",
"$settings_category_Browse": "Explorar",
"$settings_category_Script": "Script",
"$settings_category_Login": "Iniciar sesión",
"$settings_category_Newly Added": "Recien añadido",
"$settings_button_export": "Exportar",
"$settings_export_description": "Puede ser útil tener una copia de seguridad si haces cosas como borrar la caché/almacenamiento de tu navegador, que también borrará la configuración de Automail",
"$settings_import": "Importar",
"$settings_experimental_suffix": "[EXPERIMENTAL]",
"$settings_partialLocalisationLanguage_description": "Idioma de Automail",
"$settings_CSSadd": "Permite añadir código CSS personalizado a tu perfil. Esto será visible para otros con el script.",
"$settings_CSSlinkTip": "(También puedes usar un enlace directo)",
"$settings_pinnedActivity": "Fijar una actividad en tu perfil",
"$settings_notificationDotColour": "Colores de los puntos de notificación",
"$setting_notifications": "Notificaciones mejoradas",
"$setting_moreStats": "Mostrar una pestaña adicional en estadísticas",
"$setting_compare": "Sustituir la función de comparación nativa",
"$setting_CSSsmileyScore": "Dar colores distintos a clasificaciones con \"smileys\"",
"$setting_tweets": "Incrustar tuits enlazados",
"$setting_CSSgreenManga": "Títulos de color verde para manga",
"$setting_CSSbannerShadow": "Remover sombras de los banners",
"$setting_CSSmobileTags": "No ocultar votación etiquetas de las páginas de los anime/manga en dispositivos móviles",
"$setting_infoTable": "Utilizar un diseño de dos columnas para la información en las páginas de anime/manga",
"$setting_reinaDark": "Añadir un tema oscuro de alto contraste [cortesía de Reina]",
"$setting_MALserial": "Añadir información de MAL sobre serialización al manga",
"$setting_MALscore": "Añadir calificaciones de MAL",
"$setting_MALrecs": "Añadir recomendaciones de MAL",
"$cssTooBig": "El código CSS pesa más de 1MB. Redúcelo o utiliza un enlace en su lugar.",
"$jsonTooBig": "El perfil JSON tiene más de 1 MB",
"$debug_tip": "(Sería bueno que incluyeras este archivo cuando reportes errores. Me hace la vida más fácil)",
"$profile_title": "Perfil de {0}",
"$profileBackground_help1": "Establecer un fondo de perfil, aquí tienes ejemplos:",
"$profileBackground_help2": "Sugerencia: Utiliza un color con transparencia, para que funcione mejor con los temas. Ejemplo:",
"$profileBackground_help3": "Sugerencia 2: ¿Quieres una imagen difuminada, que permanezca fija en su sitio y que llene la pantalla? Aquí esta como se hace:",
"$mediaStatus_not": "Agregar",
"$mediaStatus_current": "en curso",
"$mediaStatus_watching": "viendo",
"$mediaStatus_reading": "leyendo",
"$mediaStatus_completed": "completado",
"$mediaStatus_completedWatching": "completado",
"$mediaStatus_completedReading": "completado",
"$mediaStatus_repeating": "repitiendo",
"$mediaStatus_rewatching": "repitiendo",
"$mediaStatus_rereading": "Repitiendo",
"$mediaStatus_paused": "pausado",
"$mediaStatus_dropped": "abandonado",
"$mediaStatus_planning": "planeado",
"$mediaStatus_planning_time": "{0} planeados",
"$mediaReleaseStatus_finished": "Finalizado",
"$mediaReleaseStatus_releasing": "Emitiendo",
"$mediaReleaseStatus_notYetReleased": "Sin emitir",
"$mediaReleaseStatus_cancelled": "Cancelado",
"$mediaReleaseStatusManga_finished": "Finalizado",
"$mediaReleaseStatusManga_releasing": "Emitiendo",
"$mediaReleaseStatusManga_notYetReleased": "Sin emitir",
"$mediaReleaseStatusManga_cancelled": "Cancelado",
"$mediaReleaseStatusAnime_finished": "Finalizado",
"$mediaReleaseStatusAnime_releasing": "Emitiendo",
"$mediaReleaseStatusAnime_notYetReleased": "Sin emitir",
"$mediaReleaseStatusAnime_cancelled": "Cancelado",
"$listActivity_MreadChapter": "leyó {0} capítulos de ",
"$listActivity_MwatchedEpisode": "vió {0} episodios de ",
"$listActivity_MreadChapter_known": "leyó el capítulo {0}",
"$listActivity_MwatchedEpisode_known": "vió el episodio {0}",
"$listActivity_planningManga": "planeó ",
"$listActivity_planningAnime": "planeó ",
"$listActivity_planningManga_known": "planeó",
"$listActivity_planningAnime_known": "planeó",
"$listActivity_completedManga": "completó ",
"$listActivity_completedAnime": "completó ",
"$listActivity_completedManga_known": "completó",
"$listActivity_completedAnime_known": "completó",
"$listActivity_repeatedManga": "repitió ",
"$listActivity_repeatedAnime": "repitió ",
"$listActivity_repeatedManga_known": "repitió",
"$listActivity_repeatedAnime_known": "repitió",
"$listActivity_pausedManga": "pausó ",
"$listActivity_pausedAnime": "pausó ",
"$listActivity_pausedManga_known": "pausó",
"$listActivity_pausedAnime_known": "pausó",
"$listActivity_droppedManga": "abandonó ",
"$listActivity_droppedAnime": "abandonó ",
"$listActivity_droppedManga_known": "abandonó",
"$listActivity_droppedAnime_known": "abandonó",
"$listActivity_MdroppedManga": "abandonó {0} de ",
"$listActivity_MdroppedAnime": "abandonó {0} de ",
"$listActivity_MdroppedManga_known": "abandonó {0}",
"$listActivity_MdroppedAnime_known": "abandonó {0}",
"$listActivity_MrepeatingManga": "repitío {0} capítulos de ",
"$listActivity_MrepeatingAnime": "repitió {0} episodios de ",
"$listActivity_MrepeatingManga_known": "repitió el capítulo {0}",
"$listActivity_MrepeatingAnime_known": "repitió el episodio {0}",
"$notification_likeActivity_1person_1activity": " ha dado \"Me gusta\" a tu actividad",
"$notification_likeActivity_1person_Mactivity": " ha dado \"Me gusta\" a tus actividades",
"$notification_likeActivity_2person_1activity": " han dado \"Me gusta\" a tu actividad",
"$notification_likeActivity_2person_Mactivity": " han dado \"Me gusta\" a tus actividades",
"$notification_likeActivity_Mperson_1activity": " han dado \"Me gusta\" a tu actividad",
"$notification_likeActivity_Mperson_Mactivity": " han dado \"Me gusta\" a tus actividades",
"$notification_likeReply_1person_1reply": " ha dado \"Me gusta\" a tu respuesta",
"$notification_likeReply_1person_Mreply": " ha dado \"Me gusta\" a tus respuestas",
"$notification_likeReply_2person_1reply": " han dado \"Me gusta\" tu respuesta",
"$notification_likeReply_2person_Mreply": " han dado \"Me gusta\" a tus respuestas",
"$notification_likeReply_Mperson_1reply": " han dado \"Me gusta\" a tu respuesta",
"$notification_likeReply_Mperson_Mreply": " han dado \"Me gusta\" a tus respuestas",
"$notification_reply_1person_1reply": " respondió a tu actividad",
"$notification_reply_1person_Mreply": " respondió a tus actividades",
"$notification_reply_2person_1reply": " respondieron a tu actividad",
"$notification_reply_2person_Mreply": " respondieron a tus actividades",
"$notification_reply_Mperson_1reply": " respondieron a tu actividad",
"$notification_reply_Mperson_Mreply": " respondieron a tus actividades",
"$notification_replyReply_1person_1reply": " respondió la actividad a la estás suscrito",
"$notification_newMedia": "se ha añadido al sitio",
"$notification_airing": "Se emitió el episodio {0} de {1}",
"$notification_message": " te envió un mensaje",
"$notification_mention": " te mencionó en su actividad",
"$notification_follow": " comenzó a seguirte",
"$notification_forumCommentLike": " dio \"Me gusta\" a tu comentario, en el hilo del foro ",
"$notification_forumMention": " te mencionó en el hilo del foro ",
"$notifications_softBlock": "Softblock",
"$notifications_softBlock_description1": "Oculta las notificaciones de determinados usuarios. Una solución menos drástica que bloquearlos por completo (si eso es lo que realmente deseas, ve a su perfil y haz clic en la pequeña flecha hacia abajo junto al botón \"Seguir\").",
"$notifications_softBlock_description2": "Las notificaciones no han desaparecido, sólo están ocultas. La opción \"Mostrar notificaciones por defecto\" las hará visibles otra vez. Desbloquearlas también las devolverá. También te pueden interesar las secciones \"Colores de los puntos de notificación\" y \"Bloquear elementos en el feed de inicio\" en la página de configuración.",
"$notifications_softBlock_description3": "Los usuarios con Softblock seguirán apareciendo en las notificaciones agrupadas, dado que no se trata de spam adicional.",
"$notifications_hideLike": "Ocultar notificaciones de \"Me gusta\"",
"$notifications_showHoh": "Mostrar notificaciones Hoh",
"$notifications_showDefault": "Mostrar notificaciones nativas",
"$notifications_comments": "comentarios",
"$notifications_button_reset": "Marcar todo como leído",
"$documentTitle_notifications": "Notificaciones · AniList",
"$documentTitle_home": "Inicio · AniList",
"$documentTitle_forum": "Foro - Discusión de Anime y Manga · AniList",
"$documentTitle_forum_prefix": "Foro",
"$documentTitle_appSettings": "Apps y configuración de Automail · AniList",
"$preview_animeSection_title": "Anime en progreso",
"$preview_mangaSection_title": "Manga en progreso",
"$preview_airingSection_title": "En emisión",
"$preview_1behind": "1 episodio pendiente",
"$preview_Mbehind": "{0} episodios pendientes",
"$preview_progress": "Progreso:",
"$publishingReply": "Publicando respuesta...",
"$anisongs_noSongs": "No hay canciones para mostrar",
"$menu_home": "Inicio",
"$menu_profile": "Perfil",
"$menu_animelist": "Lista anime",
"$menu_mangalist": "Lista manga",
"$menu_browse": "Explorar",
"$menu_forum": "Foro",
"$menu_overview": "Resumen",
"$submenu_stats": "Estadísticas",
"$submenu_social": "Social",
"$submenu_reviews": "Reseñas",
"$submenu_favourites": "Favoritos",
"$submenu_submissions": "Propuestas",
"$submenu_characters": "Personajes",
"$submenu_recommendations": "Recomendaciones",
"$submenu_relations": "Relaciones",
"$submenu_threads": "Hilos",
"$submenu_statusDistribution": "Distribución por estado",
"$submenu_scoreDistribution": "Distribución por calificación",
"$mainMenu_notifications": "Notificaciones",
"$mainMenu_profile": "Perfil",
"$mainMenu_settings": "Configuración",
"$timeline_search_description": "¿Buscas actividades de otro usuario?",
"$noScrollPosts_description": "Mostrar mensajes de estado completos, independientemente de su longitud",
"$ALbuttonReload_description": "Hacer que el botón \"AL\" recargue los feeds en la página de inicio",
"$timeline_title": "Línea de tiempo",
"$filter_replies": "Respuestas",
"$filter_following": "Siguiendo",
"$input_user_placeholder": "Usuario",
"$error_userNotFound": "Usuario no encontrado",
"$error_connection": "Error de conexión",
"$myThreads_link": "Mis hilos",
"$piracy_message": "ESTE ES UN ENLACE MALO, YA ESTÁ DESECHADO OwO (haz clic en el botón de reportar para llamar a los moderadores sobre este travieso usuario)",
"$compare_default": "Mostrar comparación nativa",
"$compare_hoh": "Mostrar comparación de Hoh",
"$compare_minRatings": "Calificación mínima:",
"$compare_individualRatings": "Sistemas de clasificación individuales:",
"$compare_normalizeRatings": "Normalizar calificaciones:",
"$compare_colourCell": "Colorear toda la celda:",
"$compare_listStatus": "cualquier estado de lista\npulse para alternar",
"$404_private_or_noUser": "{0} no existe o es privado",
"$404_private": "{0} es privado",
"$404_noUser": "{0} no existe",
"$404_blocked": "{0} te ha bloqueado",
"$recs_forYou": "Para ti",
"$download_banner_tooltip": "Descargar banner",
"$recs_description": "Cada par, es uno que te gusta + uno que no has empezado\nLa mejor combinación se muestra primero primero",
"$module_unicodifier_description": "Convertir los emojis para que funcionen en anilist",
"$module_unicodifier_extendedDescription": "Anilist no maneja correctamente algunos caracteres Unicode, dando lugar a mensajes confusos. Este módulo los convierte en código HTML, que el sitio puede manejar\nIdea original del gran GoBusto: https://files.kiniro.uk/unicodifier.html",
"$rewatch_suffix_1": "[repetir]",
"$rewatch_suffix_M": "[repetir {0}]",
"$reread_suffix_1": "[repetir]",
"$reread_suffix_M": "[repetir {0}]",
"$reviewLike_tooltip": "A {0} de {1} usuarios les gustó esta reseña",
"$review_reviewTitle": "Reseña de {0} por\u00a0{1}",
"$updates_noNewManga": "No se encontraron elementos nuevos :(",
"$staff_filter_placeholder": "Filtrar por título, función, etc.",
"$relations_following_only": "Solo seguidos",
"$relations_followers_only": "Solo seguidores",
"$relations_mutuals": "Mutuo",
"$relations_shared_following": "Seguidos compartidos",
"$relations_shared_followers": "Seguidores compartidos",
"$relations_description": "Añadir pestañas separadas en la página social para tipos de seguidores",
"$additionalTranslation_description": "Traducir partes adicionales de la interfaz de Anilist",
"$twoColumnFeed_description": "Dividir el feed de inicio en dos columnas",
"$markdown_help_title": "Ayuda Markdown",
"$markdown_help_description": "Añadir ayuda de Markdown en la esquina inferior izquierda",
"$markdown_help_images_header": "Imágenes",
"$markdown_help_imageUpload": "(debes subirlo a un sitio externo para obtener un enlace)",
"$markdown_help_imageSize": "Ajuste de tamaño:",
"$markdown_help_links_header": "Enlaces",
"$markdown_help_formatting_header": "Formato",
"$markdown_help_infixOr": "o",
"$navigation_profileLink": "Perfil de {0}",
"$MAL_score": "Calificación de MAL",
"$MAL_serialization": "Serialización",
"$adjustColours_title": "Ajustar colores",
"$button_newChapters": "Nuevos capítulos",
"$scanning": "Escaneando...",
"$noResults": "Sin resultados",
"$filters": "Filtros",
"$filters_lists": "Listas",
"$filters_year": "Año",
"$heading_anime": "Anime:",
"$heading_manga": "Manga:",
"$heading_similarFavs": "Favoritos similares:",
"$stats_animeOnList": "Anime listado: ",
"$stats_mangaOnList": "Manga listado: ",
"$stats_animeRated": "Anime calificado: ",
"$stats_mangaRated": "Manga calificado: ",
"$stats_averageScore": "Ponderación: ",
"$stats_onlyOne": "Sólo se ha dado una puntuación: ",
"$stats_medianScore": "Calificación mediana: ",
"$stats_globalDifference": "Diferencia global: ",
"$stats_globalDeviation": "Desviación global: ",
"$stats_ratingEntropy": "Calificación por entropía: ",
"$stats_mostCommonScore": "Puntuación más común: ",
"$stats_timeWatched": "Tiempo visto: ",
"$stats_totalChapters": "Capítulos totales: ",
"$stats_totalVolumes": "Volúmenes totales: ",
"$stats_TVEpisodesWatched": "Episodios vistos: ",
"$stats_TVEpisodesRemaining": "Episodios restantes de series en emisión: ",
"$stats_firstLoggedAnime": "Primer anime registrado: ",
"$stats_firstLoggedAnime_note": "(los usuarios pueden cambiar libremente las fechas de inicio)",
"$stats_weightComment_duration": " (ponderado por la duración)",
"$stats_weightComment_chapers": " (ponderado por capítulos)",
"$stats_globalDifference_comment": " (diferencia promedio con respecto a la nota global)",
"$stats_globalDeviation_comment": " (desviación estándar del  promedio global de cada entrada)",
"$stats_ratingEntropy_comment": " bits/clasificación (número más alto = clasificaciones más precisas. Normalmente entre 1 y 6)",
"$stats_moreStats_title": "Más estadísticas",
"$stats_genresTags_title": "Géneros y etiquetas",
"$stats_genre": "Género",
"$stats_tag": "Etiqueta",
"$stats_count": "Recuento",
"$stats_name": "Título",
"$stats_siteStats_title": "Estadísticas del sitio",
"$stats_anime_heading": "Estadísticas de anime para {0}",
"$stats_manga_heading": "Estadísticas de manga para {0}",
"$stats_loadingAnime": "cargando lista de anime...",
"$stats_loadingManga": "cargando lista de manga...",
"$stats_instances": "({0} instancias)",
"$stats_instances_unique": "no hay dos instancias iguales",
"$stats_longestTime": "{0}% es {1}",
"$stats_varousStats_heading": "Estadísticas varias",
"$stats_longest_watching": "En progreso",
"$stats_longest_paused": "Pausado",
"$stats_longest_dropped": "Abandonado",
"$stats_longest_1rewatch": "Repetido una vez",
"$stats_longest_2rewatch": "Repetido dos veces",
"$stats_longest_Mrewatch": "Repetido {0} veces",
"$stats_longest_1rewatching": "Primera repetición en progreso",
"$stats_longest_2rewatching": "Segunda repetición en progreso",
"$stats_longest_Mrewatching": "Repetición {0} en progreso",
"$stats_longest_1rewatchPaused": "Primera repetición en pausa",
"$stats_longest_2rewatchPaused": "Segunda repetición en pausa",
"$stats_longest_MrewatchPaused": "Repetición {0} en  pausa",
"$stats_longest_1rewatchDropped": "Abandonado en la primera repetición",
"$stats_longest_2rewatchDropped": "Abandonado en la segunda repetición",
"$stats_longest_MrewatchDropped": "Abandonado en la repetición número {0}",
"$stats_regularTags": "Etiquetas regulares a incluir (se aplicarán en la recarga): ",
"$stats_meanScore": "Nota media",
"$stats_customTagsAnime": "Etiquetas personalizadas de anime",
"$stats_customTagsManga": "Etiquetas personalizadas de manga",
"$stats_chapters": "Capítulos",
"$stats_volumes": "Volúmenes",
"$characterBrowseTooltip": "Favoritos",
"$make3x3": "Hacer 3x3",
"$make3x3_title": "Haga clic en este botón y, a continuación, en 9 entradas de su lista",
"$forum_preview_reply": "respondió ",
"$forum_singleThread": "Estás viendo un solo comentario. ¿Mostrar todo el hilo?",
"$staff_filterHelp": "Ayuda filtro",
"$staff_hoursWatched": "Horas vistas: ",
"$staff_chaptersRead": " Capítulos leídos: ",
"$staff_volumesRead": " Volumenes leídos: ",
"$staff_meanScore": " Nota media: ",
"$staff_sort": "Ordenar",
"$sort_alphabetical": "Alfabéticamente",
"$sort_newest": "Más reciente",
"$sort_oldest": "Más antiguo",
"$sort_length": "Duración",
"$sort_popularity": "Popularidad",
"$sort_score": "Calificación",
"$sort_myScore": "Mi calificación",
"$sort_myProgress": "Mi progreso",
"$milestones_totalVolumes": "Volúmenes totales",
"$milestones_totalEpisodes": "Episodios totales",
"$milestones_daysWatched": "{0} Días vistos",
"$milestones_chaptersRead": "{0} Capítulos leídos",
"$colour_transparent": "Transparente",
"$colour_blue": "Azul",
"$colour_white": "Blanco",
"$colour_black": "Negro",
"$colour_red": "Rojo",
"$colour_peach": "Durazno",
"$colour_orange": "Naranja",
"$colour_yellow": "Amarillo",
"$colour_green": "Verde",
"$terms_description": "Añade un feed para redes lentas debajo de https://anilist.co/terms",
"$terms_privacyPolicy": "Ver política de privacidad",
"$terms_privacyPolicy_title": "Esta página muestra normalmente la política de privacidad de AniList. Haga clic para obtener la vista por defecto",
"$terms_signin": "Inicia sesión en Automail para poder usar éste modulo",
"$terms_signin_link": "Iniciar sesión con el script",
"$terms_option_global": "Global",
"$terms_option_text": "Estado",
"$terms_option_replies": "Respuestas",
"$terms_option_forum": "Foro",
"$terms_option_reviews": "Reseñas",
"$terms_option_user": "Usuario",
"$terms_option_media": "Media",
"$mediaStaff_filter": "Filtro",
"$socialTab_tooManyChapters": "Lo más probable es la base de datos se haya actualizado",
"$socialTab_users": "Usuarios",
"$socialTab_shortAverage": "Prom",
"$query_firstActivity": "Primera actividad",
"$query_autorecs": "Autorrecomendaciones",
"$query_autorecs_collecting": "Recopilando datos de lista...",
"$query_autorecs_processing": "Procesando...",
"$query_autorecs_info": "Las mejores selecciones, basadas en tus calificaciones, las de otros usuarios y la base de datos de recomendaciones. Las mejores coincidencias están en la parte superior",
"$mobileFriendly_description": "Modo amigable para dispositivos móviles. Desactiva algunos módulos que no funcionan correctamente y ajusta otros",
"$hideLikes_description": "Ocultar notificaciones de \"Me gusta\". No afectará el recuento de notificaciones",
"$settingsTip_description": "Mostrar un aviso en la página de notificaciones para saber dónde se puede encontrar la configuración del script",
"$settings_errorInvalidJSON": "Perfil JSON no válido",
"$settings_errorInvalidActivity": "debe ser un enlace directo a una actividad, o un ID de actividad",
"$settings_errorInvalidActivity2": "actividad no encontrada",
"$dismissDot_description": "Mostrar un elemento para descartar las notificaciones cuando se ha iniciado sesión",
"$socialTabFeed_noActivities": "Sin coincidencias",
"$socialTab_description": "Tabla social, ponderación, progreso y notas",
"$socialTabFeed_description": "Filtros de la tabla social",
"$forumMedia_description": "Añadir los medios etiquetados a la vista previa del foro en la página de inicio",
"$mangaBrowse_description": "Hacer que la navegación por defecto sea manga",
"$dblclickZoom_description": "Haga doble clic en las actividades para ampliarlas",
"$dblclickZoom_extendedDescription": "Es probable que haya mejores complementos de accesibilidad en el navegador.",
"$draw3x3_description": "Añade un botón para crear tablas 3x3 a partir de las entradas de la lista. Haz clic en el botón y, a continuación, seleccione nueve elementos",
"$subTitleInfo_description": "Añadir datos básicos debajo del título en las páginas de los medios",
"$entryScore_description": "Añade tu calificación y progreso a las páginas de los medios",
"$activityTimeline_description": "Vincule sus actividades en la pestaña social de media, y entre las actividades individuales",
"$CSSfollowCounter_description": "Mostrar recuento en la página \"Social\"",
"$completedScore_description": "Mostrar puntuación en la actividad cuando un anime/manga es completado",
"$droppedScore_description": "Mostrar puntuación en la actividad cuando un anime/manga es abandonado",
"$replaceNativeTags_description": "Listas completas para etiquetas, staff y estudios en las estadísticas",
"$hideGlobalFeed_description": "Ocultar el feed global",
"$CSScompactBrowse_description": "Hacer la sección de exploración más compacta",
"$cleanSocial_description": "Colocar \"Seguidores\" antes de \"Hilos del foro\" en las ficha social de anime/manga",
"$CSSverticalNav_description": "Modo de navegación alternativo [con barra de navegación vertical cortesía de Kuwabara]",
"$nonJumpScroll_description": "Evitar que el contenido de la actividad salte al utilizar las barras de desplazamiento [cortesía de Reina]",
"$blockWord_description": "Ocultar publicaciones de estado que contengan esta palabra:",
"$statusBorder_description": "Colorear el borde derecho de las actividades según el estado del anime/manga",
"$betterReviewRatings_description": "Añadir el número total de valoraciones a las reseñas en la página de inicio",
"$browseFilters_description": "Añadir más opciones de orden al navegar",
"$tagIndex_description": "Mostrar un índice de etiquetas personalizadas en las listas de anime y manga",
"$dubMarker_description": "Mostrar un aviso en la parte superior de los otros datos en una página de anime si un doblaje está disponible",
"$mangaGuess_description": "Hacer una estimación del número de capítulos para un manga en emisión",
"$allStudios_description": "Incluir compañias que no son estudios de animación en la tabla de estadísticas de estudios ampliada",
"$noRewatches_description": "No incluir progreso de repeticiones en las estadísticas",
"$hideCustomTags_description": "Ocultar tablas de etiquetas personalizadas de forma predeterminada",
"$negativeCustomList_description": "Añadir una entrada a las tablas de etiquetas personalizadas con todos los anime/manga que no estén en una lista personalizada",
"$globalCustomList_description": "Añadir una entrada a las tablas de etiquetas personalizadas con todos los anime/manga",
"$timeToCompleteColumn_description": "Añadir una columna de \"tiempo restante para completar\" a tablas de etiquetas",
"$feedCommentFilter_description": "Añadir opciones de filtro a feeds para ocultar las publicaciones con pocos comentarios o likes",
"$browseSubmenu_description": "Sustituir el submenú \"navegar\" cuando se utiliza la navegación vertical",
"$annoyingAnimations_description": "Eliminar animaciones de la interfaz",
"$customCSS_description": "Habilitar CSS personalizado de perfil y actividades ancladas",
"$pinned": "Fijado",
"$staff_animeRoles": "Funciones de staff de Anime",
"$staff_mangaRoles": "Funciones de staff de Manga",
"$staff_voiceRoles": "Funciones de voz de personajes",
"$forumHeading_recentlyActive": "Hilos con actividad reciente",
"$forumHeading_releaseDiscussion": "Hilos de discusión sobre anime/manga en emisión",
"$forumHeading_newThreads": "Hilos recién creados",
"$home_reviewLink": "Reseñas recientes",
"$home_forumLink": "Actividad del foro",
"$home_trendingAnime": "Tendencia anime",
"$home_trendingManga": " y Manga",
"$home_newAnime": "Anime recién añadido",
"$home_newManga": "Manga recién añadido",
"$footer_siteTheme": "Tema del sitio",
"$footer_addData": "Envío de datos",
"$footer_moderators": "Moderadores",
"$footer_contact": "Contáctanos",
"$footer_terms": "Términos y privacidad",
"$footer_siteMap": "Mapa del sitio",
"$theme_default": "Predetermiado",
"$theme_dark": "Oscuro",
"$theme_highContrast": "Alto contraste",
"$theme_highContrastDark": "Alto contraste oscuro",
"$feed_header": "Actividad",
"$feedSelect_all": "Todo",
"$feedSelect_text": "Publicaciones",
"$feedSelect_list": "Progreso de lista",
"$feedSelect_status": "Estado",
"$feedSelect_message": "Mensajes",
"$mediaFormat_TV" : "TV",
"$mediaFormat_TV_SHORT" : "Corto de TV",
"$mediaFormat_MOVIE" : "Película",
"$mediaFormat_SPECIAL" : "Especial",
"$mediaFormat_MUSIC" : "Música",
"$mediaFormat_MANGA" : "Manga",
"$mediaFormat_NOVEL" : "Novela ligera",
"$forumCategory_3": "Novelas ligeras",
"$forumCategory_4": "Novelas visuales",
"$forumCategory_5": "Discusión sobre anime/manga en emisión",
"$forumCategory_8": "Novedades",
"$forumCategory_9": "Música",
"$forumCategory_10": "Gaming",
"$forumCategory_11": "Comentarios del sitio",
"$forumCategory_12": "Informes de errores",
"$forumCategory_13": "Anuncios del sitio",
"$forumCategory_14": "Personalización de listas",
"$forumCategory_15": "Recomendaciones",
"$forumCategory_16": "Juegos en el foro",
"$forumCategory_17": "Varios",
"$role_Original Creator": "Autor original",
"$role_Creator": "Autor",
"$role_Music": "Música",
"$role_Key Animation": "Animación clave",
"$role_Key Animation Assistance": "Asistencia de animación",
"$role_In-Between Animation": "Animación intermedia",
"$role_Animator": "Animador",
"$role_Animation": "Animación",
"$role_Main Animator": "Animador principal",
"$role_Opening Animation": "Animación de apertura",
"$role_Art": "Arte",
"$role_Illustration": "Ilustración",
"$role_Original Concept": "Concepto original",
"$role_Story Concept": "Concepto de historia",
"$role_Original Story": "Historia original",
"$role_Story": "Historia",
"$role_Official Writer": "Escritor oficial",
"$role_Story & Art": "Historia y arte",
"$role_CG Director": "Director de CG",
"$role_Character Design": "Diseño de personajes",
"$role_Original Character Design": "Diseño original de personajes",
"$role_Animation Director": "Director de animación",
"$role_Assistant Episode Director": "Asistente de dirección del episodio",
"$role_Assistant Animation Director": "Asistente del director de animación",
"$role_Assistant Director": "Asistente del director",
"$role_Chief Animation Director": "Director de animación en jefe",
"$role_Episode Director": "Director del episodio",
"$role_Sound Director": "Director de sonido",
"$role_Chief Director": "Director general",
"$role_Unit Director": "Director de unidad",
"$role_Art Director": "Director de arte",
"$role_Art Design": "Diseño artístico",
"$role_Chief Unit Director": "Director de unidad en jefe",
"$role_Planning Producer": "Productor de planificación",
"$role_Producer": "Productor",
"$role_Co-Producer": "Co-productor",
"$role_Production Coordination": "Coordinación de producción",
"$role_Production Generalization": "Generalización de la producción",
"$role_Executive Director": "Director ejecutivo",
"$role_Executive Producer": "Productor ejecutivo",
"$role_Animation Producer": "Productor de animación",
"$role_Creative Producer": "Productor creativo",
"$role_Production Assistant": "Asistente de producción",
"$role_Production Assistance": "Asistencia en la producción",
"$role_Photography Assistance": "Asistencia de fotografía",
"$role_Director of Photography": "Director de fotografía",
"$role_Photography": "Fotografía",
"$role_Camera": "Cámara",
"$role_Advertising": "Publicidad",
"$role_Finishing": "Acabado",
"$role_Recording": "Grabación",
"$role_Recording Assistant": "Asistente de grabación",
"$role_Dialogue Recording": "Grabación de diálogos",
"$role_3D Works": "Trabajos 3D",
"$role_CG Animation": "Animación CG",
"$role_Color Design": "Diseño de color",
"$role_Color Coordination": "Coordinación de color",
"$role_Insert Song Lyrics": "Insertar la letra de la canción",
"$role_Theme Song Lyrics": "Letra del tema principal",
"$role_Theme Song Composition": "Composición de la canción principal",
"$role_Theme Song Performance": "Interpretación de la canción principal",
"$role_Theme Song Arrangement": "Arreglo de la canción principal",
"$role_Music Piano Performance": "Piano",
"$role_Conductor": "Director de orquesta",
"$role_Special Thanks": "Agradecimientos especiales",
"$role_Material Texture": "Textura de materiales",
"$role_Original Plan": "Plan original",
"$role_Editing": "Edición",
"$role_PV Production": "Producción de PV",
"$role_Title Design": "Diseño del título",
"$role_Title Logo Design": "Diseño del logotipo del título",
"$role_Visual Effects": "Efectos visuales",
"$role_Digital Effects": "Efectos digitales",
"$role_Prop Design": "Diseño de utilería",
"$role_Firearms Design": "Diseño de armas",
"$role_ADR Script": "Guión de ADR",
"$role_ADR Scriptwriter": "Guionista de ADR",
"$role_ADR Script Adaptation": "Adaptación de guiones de ADR",
"$role_Layout": "Diseño",
"$role_Layout Composition": "Composición del diseño",
"$role_Scene Design": "Diseño de escenas",
"$role_Mechanical Design": "Diseño mecánico",
"$role_Background Art": "Arte de fondo",
"$role_In-Betweens Check": "Comprobación de intermedios",
"$role_Animation Check": "Comprobación de animación",
"$role_Series Composition": "Composición de la serie",
"$role_Animation Supervisor": "Supervisor de animación",
"$role_Supervision": "Supervisión",
"$role_Planning": "Planificación",
"$role_Title": "Título",
"$role_Script": "Guión",
"$role_Screenplay": "Libreto",
"$role_Setting": "Escenario",
"$role_Translator": "Traductor",
"$role_Assistant": "Asistente",
"$role_Main": "Principal",
"$role_Supporting": "Apoyo",
"$role_Background": "Fondo"
	}
}

}
function translate(key,subs,fallback){
	if(key[0] !== "$"){
		return key
	}
	let immediate = languageFiles[useScripts.partialLocalisationLanguage].keys[key];
	if(!immediate){
		for(let i=0;i<languageFiles[useScripts.partialLocalisationLanguage].info.fallback.length;i++){
			immediate = languageFiles[languageFiles[useScripts.partialLocalisationLanguage].info.fallback[i]].keys[key];
			if(immediate){
				break
			}
		}
		if(!immediate){
			immediate = languageFiles["English"].keys[key];
			if(!immediate){
				if(fallback){
					return fallback
				}
				if(key.substring(0,6) !== "$role_"){
					console.warn("[" + script_type + " localisation] missing key!",key)
				}
				immediate = key
			}
		}
	}
	if(subs){
		if(Array.isArray(subs)){
			subs.forEach((sub,i) => {
				immediate = immediate.replace("{" + i + "}",sub)
			})
		}
		else{
			immediate = immediate.replace("{0}",subs)
		}
	}
	return immediate
}

if(!languageFiles[useScripts.partialLocalisationLanguage]){
	let candidates = []
	Object.keys(languageFiles).forEach(key => {
		if(key.includes(useScripts.partialLocalisationLanguage)){
			candidates.push(key)
		}
	})
	if(candidates.length){
		alert("No \"" + useScripts.partialLocalisationLanguage +"\" language file for " + script_type + " found. Setting language to \"English\"\nPossible candidates: " + candidates.map(a => "\"" + a + "\"").join(",") +"\nYou can change this in the settings")
	}
	else{
		alert("No \"" + useScripts.partialLocalisationLanguage +"\" language file for " + script_type + " found. Setting language to \"English\"\nYou can change this in the settings")
	}
	useScripts.partialLocalisationLanguage = "English";
	useScripts.save()
}
//end "localisation.js"

//begin "utilities.js"

/*
create()

This is the main framework code of the script
It shortens the otherwise verbose procedure of creating a new HTML element and inserting it into the DOM.
Instead of:

	let element = document.createElement("p");
	element.innerText = "lorem ipsum";
	element.classList.add("hohParagraph");
	pageParentElement.append(element);

You would do:

	create("p","hohParagraph","lorem ipsum");

All arguments except for the HTML tag are optional.
*/
function create(
	HTMLtag,//<string>: The kind of DOM element to create
	classes,//(optional) <string>: The css class to give the element  OR   [<strings>]: A list of multiple class names
	//(the first string of the list could optionally start with a "#", in which case it will be an id instead)
	text,//(optional) <string>: The innerText to give the element
	appendLocation,//(optional) DOMnode: a node to immediately append the created element to
	cssText//(optional) <string>: Inline CSS to appy to the element
){
	let element = document.createElement(HTMLtag);
	if(Array.isArray(classes)){
		element.classList.add(...classes);
		if(classes.includes("newTab")){
			element.setAttribute("target","_blank")
		}
	}
	else if(classes){
		if(classes[0] === "#"){
			element.id = classes.substring(1)
		}
		else{
			element.classList.add(classes);
			if(classes === "newTab"){
				element.setAttribute("target","_blank")
			}
		}
	}
	if(text || text === 0){
		element.innerText = text
	}
	if(appendLocation && appendLocation.appendChild){
		appendLocation.appendChild(element)
	}
	if(cssText){
		element.style.cssText = cssText
	}
	return element
}

function safeURL(URL){
/*
	NOTE: DO NOT USE THIS FOR ANYTHING 'UNSAFE'!
	This is a cosmetic utility, not a security feature
	consider using "purify.js" if you have to deal with naughty user input, or better, please stop what you are doing
 */
	let compo = encodeURIComponent((URL || "")
		.replace(/\s|\/|:|★|☆/g,"-")
		.replace(/\((\d+)\)/g,(string,year) => year)
		.replace(/(\.|\)|\\|\?|#|!|,|%|’)/g,"")
		.replace(/ä/g,"a")
		.replace(/×/g,"x")
	);
	if(useScripts.SFWmode){
		if(badWords.some(
			word => compo.includes(word)
		)){
			return ""
		}
	}
	return compo
}

function fuzzyDateCompare(first,second){//returns an INDEX, not to be used for sorting. That is, "-1" means they are equal.
	if(!first.year || !second.year){
		return -1
	}
	if(first.year > second.year){
		return 0
	}
	else if(first.year < second.year){
		return 1
	}
	if(!first.month || !second.month){
		return -1
	}
	if(first.month > second.month){
		return 0
	}
	else if(first.month < second.month){
		return 1
	}
	if(!first.day || !second.day){
		return -1
	}
	if(first.day > second.day){
		return 0
	}
	else if(first.day < second.day){
		return 1
	}
	return -1
}

//time in seconds, not milliseconds
function formatTime(diff,type){
	let magRound = function(num){
		if(num < 1){
			return Math.round(num);
		}
		else{
			if(
				Math.log(Math.ceil(num)) < 2*Math.log(num) - Math.log(Math.floor(num))
			){
				return Math.ceil(num)
			}
			else{
				return Math.floor(num)
			}
		}
	};
	let times = [
		{name: "year",short: translate("$time_short_year"),medium: translate("$time_medium_year"),Mmedium: translate("$time_medium_Myear"),value: 60*60*24*365},
		{name: "month",short: translate("$time_short_month"),medium: translate("$time_medium_month"),Mmedium: translate("$time_medium_Mmonth"),value: 60*60*24*30},
		{name: "week",short: translate("$time_short_week"),medium: translate("$time_medium_week"),Mmedium: translate("$time_medium_Mweek"),value: 60*60*24*7},
		{name: "day",short: translate("$time_short_day"),medium: translate("$time_medium_day"),Mmedium: translate("$time_medium_Mday"),value: 60*60*24},
		{name: "hour",short: translate("$time_short_hour"),medium: translate("$time_medium_hour"),Mmedium: translate("$time_medium_Mhour"),value: 60*60},
		{name: "minute",short: translate("$time_short_minute"),medium: translate("$time_medium_minute"),Mmedium: translate("$time_medium_Mminute"),value: 60},
		{name: "second",short: translate("$time_short_second"),medium: translate("$time_medium_second"),Mmedium: translate("$time_medium_Msecond"),value: 1}
	];
	let timeIndex = 0;
	let significantValue = 0;
	let reminder = 0;
	do{
		significantValue = diff/times[timeIndex].value;
		reminder = (diff - Math.floor(significantValue) * times[timeIndex].value)/times[timeIndex + 1].value;
		timeIndex++;
	}while(!Math.floor(significantValue) && timeIndex < (times.length - 1));
	timeIndex--;
	if(!Math.floor(significantValue)){
		if(type === "short"){
			return magRound(diff) + translate("$time_short_second")
		}
		if(magRound(diff) === 1){
			return magRound(diff) + " " + translate("$time_medium_second")
		}
		return magRound(diff) + " " + translate("$time_medium_Msecond");
	}
	if(Math.floor(significantValue) > 1){
		if(type === "short"){
			return magRound(significantValue) + times[timeIndex].short
		}
		return magRound(significantValue) + " " + times[timeIndex].Mmedium;
	}
	if(magRound(reminder) > 1){
		if(type === "short"){
			return "1" + times[timeIndex].short + " " + magRound(reminder) + times[timeIndex + 1].short	
		}
		return "1 " + times[timeIndex].medium + " " + magRound(reminder) + " " + times[timeIndex + 1].Mmedium
	}
	if(magRound(reminder) === 1){
		if(type === "short"){
			return "1" + times[timeIndex].short + " 1" + times[timeIndex + 1].short	
		}
		return "1 " + times[timeIndex].medium + " 1 " + times[timeIndex + 1].medium;
	}
	if(type === "short"){
		return "1" + times[timeIndex].short
	}
	return "1 " + times[timeIndex].medium;
}

function nativeTimeElement(timestamp){//time in seconds
	let dateObj = new Date(timestamp*1000);
	let elem = create("time","hohTimeGeneric");
	elem.setAttribute("datetime",dateObj);
	let locale = languageFiles[useScripts.partialLocalisationLanguage].info.locale || "en-UK";
	elem.title = dateObj.toLocaleDateString(locale,{weekday: undefined, year: "numeric", month: "numeric", day: "numeric"}) + ", " + dateObj.toLocaleTimeString(locale);
	let calculateTime = function(){
		let now = new Date();
		let diff = Math.round(now.valueOf()/1000) - Math.round(dateObj.valueOf()/1000);
		if(diff === 0){
			elem.innerText = translate("$time_now")
		}
		if(diff === 1){
			elem.innerText = translate("$time_1second")
		}
		else if(diff < 60){
			elem.innerText = translate("$time_Msecond",diff)
		}
		else{
			diff = Math.floor(diff/60);
			if(diff === 1){
				elem.innerText = translate("$time_1minute")
			}
			else if(diff < 60){
				elem.innerText = translate("$time_Mminute",diff)
			}
			else{
				diff = Math.floor(diff/60);
				if(diff === 1){
					elem.innerText = translate("$time_1hour")
				}
				else if(diff < 24){
					elem.innerText = translate("$time_Mhour",diff)
				}
				else{
					diff = Math.floor(diff/24);
					if(diff === 1){
						elem.innerText = translate("$time_1day")
					}
					else if(diff < 7){
						elem.innerText = translate("$time_Mday",diff)
					}
					else if(diff < 14){
						elem.innerText = translate("$time_1week")
					}
					else if(diff < 30){
						elem.innerText = translate("$time_Mweek",Math.floor(diff/7))
					}
					else if(diff < 365){
						if(Math.floor(diff/30) === 1){
							elem.innerText = translate("$time_1month")
						}
						else{
							elem.innerText = translate("$time_Mmonth",Math.floor(diff/30))
						}
					}
					else{
						diff = Math.floor(diff/365);
						if(diff === 1){
							elem.innerText = translate("$time_1year")
						}
						else{
							elem.innerText = translate("$time_Myear",diff)
						}
					}
				}
			}
		}
		setTimeout(function(){
			if(!document.body.contains(elem)){
				return
			}
			calculateTime()
		},20*1000)
	};calculateTime();
	return elem
}

let wilson = function(positiveScore,total){
	if(total === 0){
		return {
			left: 0,
			right: 0
		}
	}
	// phat is the proportion of successes
	// in a Bernoulli trial process
	let phat = positiveScore / total;
	// z is 1-alpha/2 percentile of a standard
	// normal distribution for error alpha=5%
	const z = 1.959963984540;
	// implement the algorithm https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Wilson_score_interval
	let a = phat + z * z / (2 * total);
	let b = z * Math.sqrt((phat * (1 - phat) + z * z / (4 * total)) / total);
	let c = 1 + z * z / total;
	return {
		left: (a - b) / c,
		right: Math.min(1,(a + b) / c)
	}
};



//consider getting rid of this one
Number.prototype.roundPlaces = function(places){
	return +(
		Math.round(
			this * Math.pow(10,places)
		) / Math.pow(10,places)
	)
}

function capitalize(string){
	return (string + "").charAt(0).toUpperCase() + (string + "").slice(1)
}

function csvEscape(string){
	return "\"" + (string || "").replace(/"/g,"\"\"") + "\""
}

function entityUnescape(string){
	return string.replace(/&lt;/g,"<")
		.replace(/&gt;/g,">")
		.replace(/&quot;/g,"\"")
		.replace(/&#039;/g,"'")
		.replace(/<br\s?\/?>\n?/g,"\n")
		.replace(/&nbsp;/g," ")//not a nbsp, but close enough in most cases. Better than the raw entity at least
		.replace(/&amp;/g,"&")
}

//https://stackoverflow.com/a/7616484/5697837
function hashCode(string){//non-cryptographic hash
	var hash = 0, i, chr;
	if(string.length === 0){
		return hash
	}
	for(i = 0; i < string.length; i++) {
		chr   = string.charCodeAt(i);
		hash  = ((hash << 5) - hash) + chr;
		hash |= 0; // Convert to 32bit integer
	}
	return hash
}

//piracy links begone
setInterval(function(){
	document.querySelectorAll(`a[rel="noopener noreferrer"]`).forEach(link => {
		if(!link || !link.href){
			return
		}
		let linker;
		try{
			linker = (new URL(link.href)).host;
		}
		catch(e){
			console.log("invalid URL:", link.href);
			return
		}
		if(linker && linker.split(".").length >= 2){
			linker = linker.split(".")[linker.split(".").length - 2];
			if(
				[556415734,1724824539,-779421562,-1111399772,-93654449,1120312799,-781704176,-1550515495,3396395,567115318,-307082983,1954992241,-307211474,-307390044,1222804306,-795095039,-1014860289,403785740,547002932,128627683]
.includes(hashCode(linker))
			){
				link.href = "https://anilist.co/forum/thread/14";
				link.innerText = translate("$piracy_message")
			}
		}
	})
	document.querySelectorAll(".sense-wrap").forEach(link => {
		link.style.display = "none"
	})
},2000);

const svgns = "http://www.w3.org/2000/svg";
const svgShape = function(shape,target,attributes,children,content){
	shape = shape || "g";
	let obj = document.createElementNS(svgns,shape);
	Object.keys(attributes || {}).forEach(key => {
		obj.setAttributeNS(null,key,attributes[key])
	});
	if(content){
		obj.appendChild(document.createTextNode(content))
	}
	if(target){
		target.appendChild(obj)
	}
	(children || []).forEach(
		child => {
			if(child.element){
				svgShape(child.element,obj,child.attributes,child.children,child.content)
			}
			else{
				obj.appendChild(child)
			}
		}
	)
	return obj
}
const VALUE = ((a,b) => a - b);//Used for sorting functions
const VALUE_DESC = ((b,a) => a - b);
const TRUTHY = (a => a);//filtering
const ACCUMULATE = (a,b) => (a || 0) + (b || 0);
const ALPHABETICAL = function(valueFunction){
	if(valueFunction){
		return (a,b) => ("" + valueFunction(a)).localeCompare("" + valueFunction(b))
	}
	return (a,b) => ("" + a).localeCompare("" + b)
}
const NOW = () => (new Date()).valueOf();

const Stats = {
	average: function(list){
		return list.reduce((a,b) => (a || 0) + (b || 0))/list.length
	},
	median: function(list){
		let temp = [...list].sort((a,b) => a - b);
		return (
			temp[Math.floor((temp.length - 1)/2)]
			+ temp[Math.ceil((temp.length - 1)/2)]
		)/2;
	},
	mode: function(list){
		return [...list].sort(
			(b,a) => list.filter(
				e => e === a
			).length - list.filter(
				e => e === b
			).length
		)[0];
	}
}

const evalBackslash = function(text){
	let output = "";
	let special = false;
	Array.from(text).forEach(char => {
		if(char === "\\"){
			if(special){
				output += "\\"
			}
			special = !special;
		}
		else{
			output += char;
		}
	});
	return output
}

//this function is for removing duplicates in a sorted list.
//the twist is that it also provides a way to merge the duplicates with a custom function
const removeGroupedDuplicates = function(
	list,
	uniquenessFunction,
	modificationFunction
){//both functions optional
	if(!uniquenessFunction){
		uniquenessFunction = e => e
	}
	list = list.sort(
		(a,b) => uniquenessFunction(a) - uniquenessFunction(b)
	);
	let returnList = [];
	list.forEach((element,index) => {
		if(index === list.length - 1){
			returnList.push(element);
			return;
		}
		if(uniquenessFunction(element) === uniquenessFunction(list[index + 1])){
			if(modificationFunction){
				modificationFunction(element,list[index + 1])
			}
		}
		else{
			returnList.push(element)
		}
	});
	return returnList
};

//for the school/workplace methods
let badWords = ["hentai","loli","nsfw","ecchi","sex","gore","porn","violence","lewd","fuck","waifu","nigger","卍"];//woooo so bad.
const badTags = ["gore","nudity","ahegao","irrumatio","sex toys","ashikoki","defloration","paizuri","tekoki","nakadashi","large breasts","facial","futanari","public sex","flat chest","voyeur","fellatio","incest","threesome","anal sex","bondage","cunnilingus","harem","masturbation","slavery","gyaru","rape","netori","milf","handjob","blackmail","sumata","watersports","boobjob","femdom","exhibitionism","human pet","virginity","group sex"];
badWords = badWords.concat(badTags);

function createCheckbox(target,id,checked){//target[,id]
	let hohCheckbox = create("label",["hohCheckbox","el-checkbox__input"],false,target);		
	let checkbox = create("input",false,false,hohCheckbox);
	if(id){
		checkbox.id = id
	}
	checkbox.type = "checkbox";
	checkbox.checked = !!checked;
	create("span","el-checkbox__inner",false,hohCheckbox);
	return checkbox
}

function createDisplayBox(cssProperties,windowTitle){
	let displayBox = create("div","hohDisplayBox",false,document.querySelector("#app") || document.querySelector(".termsFeed") || document.body,cssProperties);
	if(windowTitle){
		create("span","hohDisplayBoxTitle",windowTitle,displayBox)
	}
	let mousePosition;
	let offset = [0,0];
	let isDown = false;
	let isDownResize = false;
	let displayBoxClose = create("span","hohDisplayBoxClose",svgAssets.cross,displayBox);
	displayBoxClose.onclick = function(){
		displayBox.remove();
	};
	let resizePearl = create("span","hohResizePearl",false,displayBox);
	displayBox.addEventListener("mousedown",function(e){
		if(!["P","PRE"].includes(e.target.tagName)){//don't annoy people trying to copy-paste
			isDown = true;
			offset = [
				displayBox.offsetLeft - e.clientX,
				displayBox.offsetTop - e.clientY
			];
		}
	},true);
	resizePearl.addEventListener("mousedown",function(event){
		event.stopPropagation();
		event.preventDefault();
		isDownResize = true;
		offset = [
			displayBox.offsetLeft,
			displayBox.offsetTop
		];
	},true);
	document.addEventListener("mouseup",function(){
		isDown = false;
		isDownResize = false;
	},true);
	document.addEventListener("mousemove",function(event){
		if(isDownResize){
			mousePosition = {
				x : event.clientX,
				y : event.clientY
			};
			displayBox.style.width = (mousePosition.x - offset[0] + 5) + "px";
			displayBox.style.height = (mousePosition.y - offset[1] + 5) + "px";
			return;
		}
		if(isDown){
			mousePosition = {
				x : event.clientX,
				y : event.clientY
			};
			displayBox.style.left = (mousePosition.x + offset[0]) + "px";
			displayBox.style.top  = (mousePosition.y + offset[1]) + "px";
		}
	},true);
	let innerSpace = create("div","scrollableContent",false,displayBox);
	return innerSpace;
}


function removeChildren(node){
	if(node){
		while(node.childElementCount){
			node.lastChild.remove()
		}
	}
}

const svgAssets = {
	envelope : "✉",
	cross : "✕",
	check: "✓",
	loading: "…",
	like : "♥"
};

const svgAssets2 = {};
[
	{
		"name": "likeNative",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "heart",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-heart fa-w-16 fa-sm"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"
					}
				}
			]
			
		}
	},
	{
		"name": "reply",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "comments",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 576 512",
				"class": "svg-inline--fa fa-comments fa-w-18 fa-sm"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z"
					}
				}
			]
		}
	},
	{
		"name": "angleDown",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "angle-down",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 310 512",
				"class": "svg-inline--fa fa-angle-down fa-w-10"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z"
					}
				}
			]
		}
	},
	{
		"name": "smile",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "smile",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 496 512",
				"class": "svg-inline--fa fa-smile fa-w-16 fa-lg"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm84-143.4c-20.8 25-51.5 39.4-84 39.4s-63.2-14.3-84-39.4c-8.5-10.2-23.6-11.5-33.8-3.1-10.2 8.5-11.5 23.6-3.1 33.8 30 36 74.1 56.6 120.9 56.6s90.9-20.6 120.9-56.6c8.5-10.2 7.1-25.3-3.1-33.8-10.2-8.4-25.3-7.1-33.8 3.1zM168 240c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32z"
					}
				}
			]
		}
	},
	{
		"name": "meh",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "meh",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 496 512",
				"class": "svg-inline--fa fa-meh fa-w-16 fa-lg"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160-64c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zm8 144H160c-13.2 0-24 10.8-24 24s10.8 24 24 24h176c13.2 0 24-10.8 24-24s-10.8-24-24-24z"
					}
				}
			]
		}
	},
	{
		"name": "frown",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "frown",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 496 512",
				"class": "svg-inline--fa fa-frown fa-w-16 fa-lg"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160-64c-17.7 0-32 14.3-32 32s14.3 32 32 32 32-14.3 32-32-14.3-32-32-32zm-80 128c-40.2 0-78 17.7-103.8 48.6-8.5 10.2-7.1 25.3 3.1 33.8 10.2 8.5 25.3 7.1 33.8-3.1 16.6-19.9 41-31.4 66.9-31.4s50.3 11.4 66.9 31.4c4.8 5.7 11.6 8.6 18.5 8.6 5.4 0 10.9-1.8 15.4-5.6 10.2-8.5 11.5-23.6 3.1-33.8C326 321.7 288.2 304 248 304z"
					}
				}
			]
		}
	},
	{
		"name": "star",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "star",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 576 512",
				"class": "icon svg-inline--fa fa-star fa-w-18"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z"
					}
				}
			]
		}
	},
	{
		"name": "notes",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "notes",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-redo-alt fa-w-16"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z"
					}
				}
			]
		}
	},
	{
		"name": "notesTags",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "notesTags",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-redo-alt fa-w-16"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z"
					}
				},
				{
					"element": "text",
					"content": "#",
					"attributes": {
						"fill": "grey",
						"x": 110,
						"y": 395,
						"font-size": 400
					}
				}
			]
		}
	},
	{
		"name": "repeat",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "redo-alt",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-redo-alt fa-w-16 repeat"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"
					}
				}
			]
		}
	},
	{
		"name": "listView",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "th-large",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "icon svg-inline--fa fa-th-large fa-w-16"
			},
			"children": [
				{
					"element": "g",
					"attributes": {
						"fill": "currentColor"
					},
					"children": [
						{
							"element": "circle",
							"attributes": {
								"cx": 48,
								"cy": 96,
								"r": 48
							}
						},
						{
							"element": "circle",
							"attributes": {
								"cx": 48,
								"cy": 256,
								"r": 48
							}
						},
						{
							"element": "circle",
							"attributes": {
								"cx": 48,
								"cy": 416,
								"r": 48
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 128,
								"y": 60,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 128,
								"y": 220,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 128,
								"y": 380,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						}
					]
				}
			]
		}
	},
	{
		"name": "simpleListView",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "th-large",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "icon svg-inline--fa fa-th-large fa-w-16"
			},
			"children": [
				{
					"element": "g",
					"attributes": {
						"fill": "currentColor"
					},
					"children": [
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 60,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 220,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 380,
								"width": 384,
								"height": 72,
								"rx": 16
							}
						}
					]
				}
			]
		}
	},
	{
		"name": "bigListView",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "th-large",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "icon svg-inline--fa fa-th-large fa-w-16"
			},
			"children": [
				{
					"element": "g",
					"attributes": {
						"fill": "currentColor"
					},
					"children": [
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 32,
								"width": 149,
								"height": 128,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 192,
								"width": 149,
								"height": 128,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 352,
								"width": 149,
								"height": 128,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 181,
								"y": 32,
								"width": 331,
								"height": 128,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 181,
								"y": 192,
								"width": 331,
								"height": 128,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 181,
								"y": 352,
								"width": 331,
								"height": 128,
								"rx": 24
							}
						}
					]
				}
			]
		}
	},
	{
		"name": "compactView",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "th-large",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "icon svg-inline--fa fa-th-large fa-w-16"
			},
			"children": [
				{
					"element": "g",
					"attributes": {
						"fill": "currentColor"
					},
					"children": [
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 32,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 272,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 178,
								"y": 32,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 178,
								"y": 272,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 356,
								"y": 32,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 356,
								"y": 272,
								"width": 155,
								"height": 208,
								"rx": 24
							}
						}
					]
				}
			]
		}
	},
	{
		"name": "cardView",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "th-large",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "icon svg-inline--fa fa-th-large fa-w-16"
			},
			"children": [
				{
					"element": "g",
					"attributes": {
						"fill": "currentColor"
					},
					"children": [
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 32,
								"width": 240,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 0,
								"y": 272,
								"width": 240,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 272,
								"y": 32,
								"width": 240,
								"height": 208,
								"rx": 24
							}
						},
						{
							"element": "rect",
							"attributes": {
								"x": 272,
								"y": 272,
								"width": 240,
								"height": 208,
								"rx": 24
							}
						}
					]
				}
			]
		}
	},
	{
		"name": "link",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"data-prefix": "fas",
				"data-icon": "link",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-link fa-w-16 fa-sm"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
					}
				}
			]
		}
	},
	{
		"name": "eye",
		"shape": {
			"element": "svg",
			"attributes": {
				"aria-hidden": "true",
				"focusable": "false",
				"data-prefix": "fas",
				"data-icon": "eye",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 576 512",
				"class": "svg-inline--fa fa-eye fa-w-18 fa-sm"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"
					}
				}
			]
		}
	},
	{
		"name": "thumbsUp",
		"shape": {
			"element": "svg",
			"attributes": {
				"focusable": "false",
				"data-prefix": "fas",
				"data-icon": "thumbs-up",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-thumbs-up fa-w-16"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M104 224H24c-13.255 0-24 10.745-24 24v240c0 13.255 10.745 24 24 24h80c13.255 0 24-10.745 24-24V248c0-13.255-10.745-24-24-24zM64 472c-13.255 0-24-10.745-24-24s10.745-24 24-24 24 10.745 24 24-10.745 24-24 24zM384 81.452c0 42.416-25.97 66.208-33.277 94.548h101.723c33.397 0 59.397 27.746 59.553 58.098.084 17.938-7.546 37.249-19.439 49.197l-.11.11c9.836 23.337 8.237 56.037-9.308 79.469 8.681 25.895-.069 57.704-16.382 74.757 4.298 17.598 2.244 32.575-6.148 44.632C440.202 511.587 389.616 512 346.839 512l-2.845-.001c-48.287-.017-87.806-17.598-119.56-31.725-15.957-7.099-36.821-15.887-52.651-16.178-6.54-.12-11.783-5.457-11.783-11.998v-213.77c0-3.2 1.282-6.271 3.558-8.521 39.614-39.144 56.648-80.587 89.117-113.111 14.804-14.832 20.188-37.236 25.393-58.902C282.515 39.293 291.817 0 312 0c24 0 72 8 72 81.452z"
					}
				}
			]
		}
	},
	{
		"name": "thumbsDown",
		"shape": {
			"element": "svg",
			"attributes": {
				"focusable": "false",
				"data-prefix": "fas",
				"data-icon": "thumbs-down",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 512 512",
				"class": "svg-inline--fa fa-thumbs-down fa-w-16"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M0 56v240c0 13.255 10.745 24 24 24h80c13.255 0 24-10.745 24-24V56c0-13.255-10.745-24-24-24H24C10.745 32 0 42.745 0 56zm40 200c0-13.255 10.745-24 24-24s24 10.745 24 24-10.745 24-24 24-24-10.745-24-24zm272 256c-20.183 0-29.485-39.293-33.931-57.795-5.206-21.666-10.589-44.07-25.393-58.902-32.469-32.524-49.503-73.967-89.117-113.111a11.98 11.98 0 0 1-3.558-8.521V59.901c0-6.541 5.243-11.878 11.783-11.998 15.831-.29 36.694-9.079 52.651-16.178C256.189 17.598 295.709.017 343.995 0h2.844c42.777 0 93.363.413 113.774 29.737 8.392 12.057 10.446 27.034 6.148 44.632 16.312 17.053 25.063 48.863 16.382 74.757 17.544 23.432 19.143 56.132 9.308 79.469l.11.11c11.893 11.949 19.523 31.259 19.439 49.197-.156 30.352-26.157 58.098-59.553 58.098H350.723C358.03 364.34 384 388.132 384 430.548 384 504 336 512 312 512z"
					}
				}
			]
		}
	},
	{
		"name": "pinned",
		"shape": {
			"element": "svg",
			"attributes": {
				"focusable": "false",
				"data-prefix": "fas",
				"data-icon": "thumbtack",
				"role": "img",
				"xmls": "http://www.w3.org/2000/svg",
				"viewBox": "0 0 384 512",
				"class": "svg-inline--fa fa-thumbstack fa-w-12 fa-sm",
				"aria-hidden": "true"
			},
			"children": [
				{
					"element": "path",
					"attributes": {
						"fill": "currentColor",
						"d": "M298.028 214.267L285.793 96H328c13.255 0 24-10.745 24-24V24c0-13.255-10.745-24-24-24H56C42.745 0 32 10.745 32 24v48c0 13.255 10.745 24 24 24h42.207L85.972 214.267C37.465 236.82 0 277.261 0 328c0 13.255 10.745 24 24 24h136v104.007c0 1.242.289 2.467.845 3.578l24 48c2.941 5.882 11.364 5.893 14.311 0l24-48a8.008 8.008 0 0 0 .845-3.578V352h136c13.255 0 24-10.745 24-24-.001-51.183-37.983-91.42-85.973-113.733z"
					}
				}
			]
		}
	}
]
.forEach(inlineSVG => {
	svgAssets2[inlineSVG.name] = svgShape(inlineSVG.shape.element,false,inlineSVG.shape.attributes,inlineSVG.shape.children,inlineSVG.shape.content)
})

const statusTypes = {
	"COMPLETED" : translate("$mediaStatus_completed"),
	"CURRENT"   : translate("$mediaStatus_current"),
	"PAUSED"    : translate("$mediaStatus_paused"),
	"DROPPED"   : translate("$mediaStatus_dropped"),
	"PLANNING"  : translate("$mediaStatus_planning"),
	"REPEATING" : translate("$mediaStatus_repeating")
};

//semantic order, from "very positive", completed, to "very negative", dropped.
//planning is a neutral in the middle.
//repeating is kinda like a middle ground between current and completed
const semmanticStatusOrder = ["COMPLETED","REPEATING","CURRENT","PLANNING","PAUSED","DROPPED"];

const distributionColours = {
	"COMPLETED" : "rgb(104, 214,  57)",
	"CURRENT"   : "rgb(  2, 169, 255)",
	"PAUSED"    : "rgb(247, 121, 164)",
	"DROPPED"   : "rgb(232,  93, 117)",
	"PLANNING"  : "rgb(247, 154,  99)",
	"REPEATING" : "violet"
};

const distributionFormats = {
	"TV" : translate("$mediaFormat_TV"),
	"TV_SHORT" : translate("$mediaFormat_TV_SHORT"),
	"MOVIE" : translate("$mediaFormat_MOVIE"),
	"SPECIAL" : translate("$mediaFormat_SPECIAL"),
	"OVA" : translate("$mediaFormat_OVA"),
	"ONA" : translate("$mediaFormat_ONA"),
	"MUSIC" : translate("$mediaFormat_MUSIC"),
	"MANGA" : translate("$mediaFormat_MANGA"),
	"NOVEL" : translate("$mediaFormat_NOVEL"),
	"ONE_SHOT" : translate("$mediaFormat_ONE_SHOT")
};

const distributionStatus = {
	"FINISHED" : translate("$mediaReleaseStatus_finished",null,"Finished"),
	"RELEASING" : translate("$mediaReleaseStatus_releasing",null,"Releasing"),
	"NOT_YET_RELEASED" : translate("$mediaReleaseStatus_notYetReleased",null,"Not Yet Released"),
	"CANCELLED" : translate("$mediaReleaseStatus_cancelled",null,"Cancelled"),
	"HIATUS"    : translate("$mediaReleaseStatus_hiatus",null,"Hiatus"),
	anime: {
		"FINISHED" : translate("$mediaReleaseStatusAnime_finished",null,"Finished"),
		"RELEASING" : translate("$mediaReleaseStatusAnime_releasing",null,"Releasing"),
		"NOT_YET_RELEASED" : translate("$mediaReleaseStatusAnime_notYetReleased",null,"Not Yet Released"),
		"CANCELLED" : translate("$mediaReleaseStatusAnime_cancelled",null,"Cancelled"),
		"HIATUS"    : translate("$mediaReleaseStatusAnime_hiatus",null,"Hiatus"),
	},
	manga: {
		"FINISHED" : translate("$mediaReleaseStatusManga_finished",null,"Finished"),
		"RELEASING" : translate("$mediaReleaseStatusManga_releasing",null,"Releasing"),
		"NOT_YET_RELEASED" : translate("$mediaReleaseStatusManga_notYetReleased",null,"Not Yet Released"),
		"CANCELLED" : translate("$mediaReleaseStatusManga_cancelled",null,"Cancelled"),
		"HIATUS"    : translate("$mediaReleaseStatusManga_hiatus",null,"Hiatus"),
	}
};

const categoryColours = new Map([
	[1,"rgb(0, 170, 255)"],
	[2,"rgb(76, 175, 80)"],
	[3,"rgb(75, 179, 185)"],
	[4,"rgb(75, 179, 185)"],
	[5,"rgb(103, 58, 183)"],
	[7,"rgb(78, 163, 230)"],
	[8,"rgb(0, 150, 136)"],
	[9,"rgb(96, 125, 139)"],
	[10,"rgb(36, 36, 169)"],
	[11,"rgb(251, 71, 30)"],
	[12,"rgb(239, 48, 81)"],
	[13,"rgb(233, 30, 99)"],
	[15,"rgb(184, 90, 199)"],
	[16,"rgb(255, 152, 0)"],
	[17,"rgb(121, 85, 72)"],
	[18,"rgb(43, 76, 105)"]
]);

if(useScripts.colourPicker && (!useScripts.mobileFriendly)){
	let colourStyle = create("style");
	colourStyle.id = "colour-picker-styles";
	colourStyle.type = "text/css";
	documentHead.appendChild(colourStyle);
	const basicStyles = `
.footer .links{
	margin-left: calc(0px + 1%);
	transform: translate(0px,10px);
}
.hohColourPicker .hohCheckbox{
	margin-left: 10px;
}
`;
	if(Array.isArray(useScripts.colourSettings)){//legacy styles
		let newObjectStyle = {};
		useScripts.colourSettings.forEach(
			colour => newObjectStyle[colour.colour] = {
				initial: colour.initial,
				dark: colour.dark,
				contrast: colour.contrast
			}
		);
		useScripts.colourSettings = newObjectStyle;
		useScripts.save()
	}
	let applyColourStyles = function(){
		colourStyle.textContent = basicStyles;//eh, fix later.
		Object.keys(useScripts.colourSettings).forEach(key => {
			let colour = useScripts.colourSettings[key];
			let hexToRgb = function(hex){
				let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? [
					parseInt(result[1],16),
					parseInt(result[2],16),
					parseInt(result[3],16)
				] : null;
			}
			if(colour.initial){
				colourStyle.textContent += `:root{${key}:${hexToRgb(colour.initial).join(",")};}`
			}
			if(colour.dark){
				colourStyle.textContent += `.site-theme-dark{${key}:${hexToRgb(colour.dark).join(",")};}`
			}
			if(colour.contrast){
				colourStyle.textContent += `.site-theme-contrast{${key}:${hexToRgb(colour.contrast).join(",")};}`
			}
		})
	};applyColourStyles();
	let adder = function(){
		let colourPickerLocation = document.querySelector("#app > .wrap > .footer > .container");
		if(colourPickerLocation){
			const supportedColours = [
				"--color-background",
				"--color-foreground",
				"--color-foreground-grey",
				"--color-foreground-grey-dark",
				"--color-foreground-blue",
				"--color-foreground-blue-dark",
				"--color-background-blue-dark",
				"--color-overlay",
				"--color-shadow",
				"--color-shadow-dark",
				"--color-text",
				"--color-text-light",
				"--color-text-lighter",
				"--color-text-bright",
				"--color-blue",
				"--color-blue-dim",
				"--color-white",
				"--color-black",
				"--color-red",
				"--color-peach",
				"--color-orange",
				"--color-yellow",
				"--color-green"
			];
			let cpContainer = create("div","hohColourPicker",false,colourPickerLocation);
			let cpTitle = create("h2",false,translate("$adjustColours_title"),cpContainer);
			let cpInput = create("input",false,false,cpContainer);
			cpInput.type = "color";
			let cpSelector = create("select",false,false,cpContainer);
			supportedColours.forEach(colour => {
				let option = create("option",false,colour,cpSelector);
				option.value = colour;
			});
			let cpDomain = create("p",false,false,cpContainer);
			let cpInitialBox = createCheckbox(cpDomain);
			create("span",false,translate("$theme_default"),cpDomain);
			let cpDarkBox = createCheckbox(cpDomain);
			create("span",false,translate("$theme_dark"),cpDomain);
			let cpContrastBox = createCheckbox(cpDomain);
			create("span",false,translate("$theme_highContrast"),cpDomain);
			let cpSelectorChanger = function(){
				if(useScripts.colourSettings[cpSelector.value]){
					cpInitialBox.checked  = !!useScripts.colourSettings[cpSelector.value].initial;
					cpDarkBox.checked     = !!useScripts.colourSettings[cpSelector.value].dark;
					cpContrastBox.checked = !!useScripts.colourSettings[cpSelector.value].contrast;
					cpInput.value = useScripts.colourSettings[cpSelector.value].initial
				}
				cpInitialBox.checked = false;
				cpDarkBox.checked = false;
				cpContrastBox.checked = false;
			};
			cpSelector.onchange = cpSelectorChanger;
			let colourChanger = function(){
				useScripts.colourSettings[cpSelector.value] = {
					"initial" :  (cpInitialBox.checked  ? cpInput.value : false),
					"dark" :     (cpDarkBox.checked     ? cpInput.value : false),
					"contrast" : (cpContrastBox.checked ? cpInput.value : false)
				}
				applyColourStyles();
				useScripts.save()
			};
			cpInput.onchange = colourChanger;
			cpInitialBox.onchange = colourChanger;
			cpDarkBox.onchange = colourChanger;
			cpContrastBox.onchange = colourChanger;
			cpSelectorChanger()
		}
		else{
			setTimeout(adder,1000)
		}
	};
	adder()
}



function scoreFormatter(score,format){
	let scoreElement = create("span","hohScore");
	if(format === "POINT_100"){
		scoreElement.innerText = score + "/100"
	}
	else if(
		format === "POINT_10_DECIMAL"
		|| format === "POINT_10"
	){
		scoreElement.innerText = score + "/10"
	}
	else if(format === "POINT_3"){
		scoreElement.classList.add("hohSmiley");
		if(score === 3){
			scoreElement.appendChild(svgAssets2.smile.cloneNode(true));
		}
		else if(score === 2){
			scoreElement.appendChild(svgAssets2.meh.cloneNode(true));
		}
		else if(score === 1){
			scoreElement.appendChild(svgAssets2.frown.cloneNode(true));
		}
	}
	else if(format === "POINT_5"){
		scoreElement.innerText = score;
		scoreElement.appendChild(svgAssets2.star.cloneNode(true));
	}
	else{//future types. Just gambling that they look okay in plain text
		scoreElement.innerText = score
	}
	return scoreElement
}

function convertScore(score,format){
	if(format === "POINT_100"){
		return score
	}
	else if(
		format === "POINT_10_DECIMAL" ||
		format === "POINT_10"
	){
		return score*10
	}
	else if(format === "POINT_3"){
		if(score === 3){
			return 85
		}
		else if(score === 2){
			return 60
		}
		else if(score === 1){
			return 35
		}
		return 0
	}
	else if(format === "POINT_5"){
		if(score === 0){
			return 0
		}
		return score*20 - 10
	}
}

function saveAs(data,fileName,pureText){
	let link = create("a");
	document.body.appendChild(link);
	let json = pureText ? data : JSON.stringify(data);
	let blob = new Blob([json],{type: "octet/stream"});
	let url = window.URL.createObjectURL(blob);
	link.href = url;
	link.download = fileName || translate("$default_filename");
	link.click();
	window.URL.revokeObjectURL(url);
	document.body.removeChild(link)
}


function levDist(s,t){//https://stackoverflow.com/a/11958496/5697837
	// Step 1
	s = s.replace("’", "'")
	t = t.replace("’", "'")
	let n = s.length;
	let m = t.length;
	if(!n){
		return m
	}
	if(!m){
		return n
	}
	let d = []; //2d matrix
	for(var i = n; i >= 0; i--) d[i] = [];
	// Step 2
	for(var i = n; i >= 0; i--) d[i][0] = i;
	for(var j = m; j >= 0; j--) d[0][j] = j;
	// Step 3
	for(var i = 1; i <= n; i++){
		let s_i = s.charAt(i - 1);
		// Step 4
		for(var j = 1; j <= m; j++){
			//Check the jagged ld total so far
			if(i === j && d[i][j] > 4){
				return n
			}
			let t_j = t.charAt(j - 1);
			let cost = (s_i === t_j) ? 0 : 1; // Step 5
			//Calculate the minimum
			let mi = d[i - 1][j] + 1;
			let b = d[i][j - 1] + 1;
			let c = d[i - 1][j - 1] + cost;
			if(b < mi){
				mi = b
			}
			if(c < mi){
				mi = c;
			}
			d[i][j] = mi; // Step 6
			//Damerau transposition
			/*if (i > 1 && j > 1 && s_i === t.charAt(j - 2) && s.charAt(i - 2) === t_j) {
				d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
			}*/
		}
	}
	return d[n][m]
}


// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  compressToBase64 : function (input) {
    if (input == null) return "";
    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
    switch (res.length % 4) { // To produce valid Base64
    default: // When could this happen ?
    case 0 : return res;
    case 1 : return res+"===";
    case 2 : return res+"==";
    case 3 : return res+"=";
    }
  },

  decompressFromBase64 : function (input) {
    if (input == null) return "";
    if (input == "") return null;
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  },

  compressToUTF16 : function (input) {
    if (input == null) return "";
    return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  },

  decompressFromUTF16: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  },

  //compress into uint8array (UCS-2 big endian format)
  compressToUint8Array: function (uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
      var current_value = compressed.charCodeAt(i);
      buf[i*2] = current_value >>> 8;
      buf[i*2+1] = current_value % 256;
    }
    return buf;
  },

  //decompress from uint8array (UCS-2 big endian format)
  decompressFromUint8Array:function (compressed) {
    if (compressed===null || compressed===undefined){
        return LZString.decompress(compressed);
    } else {
        var buf=new Array(compressed.length/2); // 2 bytes per character
        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
          buf[i]=compressed[i*2]*256+compressed[i*2+1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));

    }

  },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();

if (typeof define === 'function' && define.amd) {
  define(function () { return LZString; });
} else if( typeof module !== 'undefined' && module != null ) {
  module.exports = LZString
}


/*!
    localForage -- Offline Storage, Improved
    Version 1.9.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
'use strict';
var immediate = _dereq_(1);

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"1":1}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';
if (typeof global.Promise !== 'function') {
  global.Promise = _dereq_(2);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"2":2}],4:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getIDB() {
    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
    try {
        if (typeof indexedDB !== 'undefined') {
            return indexedDB;
        }
        if (typeof webkitIndexedDB !== 'undefined') {
            return webkitIndexedDB;
        }
        if (typeof mozIndexedDB !== 'undefined') {
            return mozIndexedDB;
        }
        if (typeof OIndexedDB !== 'undefined') {
            return OIndexedDB;
        }
        if (typeof msIndexedDB !== 'undefined') {
            return msIndexedDB;
        }
    } catch (e) {
        return;
    }
}

var idb = getIDB();

function isIndexedDBValid() {
    try {
        // Initialize IndexedDB; fall back to vendor-prefixed versions
        // if needed.
        if (!idb || !idb.open) {
            return false;
        }
        // We mimic PouchDB here;
        //
        // We test for openDatabase because IE Mobile identifies itself
        // as Safari. Oh the lulz...
        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

        // Safari <10.1 does not meet our requirements for IDB support
        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
        // Safari 10.1 shipped with fetch, we can use that to detect it.
        // Note: this creates issues with `window.fetch` polyfills and
        // overrides; see:
        // https://github.com/localForage/localForage/issues/856
        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        // See: https://github.com/mozilla/localForage/issues/128
        // See: https://github.com/mozilla/localForage/issues/272
        typeof IDBKeyRange !== 'undefined';
    } catch (e) {
        return false;
    }
}

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
function createBlob(parts, properties) {
    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
    parts = parts || [];
    properties = properties || {};
    try {
        return new Blob(parts, properties);
    } catch (e) {
        if (e.name !== 'TypeError') {
            throw e;
        }
        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
        var builder = new Builder();
        for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
        }
        return builder.getBlob(properties.type);
    }
}

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
if (typeof Promise === 'undefined') {
    // In the "nopromises" build this will just throw if you don't have
    // a global promise object, but it would throw anyway later.
    _dereq_(3);
}
var Promise$1 = Promise;

function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}

function executeTwoCallbacks(promise, callback, errorCallback) {
    if (typeof callback === 'function') {
        promise.then(callback);
    }

    if (typeof errorCallback === 'function') {
        promise["catch"](errorCallback);
    }
}

function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + ' used as a key, but it is not a string.');
        key = String(key);
    }

    return key;
}

function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
var supportsBlobs = void 0;
var dbContexts = {};
var toString = Object.prototype.toString;

// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
function _binStringToArrayBuffer(bin) {
    var length = bin.length;
    var buf = new ArrayBuffer(length);
    var arr = new Uint8Array(buf);
    for (var i = 0; i < length; i++) {
        arr[i] = bin.charCodeAt(i);
    }
    return buf;
}

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
function _checkBlobSupportWithoutCaching(idb) {
    return new Promise$1(function (resolve) {
        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
        var blob = createBlob(['']);
        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

        txn.onabort = function (e) {
            // If the transaction aborts now its due to not being able to
            // write to the database, likely due to the disk being full
            e.preventDefault();
            e.stopPropagation();
            resolve(false);
        };

        txn.oncomplete = function () {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            // MS Edge pretends to be Chrome 42:
            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
        };
    })["catch"](function () {
        return false; // error, so assume unsupported
    });
}

function _checkBlobSupport(idb) {
    if (typeof supportsBlobs === 'boolean') {
        return Promise$1.resolve(supportsBlobs);
    }
    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
        supportsBlobs = value;
        return supportsBlobs;
    });
}

function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Create a deferred object representing the current database operation.
    var deferredOperation = {};

    deferredOperation.promise = new Promise$1(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });

    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);

    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    } else {
        dbContext.dbReady = dbContext.dbReady.then(function () {
            return deferredOperation.promise;
        });
    }
}

function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}

function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];

    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();

    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}

function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise$1(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            } else {
                return resolve(dbInfo.db);
            }
        }

        var dbArgs = [dbInfo.name];

        if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
        }

        var openreq = idb.open.apply(idb, dbArgs);

        if (upgradeNeeded) {
            openreq.onupgradeneeded = function (e) {
                var db = openreq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                        // Added when support for blob shims was added
                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                        throw ex;
                    }
                }
            };
        }

        openreq.onerror = function (e) {
            e.preventDefault();
            reject(openreq.error);
        };

        openreq.onsuccess = function () {
            resolve(openreq.result);
            _advanceReadiness(dbInfo);
        };
    });
}

function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}

function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}

function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }

    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;

    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }

    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }

        return true;
    }

    return false;
}

// encode a blob for indexeddb engines that don't support blobs
function _encodeBlob(blob) {
    return new Promise$1(function (resolve, reject) {
        var reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = function (e) {
            var base64 = btoa(e.target.result || '');
            resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
            });
        };
        reader.readAsBinaryString(blob);
    });
}

// decode an encoded blob
function _decodeBlob(encodedBlob) {
    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
    return createBlob([arrayBuff], { type: encodedBlob.type });
}

// is this one of our fancy encoded blobs?
function _isEncodedBlob(value) {
    return value && value.__local_forage_encoded_blob;
}

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
function _fullyReady(callback) {
    var self = this;

    var promise = self._initReady().then(function () {
        var dbContext = dbContexts[self._dbInfo.name];

        if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
        }
    });

    executeTwoCallbacks(promise, callback, callback);
    return promise;
}

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);

    var dbContext = dbContexts[dbInfo.name];
    var forages = dbContext.forages;

    for (var i = 0; i < forages.length; i++) {
        var forage = forages[i];
        if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
        }
    }
    dbInfo.db = null;

    return _getOriginalConnection(dbInfo).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
        for (var i = 0; i < forages.length; i++) {
            forages[i]._dbInfo.db = db;
        }
    })["catch"](function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }

    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    } catch (err) {
        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
            return Promise$1.resolve().then(function () {
                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            }).then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })["catch"](callback);
        }

        callback(err);
    }
}

function createDbContext() {
    return {
        // Running localForages sharing a database.
        forages: [],
        // Shared database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    // Get the current context of the database;
    var dbContext = dbContexts[dbInfo.name];

    // ...or create a new context.
    if (!dbContext) {
        dbContext = createDbContext();
        // Register the new context in the global container.
        dbContexts[dbInfo.name] = dbContext;
    }

    // Register itself as a running localForage in the current context.
    dbContext.forages.push(self);

    // Replace the default `ready()` function with the specialized one.
    if (!self._initReady) {
        self._initReady = self.ready;
        self.ready = _fullyReady;
    }

    // Create an array of initialization states of the related localForages.
    var initPromises = [];

    function ignoreErrors() {
        // Don't handle errors here,
        // just makes sure related localForages aren't pending.
        return Promise$1.resolve();
    }

    for (var j = 0; j < dbContext.forages.length; j++) {
        var forage = dbContext.forages[j];
        if (forage !== self) {
            // Don't wait for itself...
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
        }
    }

    // Take a snapshot of the related localForages.
    var forages = dbContext.forages.slice(0);

    // Initialize the connection process only when
    // all the related localForages aren't pending.
    return Promise$1.all(initPromises).then(function () {
        dbInfo.db = dbContext.db;
        // Get the connection or open a new one without upgrade.
        return _getOriginalConnection(dbInfo);
    }).then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    }).then(function (db) {
        dbInfo.db = dbContext.db = db;
        self._dbInfo = dbInfo;
        // Share the final connection amongst related localForages.
        for (var k = 0; k < forages.length; k++) {
            var forage = forages[k];
            if (forage !== self) {
                // Self is already up-to-date.
                forage._dbInfo.db = dbInfo.db;
                forage._dbInfo.version = dbInfo.version;
            }
        }
    });
}

function getItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.get(key);

                    req.onsuccess = function () {
                        var value = req.result;
                        if (value === undefined) {
                            value = null;
                        }
                        if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                        }
                        resolve(value);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items stored in database.
function iterate(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openCursor();
                    var iterationNumber = 1;

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (cursor) {
                            var value = cursor.value;
                            if (_isEncodedBlob(value)) {
                                value = _decodeBlob(value);
                            }
                            var result = iterator(value, cursor.key, iterationNumber++);

                            // when the iterator callback returns any
                            // (non-`undefined`) value, then we stop
                            // the iteration immediately
                            if (result !== void 0) {
                                resolve(result);
                            } else {
                                cursor["continue"]();
                            }
                        } else {
                            resolve();
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);

    return promise;
}

function setItem(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        var dbInfo;
        self.ready().then(function () {
            dbInfo = self._dbInfo;
            if (toString.call(value) === '[object Blob]') {
                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                    if (blobSupport) {
                        return value;
                    }
                    return _encodeBlob(value);
                });
            }
            return value;
        }).then(function (value) {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);

                    // The reason we don't _save_ null is because IE 10 does
                    // not support saving the `null` type in IndexedDB. How
                    // ironic, given the bug below!
                    // See: https://github.com/mozilla/localForage/issues/161
                    if (value === null) {
                        value = undefined;
                    }

                    var req = store.put(value, key);

                    transaction.oncomplete = function () {
                        // Cast to undefined so the value passed to
                        // callback/promise is the same as what one would get out
                        // of `getItem()` later. This leads to some weirdness
                        // (setItem('foo', undefined) will return `null`), but
                        // it's not my fault localStorage is our baseline and that
                        // it's weird.
                        if (value === undefined) {
                            value = null;
                        }

                        resolve(value);
                    };
                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function removeItem(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    // We use a Grunt task to make this safe for IE and some
                    // versions of Android (including those used by Cordova).
                    // Normally IE won't like `.delete()` and will insist on
                    // using `['delete']()`, but we have a build step that
                    // fixes this for us now.
                    var req = store["delete"](key);
                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onerror = function () {
                        reject(req.error);
                    };

                    // The request will be also be aborted if we've exceeded our storage
                    // space.
                    transaction.onabort = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function clear(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.clear();

                    transaction.oncomplete = function () {
                        resolve();
                    };

                    transaction.onabort = transaction.onerror = function () {
                        var err = req.error ? req.error : req.transaction.error;
                        reject(err);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function length(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.count();

                    req.onsuccess = function () {
                        resolve(req.result);
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function key(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        if (n < 0) {
            resolve(null);

            return;
        }

        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var advanced = false;
                    var req = store.openKeyCursor();

                    req.onsuccess = function () {
                        var cursor = req.result;
                        if (!cursor) {
                            // this means there weren't enough keys
                            resolve(null);

                            return;
                        }

                        if (n === 0) {
                            // We have the first key, return it if that's what they
                            // wanted.
                            resolve(cursor.key);
                        } else {
                            if (!advanced) {
                                // Otherwise, ask the cursor to skip ahead n
                                // records.
                                advanced = true;
                                cursor.advance(n);
                            } else {
                                // When we get here, we've got the nth key.
                                resolve(cursor.key);
                            }
                        }
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                if (err) {
                    return reject(err);
                }

                try {
                    var store = transaction.objectStore(self._dbInfo.storeName);
                    var req = store.openKeyCursor();
                    var keys = [];

                    req.onsuccess = function () {
                        var cursor = req.result;

                        if (!cursor) {
                            resolve(keys);
                            return;
                        }

                        keys.push(cursor.key);
                        cursor["continue"]();
                    };

                    req.onerror = function () {
                        reject(req.error);
                    };
                } catch (e) {
                    reject(e);
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
            }
            return db;
        });

        if (!options.storeName) {
            promise = dbPromise.then(function (db) {
                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                }

                var dropDBPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.deleteDatabase(options.name);

                    req.onerror = req.onblocked = function (err) {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        reject(err);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        if (db) {
                            db.close();
                        }
                        resolve(db);
                    };
                });

                return dropDBPromise.then(function (db) {
                    dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        var _forage = forages[i];
                        _advanceReadiness(_forage._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        } else {
            promise = dbPromise.then(function (db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                    return;
                }

                var newVersion = db.version + 1;

                _deferReadiness(options);

                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;

                db.close();
                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    forage._dbInfo.db = null;
                    forage._dbInfo.version = newVersion;
                }

                var dropObjectPromise = new Promise$1(function (resolve, reject) {
                    var req = idb.open(options.name, newVersion);

                    req.onerror = function (err) {
                        var db = req.result;
                        db.close();
                        reject(err);
                    };

                    req.onupgradeneeded = function () {
                        var db = req.result;
                        db.deleteObjectStore(options.storeName);
                    };

                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        resolve(db);
                    };
                });

                return dropObjectPromise.then(function (db) {
                    dbContext.db = db;
                    for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db;
                        _advanceReadiness(_forage2._dbInfo);
                    }
                })["catch"](function (err) {
                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                    throw err;
                });
            });
        }
    }

    executeCallback(promise, callback);
    return promise;
}

var asyncStorage = {
    _driver: 'asyncStorage',
    _initStorage: _initStorage,
    _support: isIndexedDBValid(),
    iterate: iterate,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys,
    dropInstance: dropInstance
};

function isWebSQLValid() {
    return typeof openDatabase === 'function';
}

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var BLOB_TYPE_PREFIX = '~~local_forage_type~';
var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

var SERIALIZED_MARKER = '__lfsc__:';
var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
var TYPE_ARRAYBUFFER = 'arbf';
var TYPE_BLOB = 'blob';
var TYPE_INT8ARRAY = 'si08';
var TYPE_UINT8ARRAY = 'ui08';
var TYPE_UINT8CLAMPEDARRAY = 'uic8';
var TYPE_INT16ARRAY = 'si16';
var TYPE_INT32ARRAY = 'si32';
var TYPE_UINT16ARRAY = 'ur16';
var TYPE_UINT32ARRAY = 'ui32';
var TYPE_FLOAT32ARRAY = 'fl32';
var TYPE_FLOAT64ARRAY = 'fl64';
var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

var toString$1 = Object.prototype.toString;

function stringToBuffer(serializedString) {
    // Fill the string into a ArrayBuffer.
    var bufferLength = serializedString.length * 0.75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;

    if (serializedString[serializedString.length - 1] === '=') {
        bufferLength--;
        if (serializedString[serializedString.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

        /*jslint bitwise: true */
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
}

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
function bufferToString(buffer) {
    // base64-arraybuffer
    var bytes = new Uint8Array(buffer);
    var base64String = '';
    var i;

    for (i = 0; i < bytes.length; i += 3) {
        /*jslint bitwise: true */
        base64String += BASE_CHARS[bytes[i] >> 2];
        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64String += BASE_CHARS[bytes[i + 2] & 63];
    }

    if (bytes.length % 3 === 2) {
        base64String = base64String.substring(0, base64String.length - 1) + '=';
    } else if (bytes.length % 3 === 1) {
        base64String = base64String.substring(0, base64String.length - 2) + '==';
    }

    return base64String;
}

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
function serialize(value, callback) {
    var valueType = '';
    if (value) {
        valueType = toString$1.call(value);
    }

    // Cannot use `value instanceof ArrayBuffer` or such here, as these
    // checks fail when running the tests using casper.js...
    //
    // TODO: See why those tests fail and use a better solution.
    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
        // Convert binary arrays to a string and prefix the string with
        // a special marker.
        var buffer;
        var marker = SERIALIZED_MARKER;

        if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
        } else {
            buffer = value.buffer;

            if (valueType === '[object Int8Array]') {
                marker += TYPE_INT8ARRAY;
            } else if (valueType === '[object Uint8Array]') {
                marker += TYPE_UINT8ARRAY;
            } else if (valueType === '[object Uint8ClampedArray]') {
                marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === '[object Int16Array]') {
                marker += TYPE_INT16ARRAY;
            } else if (valueType === '[object Uint16Array]') {
                marker += TYPE_UINT16ARRAY;
            } else if (valueType === '[object Int32Array]') {
                marker += TYPE_INT32ARRAY;
            } else if (valueType === '[object Uint32Array]') {
                marker += TYPE_UINT32ARRAY;
            } else if (valueType === '[object Float32Array]') {
                marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === '[object Float64Array]') {
                marker += TYPE_FLOAT64ARRAY;
            } else {
                callback(new Error('Failed to get type for BinaryArray'));
            }
        }

        callback(marker + bufferToString(buffer));
    } else if (valueType === '[object Blob]') {
        // Conver the blob to a binaryArray and then to a string.
        var fileReader = new FileReader();

        fileReader.onload = function () {
            // Backwards-compatible prefix for the blob type.
            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
        };

        fileReader.readAsArrayBuffer(value);
    } else {
        try {
            callback(JSON.stringify(value));
        } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);

            callback(null, e);
        }
    }
}

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
function deserialize(value) {
    // If we haven't marked this string as being specially serialized (i.e.
    // something other than serialized JSON), we can just return it and be
    // done with it.
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
        return JSON.parse(value);
    }

    // The following code deals with deserializing some kind of Blob or
    // TypedArray. First we separate out the type of data we're dealing
    // with from the data itself.
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

    var blobType;
    // Backwards-compatible blob type serialization strategy.
    // DBs created with older versions of localForage will simply not have the blob type.
    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
        blobType = matcher[1];
        serializedString = serializedString.substring(matcher[0].length);
    }
    var buffer = stringToBuffer(serializedString);

    // Return the right type based on the code/type set during
    // serialization.
    switch (type) {
        case TYPE_ARRAYBUFFER:
            return buffer;
        case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
        case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
        case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
        case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
        case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
        case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
        case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
        case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
        case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
        case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
        default:
            throw new Error('Unkown type: ' + type);
    }
}

var localforageSerializer = {
    serialize: serialize,
    deserialize: deserialize,
    stringToBuffer: stringToBuffer,
    bufferToString: bufferToString
};

/*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function createDbTable(t, dbInfo, callback, errorCallback) {
    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
}

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
function _initStorage$1(options) {
    var self = this;
    var dbInfo = {
        db: null
    };

    if (options) {
        for (var i in options) {
            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
        }
    }

    var dbInfoPromise = new Promise$1(function (resolve, reject) {
        // Open the database; the openDatabase API will automatically
        // create it for us if it doesn't exist.
        try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
        } catch (e) {
            return reject(e);
        }

        // Create our key/value table if it doesn't exist.
        dbInfo.db.transaction(function (t) {
            createDbTable(t, dbInfo, function () {
                self._dbInfo = dbInfo;
                resolve();
            }, function (t, error) {
                reject(error);
            });
        }, reject);
    });

    dbInfo.serializer = localforageSerializer;
    return dbInfoPromise;
}

function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
    t.executeSql(sqlStatement, args, callback, function (t, error) {
        if (error.code === error.SYNTAX_ERR) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                if (!results.rows.length) {
                    // if the table is missing (was deleted)
                    // re-create it table and retry
                    createDbTable(t, dbInfo, function () {
                        t.executeSql(sqlStatement, args, callback, errorCallback);
                    }, errorCallback);
                } else {
                    errorCallback(t, error);
                }
            }, errorCallback);
        } else {
            errorCallback(t, error);
        }
    }, errorCallback);
}

function getItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;

                    // Check to see if this is serialized content we need to
                    // unpack.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function iterate$1(iterator, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;

            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                    var rows = results.rows;
                    var length = rows.length;

                    for (var i = 0; i < length; i++) {
                        var item = rows.item(i);
                        var result = item.value;

                        // Check to see if this is serialized content
                        // we need to unpack.
                        if (result) {
                            result = dbInfo.serializer.deserialize(result);
                        }

                        result = iterator(result, item.key, i + 1);

                        // void(0) prevents problems with redefinition
                        // of `undefined`.
                        if (result !== void 0) {
                            resolve(result);
                            return;
                        }
                    }

                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function _setItem(key, value, callback, retriesLeft) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            // The localStorage API doesn't return undefined values in an
            // "expected" way, so undefined is always cast to null in all
            // drivers. See: https://github.com/mozilla/localForage/pull/42
            if (value === undefined) {
                value = null;
            }

            // Save the original value to pass to the callback.
            var originalValue = value;

            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    dbInfo.db.transaction(function (t) {
                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                            resolve(originalValue);
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        // The transaction failed; check
                        // to see if it's a quota error.
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                            // We reject the callback outright for now, but
                            // it's worth trying to re-run the transaction.
                            // Even if the user accepts the prompt to use
                            // more storage on Safari, this error will
                            // be called.
                            //
                            // Try to re-run the transaction.
                            if (retriesLeft > 0) {
                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                return;
                            }
                            reject(sqlError);
                        }
                    });
                }
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function setItem$1(key, value, callback) {
    return _setItem.apply(this, [key, value, callback, 1]);
}

function removeItem$1(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
function clear$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                    resolve();
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
function length$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                // Ahhh, SQL makes this one soooooo easy.
                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
function key$1(n, callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$1(callback) {
    var self = this;

    var promise = new Promise$1(function (resolve, reject) {
        self.ready().then(function () {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function (t) {
                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                    var keys = [];

                    for (var i = 0; i < results.rows.length; i++) {
                        keys.push(results.rows.item(i).key);
                    }

                    resolve(keys);
                }, function (t, error) {
                    reject(error);
                });
            });
        })["catch"](reject);
    });

    executeCallback(promise, callback);
    return promise;
}

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
function getAllStoreNames(db) {
    return new Promise$1(function (resolve, reject) {
        db.transaction(function (t) {
            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                var storeNames = [];

                for (var i = 0; i < results.rows.length; i++) {
                    storeNames.push(results.rows.item(i).name);
                }

                resolve({
                    db: db,
                    storeNames: storeNames
                });
            }, function (t, error) {
                reject(error);
            });
        }, function (sqlError) {
            reject(sqlError);
        });
    });
}

function dropInstance$1(options, callback) {
    callback = getCallback.apply(this, arguments);

    var currentConfig = this.config();
    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            var db;
            if (options.name === currentConfig.name) {
                // use the db reference of the current instance
                db = self._dbInfo.db;
            } else {
                db = openDatabase(options.name, '', '', 0);
            }

            if (!options.storeName) {
                // drop all database tables
                resolve(getAllStoreNames(db));
            } else {
                resolve({
                    db: db,
                    storeNames: [options.storeName]
                });
            }
        }).then(function (operationInfo) {
            return new Promise$1(function (resolve, reject) {
                operationInfo.db.transaction(function (t) {
                    function dropTable(storeName) {
                        return new Promise$1(function (resolve, reject) {
                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    }

                    var operations = [];
                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                        operations.push(dropTable(operationInfo.storeNames[i]));
                    }

                    Promise$1.all(operations).then(function () {
                        resolve();
                    })["catch"](function (e) {
                        reject(e);
                    });
                }, function (sqlError) {
                    reject(sqlError);
                });
            });
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var webSQLStorage = {
    _driver: 'webSQLStorage',
    _initStorage: _initStorage$1,
    _support: isWebSQLValid(),
    iterate: iterate$1,
    getItem: getItem$1,
    setItem: setItem$1,
    removeItem: removeItem$1,
    clear: clear$1,
    length: length$1,
    key: key$1,
    keys: keys$1,
    dropInstance: dropInstance$1
};

function isLocalStorageValid() {
    try {
        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
        // in IE8 typeof localStorage.setItem === 'object'
        !!localStorage.setItem;
    } catch (e) {
        return false;
    }
}

function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + '/';

    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + '/';
    }
    return keyPrefix;
}

// Check if localStorage throws when saving an item
function checkIfLocalStorageThrows() {
    var localStorageTestKey = '_localforage_support_test';

    try {
        localStorage.setItem(localStorageTestKey, true);
        localStorage.removeItem(localStorageTestKey);

        return false;
    } catch (e) {
        return true;
    }
}

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
function _isLocalStorageUsable() {
    return !checkIfLocalStorageThrows() || localStorage.length > 0;
}

// Config the localStorage backend, using options set in the config.
function _initStorage$2(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }

    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

    if (!_isLocalStorageUsable()) {
        return Promise$1.reject();
    }

    self._dbInfo = dbInfo;
    dbInfo.serializer = localforageSerializer;

    return Promise$1.resolve();
}

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
function clear$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var keyPrefix = self._dbInfo.keyPrefix;

        for (var i = localStorage.length - 1; i >= 0; i--) {
            var key = localStorage.key(i);

            if (key.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
function getItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result = localStorage.getItem(dbInfo.keyPrefix + key);

        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = dbInfo.serializer.deserialize(result);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

// Iterate over all items in the store.
function iterate$2(iterator, callback) {
    var self = this;

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var keyPrefix = dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length = localStorage.length;

        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in localStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        var iterationNumber = 1;

        for (var i = 0; i < length; i++) {
            var key = localStorage.key(i);
            if (key.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = localStorage.getItem(key);

            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = dbInfo.serializer.deserialize(value);
            }

            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

            if (value !== void 0) {
                return value;
            }
        }
    });

    executeCallback(promise, callback);
    return promise;
}

// Same as localStorage's key() method, except takes a callback.
function key$2(n, callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var result;
        try {
            result = localStorage.key(n);
        } catch (error) {
            result = null;
        }

        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
        }

        return result;
    });

    executeCallback(promise, callback);
    return promise;
}

function keys$2(callback) {
    var self = this;
    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];

        for (var i = 0; i < length; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
        }

        return keys;
    });

    executeCallback(promise, callback);
    return promise;
}

// Supply the number of keys in the datastore to the callback function.
function length$2(callback) {
    var self = this;
    var promise = self.keys().then(function (keys) {
        return keys.length;
    });

    executeCallback(promise, callback);
    return promise;
}

// Remove an item from the store, nice and simple.
function removeItem$2(key, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
    });

    executeCallback(promise, callback);
    return promise;
}

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
function setItem$2(key, value, callback) {
    var self = this;

    key = normalizeKey(key);

    var promise = self.ready().then(function () {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }

        // Save the original value to pass to the callback.
        var originalValue = value;

        return new Promise$1(function (resolve, reject) {
            var dbInfo = self._dbInfo;
            dbInfo.serializer.serialize(value, function (value, error) {
                if (error) {
                    reject(error);
                } else {
                    try {
                        localStorage.setItem(dbInfo.keyPrefix + key, value);
                        resolve(originalValue);
                    } catch (e) {
                        // localStorage capacity exceeded.
                        // TODO: Make this a specific error/event.
                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });

    executeCallback(promise, callback);
    return promise;
}

function dropInstance$2(options, callback) {
    callback = getCallback.apply(this, arguments);

    options = typeof options !== 'function' && options || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }

    var self = this;
    var promise;
    if (!options.name) {
        promise = Promise$1.reject('Invalid arguments');
    } else {
        promise = new Promise$1(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + '/');
            } else {
                resolve(_getKeyPrefix(options, self._defaultConfig));
            }
        }).then(function (keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);

                if (key.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key);
                }
            }
        });
    }

    executeCallback(promise, callback);
    return promise;
}

var localStorageWrapper = {
    _driver: 'localStorageWrapper',
    _initStorage: _initStorage$2,
    _support: isLocalStorageValid(),
    iterate: iterate$2,
    getItem: getItem$2,
    setItem: setItem$2,
    removeItem: removeItem$2,
    clear: clear$2,
    length: length$2,
    key: key$2,
    keys: keys$2,
    dropInstance: dropInstance$2
};

var sameValue = function sameValue(x, y) {
    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
};

var includes = function includes(array, searchElement) {
    var len = array.length;
    var i = 0;
    while (i < len) {
        if (sameValue(array[i], searchElement)) {
            return true;
        }
        i++;
    }

    return false;
};

var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
};

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
var DefinedDrivers = {};

var DriverSupport = {};

var DefaultDrivers = {
    INDEXEDDB: asyncStorage,
    WEBSQL: webSQLStorage,
    LOCALSTORAGE: localStorageWrapper
};

var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

var OptionalDriverMethods = ['dropInstance'];

var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

var DefaultConfig = {
    description: '',
    driver: DefaultDriverOrder.slice(),
    name: 'localforage',
    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
    // we can use without a prompt.
    size: 4980736,
    storeName: 'keyvaluepairs',
    version: 1.0
};

function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function () {
        var _args = arguments;
        return localForageInstance.ready().then(function () {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
        });
    };
}

function extend() {
    for (var i = 1; i < arguments.length; i++) {
        var arg = arguments[i];

        if (arg) {
            for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                    if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                    } else {
                        arguments[0][_key] = arg[_key];
                    }
                }
            }
        }
    }

    return arguments[0];
}

var LocalForage = function () {
    function LocalForage(options) {
        _classCallCheck(this, LocalForage);

        for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;

                if (!DefinedDrivers[driverName]) {
                    // we don't need to wait for the promise,
                    // since the default drivers can be defined
                    // in a blocking manner
                    this.defineDriver(driver);
                }
            }
        }

        this._defaultConfig = extend({}, DefaultConfig);
        this._config = extend({}, this._defaultConfig, options);
        this._driverSet = null;
        this._initDriver = null;
        this._ready = false;
        this._dbInfo = null;

        this._wrapLibraryMethodsWithReady();
        this.setDriver(this._config.driver)["catch"](function () {});
    }

    // Set any config values for localForage; can be called anytime before
    // the first API call (e.g. `getItem`, `setItem`).
    // We loop through options so we don't overwrite existing config
    // values.


    LocalForage.prototype.config = function config(options) {
        // If the options argument is an object, we use it to set values.
        // Otherwise, we return either a specified config value or all
        // config values.
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
            // If localforage is ready and fully initialized, we can't set
            // any new configuration values. Instead, we return an error.
            if (this._ready) {
                return new Error("Can't call config() after localforage " + 'has been used.');
            }

            for (var i in options) {
                if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                }

                if (i === 'version' && typeof options[i] !== 'number') {
                    return new Error('Database version must be a number.');
                }

                this._config[i] = options[i];
            }

            // after all config options are set and
            // the driver option is used, try setting it
            if ('driver' in options && options.driver) {
                return this.setDriver(this._config.driver);
            }

            return true;
        } else if (typeof options === 'string') {
            return this._config[options];
        } else {
            return this._config;
        }
    };

    // Used to define a custom driver, shared across all instances of
    // localForage.


    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
        var promise = new Promise$1(function (resolve, reject) {
            try {
                var driverName = driverObject._driver;
                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                // A driver name should be defined and not overlap with the
                // library-defined, default drivers.
                if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                }

                var driverMethods = LibraryMethods.concat('_initStorage');
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                    var driverMethodName = driverMethods[i];

                    // when the property is there,
                    // it should be a method even when optional
                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                        reject(complianceError);
                        return;
                    }
                }

                var configureMissingMethods = function configureMissingMethods() {
                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                        return function () {
                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                            var promise = Promise$1.reject(error);
                            executeCallback(promise, arguments[arguments.length - 1]);
                            return promise;
                        };
                    };

                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                    }
                };

                configureMissingMethods();

                var setDriverSupport = function setDriverSupport(support) {
                    if (DefinedDrivers[driverName]) {
                        console.info('Redefining LocalForage driver: ' + driverName);
                    }
                    DefinedDrivers[driverName] = driverObject;
                    DriverSupport[driverName] = support;
                    // don't use a then, so that we can define
                    // drivers that have simple _support methods
                    // in a blocking manner
                    resolve();
                };

                if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                        driverObject._support().then(setDriverSupport, reject);
                    } else {
                        setDriverSupport(!!driverObject._support);
                    }
                } else {
                    setDriverSupport(true);
                }
            } catch (e) {
                reject(e);
            }
        });

        executeTwoCallbacks(promise, callback, errorCallback);
        return promise;
    };

    LocalForage.prototype.driver = function driver() {
        return this._driver || null;
    };

    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
        return getDriverPromise;
    };

    LocalForage.prototype.getSerializer = function getSerializer(callback) {
        var serializerPromise = Promise$1.resolve(localforageSerializer);
        executeTwoCallbacks(serializerPromise, callback);
        return serializerPromise;
    };

    LocalForage.prototype.ready = function ready(callback) {
        var self = this;

        var promise = self._driverSet.then(function () {
            if (self._ready === null) {
                self._ready = self._initDriver();
            }

            return self._ready;
        });

        executeTwoCallbacks(promise, callback, callback);
        return promise;
    };

    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
        var self = this;

        if (!isArray(drivers)) {
            drivers = [drivers];
        }

        var supportedDrivers = this._getSupportedDrivers(drivers);

        function setDriverToConfig() {
            self._config.driver = self.driver();
        }

        function extendSelfWithDriver(driver) {
            self._extend(driver);
            setDriverToConfig();

            self._ready = self._initStorage(self._config);
            return self._ready;
        }

        function initDriver(supportedDrivers) {
            return function () {
                var currentDriverIndex = 0;

                function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                        var driverName = supportedDrivers[currentDriverIndex];
                        currentDriverIndex++;

                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                    }

                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise$1.reject(error);
                    return self._driverSet;
                }

                return driverPromiseLoop();
            };
        }

        // There might be a driver initialization in progress
        // so wait for it to finish in order to avoid a possible
        // race condition to set _dbInfo
        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
            return Promise$1.resolve();
        }) : Promise$1.resolve();

        this._driverSet = oldDriverSetDone.then(function () {
            var driverName = supportedDrivers[0];
            self._dbInfo = null;
            self._ready = null;

            return self.getDriver(driverName).then(function (driver) {
                self._driver = driver._driver;
                setDriverToConfig();
                self._wrapLibraryMethodsWithReady();
                self._initDriver = initDriver(supportedDrivers);
            });
        })["catch"](function () {
            setDriverToConfig();
            var error = new Error('No available storage method found.');
            self._driverSet = Promise$1.reject(error);
            return self._driverSet;
        });

        executeTwoCallbacks(this._driverSet, callback, errorCallback);
        return this._driverSet;
    };

    LocalForage.prototype.supports = function supports(driverName) {
        return !!DriverSupport[driverName];
    };

    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
        extend(this, libraryMethodsAndProperties);
    };

    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
        var supportedDrivers = [];
        for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
            }
        }
        return supportedDrivers;
    };

    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
        // Add a stub for each driver API method that delays the call to the
        // corresponding driver method until localForage is ready. These stubs
        // will be replaced by the driver methods as soon as the driver is
        // loaded, so there is no performance impact.
        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
        }
    };

    LocalForage.prototype.createInstance = function createInstance(options) {
        return new LocalForage(options);
    };

    return LocalForage;
}();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


var localforage_js = new LocalForage();

module.exports = localforage_js;

},{"3":3}]},{},[4])(4)
});


;/*! showdown v 1.9.1 - 02-11-2019 */
(function(){
/**
 * Created by Tivie on 13-07-2015.
 */

function getDefaultOpts (simple) {
  'use strict';

  var defaultOptions = {
    omitExtraWLInCodeBlocks: {
      defaultValue: false,
      describe: 'Omit the default extra whiteline added to code blocks',
      type: 'boolean'
    },
    noHeaderId: {
      defaultValue: false,
      describe: 'Turn on/off generated header id',
      type: 'boolean'
    },
    prefixHeaderId: {
      defaultValue: false,
      describe: 'Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic \'section-\' prefix',
      type: 'string'
    },
    rawPrefixHeaderId: {
      defaultValue: false,
      describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
      type: 'boolean'
    },
    ghCompatibleHeaderId: {
      defaultValue: false,
      describe: 'Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)',
      type: 'boolean'
    },
    rawHeaderId: {
      defaultValue: false,
      describe: 'Remove only spaces, \' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids',
      type: 'boolean'
    },
    headerLevelStart: {
      defaultValue: false,
      describe: 'The header blocks level start',
      type: 'integer'
    },
    parseImgDimensions: {
      defaultValue: false,
      describe: 'Turn on/off image dimension parsing',
      type: 'boolean'
    },
    simplifiedAutoLink: {
      defaultValue: false,
      describe: 'Turn on/off GFM autolink style',
      type: 'boolean'
    },
    excludeTrailingPunctuationFromURLs: {
      defaultValue: false,
      describe: 'Excludes trailing punctuation from links generated with autoLinking',
      type: 'boolean'
    },
    literalMidWordUnderscores: {
      defaultValue: false,
      describe: 'Parse midword underscores as literal underscores',
      type: 'boolean'
    },
    literalMidWordAsterisks: {
      defaultValue: false,
      describe: 'Parse midword asterisks as literal asterisks',
      type: 'boolean'
    },
    strikethrough: {
      defaultValue: false,
      describe: 'Turn on/off strikethrough support',
      type: 'boolean'
    },
    tables: {
      defaultValue: false,
      describe: 'Turn on/off tables support',
      type: 'boolean'
    },
    tablesHeaderId: {
      defaultValue: false,
      describe: 'Add an id to table headers',
      type: 'boolean'
    },
    ghCodeBlocks: {
      defaultValue: true,
      describe: 'Turn on/off GFM fenced code blocks support',
      type: 'boolean'
    },
    tasklists: {
      defaultValue: false,
      describe: 'Turn on/off GFM tasklist support',
      type: 'boolean'
    },
    smoothLivePreview: {
      defaultValue: false,
      describe: 'Prevents weird effects in live previews due to incomplete input',
      type: 'boolean'
    },
    smartIndentationFix: {
      defaultValue: false,
      description: 'Tries to smartly fix indentation in es6 strings',
      type: 'boolean'
    },
    disableForced4SpacesIndentedSublists: {
      defaultValue: false,
      description: 'Disables the requirement of indenting nested sublists by 4 spaces',
      type: 'boolean'
    },
    simpleLineBreaks: {
      defaultValue: false,
      description: 'Parses simple line breaks as <br> (GFM Style)',
      type: 'boolean'
    },
    requireSpaceBeforeHeadingText: {
      defaultValue: false,
      description: 'Makes adding a space between `#` and the header text mandatory (GFM Style)',
      type: 'boolean'
    },
    ghMentions: {
      defaultValue: false,
      description: 'Enables github @mentions',
      type: 'boolean'
    },
    ghMentionsLink: {
      defaultValue: 'https://github.com/{u}',
      description: 'Changes the link generated by @mentions. Only applies if ghMentions option is enabled.',
      type: 'string'
    },
    encodeEmails: {
      defaultValue: true,
      description: 'Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities',
      type: 'boolean'
    },
    openLinksInNewWindow: {
      defaultValue: false,
      description: 'Open all links in new windows',
      type: 'boolean'
    },
    backslashEscapesHTMLTags: {
      defaultValue: false,
      description: 'Support for HTML Tag escaping. ex: \<div>foo\</div>',
      type: 'boolean'
    },
    emoji: {
      defaultValue: false,
      description: 'Enable emoji support. Ex: `this is a :smile: emoji`',
      type: 'boolean'
    },
    underline: {
      defaultValue: false,
      description: 'Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`',
      type: 'boolean'
    },
    completeHTMLDocument: {
      defaultValue: false,
      description: 'Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags',
      type: 'boolean'
    },
    metadata: {
      defaultValue: false,
      description: 'Enable support for document metadata (defined at the top of the document between `«««` and `»»»` or between `---` and `---`).',
      type: 'boolean'
    },
    splitAdjacentBlockquotes: {
      defaultValue: false,
      description: 'Split adjacent blockquote blocks',
      type: 'boolean'
    }
  };
  if (simple === false) {
    return JSON.parse(JSON.stringify(defaultOptions));
  }
  var ret = {};
  for (var opt in defaultOptions) {
    if (defaultOptions.hasOwnProperty(opt)) {
      ret[opt] = defaultOptions[opt].defaultValue;
    }
  }
  return ret;
}

function allOptionsOn () {
  'use strict';
  var options = getDefaultOpts(true),
      ret = {};
  for (var opt in options) {
    if (options.hasOwnProperty(opt)) {
      ret[opt] = true;
    }
  }
  return ret;
}

/**
 * Created by Tivie on 06-01-2015.
 */

// Private properties
var showdown = {},
    parsers = {},
    extensions = {},
    globalOptions = getDefaultOpts(true),
    setFlavor = 'vanilla',
    flavor = {
      github: {
        omitExtraWLInCodeBlocks:              true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        disableForced4SpacesIndentedSublists: true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghCompatibleHeaderId:                 true,
        ghMentions:                           true,
        backslashEscapesHTMLTags:             true,
        emoji:                                true,
        splitAdjacentBlockquotes:             true
      },
      original: {
        noHeaderId:                           true,
        ghCodeBlocks:                         false
      },
      ghost: {
        omitExtraWLInCodeBlocks:              true,
        parseImgDimensions:                   true,
        simplifiedAutoLink:                   true,
        excludeTrailingPunctuationFromURLs:   true,
        literalMidWordUnderscores:            true,
        strikethrough:                        true,
        tables:                               true,
        tablesHeaderId:                       true,
        ghCodeBlocks:                         true,
        tasklists:                            true,
        smoothLivePreview:                    true,
        simpleLineBreaks:                     true,
        requireSpaceBeforeHeadingText:        true,
        ghMentions:                           false,
        encodeEmails:                         true
      },
      vanilla: getDefaultOpts(true),
      allOn: allOptionsOn()
    };

/**
 * helper namespace
 * @type {{}}
 */
showdown.helper = {};

/**
 * TODO LEGACY SUPPORT CODE
 * @type {{}}
 */
showdown.extensions = {};

/**
 * Set a global option
 * @static
 * @param {string} key
 * @param {*} value
 * @returns {showdown}
 */
showdown.setOption = function (key, value) {
  'use strict';
  globalOptions[key] = value;
  return this;
};

/**
 * Get a global option
 * @static
 * @param {string} key
 * @returns {*}
 */
showdown.getOption = function (key) {
  'use strict';
  return globalOptions[key];
};

/**
 * Get the global options
 * @static
 * @returns {{}}
 */
showdown.getOptions = function () {
  'use strict';
  return globalOptions;
};

/**
 * Reset global options to the default values
 * @static
 */
showdown.resetOptions = function () {
  'use strict';
  globalOptions = getDefaultOpts(true);
};

/**
 * Set the flavor showdown should use as default
 * @param {string} name
 */
showdown.setFlavor = function (name) {
  'use strict';
  if (!flavor.hasOwnProperty(name)) {
    throw Error(name + ' flavor was not found');
  }
  showdown.resetOptions();
  var preset = flavor[name];
  setFlavor = name;
  for (var option in preset) {
    if (preset.hasOwnProperty(option)) {
      globalOptions[option] = preset[option];
    }
  }
};

/**
 * Get the currently set flavor
 * @returns {string}
 */
showdown.getFlavor = function () {
  'use strict';
  return setFlavor;
};

/**
 * Get the options of a specified flavor. Returns undefined if the flavor was not found
 * @param {string} name Name of the flavor
 * @returns {{}|undefined}
 */
showdown.getFlavorOptions = function (name) {
  'use strict';
  if (flavor.hasOwnProperty(name)) {
    return flavor[name];
  }
};

/**
 * Get the default options
 * @static
 * @param {boolean} [simple=true]
 * @returns {{}}
 */
showdown.getDefaultOptions = function (simple) {
  'use strict';
  return getDefaultOpts(simple);
};

/**
 * Get or set a subParser
 *
 * subParser(name)       - Get a registered subParser
 * subParser(name, func) - Register a subParser
 * @static
 * @param {string} name
 * @param {function} [func]
 * @returns {*}
 */
showdown.subParser = function (name, func) {
  'use strict';
  if (showdown.helper.isString(name)) {
    if (typeof func !== 'undefined') {
      parsers[name] = func;
    } else {
      if (parsers.hasOwnProperty(name)) {
        return parsers[name];
      } else {
        throw Error('SubParser named ' + name + ' not registered!');
      }
    }
  }
};

/**
 * Gets or registers an extension
 * @static
 * @param {string} name
 * @param {object|function=} ext
 * @returns {*}
 */
showdown.extension = function (name, ext) {
  'use strict';

  if (!showdown.helper.isString(name)) {
    throw Error('Extension \'name\' must be a string');
  }

  name = showdown.helper.stdExtName(name);

  // Getter
  if (showdown.helper.isUndefined(ext)) {
    if (!extensions.hasOwnProperty(name)) {
      throw Error('Extension named ' + name + ' is not registered!');
    }
    return extensions[name];

    // Setter
  } else {
    // Expand extension if it's wrapped in a function
    if (typeof ext === 'function') {
      ext = ext();
    }

    // Ensure extension is an array
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExtension = validate(ext, name);

    if (validExtension.valid) {
      extensions[name] = ext;
    } else {
      throw Error(validExtension.error);
    }
  }
};

/**
 * Gets all extensions registered
 * @returns {{}}
 */
showdown.getAllExtensions = function () {
  'use strict';
  return extensions;
};

/**
 * Remove an extension
 * @param {string} name
 */
showdown.removeExtension = function (name) {
  'use strict';
  delete extensions[name];
};

/**
 * Removes all extensions
 */
showdown.resetExtensions = function () {
  'use strict';
  extensions = {};
};

/**
 * Validate extension
 * @param {array} extension
 * @param {string} name
 * @returns {{valid: boolean, error: string}}
 */
function validate (extension, name) {
  'use strict';

  var errMsg = (name) ? 'Error in ' + name + ' extension->' : 'Error in unnamed extension',
      ret = {
        valid: true,
        error: ''
      };

  if (!showdown.helper.isArray(extension)) {
    extension = [extension];
  }

  for (var i = 0; i < extension.length; ++i) {
    var baseMsg = errMsg + ' sub-extension ' + i + ': ',
        ext = extension[i];
    if (typeof ext !== 'object') {
      ret.valid = false;
      ret.error = baseMsg + 'must be an object, but ' + typeof ext + ' given';
      return ret;
    }

    if (!showdown.helper.isString(ext.type)) {
      ret.valid = false;
      ret.error = baseMsg + 'property "type" must be a string, but ' + typeof ext.type + ' given';
      return ret;
    }

    var type = ext.type = ext.type.toLowerCase();

    // normalize extension type
    if (type === 'language') {
      type = ext.type = 'lang';
    }

    if (type === 'html') {
      type = ext.type = 'output';
    }

    if (type !== 'lang' && type !== 'output' && type !== 'listener') {
      ret.valid = false;
      ret.error = baseMsg + 'type ' + type + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"';
      return ret;
    }

    if (type === 'listener') {
      if (showdown.helper.isUndefined(ext.listeners)) {
        ret.valid = false;
        ret.error = baseMsg + '. Extensions of type "listener" must have a property called "listeners"';
        return ret;
      }
    } else {
      if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {
        ret.valid = false;
        ret.error = baseMsg + type + ' extensions must define either a "regex" property or a "filter" method';
        return ret;
      }
    }

    if (ext.listeners) {
      if (typeof ext.listeners !== 'object') {
        ret.valid = false;
        ret.error = baseMsg + '"listeners" property must be an object but ' + typeof ext.listeners + ' given';
        return ret;
      }
      for (var ln in ext.listeners) {
        if (ext.listeners.hasOwnProperty(ln)) {
          if (typeof ext.listeners[ln] !== 'function') {
            ret.valid = false;
            ret.error = baseMsg + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + ln +
              ' must be a function but ' + typeof ext.listeners[ln] + ' given';
            return ret;
          }
        }
      }
    }

    if (ext.filter) {
      if (typeof ext.filter !== 'function') {
        ret.valid = false;
        ret.error = baseMsg + '"filter" must be a function, but ' + typeof ext.filter + ' given';
        return ret;
      }
    } else if (ext.regex) {
      if (showdown.helper.isString(ext.regex)) {
        ext.regex = new RegExp(ext.regex, 'g');
      }
      if (!(ext.regex instanceof RegExp)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" property must either be a string or a RegExp object, but ' + typeof ext.regex + ' given';
        return ret;
      }
      if (showdown.helper.isUndefined(ext.replace)) {
        ret.valid = false;
        ret.error = baseMsg + '"regex" extensions must implement a replace string or function';
        return ret;
      }
    }
  }
  return ret;
}

/**
 * Validate extension
 * @param {object} ext
 * @returns {boolean}
 */
showdown.validateExtension = function (ext) {
  'use strict';

  var validateExtension = validate(ext, null);
  if (!validateExtension.valid) {
    console.warn(validateExtension.error);
    return false;
  }
  return true;
};

/**
 * showdownjs helper functions
 */

if (!showdown.hasOwnProperty('helper')) {
  showdown.helper = {};
}

/**
 * Check if var is string
 * @static
 * @param {string} a
 * @returns {boolean}
 */
showdown.helper.isString = function (a) {
  'use strict';
  return (typeof a === 'string' || a instanceof String);
};

/**
 * Check if var is a function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isFunction = function (a) {
  'use strict';
  var getType = {};
  return a && getType.toString.call(a) === '[object Function]';
};

/**
 * isArray helper function
 * @static
 * @param {*} a
 * @returns {boolean}
 */
showdown.helper.isArray = function (a) {
  'use strict';
  return Array.isArray(a);
};

/**
 * Check if value is undefined
 * @static
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 */
showdown.helper.isUndefined = function (value) {
  'use strict';
  return typeof value === 'undefined';
};

/**
 * ForEach helper function
 * Iterates over Arrays and Objects (own properties only)
 * @static
 * @param {*} obj
 * @param {function} callback Accepts 3 params: 1. value, 2. key, 3. the original array/object
 */
showdown.helper.forEach = function (obj, callback) {
  'use strict';
  // check if obj is defined
  if (showdown.helper.isUndefined(obj)) {
    throw new Error('obj param is required');
  }

  if (showdown.helper.isUndefined(callback)) {
    throw new Error('callback param is required');
  }

  if (!showdown.helper.isFunction(callback)) {
    throw new Error('callback param must be a function/closure');
  }

  if (typeof obj.forEach === 'function') {
    obj.forEach(callback);
  } else if (showdown.helper.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      callback(obj[i], i, obj);
    }
  } else if (typeof (obj) === 'object') {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        callback(obj[prop], prop, obj);
      }
    }
  } else {
    throw new Error('obj does not seem to be an array or an iterable object');
  }
};

/**
 * Standardidize extension name
 * @static
 * @param {string} s extension name
 * @returns {string}
 */
showdown.helper.stdExtName = function (s) {
  'use strict';
  return s.replace(/[_?*+\/\\.^-]/g, '').replace(/\s/g, '').toLowerCase();
};

function escapeCharactersCallback (wholeMatch, m1) {
  'use strict';
  var charCodeToEscape = m1.charCodeAt(0);
  return '¨E' + charCodeToEscape + 'E';
}

/**
 * Callback used to escape characters when passing through String.replace
 * @static
 * @param {string} wholeMatch
 * @param {string} m1
 * @returns {string}
 */
showdown.helper.escapeCharactersCallback = escapeCharactersCallback;

/**
 * Escape characters in a string
 * @static
 * @param {string} text
 * @param {string} charsToEscape
 * @param {boolean} afterBackslash
 * @returns {XML|string|void|*}
 */
showdown.helper.escapeCharacters = function (text, charsToEscape, afterBackslash) {
  'use strict';
  // First we have to escape the escape characters so that
  // we can build a character class out of them
  var regexString = '([' + charsToEscape.replace(/([\[\]\\])/g, '\\$1') + '])';

  if (afterBackslash) {
    regexString = '\\\\' + regexString;
  }

  var regex = new RegExp(regexString, 'g');
  text = text.replace(regex, escapeCharactersCallback);

  return text;
};

/**
 * Unescape HTML entities
 * @param txt
 * @returns {string}
 */
showdown.helper.unescapeHTMLEntities = function (txt) {
  'use strict';

  return txt
    .replace(/&quot;/g, '"')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&');
};

var rgxFindMatchPos = function (str, left, right, flags) {
  'use strict';
  var f = flags || '',
      g = f.indexOf('g') > -1,
      x = new RegExp(left + '|' + right, 'g' + f.replace(/g/g, '')),
      l = new RegExp(left, f.replace(/g/g, '')),
      pos = [],
      t, s, m, start, end;

  do {
    t = 0;
    while ((m = x.exec(str))) {
      if (l.test(m[0])) {
        if (!(t++)) {
          s = x.lastIndex;
          start = s - m[0].length;
        }
      } else if (t) {
        if (!--t) {
          end = m.index + m[0].length;
          var obj = {
            left: {start: start, end: s},
            match: {start: s, end: m.index},
            right: {start: m.index, end: end},
            wholeMatch: {start: start, end: end}
          };
          pos.push(obj);
          if (!g) {
            return pos;
          }
        }
      }
    }
  } while (t && (x.lastIndex = s));

  return pos;
};

/**
 * matchRecursiveRegExp
 *
 * (c) 2007 Steven Levithan <stevenlevithan.com>
 * MIT License
 *
 * Accepts a string to search, a left and right format delimiter
 * as regex patterns, and optional regex flags. Returns an array
 * of matches, allowing nested instances of left/right delimiters.
 * Use the "g" flag to return all matches, otherwise only the
 * first is returned. Be careful to ensure that the left and
 * right format delimiters produce mutually exclusive matches.
 * Backreferences are not supported within the right delimiter
 * due to how it is internally combined with the left delimiter.
 * When matching strings whose format delimiters are unbalanced
 * to the left or right, the output is intentionally as a
 * conventional regex library with recursion support would
 * produce, e.g. "<<x>" and "<x>>" both produce ["x"] when using
 * "<" and ">" as the delimiters (both strings contain a single,
 * balanced instance of "<x>").
 *
 * examples:
 * matchRecursiveRegExp("test", "\\(", "\\)")
 * returns: []
 * matchRecursiveRegExp("<t<<e>><s>>t<>", "<", ">", "g")
 * returns: ["t<<e>><s>", ""]
 * matchRecursiveRegExp("<div id=\"x\">test</div>", "<div\\b[^>]*>", "</div>", "gi")
 * returns: ["test"]
 */
showdown.helper.matchRecursiveRegExp = function (str, left, right, flags) {
  'use strict';

  var matchPos = rgxFindMatchPos (str, left, right, flags),
      results = [];

  for (var i = 0; i < matchPos.length; ++i) {
    results.push([
      str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
      str.slice(matchPos[i].match.start, matchPos[i].match.end),
      str.slice(matchPos[i].left.start, matchPos[i].left.end),
      str.slice(matchPos[i].right.start, matchPos[i].right.end)
    ]);
  }
  return results;
};

/**
 *
 * @param {string} str
 * @param {string|function} replacement
 * @param {string} left
 * @param {string} right
 * @param {string} flags
 * @returns {string}
 */
showdown.helper.replaceRecursiveRegExp = function (str, replacement, left, right, flags) {
  'use strict';

  if (!showdown.helper.isFunction(replacement)) {
    var repStr = replacement;
    replacement = function () {
      return repStr;
    };
  }

  var matchPos = rgxFindMatchPos(str, left, right, flags),
      finalStr = str,
      lng = matchPos.length;

  if (lng > 0) {
    var bits = [];
    if (matchPos[0].wholeMatch.start !== 0) {
      bits.push(str.slice(0, matchPos[0].wholeMatch.start));
    }
    for (var i = 0; i < lng; ++i) {
      bits.push(
        replacement(
          str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),
          str.slice(matchPos[i].match.start, matchPos[i].match.end),
          str.slice(matchPos[i].left.start, matchPos[i].left.end),
          str.slice(matchPos[i].right.start, matchPos[i].right.end)
        )
      );
      if (i < lng - 1) {
        bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));
      }
    }
    if (matchPos[lng - 1].wholeMatch.end < str.length) {
      bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));
    }
    finalStr = bits.join('');
  }
  return finalStr;
};

/**
 * Returns the index within the passed String object of the first occurrence of the specified regex,
 * starting the search at fromIndex. Returns -1 if the value is not found.
 *
 * @param {string} str string to search
 * @param {RegExp} regex Regular expression to search
 * @param {int} [fromIndex = 0] Index to start the search
 * @returns {Number}
 * @throws InvalidArgumentError
 */
showdown.helper.regexIndexOf = function (str, regex, fromIndex) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  if (regex instanceof RegExp === false) {
    throw 'InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp';
  }
  var indexOf = str.substring(fromIndex || 0).search(regex);
  return (indexOf >= 0) ? (indexOf + (fromIndex || 0)) : indexOf;
};

/**
 * Splits the passed string object at the defined index, and returns an array composed of the two substrings
 * @param {string} str string to split
 * @param {int} index index to split string at
 * @returns {[string,string]}
 * @throws InvalidArgumentError
 */
showdown.helper.splitAtIndex = function (str, index) {
  'use strict';
  if (!showdown.helper.isString(str)) {
    throw 'InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string';
  }
  return [str.substring(0, index), str.substring(index)];
};

/**
 * Obfuscate an e-mail address through the use of Character Entities,
 * transforming ASCII characters into their equivalent decimal or hex entities.
 *
 * Since it has a random component, subsequent calls to this function produce different results
 *
 * @param {string} mail
 * @returns {string}
 */
showdown.helper.encodeEmailAddress = function (mail) {
  'use strict';
  var encode = [
    function (ch) {
      return '&#' + ch.charCodeAt(0) + ';';
    },
    function (ch) {
      return '&#x' + ch.charCodeAt(0).toString(16) + ';';
    },
    function (ch) {
      return ch;
    }
  ];

  mail = mail.replace(/./g, function (ch) {
    if (ch === '@') {
      // this *must* be encoded. I insist.
      ch = encode[Math.floor(Math.random() * 2)](ch);
    } else {
      var r = Math.random();
      // roughly 10% raw, 45% hex, 45% dec
      ch = (
        r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch)
      );
    }
    return ch;
  });

  return mail;
};

/**
 *
 * @param str
 * @param targetLength
 * @param padString
 * @returns {string}
 */
showdown.helper.padEnd = function padEnd (str, targetLength, padString) {
  'use strict';
  /*jshint bitwise: false*/
  // eslint-disable-next-line space-infix-ops
  targetLength = targetLength>>0; //floor if number or convert non-number to 0;
  /*jshint bitwise: true*/
  padString = String(padString || ' ');
  if (str.length > targetLength) {
    return String(str);
  } else {
    targetLength = targetLength - str.length;
    if (targetLength > padString.length) {
      padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed
    }
    return String(str) + padString.slice(0,targetLength);
  }
};

/**
 * POLYFILLS
 */
// use this instead of builtin is undefined for IE8 compatibility
if (typeof console === 'undefined') {
  console = {
    warn: function (msg) {
      'use strict';
      alert(msg);
    },
    log: function (msg) {
      'use strict';
      alert(msg);
    },
    error: function (msg) {
      'use strict';
      throw msg;
    }
  };
}

/**
 * Common regexes.
 * We declare some common regexes to improve performance
 */
showdown.helper.regexes = {
  asteriskDashAndColon: /([*_:~])/g
};

/**
 * EMOJIS LIST
 */
showdown.helper.emojis = {
  '+1':'\ud83d\udc4d',
  '-1':'\ud83d\udc4e',
  '100':'\ud83d\udcaf',
  '1234':'\ud83d\udd22',
  '1st_place_medal':'\ud83e\udd47',
  '2nd_place_medal':'\ud83e\udd48',
  '3rd_place_medal':'\ud83e\udd49',
  '8ball':'\ud83c\udfb1',
  'a':'\ud83c\udd70\ufe0f',
  'ab':'\ud83c\udd8e',
  'abc':'\ud83d\udd24',
  'abcd':'\ud83d\udd21',
  'accept':'\ud83c\ude51',
  'aerial_tramway':'\ud83d\udea1',
  'airplane':'\u2708\ufe0f',
  'alarm_clock':'\u23f0',
  'alembic':'\u2697\ufe0f',
  'alien':'\ud83d\udc7d',
  'ambulance':'\ud83d\ude91',
  'amphora':'\ud83c\udffa',
  'anchor':'\u2693\ufe0f',
  'angel':'\ud83d\udc7c',
  'anger':'\ud83d\udca2',
  'angry':'\ud83d\ude20',
  'anguished':'\ud83d\ude27',
  'ant':'\ud83d\udc1c',
  'apple':'\ud83c\udf4e',
  'aquarius':'\u2652\ufe0f',
  'aries':'\u2648\ufe0f',
  'arrow_backward':'\u25c0\ufe0f',
  'arrow_double_down':'\u23ec',
  'arrow_double_up':'\u23eb',
  'arrow_down':'\u2b07\ufe0f',
  'arrow_down_small':'\ud83d\udd3d',
  'arrow_forward':'\u25b6\ufe0f',
  'arrow_heading_down':'\u2935\ufe0f',
  'arrow_heading_up':'\u2934\ufe0f',
  'arrow_left':'\u2b05\ufe0f',
  'arrow_lower_left':'\u2199\ufe0f',
  'arrow_lower_right':'\u2198\ufe0f',
  'arrow_right':'\u27a1\ufe0f',
  'arrow_right_hook':'\u21aa\ufe0f',
  'arrow_up':'\u2b06\ufe0f',
  'arrow_up_down':'\u2195\ufe0f',
  'arrow_up_small':'\ud83d\udd3c',
  'arrow_upper_left':'\u2196\ufe0f',
  'arrow_upper_right':'\u2197\ufe0f',
  'arrows_clockwise':'\ud83d\udd03',
  'arrows_counterclockwise':'\ud83d\udd04',
  'art':'\ud83c\udfa8',
  'articulated_lorry':'\ud83d\ude9b',
  'artificial_satellite':'\ud83d\udef0',
  'astonished':'\ud83d\ude32',
  'athletic_shoe':'\ud83d\udc5f',
  'atm':'\ud83c\udfe7',
  'atom_symbol':'\u269b\ufe0f',
  'avocado':'\ud83e\udd51',
  'b':'\ud83c\udd71\ufe0f',
  'baby':'\ud83d\udc76',
  'baby_bottle':'\ud83c\udf7c',
  'baby_chick':'\ud83d\udc24',
  'baby_symbol':'\ud83d\udebc',
  'back':'\ud83d\udd19',
  'bacon':'\ud83e\udd53',
  'badminton':'\ud83c\udff8',
  'baggage_claim':'\ud83d\udec4',
  'baguette_bread':'\ud83e\udd56',
  'balance_scale':'\u2696\ufe0f',
  'balloon':'\ud83c\udf88',
  'ballot_box':'\ud83d\uddf3',
  'ballot_box_with_check':'\u2611\ufe0f',
  'bamboo':'\ud83c\udf8d',
  'banana':'\ud83c\udf4c',
  'bangbang':'\u203c\ufe0f',
  'bank':'\ud83c\udfe6',
  'bar_chart':'\ud83d\udcca',
  'barber':'\ud83d\udc88',
  'baseball':'\u26be\ufe0f',
  'basketball':'\ud83c\udfc0',
  'basketball_man':'\u26f9\ufe0f',
  'basketball_woman':'\u26f9\ufe0f&zwj;\u2640\ufe0f',
  'bat':'\ud83e\udd87',
  'bath':'\ud83d\udec0',
  'bathtub':'\ud83d\udec1',
  'battery':'\ud83d\udd0b',
  'beach_umbrella':'\ud83c\udfd6',
  'bear':'\ud83d\udc3b',
  'bed':'\ud83d\udecf',
  'bee':'\ud83d\udc1d',
  'beer':'\ud83c\udf7a',
  'beers':'\ud83c\udf7b',
  'beetle':'\ud83d\udc1e',
  'beginner':'\ud83d\udd30',
  'bell':'\ud83d\udd14',
  'bellhop_bell':'\ud83d\udece',
  'bento':'\ud83c\udf71',
  'biking_man':'\ud83d\udeb4',
  'bike':'\ud83d\udeb2',
  'biking_woman':'\ud83d\udeb4&zwj;\u2640\ufe0f',
  'bikini':'\ud83d\udc59',
  'biohazard':'\u2623\ufe0f',
  'bird':'\ud83d\udc26',
  'birthday':'\ud83c\udf82',
  'black_circle':'\u26ab\ufe0f',
  'black_flag':'\ud83c\udff4',
  'black_heart':'\ud83d\udda4',
  'black_joker':'\ud83c\udccf',
  'black_large_square':'\u2b1b\ufe0f',
  'black_medium_small_square':'\u25fe\ufe0f',
  'black_medium_square':'\u25fc\ufe0f',
  'black_nib':'\u2712\ufe0f',
  'black_small_square':'\u25aa\ufe0f',
  'black_square_button':'\ud83d\udd32',
  'blonde_man':'\ud83d\udc71',
  'blonde_woman':'\ud83d\udc71&zwj;\u2640\ufe0f',
  'blossom':'\ud83c\udf3c',
  'blowfish':'\ud83d\udc21',
  'blue_book':'\ud83d\udcd8',
  'blue_car':'\ud83d\ude99',
  'blue_heart':'\ud83d\udc99',
  'blush':'\ud83d\ude0a',
  'boar':'\ud83d\udc17',
  'boat':'\u26f5\ufe0f',
  'bomb':'\ud83d\udca3',
  'book':'\ud83d\udcd6',
  'bookmark':'\ud83d\udd16',
  'bookmark_tabs':'\ud83d\udcd1',
  'books':'\ud83d\udcda',
  'boom':'\ud83d\udca5',
  'boot':'\ud83d\udc62',
  'bouquet':'\ud83d\udc90',
  'bowing_man':'\ud83d\ude47',
  'bow_and_arrow':'\ud83c\udff9',
  'bowing_woman':'\ud83d\ude47&zwj;\u2640\ufe0f',
  'bowling':'\ud83c\udfb3',
  'boxing_glove':'\ud83e\udd4a',
  'boy':'\ud83d\udc66',
  'bread':'\ud83c\udf5e',
  'bride_with_veil':'\ud83d\udc70',
  'bridge_at_night':'\ud83c\udf09',
  'briefcase':'\ud83d\udcbc',
  'broken_heart':'\ud83d\udc94',
  'bug':'\ud83d\udc1b',
  'building_construction':'\ud83c\udfd7',
  'bulb':'\ud83d\udca1',
  'bullettrain_front':'\ud83d\ude85',
  'bullettrain_side':'\ud83d\ude84',
  'burrito':'\ud83c\udf2f',
  'bus':'\ud83d\ude8c',
  'business_suit_levitating':'\ud83d\udd74',
  'busstop':'\ud83d\ude8f',
  'bust_in_silhouette':'\ud83d\udc64',
  'busts_in_silhouette':'\ud83d\udc65',
  'butterfly':'\ud83e\udd8b',
  'cactus':'\ud83c\udf35',
  'cake':'\ud83c\udf70',
  'calendar':'\ud83d\udcc6',
  'call_me_hand':'\ud83e\udd19',
  'calling':'\ud83d\udcf2',
  'camel':'\ud83d\udc2b',
  'camera':'\ud83d\udcf7',
  'camera_flash':'\ud83d\udcf8',
  'camping':'\ud83c\udfd5',
  'cancer':'\u264b\ufe0f',
  'candle':'\ud83d\udd6f',
  'candy':'\ud83c\udf6c',
  'canoe':'\ud83d\udef6',
  'capital_abcd':'\ud83d\udd20',
  'capricorn':'\u2651\ufe0f',
  'car':'\ud83d\ude97',
  'card_file_box':'\ud83d\uddc3',
  'card_index':'\ud83d\udcc7',
  'card_index_dividers':'\ud83d\uddc2',
  'carousel_horse':'\ud83c\udfa0',
  'carrot':'\ud83e\udd55',
  'cat':'\ud83d\udc31',
  'cat2':'\ud83d\udc08',
  'cd':'\ud83d\udcbf',
  'chains':'\u26d3',
  'champagne':'\ud83c\udf7e',
  'chart':'\ud83d\udcb9',
  'chart_with_downwards_trend':'\ud83d\udcc9',
  'chart_with_upwards_trend':'\ud83d\udcc8',
  'checkered_flag':'\ud83c\udfc1',
  'cheese':'\ud83e\uddc0',
  'cherries':'\ud83c\udf52',
  'cherry_blossom':'\ud83c\udf38',
  'chestnut':'\ud83c\udf30',
  'chicken':'\ud83d\udc14',
  'children_crossing':'\ud83d\udeb8',
  'chipmunk':'\ud83d\udc3f',
  'chocolate_bar':'\ud83c\udf6b',
  'christmas_tree':'\ud83c\udf84',
  'church':'\u26ea\ufe0f',
  'cinema':'\ud83c\udfa6',
  'circus_tent':'\ud83c\udfaa',
  'city_sunrise':'\ud83c\udf07',
  'city_sunset':'\ud83c\udf06',
  'cityscape':'\ud83c\udfd9',
  'cl':'\ud83c\udd91',
  'clamp':'\ud83d\udddc',
  'clap':'\ud83d\udc4f',
  'clapper':'\ud83c\udfac',
  'classical_building':'\ud83c\udfdb',
  'clinking_glasses':'\ud83e\udd42',
  'clipboard':'\ud83d\udccb',
  'clock1':'\ud83d\udd50',
  'clock10':'\ud83d\udd59',
  'clock1030':'\ud83d\udd65',
  'clock11':'\ud83d\udd5a',
  'clock1130':'\ud83d\udd66',
  'clock12':'\ud83d\udd5b',
  'clock1230':'\ud83d\udd67',
  'clock130':'\ud83d\udd5c',
  'clock2':'\ud83d\udd51',
  'clock230':'\ud83d\udd5d',
  'clock3':'\ud83d\udd52',
  'clock330':'\ud83d\udd5e',
  'clock4':'\ud83d\udd53',
  'clock430':'\ud83d\udd5f',
  'clock5':'\ud83d\udd54',
  'clock530':'\ud83d\udd60',
  'clock6':'\ud83d\udd55',
  'clock630':'\ud83d\udd61',
  'clock7':'\ud83d\udd56',
  'clock730':'\ud83d\udd62',
  'clock8':'\ud83d\udd57',
  'clock830':'\ud83d\udd63',
  'clock9':'\ud83d\udd58',
  'clock930':'\ud83d\udd64',
  'closed_book':'\ud83d\udcd5',
  'closed_lock_with_key':'\ud83d\udd10',
  'closed_umbrella':'\ud83c\udf02',
  'cloud':'\u2601\ufe0f',
  'cloud_with_lightning':'\ud83c\udf29',
  'cloud_with_lightning_and_rain':'\u26c8',
  'cloud_with_rain':'\ud83c\udf27',
  'cloud_with_snow':'\ud83c\udf28',
  'clown_face':'\ud83e\udd21',
  'clubs':'\u2663\ufe0f',
  'cocktail':'\ud83c\udf78',
  'coffee':'\u2615\ufe0f',
  'coffin':'\u26b0\ufe0f',
  'cold_sweat':'\ud83d\ude30',
  'comet':'\u2604\ufe0f',
  'computer':'\ud83d\udcbb',
  'computer_mouse':'\ud83d\uddb1',
  'confetti_ball':'\ud83c\udf8a',
  'confounded':'\ud83d\ude16',
  'confused':'\ud83d\ude15',
  'congratulations':'\u3297\ufe0f',
  'construction':'\ud83d\udea7',
  'construction_worker_man':'\ud83d\udc77',
  'construction_worker_woman':'\ud83d\udc77&zwj;\u2640\ufe0f',
  'control_knobs':'\ud83c\udf9b',
  'convenience_store':'\ud83c\udfea',
  'cookie':'\ud83c\udf6a',
  'cool':'\ud83c\udd92',
  'policeman':'\ud83d\udc6e',
  'copyright':'\u00a9\ufe0f',
  'corn':'\ud83c\udf3d',
  'couch_and_lamp':'\ud83d\udecb',
  'couple':'\ud83d\udc6b',
  'couple_with_heart_woman_man':'\ud83d\udc91',
  'couple_with_heart_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc68',
  'couple_with_heart_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc69',
  'couplekiss_man_man':'\ud83d\udc68&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc68',
  'couplekiss_man_woman':'\ud83d\udc8f',
  'couplekiss_woman_woman':'\ud83d\udc69&zwj;\u2764\ufe0f&zwj;\ud83d\udc8b&zwj;\ud83d\udc69',
  'cow':'\ud83d\udc2e',
  'cow2':'\ud83d\udc04',
  'cowboy_hat_face':'\ud83e\udd20',
  'crab':'\ud83e\udd80',
  'crayon':'\ud83d\udd8d',
  'credit_card':'\ud83d\udcb3',
  'crescent_moon':'\ud83c\udf19',
  'cricket':'\ud83c\udfcf',
  'crocodile':'\ud83d\udc0a',
  'croissant':'\ud83e\udd50',
  'crossed_fingers':'\ud83e\udd1e',
  'crossed_flags':'\ud83c\udf8c',
  'crossed_swords':'\u2694\ufe0f',
  'crown':'\ud83d\udc51',
  'cry':'\ud83d\ude22',
  'crying_cat_face':'\ud83d\ude3f',
  'crystal_ball':'\ud83d\udd2e',
  'cucumber':'\ud83e\udd52',
  'cupid':'\ud83d\udc98',
  'curly_loop':'\u27b0',
  'currency_exchange':'\ud83d\udcb1',
  'curry':'\ud83c\udf5b',
  'custard':'\ud83c\udf6e',
  'customs':'\ud83d\udec3',
  'cyclone':'\ud83c\udf00',
  'dagger':'\ud83d\udde1',
  'dancer':'\ud83d\udc83',
  'dancing_women':'\ud83d\udc6f',
  'dancing_men':'\ud83d\udc6f&zwj;\u2642\ufe0f',
  'dango':'\ud83c\udf61',
  'dark_sunglasses':'\ud83d\udd76',
  'dart':'\ud83c\udfaf',
  'dash':'\ud83d\udca8',
  'date':'\ud83d\udcc5',
  'deciduous_tree':'\ud83c\udf33',
  'deer':'\ud83e\udd8c',
  'department_store':'\ud83c\udfec',
  'derelict_house':'\ud83c\udfda',
  'desert':'\ud83c\udfdc',
  'desert_island':'\ud83c\udfdd',
  'desktop_computer':'\ud83d\udda5',
  'male_detective':'\ud83d\udd75\ufe0f',
  'diamond_shape_with_a_dot_inside':'\ud83d\udca0',
  'diamonds':'\u2666\ufe0f',
  'disappointed':'\ud83d\ude1e',
  'disappointed_relieved':'\ud83d\ude25',
  'dizzy':'\ud83d\udcab',
  'dizzy_face':'\ud83d\ude35',
  'do_not_litter':'\ud83d\udeaf',
  'dog':'\ud83d\udc36',
  'dog2':'\ud83d\udc15',
  'dollar':'\ud83d\udcb5',
  'dolls':'\ud83c\udf8e',
  'dolphin':'\ud83d\udc2c',
  'door':'\ud83d\udeaa',
  'doughnut':'\ud83c\udf69',
  'dove':'\ud83d\udd4a',
  'dragon':'\ud83d\udc09',
  'dragon_face':'\ud83d\udc32',
  'dress':'\ud83d\udc57',
  'dromedary_camel':'\ud83d\udc2a',
  'drooling_face':'\ud83e\udd24',
  'droplet':'\ud83d\udca7',
  'drum':'\ud83e\udd41',
  'duck':'\ud83e\udd86',
  'dvd':'\ud83d\udcc0',
  'e-mail':'\ud83d\udce7',
  'eagle':'\ud83e\udd85',
  'ear':'\ud83d\udc42',
  'ear_of_rice':'\ud83c\udf3e',
  'earth_africa':'\ud83c\udf0d',
  'earth_americas':'\ud83c\udf0e',
  'earth_asia':'\ud83c\udf0f',
  'egg':'\ud83e\udd5a',
  'eggplant':'\ud83c\udf46',
  'eight_pointed_black_star':'\u2734\ufe0f',
  'eight_spoked_asterisk':'\u2733\ufe0f',
  'electric_plug':'\ud83d\udd0c',
  'elephant':'\ud83d\udc18',
  'email':'\u2709\ufe0f',
  'end':'\ud83d\udd1a',
  'envelope_with_arrow':'\ud83d\udce9',
  'euro':'\ud83d\udcb6',
  'european_castle':'\ud83c\udff0',
  'european_post_office':'\ud83c\udfe4',
  'evergreen_tree':'\ud83c\udf32',
  'exclamation':'\u2757\ufe0f',
  'expressionless':'\ud83d\ude11',
  'eye':'\ud83d\udc41',
  'eye_speech_bubble':'\ud83d\udc41&zwj;\ud83d\udde8',
  'eyeglasses':'\ud83d\udc53',
  'eyes':'\ud83d\udc40',
  'face_with_head_bandage':'\ud83e\udd15',
  'face_with_thermometer':'\ud83e\udd12',
  'fist_oncoming':'\ud83d\udc4a',
  'factory':'\ud83c\udfed',
  'fallen_leaf':'\ud83c\udf42',
  'family_man_woman_boy':'\ud83d\udc6a',
  'family_man_boy':'\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_girl':'\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_man_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66',
  'family_man_man_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_man_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67',
  'family_man_man_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_man_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc68&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_man_woman_boy_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_man_woman_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_man_woman_girl_boy':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_man_woman_girl_girl':'\ud83d\udc68&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'family_woman_woman_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66',
  'family_woman_woman_boy_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc66&zwj;\ud83d\udc66',
  'family_woman_woman_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67',
  'family_woman_woman_girl_boy':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc66',
  'family_woman_woman_girl_girl':'\ud83d\udc69&zwj;\ud83d\udc69&zwj;\ud83d\udc67&zwj;\ud83d\udc67',
  'fast_forward':'\u23e9',
  'fax':'\ud83d\udce0',
  'fearful':'\ud83d\ude28',
  'feet':'\ud83d\udc3e',
  'female_detective':'\ud83d\udd75\ufe0f&zwj;\u2640\ufe0f',
  'ferris_wheel':'\ud83c\udfa1',
  'ferry':'\u26f4',
  'field_hockey':'\ud83c\udfd1',
  'file_cabinet':'\ud83d\uddc4',
  'file_folder':'\ud83d\udcc1',
  'film_projector':'\ud83d\udcfd',
  'film_strip':'\ud83c\udf9e',
  'fire':'\ud83d\udd25',
  'fire_engine':'\ud83d\ude92',
  'fireworks':'\ud83c\udf86',
  'first_quarter_moon':'\ud83c\udf13',
  'first_quarter_moon_with_face':'\ud83c\udf1b',
  'fish':'\ud83d\udc1f',
  'fish_cake':'\ud83c\udf65',
  'fishing_pole_and_fish':'\ud83c\udfa3',
  'fist_raised':'\u270a',
  'fist_left':'\ud83e\udd1b',
  'fist_right':'\ud83e\udd1c',
  'flags':'\ud83c\udf8f',
  'flashlight':'\ud83d\udd26',
  'fleur_de_lis':'\u269c\ufe0f',
  'flight_arrival':'\ud83d\udeec',
  'flight_departure':'\ud83d\udeeb',
  'floppy_disk':'\ud83d\udcbe',
  'flower_playing_cards':'\ud83c\udfb4',
  'flushed':'\ud83d\ude33',
  'fog':'\ud83c\udf2b',
  'foggy':'\ud83c\udf01',
  'football':'\ud83c\udfc8',
  'footprints':'\ud83d\udc63',
  'fork_and_knife':'\ud83c\udf74',
  'fountain':'\u26f2\ufe0f',
  'fountain_pen':'\ud83d\udd8b',
  'four_leaf_clover':'\ud83c\udf40',
  'fox_face':'\ud83e\udd8a',
  'framed_picture':'\ud83d\uddbc',
  'free':'\ud83c\udd93',
  'fried_egg':'\ud83c\udf73',
  'fried_shrimp':'\ud83c\udf64',
  'fries':'\ud83c\udf5f',
  'frog':'\ud83d\udc38',
  'frowning':'\ud83d\ude26',
  'frowning_face':'\u2639\ufe0f',
  'frowning_man':'\ud83d\ude4d&zwj;\u2642\ufe0f',
  'frowning_woman':'\ud83d\ude4d',
  'middle_finger':'\ud83d\udd95',
  'fuelpump':'\u26fd\ufe0f',
  'full_moon':'\ud83c\udf15',
  'full_moon_with_face':'\ud83c\udf1d',
  'funeral_urn':'\u26b1\ufe0f',
  'game_die':'\ud83c\udfb2',
  'gear':'\u2699\ufe0f',
  'gem':'\ud83d\udc8e',
  'gemini':'\u264a\ufe0f',
  'ghost':'\ud83d\udc7b',
  'gift':'\ud83c\udf81',
  'gift_heart':'\ud83d\udc9d',
  'girl':'\ud83d\udc67',
  'globe_with_meridians':'\ud83c\udf10',
  'goal_net':'\ud83e\udd45',
  'goat':'\ud83d\udc10',
  'golf':'\u26f3\ufe0f',
  'golfing_man':'\ud83c\udfcc\ufe0f',
  'golfing_woman':'\ud83c\udfcc\ufe0f&zwj;\u2640\ufe0f',
  'gorilla':'\ud83e\udd8d',
  'grapes':'\ud83c\udf47',
  'green_apple':'\ud83c\udf4f',
  'green_book':'\ud83d\udcd7',
  'green_heart':'\ud83d\udc9a',
  'green_salad':'\ud83e\udd57',
  'grey_exclamation':'\u2755',
  'grey_question':'\u2754',
  'grimacing':'\ud83d\ude2c',
  'grin':'\ud83d\ude01',
  'grinning':'\ud83d\ude00',
  'guardsman':'\ud83d\udc82',
  'guardswoman':'\ud83d\udc82&zwj;\u2640\ufe0f',
  'guitar':'\ud83c\udfb8',
  'gun':'\ud83d\udd2b',
  'haircut_woman':'\ud83d\udc87',
  'haircut_man':'\ud83d\udc87&zwj;\u2642\ufe0f',
  'hamburger':'\ud83c\udf54',
  'hammer':'\ud83d\udd28',
  'hammer_and_pick':'\u2692',
  'hammer_and_wrench':'\ud83d\udee0',
  'hamster':'\ud83d\udc39',
  'hand':'\u270b',
  'handbag':'\ud83d\udc5c',
  'handshake':'\ud83e\udd1d',
  'hankey':'\ud83d\udca9',
  'hatched_chick':'\ud83d\udc25',
  'hatching_chick':'\ud83d\udc23',
  'headphones':'\ud83c\udfa7',
  'hear_no_evil':'\ud83d\ude49',
  'heart':'\u2764\ufe0f',
  'heart_decoration':'\ud83d\udc9f',
  'heart_eyes':'\ud83d\ude0d',
  'heart_eyes_cat':'\ud83d\ude3b',
  'heartbeat':'\ud83d\udc93',
  'heartpulse':'\ud83d\udc97',
  'hearts':'\u2665\ufe0f',
  'heavy_check_mark':'\u2714\ufe0f',
  'heavy_division_sign':'\u2797',
  'heavy_dollar_sign':'\ud83d\udcb2',
  'heavy_heart_exclamation':'\u2763\ufe0f',
  'heavy_minus_sign':'\u2796',
  'heavy_multiplication_x':'\u2716\ufe0f',
  'heavy_plus_sign':'\u2795',
  'helicopter':'\ud83d\ude81',
  'herb':'\ud83c\udf3f',
  'hibiscus':'\ud83c\udf3a',
  'high_brightness':'\ud83d\udd06',
  'high_heel':'\ud83d\udc60',
  'hocho':'\ud83d\udd2a',
  'hole':'\ud83d\udd73',
  'honey_pot':'\ud83c\udf6f',
  'horse':'\ud83d\udc34',
  'horse_racing':'\ud83c\udfc7',
  'hospital':'\ud83c\udfe5',
  'hot_pepper':'\ud83c\udf36',
  'hotdog':'\ud83c\udf2d',
  'hotel':'\ud83c\udfe8',
  'hotsprings':'\u2668\ufe0f',
  'hourglass':'\u231b\ufe0f',
  'hourglass_flowing_sand':'\u23f3',
  'house':'\ud83c\udfe0',
  'house_with_garden':'\ud83c\udfe1',
  'houses':'\ud83c\udfd8',
  'hugs':'\ud83e\udd17',
  'hushed':'\ud83d\ude2f',
  'ice_cream':'\ud83c\udf68',
  'ice_hockey':'\ud83c\udfd2',
  'ice_skate':'\u26f8',
  'icecream':'\ud83c\udf66',
  'id':'\ud83c\udd94',
  'ideograph_advantage':'\ud83c\ude50',
  'imp':'\ud83d\udc7f',
  'inbox_tray':'\ud83d\udce5',
  'incoming_envelope':'\ud83d\udce8',
  'tipping_hand_woman':'\ud83d\udc81',
  'information_source':'\u2139\ufe0f',
  'innocent':'\ud83d\ude07',
  'interrobang':'\u2049\ufe0f',
  'iphone':'\ud83d\udcf1',
  'izakaya_lantern':'\ud83c\udfee',
  'jack_o_lantern':'\ud83c\udf83',
  'japan':'\ud83d\uddfe',
  'japanese_castle':'\ud83c\udfef',
  'japanese_goblin':'\ud83d\udc7a',
  'japanese_ogre':'\ud83d\udc79',
  'jeans':'\ud83d\udc56',
  'joy':'\ud83d\ude02',
  'joy_cat':'\ud83d\ude39',
  'joystick':'\ud83d\udd79',
  'kaaba':'\ud83d\udd4b',
  'key':'\ud83d\udd11',
  'keyboard':'\u2328\ufe0f',
  'keycap_ten':'\ud83d\udd1f',
  'kick_scooter':'\ud83d\udef4',
  'kimono':'\ud83d\udc58',
  'kiss':'\ud83d\udc8b',
  'kissing':'\ud83d\ude17',
  'kissing_cat':'\ud83d\ude3d',
  'kissing_closed_eyes':'\ud83d\ude1a',
  'kissing_heart':'\ud83d\ude18',
  'kissing_smiling_eyes':'\ud83d\ude19',
  'kiwi_fruit':'\ud83e\udd5d',
  'koala':'\ud83d\udc28',
  'koko':'\ud83c\ude01',
  'label':'\ud83c\udff7',
  'large_blue_circle':'\ud83d\udd35',
  'large_blue_diamond':'\ud83d\udd37',
  'large_orange_diamond':'\ud83d\udd36',
  'last_quarter_moon':'\ud83c\udf17',
  'last_quarter_moon_with_face':'\ud83c\udf1c',
  'latin_cross':'\u271d\ufe0f',
  'laughing':'\ud83d\ude06',
  'leaves':'\ud83c\udf43',
  'ledger':'\ud83d\udcd2',
  'left_luggage':'\ud83d\udec5',
  'left_right_arrow':'\u2194\ufe0f',
  'leftwards_arrow_with_hook':'\u21a9\ufe0f',
  'lemon':'\ud83c\udf4b',
  'leo':'\u264c\ufe0f',
  'leopard':'\ud83d\udc06',
  'level_slider':'\ud83c\udf9a',
  'libra':'\u264e\ufe0f',
  'light_rail':'\ud83d\ude88',
  'link':'\ud83d\udd17',
  'lion':'\ud83e\udd81',
  'lips':'\ud83d\udc44',
  'lipstick':'\ud83d\udc84',
  'lizard':'\ud83e\udd8e',
  'lock':'\ud83d\udd12',
  'lock_with_ink_pen':'\ud83d\udd0f',
  'lollipop':'\ud83c\udf6d',
  'loop':'\u27bf',
  'loud_sound':'\ud83d\udd0a',
  'loudspeaker':'\ud83d\udce2',
  'love_hotel':'\ud83c\udfe9',
  'love_letter':'\ud83d\udc8c',
  'low_brightness':'\ud83d\udd05',
  'lying_face':'\ud83e\udd25',
  'm':'\u24c2\ufe0f',
  'mag':'\ud83d\udd0d',
  'mag_right':'\ud83d\udd0e',
  'mahjong':'\ud83c\udc04\ufe0f',
  'mailbox':'\ud83d\udceb',
  'mailbox_closed':'\ud83d\udcea',
  'mailbox_with_mail':'\ud83d\udcec',
  'mailbox_with_no_mail':'\ud83d\udced',
  'man':'\ud83d\udc68',
  'man_artist':'\ud83d\udc68&zwj;\ud83c\udfa8',
  'man_astronaut':'\ud83d\udc68&zwj;\ud83d\ude80',
  'man_cartwheeling':'\ud83e\udd38&zwj;\u2642\ufe0f',
  'man_cook':'\ud83d\udc68&zwj;\ud83c\udf73',
  'man_dancing':'\ud83d\udd7a',
  'man_facepalming':'\ud83e\udd26&zwj;\u2642\ufe0f',
  'man_factory_worker':'\ud83d\udc68&zwj;\ud83c\udfed',
  'man_farmer':'\ud83d\udc68&zwj;\ud83c\udf3e',
  'man_firefighter':'\ud83d\udc68&zwj;\ud83d\ude92',
  'man_health_worker':'\ud83d\udc68&zwj;\u2695\ufe0f',
  'man_in_tuxedo':'\ud83e\udd35',
  'man_judge':'\ud83d\udc68&zwj;\u2696\ufe0f',
  'man_juggling':'\ud83e\udd39&zwj;\u2642\ufe0f',
  'man_mechanic':'\ud83d\udc68&zwj;\ud83d\udd27',
  'man_office_worker':'\ud83d\udc68&zwj;\ud83d\udcbc',
  'man_pilot':'\ud83d\udc68&zwj;\u2708\ufe0f',
  'man_playing_handball':'\ud83e\udd3e&zwj;\u2642\ufe0f',
  'man_playing_water_polo':'\ud83e\udd3d&zwj;\u2642\ufe0f',
  'man_scientist':'\ud83d\udc68&zwj;\ud83d\udd2c',
  'man_shrugging':'\ud83e\udd37&zwj;\u2642\ufe0f',
  'man_singer':'\ud83d\udc68&zwj;\ud83c\udfa4',
  'man_student':'\ud83d\udc68&zwj;\ud83c\udf93',
  'man_teacher':'\ud83d\udc68&zwj;\ud83c\udfeb',
  'man_technologist':'\ud83d\udc68&zwj;\ud83d\udcbb',
  'man_with_gua_pi_mao':'\ud83d\udc72',
  'man_with_turban':'\ud83d\udc73',
  'tangerine':'\ud83c\udf4a',
  'mans_shoe':'\ud83d\udc5e',
  'mantelpiece_clock':'\ud83d\udd70',
  'maple_leaf':'\ud83c\udf41',
  'martial_arts_uniform':'\ud83e\udd4b',
  'mask':'\ud83d\ude37',
  'massage_woman':'\ud83d\udc86',
  'massage_man':'\ud83d\udc86&zwj;\u2642\ufe0f',
  'meat_on_bone':'\ud83c\udf56',
  'medal_military':'\ud83c\udf96',
  'medal_sports':'\ud83c\udfc5',
  'mega':'\ud83d\udce3',
  'melon':'\ud83c\udf48',
  'memo':'\ud83d\udcdd',
  'men_wrestling':'\ud83e\udd3c&zwj;\u2642\ufe0f',
  'menorah':'\ud83d\udd4e',
  'mens':'\ud83d\udeb9',
  'metal':'\ud83e\udd18',
  'metro':'\ud83d\ude87',
  'microphone':'\ud83c\udfa4',
  'microscope':'\ud83d\udd2c',
  'milk_glass':'\ud83e\udd5b',
  'milky_way':'\ud83c\udf0c',
  'minibus':'\ud83d\ude90',
  'minidisc':'\ud83d\udcbd',
  'mobile_phone_off':'\ud83d\udcf4',
  'money_mouth_face':'\ud83e\udd11',
  'money_with_wings':'\ud83d\udcb8',
  'moneybag':'\ud83d\udcb0',
  'monkey':'\ud83d\udc12',
  'monkey_face':'\ud83d\udc35',
  'monorail':'\ud83d\ude9d',
  'moon':'\ud83c\udf14',
  'mortar_board':'\ud83c\udf93',
  'mosque':'\ud83d\udd4c',
  'motor_boat':'\ud83d\udee5',
  'motor_scooter':'\ud83d\udef5',
  'motorcycle':'\ud83c\udfcd',
  'motorway':'\ud83d\udee3',
  'mount_fuji':'\ud83d\uddfb',
  'mountain':'\u26f0',
  'mountain_biking_man':'\ud83d\udeb5',
  'mountain_biking_woman':'\ud83d\udeb5&zwj;\u2640\ufe0f',
  'mountain_cableway':'\ud83d\udea0',
  'mountain_railway':'\ud83d\ude9e',
  'mountain_snow':'\ud83c\udfd4',
  'mouse':'\ud83d\udc2d',
  'mouse2':'\ud83d\udc01',
  'movie_camera':'\ud83c\udfa5',
  'moyai':'\ud83d\uddff',
  'mrs_claus':'\ud83e\udd36',
  'muscle':'\ud83d\udcaa',
  'mushroom':'\ud83c\udf44',
  'musical_keyboard':'\ud83c\udfb9',
  'musical_note':'\ud83c\udfb5',
  'musical_score':'\ud83c\udfbc',
  'mute':'\ud83d\udd07',
  'nail_care':'\ud83d\udc85',
  'name_badge':'\ud83d\udcdb',
  'national_park':'\ud83c\udfde',
  'nauseated_face':'\ud83e\udd22',
  'necktie':'\ud83d\udc54',
  'negative_squared_cross_mark':'\u274e',
  'nerd_face':'\ud83e\udd13',
  'neutral_face':'\ud83d\ude10',
  'new':'\ud83c\udd95',
  'new_moon':'\ud83c\udf11',
  'new_moon_with_face':'\ud83c\udf1a',
  'newspaper':'\ud83d\udcf0',
  'newspaper_roll':'\ud83d\uddde',
  'next_track_button':'\u23ed',
  'ng':'\ud83c\udd96',
  'no_good_man':'\ud83d\ude45&zwj;\u2642\ufe0f',
  'no_good_woman':'\ud83d\ude45',
  'night_with_stars':'\ud83c\udf03',
  'no_bell':'\ud83d\udd15',
  'no_bicycles':'\ud83d\udeb3',
  'no_entry':'\u26d4\ufe0f',
  'no_entry_sign':'\ud83d\udeab',
  'no_mobile_phones':'\ud83d\udcf5',
  'no_mouth':'\ud83d\ude36',
  'no_pedestrians':'\ud83d\udeb7',
  'no_smoking':'\ud83d\udead',
  'non-potable_water':'\ud83d\udeb1',
  'nose':'\ud83d\udc43',
  'notebook':'\ud83d\udcd3',
  'notebook_with_decorative_cover':'\ud83d\udcd4',
  'notes':'\ud83c\udfb6',
  'nut_and_bolt':'\ud83d\udd29',
  'o':'\u2b55\ufe0f',
  'o2':'\ud83c\udd7e\ufe0f',
  'ocean':'\ud83c\udf0a',
  'octopus':'\ud83d\udc19',
  'oden':'\ud83c\udf62',
  'office':'\ud83c\udfe2',
  'oil_drum':'\ud83d\udee2',
  'ok':'\ud83c\udd97',
  'ok_hand':'\ud83d\udc4c',
  'ok_man':'\ud83d\ude46&zwj;\u2642\ufe0f',
  'ok_woman':'\ud83d\ude46',
  'old_key':'\ud83d\udddd',
  'older_man':'\ud83d\udc74',
  'older_woman':'\ud83d\udc75',
  'om':'\ud83d\udd49',
  'on':'\ud83d\udd1b',
  'oncoming_automobile':'\ud83d\ude98',
  'oncoming_bus':'\ud83d\ude8d',
  'oncoming_police_car':'\ud83d\ude94',
  'oncoming_taxi':'\ud83d\ude96',
  'open_file_folder':'\ud83d\udcc2',
  'open_hands':'\ud83d\udc50',
  'open_mouth':'\ud83d\ude2e',
  'open_umbrella':'\u2602\ufe0f',
  'ophiuchus':'\u26ce',
  'orange_book':'\ud83d\udcd9',
  'orthodox_cross':'\u2626\ufe0f',
  'outbox_tray':'\ud83d\udce4',
  'owl':'\ud83e\udd89',
  'ox':'\ud83d\udc02',
  'package':'\ud83d\udce6',
  'page_facing_up':'\ud83d\udcc4',
  'page_with_curl':'\ud83d\udcc3',
  'pager':'\ud83d\udcdf',
  'paintbrush':'\ud83d\udd8c',
  'palm_tree':'\ud83c\udf34',
  'pancakes':'\ud83e\udd5e',
  'panda_face':'\ud83d\udc3c',
  'paperclip':'\ud83d\udcce',
  'paperclips':'\ud83d\udd87',
  'parasol_on_ground':'\u26f1',
  'parking':'\ud83c\udd7f\ufe0f',
  'part_alternation_mark':'\u303d\ufe0f',
  'partly_sunny':'\u26c5\ufe0f',
  'passenger_ship':'\ud83d\udef3',
  'passport_control':'\ud83d\udec2',
  'pause_button':'\u23f8',
  'peace_symbol':'\u262e\ufe0f',
  'peach':'\ud83c\udf51',
  'peanuts':'\ud83e\udd5c',
  'pear':'\ud83c\udf50',
  'pen':'\ud83d\udd8a',
  'pencil2':'\u270f\ufe0f',
  'penguin':'\ud83d\udc27',
  'pensive':'\ud83d\ude14',
  'performing_arts':'\ud83c\udfad',
  'persevere':'\ud83d\ude23',
  'person_fencing':'\ud83e\udd3a',
  'pouting_woman':'\ud83d\ude4e',
  'phone':'\u260e\ufe0f',
  'pick':'\u26cf',
  'pig':'\ud83d\udc37',
  'pig2':'\ud83d\udc16',
  'pig_nose':'\ud83d\udc3d',
  'pill':'\ud83d\udc8a',
  'pineapple':'\ud83c\udf4d',
  'ping_pong':'\ud83c\udfd3',
  'pisces':'\u2653\ufe0f',
  'pizza':'\ud83c\udf55',
  'place_of_worship':'\ud83d\uded0',
  'plate_with_cutlery':'\ud83c\udf7d',
  'play_or_pause_button':'\u23ef',
  'point_down':'\ud83d\udc47',
  'point_left':'\ud83d\udc48',
  'point_right':'\ud83d\udc49',
  'point_up':'\u261d\ufe0f',
  'point_up_2':'\ud83d\udc46',
  'police_car':'\ud83d\ude93',
  'policewoman':'\ud83d\udc6e&zwj;\u2640\ufe0f',
  'poodle':'\ud83d\udc29',
  'popcorn':'\ud83c\udf7f',
  'post_office':'\ud83c\udfe3',
  'postal_horn':'\ud83d\udcef',
  'postbox':'\ud83d\udcee',
  'potable_water':'\ud83d\udeb0',
  'potato':'\ud83e\udd54',
  'pouch':'\ud83d\udc5d',
  'poultry_leg':'\ud83c\udf57',
  'pound':'\ud83d\udcb7',
  'rage':'\ud83d\ude21',
  'pouting_cat':'\ud83d\ude3e',
  'pouting_man':'\ud83d\ude4e&zwj;\u2642\ufe0f',
  'pray':'\ud83d\ude4f',
  'prayer_beads':'\ud83d\udcff',
  'pregnant_woman':'\ud83e\udd30',
  'previous_track_button':'\u23ee',
  'prince':'\ud83e\udd34',
  'princess':'\ud83d\udc78',
  'printer':'\ud83d\udda8',
  'purple_heart':'\ud83d\udc9c',
  'purse':'\ud83d\udc5b',
  'pushpin':'\ud83d\udccc',
  'put_litter_in_its_place':'\ud83d\udeae',
  'question':'\u2753',
  'rabbit':'\ud83d\udc30',
  'rabbit2':'\ud83d\udc07',
  'racehorse':'\ud83d\udc0e',
  'racing_car':'\ud83c\udfce',
  'radio':'\ud83d\udcfb',
  'radio_button':'\ud83d\udd18',
  'radioactive':'\u2622\ufe0f',
  'railway_car':'\ud83d\ude83',
  'railway_track':'\ud83d\udee4',
  'rainbow':'\ud83c\udf08',
  'rainbow_flag':'\ud83c\udff3\ufe0f&zwj;\ud83c\udf08',
  'raised_back_of_hand':'\ud83e\udd1a',
  'raised_hand_with_fingers_splayed':'\ud83d\udd90',
  'raised_hands':'\ud83d\ude4c',
  'raising_hand_woman':'\ud83d\ude4b',
  'raising_hand_man':'\ud83d\ude4b&zwj;\u2642\ufe0f',
  'ram':'\ud83d\udc0f',
  'ramen':'\ud83c\udf5c',
  'rat':'\ud83d\udc00',
  'record_button':'\u23fa',
  'recycle':'\u267b\ufe0f',
  'red_circle':'\ud83d\udd34',
  'registered':'\u00ae\ufe0f',
  'relaxed':'\u263a\ufe0f',
  'relieved':'\ud83d\ude0c',
  'reminder_ribbon':'\ud83c\udf97',
  'repeat':'\ud83d\udd01',
  'repeat_one':'\ud83d\udd02',
  'rescue_worker_helmet':'\u26d1',
  'restroom':'\ud83d\udebb',
  'revolving_hearts':'\ud83d\udc9e',
  'rewind':'\u23ea',
  'rhinoceros':'\ud83e\udd8f',
  'ribbon':'\ud83c\udf80',
  'rice':'\ud83c\udf5a',
  'rice_ball':'\ud83c\udf59',
  'rice_cracker':'\ud83c\udf58',
  'rice_scene':'\ud83c\udf91',
  'right_anger_bubble':'\ud83d\uddef',
  'ring':'\ud83d\udc8d',
  'robot':'\ud83e\udd16',
  'rocket':'\ud83d\ude80',
  'rofl':'\ud83e\udd23',
  'roll_eyes':'\ud83d\ude44',
  'roller_coaster':'\ud83c\udfa2',
  'rooster':'\ud83d\udc13',
  'rose':'\ud83c\udf39',
  'rosette':'\ud83c\udff5',
  'rotating_light':'\ud83d\udea8',
  'round_pushpin':'\ud83d\udccd',
  'rowing_man':'\ud83d\udea3',
  'rowing_woman':'\ud83d\udea3&zwj;\u2640\ufe0f',
  'rugby_football':'\ud83c\udfc9',
  'running_man':'\ud83c\udfc3',
  'running_shirt_with_sash':'\ud83c\udfbd',
  'running_woman':'\ud83c\udfc3&zwj;\u2640\ufe0f',
  'sa':'\ud83c\ude02\ufe0f',
  'sagittarius':'\u2650\ufe0f',
  'sake':'\ud83c\udf76',
  'sandal':'\ud83d\udc61',
  'santa':'\ud83c\udf85',
  'satellite':'\ud83d\udce1',
  'saxophone':'\ud83c\udfb7',
  'school':'\ud83c\udfeb',
  'school_satchel':'\ud83c\udf92',
  'scissors':'\u2702\ufe0f',
  'scorpion':'\ud83e\udd82',
  'scorpius':'\u264f\ufe0f',
  'scream':'\ud83d\ude31',
  'scream_cat':'\ud83d\ude40',
  'scroll':'\ud83d\udcdc',
  'seat':'\ud83d\udcba',
  'secret':'\u3299\ufe0f',
  'see_no_evil':'\ud83d\ude48',
  'seedling':'\ud83c\udf31',
  'selfie':'\ud83e\udd33',
  'shallow_pan_of_food':'\ud83e\udd58',
  'shamrock':'\u2618\ufe0f',
  'shark':'\ud83e\udd88',
  'shaved_ice':'\ud83c\udf67',
  'sheep':'\ud83d\udc11',
  'shell':'\ud83d\udc1a',
  'shield':'\ud83d\udee1',
  'shinto_shrine':'\u26e9',
  'ship':'\ud83d\udea2',
  'shirt':'\ud83d\udc55',
  'shopping':'\ud83d\udecd',
  'shopping_cart':'\ud83d\uded2',
  'shower':'\ud83d\udebf',
  'shrimp':'\ud83e\udd90',
  'signal_strength':'\ud83d\udcf6',
  'six_pointed_star':'\ud83d\udd2f',
  'ski':'\ud83c\udfbf',
  'skier':'\u26f7',
  'skull':'\ud83d\udc80',
  'skull_and_crossbones':'\u2620\ufe0f',
  'sleeping':'\ud83d\ude34',
  'sleeping_bed':'\ud83d\udecc',
  'sleepy':'\ud83d\ude2a',
  'slightly_frowning_face':'\ud83d\ude41',
  'slightly_smiling_face':'\ud83d\ude42',
  'slot_machine':'\ud83c\udfb0',
  'small_airplane':'\ud83d\udee9',
  'small_blue_diamond':'\ud83d\udd39',
  'small_orange_diamond':'\ud83d\udd38',
  'small_red_triangle':'\ud83d\udd3a',
  'small_red_triangle_down':'\ud83d\udd3b',
  'smile':'\ud83d\ude04',
  'smile_cat':'\ud83d\ude38',
  'smiley':'\ud83d\ude03',
  'smiley_cat':'\ud83d\ude3a',
  'smiling_imp':'\ud83d\ude08',
  'smirk':'\ud83d\ude0f',
  'smirk_cat':'\ud83d\ude3c',
  'smoking':'\ud83d\udeac',
  'snail':'\ud83d\udc0c',
  'snake':'\ud83d\udc0d',
  'sneezing_face':'\ud83e\udd27',
  'snowboarder':'\ud83c\udfc2',
  'snowflake':'\u2744\ufe0f',
  'snowman':'\u26c4\ufe0f',
  'snowman_with_snow':'\u2603\ufe0f',
  'sob':'\ud83d\ude2d',
  'soccer':'\u26bd\ufe0f',
  'soon':'\ud83d\udd1c',
  'sos':'\ud83c\udd98',
  'sound':'\ud83d\udd09',
  'space_invader':'\ud83d\udc7e',
  'spades':'\u2660\ufe0f',
  'spaghetti':'\ud83c\udf5d',
  'sparkle':'\u2747\ufe0f',
  'sparkler':'\ud83c\udf87',
  'sparkles':'\u2728',
  'sparkling_heart':'\ud83d\udc96',
  'speak_no_evil':'\ud83d\ude4a',
  'speaker':'\ud83d\udd08',
  'speaking_head':'\ud83d\udde3',
  'speech_balloon':'\ud83d\udcac',
  'speedboat':'\ud83d\udea4',
  'spider':'\ud83d\udd77',
  'spider_web':'\ud83d\udd78',
  'spiral_calendar':'\ud83d\uddd3',
  'spiral_notepad':'\ud83d\uddd2',
  'spoon':'\ud83e\udd44',
  'squid':'\ud83e\udd91',
  'stadium':'\ud83c\udfdf',
  'star':'\u2b50\ufe0f',
  'star2':'\ud83c\udf1f',
  'star_and_crescent':'\u262a\ufe0f',
  'star_of_david':'\u2721\ufe0f',
  'stars':'\ud83c\udf20',
  'station':'\ud83d\ude89',
  'statue_of_liberty':'\ud83d\uddfd',
  'steam_locomotive':'\ud83d\ude82',
  'stew':'\ud83c\udf72',
  'stop_button':'\u23f9',
  'stop_sign':'\ud83d\uded1',
  'stopwatch':'\u23f1',
  'straight_ruler':'\ud83d\udccf',
  'strawberry':'\ud83c\udf53',
  'stuck_out_tongue':'\ud83d\ude1b',
  'stuck_out_tongue_closed_eyes':'\ud83d\ude1d',
  'stuck_out_tongue_winking_eye':'\ud83d\ude1c',
  'studio_microphone':'\ud83c\udf99',
  'stuffed_flatbread':'\ud83e\udd59',
  'sun_behind_large_cloud':'\ud83c\udf25',
  'sun_behind_rain_cloud':'\ud83c\udf26',
  'sun_behind_small_cloud':'\ud83c\udf24',
  'sun_with_face':'\ud83c\udf1e',
  'sunflower':'\ud83c\udf3b',
  'sunglasses':'\ud83d\ude0e',
  'sunny':'\u2600\ufe0f',
  'sunrise':'\ud83c\udf05',
  'sunrise_over_mountains':'\ud83c\udf04',
  'surfing_man':'\ud83c\udfc4',
  'surfing_woman':'\ud83c\udfc4&zwj;\u2640\ufe0f',
  'sushi':'\ud83c\udf63',
  'suspension_railway':'\ud83d\ude9f',
  'sweat':'\ud83d\ude13',
  'sweat_drops':'\ud83d\udca6',
  'sweat_smile':'\ud83d\ude05',
  'sweet_potato':'\ud83c\udf60',
  'swimming_man':'\ud83c\udfca',
  'swimming_woman':'\ud83c\udfca&zwj;\u2640\ufe0f',
  'symbols':'\ud83d\udd23',
  'synagogue':'\ud83d\udd4d',
  'syringe':'\ud83d\udc89',
  'taco':'\ud83c\udf2e',
  'tada':'\ud83c\udf89',
  'tanabata_tree':'\ud83c\udf8b',
  'taurus':'\u2649\ufe0f',
  'taxi':'\ud83d\ude95',
  'tea':'\ud83c\udf75',
  'telephone_receiver':'\ud83d\udcde',
  'telescope':'\ud83d\udd2d',
  'tennis':'\ud83c\udfbe',
  'tent':'\u26fa\ufe0f',
  'thermometer':'\ud83c\udf21',
  'thinking':'\ud83e\udd14',
  'thought_balloon':'\ud83d\udcad',
  'ticket':'\ud83c\udfab',
  'tickets':'\ud83c\udf9f',
  'tiger':'\ud83d\udc2f',
  'tiger2':'\ud83d\udc05',
  'timer_clock':'\u23f2',
  'tipping_hand_man':'\ud83d\udc81&zwj;\u2642\ufe0f',
  'tired_face':'\ud83d\ude2b',
  'tm':'\u2122\ufe0f',
  'toilet':'\ud83d\udebd',
  'tokyo_tower':'\ud83d\uddfc',
  'tomato':'\ud83c\udf45',
  'tongue':'\ud83d\udc45',
  'top':'\ud83d\udd1d',
  'tophat':'\ud83c\udfa9',
  'tornado':'\ud83c\udf2a',
  'trackball':'\ud83d\uddb2',
  'tractor':'\ud83d\ude9c',
  'traffic_light':'\ud83d\udea5',
  'train':'\ud83d\ude8b',
  'train2':'\ud83d\ude86',
  'tram':'\ud83d\ude8a',
  'triangular_flag_on_post':'\ud83d\udea9',
  'triangular_ruler':'\ud83d\udcd0',
  'trident':'\ud83d\udd31',
  'triumph':'\ud83d\ude24',
  'trolleybus':'\ud83d\ude8e',
  'trophy':'\ud83c\udfc6',
  'tropical_drink':'\ud83c\udf79',
  'tropical_fish':'\ud83d\udc20',
  'truck':'\ud83d\ude9a',
  'trumpet':'\ud83c\udfba',
  'tulip':'\ud83c\udf37',
  'tumbler_glass':'\ud83e\udd43',
  'turkey':'\ud83e\udd83',
  'turtle':'\ud83d\udc22',
  'tv':'\ud83d\udcfa',
  'twisted_rightwards_arrows':'\ud83d\udd00',
  'two_hearts':'\ud83d\udc95',
  'two_men_holding_hands':'\ud83d\udc6c',
  'two_women_holding_hands':'\ud83d\udc6d',
  'u5272':'\ud83c\ude39',
  'u5408':'\ud83c\ude34',
  'u55b6':'\ud83c\ude3a',
  'u6307':'\ud83c\ude2f\ufe0f',
  'u6708':'\ud83c\ude37\ufe0f',
  'u6709':'\ud83c\ude36',
  'u6e80':'\ud83c\ude35',
  'u7121':'\ud83c\ude1a\ufe0f',
  'u7533':'\ud83c\ude38',
  'u7981':'\ud83c\ude32',
  'u7a7a':'\ud83c\ude33',
  'umbrella':'\u2614\ufe0f',
  'unamused':'\ud83d\ude12',
  'underage':'\ud83d\udd1e',
  'unicorn':'\ud83e\udd84',
  'unlock':'\ud83d\udd13',
  'up':'\ud83c\udd99',
  'upside_down_face':'\ud83d\ude43',
  'v':'\u270c\ufe0f',
  'vertical_traffic_light':'\ud83d\udea6',
  'vhs':'\ud83d\udcfc',
  'vibration_mode':'\ud83d\udcf3',
  'video_camera':'\ud83d\udcf9',
  'video_game':'\ud83c\udfae',
  'violin':'\ud83c\udfbb',
  'virgo':'\u264d\ufe0f',
  'volcano':'\ud83c\udf0b',
  'volleyball':'\ud83c\udfd0',
  'vs':'\ud83c\udd9a',
  'vulcan_salute':'\ud83d\udd96',
  'walking_man':'\ud83d\udeb6',
  'walking_woman':'\ud83d\udeb6&zwj;\u2640\ufe0f',
  'waning_crescent_moon':'\ud83c\udf18',
  'waning_gibbous_moon':'\ud83c\udf16',
  'warning':'\u26a0\ufe0f',
  'wastebasket':'\ud83d\uddd1',
  'watch':'\u231a\ufe0f',
  'water_buffalo':'\ud83d\udc03',
  'watermelon':'\ud83c\udf49',
  'wave':'\ud83d\udc4b',
  'wavy_dash':'\u3030\ufe0f',
  'waxing_crescent_moon':'\ud83c\udf12',
  'wc':'\ud83d\udebe',
  'weary':'\ud83d\ude29',
  'wedding':'\ud83d\udc92',
  'weight_lifting_man':'\ud83c\udfcb\ufe0f',
  'weight_lifting_woman':'\ud83c\udfcb\ufe0f&zwj;\u2640\ufe0f',
  'whale':'\ud83d\udc33',
  'whale2':'\ud83d\udc0b',
  'wheel_of_dharma':'\u2638\ufe0f',
  'wheelchair':'\u267f\ufe0f',
  'white_check_mark':'\u2705',
  'white_circle':'\u26aa\ufe0f',
  'white_flag':'\ud83c\udff3\ufe0f',
  'white_flower':'\ud83d\udcae',
  'white_large_square':'\u2b1c\ufe0f',
  'white_medium_small_square':'\u25fd\ufe0f',
  'white_medium_square':'\u25fb\ufe0f',
  'white_small_square':'\u25ab\ufe0f',
  'white_square_button':'\ud83d\udd33',
  'wilted_flower':'\ud83e\udd40',
  'wind_chime':'\ud83c\udf90',
  'wind_face':'\ud83c\udf2c',
  'wine_glass':'\ud83c\udf77',
  'wink':'\ud83d\ude09',
  'wolf':'\ud83d\udc3a',
  'woman':'\ud83d\udc69',
  'woman_artist':'\ud83d\udc69&zwj;\ud83c\udfa8',
  'woman_astronaut':'\ud83d\udc69&zwj;\ud83d\ude80',
  'woman_cartwheeling':'\ud83e\udd38&zwj;\u2640\ufe0f',
  'woman_cook':'\ud83d\udc69&zwj;\ud83c\udf73',
  'woman_facepalming':'\ud83e\udd26&zwj;\u2640\ufe0f',
  'woman_factory_worker':'\ud83d\udc69&zwj;\ud83c\udfed',
  'woman_farmer':'\ud83d\udc69&zwj;\ud83c\udf3e',
  'woman_firefighter':'\ud83d\udc69&zwj;\ud83d\ude92',
  'woman_health_worker':'\ud83d\udc69&zwj;\u2695\ufe0f',
  'woman_judge':'\ud83d\udc69&zwj;\u2696\ufe0f',
  'woman_juggling':'\ud83e\udd39&zwj;\u2640\ufe0f',
  'woman_mechanic':'\ud83d\udc69&zwj;\ud83d\udd27',
  'woman_office_worker':'\ud83d\udc69&zwj;\ud83d\udcbc',
  'woman_pilot':'\ud83d\udc69&zwj;\u2708\ufe0f',
  'woman_playing_handball':'\ud83e\udd3e&zwj;\u2640\ufe0f',
  'woman_playing_water_polo':'\ud83e\udd3d&zwj;\u2640\ufe0f',
  'woman_scientist':'\ud83d\udc69&zwj;\ud83d\udd2c',
  'woman_shrugging':'\ud83e\udd37&zwj;\u2640\ufe0f',
  'woman_singer':'\ud83d\udc69&zwj;\ud83c\udfa4',
  'woman_student':'\ud83d\udc69&zwj;\ud83c\udf93',
  'woman_teacher':'\ud83d\udc69&zwj;\ud83c\udfeb',
  'woman_technologist':'\ud83d\udc69&zwj;\ud83d\udcbb',
  'woman_with_turban':'\ud83d\udc73&zwj;\u2640\ufe0f',
  'womans_clothes':'\ud83d\udc5a',
  'womans_hat':'\ud83d\udc52',
  'women_wrestling':'\ud83e\udd3c&zwj;\u2640\ufe0f',
  'womens':'\ud83d\udeba',
  'world_map':'\ud83d\uddfa',
  'worried':'\ud83d\ude1f',
  'wrench':'\ud83d\udd27',
  'writing_hand':'\u270d\ufe0f',
  'x':'\u274c',
  'yellow_heart':'\ud83d\udc9b',
  'yen':'\ud83d\udcb4',
  'yin_yang':'\u262f\ufe0f',
  'yum':'\ud83d\ude0b',
  'zap':'\u26a1\ufe0f',
  'zipper_mouth_face':'\ud83e\udd10',
  'zzz':'\ud83d\udca4',

  /* special emojis :P */
  'octocat':  '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
  'showdown': '<span style="font-family: \'Anonymous Pro\', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>'
};

/**
 * Created by Estevao on 31-05-2015.
 */

/**
 * Showdown Converter class
 * @class
 * @param {object} [converterOptions]
 * @returns {Converter}
 */
showdown.Converter = function (converterOptions) {
  'use strict';

  var
      /**
       * Options used by this converter
       * @private
       * @type {{}}
       */
      options = {},

      /**
       * Language extensions used by this converter
       * @private
       * @type {Array}
       */
      langExtensions = [],

      /**
       * Output modifiers extensions used by this converter
       * @private
       * @type {Array}
       */
      outputModifiers = [],

      /**
       * Event listeners
       * @private
       * @type {{}}
       */
      listeners = {},

      /**
       * The flavor set in this converter
       */
      setConvFlavor = setFlavor,

      /**
       * Metadata of the document
       * @type {{parsed: {}, raw: string, format: string}}
       */
      metadata = {
        parsed: {},
        raw: '',
        format: ''
      };

  _constructor();

  /**
   * Converter constructor
   * @private
   */
  function _constructor () {
    converterOptions = converterOptions || {};

    for (var gOpt in globalOptions) {
      if (globalOptions.hasOwnProperty(gOpt)) {
        options[gOpt] = globalOptions[gOpt];
      }
    }

    // Merge options
    if (typeof converterOptions === 'object') {
      for (var opt in converterOptions) {
        if (converterOptions.hasOwnProperty(opt)) {
          options[opt] = converterOptions[opt];
        }
      }
    } else {
      throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +
      ' was passed instead.');
    }

    if (options.extensions) {
      showdown.helper.forEach(options.extensions, _parseExtension);
    }
  }

  /**
   * Parse extension
   * @param {*} ext
   * @param {string} [name='']
   * @private
   */
  function _parseExtension (ext, name) {

    name = name || null;
    // If it's a string, the extension was previously loaded
    if (showdown.helper.isString(ext)) {
      ext = showdown.helper.stdExtName(ext);
      name = ext;

      // LEGACY_SUPPORT CODE
      if (showdown.extensions[ext]) {
        console.warn('DEPRECATION WARNING: ' + ext + ' is an old extension that uses a deprecated loading method.' +
          'Please inform the developer that the extension should be updated!');
        legacyExtensionLoading(showdown.extensions[ext], ext);
        return;
        // END LEGACY SUPPORT CODE

      } else if (!showdown.helper.isUndefined(extensions[ext])) {
        ext = extensions[ext];

      } else {
        throw Error('Extension "' + ext + '" could not be loaded. It was either not found or is not a valid extension.');
      }
    }

    if (typeof ext === 'function') {
      ext = ext();
    }

    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }

    var validExt = validate(ext, name);
    if (!validExt.valid) {
      throw Error(validExt.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {

        case 'lang':
          langExtensions.push(ext[i]);
          break;

        case 'output':
          outputModifiers.push(ext[i]);
          break;
      }
      if (ext[i].hasOwnProperty('listeners')) {
        for (var ln in ext[i].listeners) {
          if (ext[i].listeners.hasOwnProperty(ln)) {
            listen(ln, ext[i].listeners[ln]);
          }
        }
      }
    }

  }

  /**
   * LEGACY_SUPPORT
   * @param {*} ext
   * @param {string} name
   */
  function legacyExtensionLoading (ext, name) {
    if (typeof ext === 'function') {
      ext = ext(new showdown.Converter());
    }
    if (!showdown.helper.isArray(ext)) {
      ext = [ext];
    }
    var valid = validate(ext, name);

    if (!valid.valid) {
      throw Error(valid.error);
    }

    for (var i = 0; i < ext.length; ++i) {
      switch (ext[i].type) {
        case 'lang':
          langExtensions.push(ext[i]);
          break;
        case 'output':
          outputModifiers.push(ext[i]);
          break;
        default:// should never reach here
          throw Error('Extension loader error: Type unrecognized!!!');
      }
    }
  }

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   */
  function listen (name, callback) {
    if (!showdown.helper.isString(name)) {
      throw Error('Invalid argument in converter.listen() method: name must be a string, but ' + typeof name + ' given');
    }

    if (typeof callback !== 'function') {
      throw Error('Invalid argument in converter.listen() method: callback must be a function, but ' + typeof callback + ' given');
    }

    if (!listeners.hasOwnProperty(name)) {
      listeners[name] = [];
    }
    listeners[name].push(callback);
  }

  function rTrimInputText (text) {
    var rsp = text.match(/^\s*/)[0].length,
        rgx = new RegExp('^\\s{0,' + rsp + '}', 'gm');
    return text.replace(rgx, '');
  }

  /**
   * Dispatch an event
   * @private
   * @param {string} evtName Event name
   * @param {string} text Text
   * @param {{}} options Converter Options
   * @param {{}} globals
   * @returns {string}
   */
  this._dispatch = function dispatch (evtName, text, options, globals) {
    if (listeners.hasOwnProperty(evtName)) {
      for (var ei = 0; ei < listeners[evtName].length; ++ei) {
        var nText = listeners[evtName][ei](evtName, text, this, options, globals);
        if (nText && typeof nText !== 'undefined') {
          text = nText;
        }
      }
    }
    return text;
  };

  /**
   * Listen to an event
   * @param {string} name
   * @param {function} callback
   * @returns {showdown.Converter}
   */
  this.listen = function (name, callback) {
    listen(name, callback);
    return this;
  };

  /**
   * Converts a markdown string into HTML
   * @param {string} text
   * @returns {*}
   */
  this.makeHtml = function (text) {
    //check if text is not falsy
    if (!text) {
      return text;
    }

    var globals = {
      gHtmlBlocks:     [],
      gHtmlMdBlocks:   [],
      gHtmlSpans:      [],
      gUrls:           {},
      gTitles:         {},
      gDimensions:     {},
      gListLevel:      0,
      hashLinkCounts:  {},
      langExtensions:  langExtensions,
      outputModifiers: outputModifiers,
      converter:       this,
      ghCodeBlocks:    [],
      metadata: {
        parsed: {},
        raw: '',
        format: ''
      }
    };

    // This lets us use ¨ trema as an escape char to avoid md5 hashes
    // The choice of character is arbitrary; anything that isn't
    // magic in Markdown will work.
    text = text.replace(/¨/g, '¨T');

    // Replace $ with ¨D
    // RegExp interprets $ as a special character
    // when it's in a replacement string
    text = text.replace(/\$/g, '¨D');

    // Standardize line endings
    text = text.replace(/\r\n/g, '\n'); // DOS to Unix
    text = text.replace(/\r/g, '\n'); // Mac to Unix

    // Stardardize line spaces
    text = text.replace(/\u00A0/g, '&nbsp;');

    if (options.smartIndentationFix) {
      text = rTrimInputText(text);
    }

    // Make sure text begins and ends with a couple of newlines:
    text = '\n\n' + text + '\n\n';

    // detab
    text = showdown.subParser('detab')(text, options, globals);

    /**
     * Strip any lines consisting only of spaces and tabs.
     * This makes subsequent regexs easier to write, because we can
     * match consecutive blank lines with /\n+/ instead of something
     * contorted like /[ \t]*\n+/
     */
    text = text.replace(/^[ \t]+$/mg, '');

    //run languageExtensions
    showdown.helper.forEach(langExtensions, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // run the sub parsers
    text = showdown.subParser('metadata')(text, options, globals);
    text = showdown.subParser('hashPreCodeTags')(text, options, globals);
    text = showdown.subParser('githubCodeBlocks')(text, options, globals);
    text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
    text = showdown.subParser('hashCodeTags')(text, options, globals);
    text = showdown.subParser('stripLinkDefinitions')(text, options, globals);
    text = showdown.subParser('blockGamut')(text, options, globals);
    text = showdown.subParser('unhashHTMLSpans')(text, options, globals);
    text = showdown.subParser('unescapeSpecialChars')(text, options, globals);

    // attacklab: Restore dollar signs
    text = text.replace(/¨D/g, '$$');

    // attacklab: Restore tremas
    text = text.replace(/¨T/g, '¨');

    // render a complete html document instead of a partial if the option is enabled
    text = showdown.subParser('completeHTMLDocument')(text, options, globals);

    // Run output modifiers
    showdown.helper.forEach(outputModifiers, function (ext) {
      text = showdown.subParser('runExtension')(ext, text, options, globals);
    });

    // update metadata
    metadata = globals.metadata;
    return text;
  };

  /**
   * Converts an HTML string into a markdown string
   * @param src
   * @param [HTMLParser] A WHATWG DOM and HTML parser, such as JSDOM. If none is supplied, window.document will be used.
   * @returns {string}
   */
  this.makeMarkdown = this.makeMd = function (src, HTMLParser) {

    // replace \r\n with \n
    src = src.replace(/\r\n/g, '\n');
    src = src.replace(/\r/g, '\n'); // old macs

    // due to an edge case, we need to find this: > <
    // to prevent removing of non silent white spaces
    // ex: <em>this is</em> <strong>sparta</strong>
    src = src.replace(/>[ \t]+</, '>¨NBSP;<');

    if (!HTMLParser) {
      if (window && window.document) {
        HTMLParser = window.document;
      } else {
        throw new Error('HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM');
      }
    }

    var doc = HTMLParser.createElement('div');
    doc.innerHTML = src;

    var globals = {
      preList: substitutePreCodeTags(doc)
    };

    // remove all newlines and collapse spaces
    clean(doc);

    // some stuff, like accidental reference links must now be escaped
    // TODO
    // doc.innerHTML = doc.innerHTML.replace(/\[[\S\t ]]/);

    var nodes = doc.childNodes,
        mdDoc = '';

    for (var i = 0; i < nodes.length; i++) {
      mdDoc += showdown.subParser('makeMarkdown.node')(nodes[i], globals);
    }

    function clean (node) {
      for (var n = 0; n < node.childNodes.length; ++n) {
        var child = node.childNodes[n];
        if (child.nodeType === 3) {
          if (!/\S/.test(child.nodeValue)) {
            node.removeChild(child);
            --n;
          } else {
            child.nodeValue = child.nodeValue.split('\n').join(' ');
            child.nodeValue = child.nodeValue.replace(/(\s)+/g, '$1');
          }
        } else if (child.nodeType === 1) {
          clean(child);
        }
      }
    }

    // find all pre tags and replace contents with placeholder
    // we need this so that we can remove all indentation from html
    // to ease up parsing
    function substitutePreCodeTags (doc) {

      var pres = doc.querySelectorAll('pre'),
          presPH = [];

      for (var i = 0; i < pres.length; ++i) {

        if (pres[i].childElementCount === 1 && pres[i].firstChild.tagName.toLowerCase() === 'code') {
          var content = pres[i].firstChild.innerHTML.trim(),
              language = pres[i].firstChild.getAttribute('data-language') || '';

          // if data-language attribute is not defined, then we look for class language-*
          if (language === '') {
            var classes = pres[i].firstChild.className.split(' ');
            for (var c = 0; c < classes.length; ++c) {
              var matches = classes[c].match(/^language-(.+)$/);
              if (matches !== null) {
                language = matches[1];
                break;
              }
            }
          }

          // unescape html entities in content
          content = showdown.helper.unescapeHTMLEntities(content);

          presPH.push(content);
          pres[i].outerHTML = '<precode language="' + language + '" precodenum="' + i.toString() + '"></precode>';
        } else {
          presPH.push(pres[i].innerHTML);
          pres[i].innerHTML = '';
          pres[i].setAttribute('prenum', i.toString());
        }
      }
      return presPH;
    }

    return mdDoc;
  };

  /**
   * Set an option of this Converter instance
   * @param {string} key
   * @param {*} value
   */
  this.setOption = function (key, value) {
    options[key] = value;
  };

  /**
   * Get the option of this Converter instance
   * @param {string} key
   * @returns {*}
   */
  this.getOption = function (key) {
    return options[key];
  };

  /**
   * Get the options of this Converter instance
   * @returns {{}}
   */
  this.getOptions = function () {
    return options;
  };

  /**
   * Add extension to THIS converter
   * @param {{}} extension
   * @param {string} [name=null]
   */
  this.addExtension = function (extension, name) {
    name = name || null;
    _parseExtension(extension, name);
  };

  /**
   * Use a global registered extension with THIS converter
   * @param {string} extensionName Name of the previously registered extension
   */
  this.useExtension = function (extensionName) {
    _parseExtension(extensionName);
  };

  /**
   * Set the flavor THIS converter should use
   * @param {string} name
   */
  this.setFlavor = function (name) {
    if (!flavor.hasOwnProperty(name)) {
      throw Error(name + ' flavor was not found');
    }
    var preset = flavor[name];
    setConvFlavor = name;
    for (var option in preset) {
      if (preset.hasOwnProperty(option)) {
        options[option] = preset[option];
      }
    }
  };

  /**
   * Get the currently set flavor of this converter
   * @returns {string}
   */
  this.getFlavor = function () {
    return setConvFlavor;
  };

  /**
   * Remove an extension from THIS converter.
   * Note: This is a costly operation. It's better to initialize a new converter
   * and specify the extensions you wish to use
   * @param {Array} extension
   */
  this.removeExtension = function (extension) {
    if (!showdown.helper.isArray(extension)) {
      extension = [extension];
    }
    for (var a = 0; a < extension.length; ++a) {
      var ext = extension[a];
      for (var i = 0; i < langExtensions.length; ++i) {
        if (langExtensions[i] === ext) {
          langExtensions[i].splice(i, 1);
        }
      }
      for (var ii = 0; ii < outputModifiers.length; ++i) {
        if (outputModifiers[ii] === ext) {
          outputModifiers[ii].splice(i, 1);
        }
      }
    }
  };

  /**
   * Get all extension of THIS converter
   * @returns {{language: Array, output: Array}}
   */
  this.getAllExtensions = function () {
    return {
      language: langExtensions,
      output: outputModifiers
    };
  };

  /**
   * Get the metadata of the previously parsed document
   * @param raw
   * @returns {string|{}}
   */
  this.getMetadata = function (raw) {
    if (raw) {
      return metadata.raw;
    } else {
      return metadata.parsed;
    }
  };

  /**
   * Get the metadata format of the previously parsed document
   * @returns {string}
   */
  this.getMetadataFormat = function () {
    return metadata.format;
  };

  /**
   * Private: set a single key, value metadata pair
   * @param {string} key
   * @param {string} value
   */
  this._setMetadataPair = function (key, value) {
    metadata.parsed[key] = value;
  };

  /**
   * Private: set metadata format
   * @param {string} format
   */
  this._setMetadataFormat = function (format) {
    metadata.format = format;
  };

  /**
   * Private: set metadata raw text
   * @param {string} raw
   */
  this._setMetadataRaw = function (raw) {
    metadata.raw = raw;
  };
};

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('anchors', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('anchors.before', text, options, globals);

  var writeAnchorTag = function (wholeMatch, linkText, linkId, url, m5, m6, title) {
    if (showdown.helper.isUndefined(title)) {
      title = '';
    }
    linkId = linkId.toLowerCase();

    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';
    } else if (!url) {
      if (!linkId) {
        // lower-case and turn embedded newlines into spaces
        linkId = linkText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {
        url = globals.gUrls[linkId];
        if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {
          title = globals.gTitles[linkId];
        }
      } else {
        return wholeMatch;
      }
    }

    //url = showdown.helper.escapeCharacters(url, '*_', false); // replaced line to improve performance
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);

    var result = '<a href="' + url + '"';

    if (title !== '' && title !== null) {
      title = title.replace(/"/g, '&quot;');
      //title = showdown.helper.escapeCharacters(title, '*_', false); // replaced line to improve performance
      title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    // optionLinksInNewWindow only applies
    // to external links. Hash links (#) open in same page
    if (options.openLinksInNewWindow && !/^#/.test(url)) {
      // escaped _
      result += ' rel="noopener noreferrer" target="¨E95Eblank"';
    }

    result += '>' + linkText + '</a>';

    return result;
  };

  // First, handle reference-style links: [link text] [id]
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, writeAnchorTag);

  // Next, inline-style links: [link text](url "optional title")
  // cases with crazy urls like ./image/cat1).png
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // normal cases
  text = text.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
    writeAnchorTag);

  // handle reference-style shortcuts: [link text]
  // These must come last in case you've also got [link test][1]
  // or [link test](/foo)
  text = text.replace(/\[([^\[\]]+)]()()()()()/g, writeAnchorTag);

  // Lastly handle GithubMentions if option is enabled
  if (options.ghMentions) {
    text = text.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (wm, st, escape, mentions, username) {
      if (escape === '\\') {
        return st + mentions;
      }

      //check if options.ghMentionsLink is a string
      if (!showdown.helper.isString(options.ghMentionsLink)) {
        throw new Error('ghMentionsLink option must be a string');
      }
      var lnk = options.ghMentionsLink.replace(/\{u}/g, username),
          target = '';
      if (options.openLinksInNewWindow) {
        target = ' rel="noopener noreferrer" target="¨E95Eblank"';
      }
      return st + '<a href="' + lnk + '"' + target + '>' + mentions + '</a>';
    });
  }

  text = globals.converter._dispatch('anchors.after', text, options, globals);
  return text;
});

// url allowed chars [a-z\d_.~:/?#[]@!$&'()*+,;=-]

var simpleURLRegex  = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
    simpleURLRegex2 = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
    delimUrlRegex   = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
    simpleMailRegex = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi,
    delimMailRegex  = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,

    replaceLink = function (options) {
      'use strict';
      return function (wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {
        link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
        var lnkTxt = link,
            append = '',
            target = '',
            lmc    = leadingMagicChars || '',
            tmc    = trailingMagicChars || '';
        if (/^www\./i.test(link)) {
          link = link.replace(/^www\./i, 'http://www.');
        }
        if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {
          append = trailingPunctuation;
        }
        if (options.openLinksInNewWindow) {
          target = ' rel="noopener noreferrer" target="¨E95Eblank"';
        }
        return lmc + '<a href="' + link + '"' + target + '>' + lnkTxt + '</a>' + append + tmc;
      };
    },

    replaceMail = function (options, globals) {
      'use strict';
      return function (wholeMatch, b, mail) {
        var href = 'mailto:';
        b = b || '';
        mail = showdown.subParser('unescapeSpecialChars')(mail, options, globals);
        if (options.encodeEmails) {
          href = showdown.helper.encodeEmailAddress(href + mail);
          mail = showdown.helper.encodeEmailAddress(mail);
        } else {
          href = href + mail;
        }
        return b + '<a href="' + href + '">' + mail + '</a>';
      };
    };

showdown.subParser('autoLinks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('autoLinks.before', text, options, globals);

  text = text.replace(delimUrlRegex, replaceLink(options));
  text = text.replace(delimMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('autoLinks.after', text, options, globals);

  return text;
});

showdown.subParser('simplifiedAutoLinks', function (text, options, globals) {
  'use strict';

  if (!options.simplifiedAutoLink) {
    return text;
  }

  text = globals.converter._dispatch('simplifiedAutoLinks.before', text, options, globals);

  if (options.excludeTrailingPunctuationFromURLs) {
    text = text.replace(simpleURLRegex2, replaceLink(options));
  } else {
    text = text.replace(simpleURLRegex, replaceLink(options));
  }
  text = text.replace(simpleMailRegex, replaceMail(options, globals));

  text = globals.converter._dispatch('simplifiedAutoLinks.after', text, options, globals);

  return text;
});

/**
 * These are all the transformations that form block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('blockGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockGamut.before', text, options, globals);

  // we parse blockquotes first so that we can have headings and hrs
  // inside blockquotes
  text = showdown.subParser('blockQuotes')(text, options, globals);
  text = showdown.subParser('headers')(text, options, globals);

  // Do Horizontal Rules:
  text = showdown.subParser('horizontalRule')(text, options, globals);

  text = showdown.subParser('lists')(text, options, globals);
  text = showdown.subParser('codeBlocks')(text, options, globals);
  text = showdown.subParser('tables')(text, options, globals);

  // We already ran _HashHTMLBlocks() before, in Markdown(), but that
  // was to escape raw HTML in the original Markdown source. This time,
  // we're escaping the markup we've just created, so that we don't wrap
  // <p> tags around block-level tags.
  text = showdown.subParser('hashHTMLBlocks')(text, options, globals);
  text = showdown.subParser('paragraphs')(text, options, globals);

  text = globals.converter._dispatch('blockGamut.after', text, options, globals);

  return text;
});

showdown.subParser('blockQuotes', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('blockQuotes.before', text, options, globals);

  // add a couple extra lines after the text and endtext mark
  text = text + '\n\n';

  var rgx = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;

  if (options.splitAdjacentBlockquotes) {
    rgx = /^ {0,3}>[\s\S]*?(?:\n\n)/gm;
  }

  text = text.replace(rgx, function (bq) {
    // attacklab: hack around Konqueror 3.5.4 bug:
    // "----------bug".replace(/^-/g,"") == "bug"
    bq = bq.replace(/^[ \t]*>[ \t]?/gm, ''); // trim one level of quoting

    // attacklab: clean up hack
    bq = bq.replace(/¨0/g, '');

    bq = bq.replace(/^[ \t]+$/gm, ''); // trim whitespace-only lines
    bq = showdown.subParser('githubCodeBlocks')(bq, options, globals);
    bq = showdown.subParser('blockGamut')(bq, options, globals); // recurse

    bq = bq.replace(/(^|\n)/g, '$1  ');
    // These leading spaces screw with <pre> content, so we need to fix that:
    bq = bq.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (wholeMatch, m1) {
      var pre = m1;
      // attacklab: hack around Konqueror 3.5.4 bug:
      pre = pre.replace(/^  /mg, '¨0');
      pre = pre.replace(/¨0/g, '');
      return pre;
    });

    return showdown.subParser('hashBlock')('<blockquote>\n' + bq + '\n</blockquote>', options, globals);
  });

  text = globals.converter._dispatch('blockQuotes.after', text, options, globals);
  return text;
});

/**
 * Process Markdown `<pre><code>` blocks.
 */
showdown.subParser('codeBlocks', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeBlocks.before', text, options, globals);

  // sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var pattern = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=¨0))/g;
  text = text.replace(pattern, function (wholeMatch, m1, m2) {
    var codeblock = m1,
        nextChar = m2,
        end = '\n';

    codeblock = showdown.subParser('outdent')(codeblock, options, globals);
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing newlines

    if (options.omitExtraWLInCodeBlocks) {
      end = '';
    }

    codeblock = '<pre><code>' + codeblock + end + '</code></pre>';

    return showdown.subParser('hashBlock')(codeblock, options, globals) + nextChar;
  });

  // strip sentinel
  text = text.replace(/¨0/, '');

  text = globals.converter._dispatch('codeBlocks.after', text, options, globals);
  return text;
});

/**
 *
 *   *  Backtick quotes are used for <code></code> spans.
 *
 *   *  You can use multiple backticks as the delimiters if you want to
 *     include literal backticks in the code span. So, this input:
 *
 *         Just type ``foo `bar` baz`` at the prompt.
 *
 *       Will translate to:
 *
 *         <p>Just type <code>foo `bar` baz</code> at the prompt.</p>
 *
 *    There's no arbitrary limit to the number of backticks you
 *    can use as delimters. If you need three consecutive backticks
 *    in your code, use four for delimiters, etc.
 *
 *  *  You can use spaces to get literal backticks at the edges:
 *
 *         ... type `` `bar` `` ...
 *
 *       Turns to:
 *
 *         ... type <code>`bar`</code> ...
 */
showdown.subParser('codeSpans', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('codeSpans.before', text, options, globals);

  if (typeof text === 'undefined') {
    text = '';
  }
  text = text.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
    function (wholeMatch, m1, m2, m3) {
      var c = m3;
      c = c.replace(/^([ \t]*)/g, '');	// leading whitespace
      c = c.replace(/[ \t]*$/g, '');	// trailing whitespace
      c = showdown.subParser('encodeCode')(c, options, globals);
      c = m1 + '<code>' + c + '</code>';
      c = showdown.subParser('hashHTMLSpans')(c, options, globals);
      return c;
    }
  );

  text = globals.converter._dispatch('codeSpans.after', text, options, globals);
  return text;
});

/**
 * Create a full HTML document from the processed markdown
 */
showdown.subParser('completeHTMLDocument', function (text, options, globals) {
  'use strict';

  if (!options.completeHTMLDocument) {
    return text;
  }

  text = globals.converter._dispatch('completeHTMLDocument.before', text, options, globals);

  var doctype = 'html',
      doctypeParsed = '<!DOCTYPE HTML>\n',
      title = '',
      charset = '<meta charset="utf-8">\n',
      lang = '',
      metadata = '';

  if (typeof globals.metadata.parsed.doctype !== 'undefined') {
    doctypeParsed = '<!DOCTYPE ' +  globals.metadata.parsed.doctype + '>\n';
    doctype = globals.metadata.parsed.doctype.toString().toLowerCase();
    if (doctype === 'html' || doctype === 'html5') {
      charset = '<meta charset="utf-8">';
    }
  }

  for (var meta in globals.metadata.parsed) {
    if (globals.metadata.parsed.hasOwnProperty(meta)) {
      switch (meta.toLowerCase()) {
        case 'doctype':
          break;

        case 'title':
          title = '<title>' +  globals.metadata.parsed.title + '</title>\n';
          break;

        case 'charset':
          if (doctype === 'html' || doctype === 'html5') {
            charset = '<meta charset="' + globals.metadata.parsed.charset + '">\n';
          } else {
            charset = '<meta name="charset" content="' + globals.metadata.parsed.charset + '">\n';
          }
          break;

        case 'language':
        case 'lang':
          lang = ' lang="' + globals.metadata.parsed[meta] + '"';
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
          break;

        default:
          metadata += '<meta name="' + meta + '" content="' + globals.metadata.parsed[meta] + '">\n';
      }
    }
  }

  text = doctypeParsed + '<html' + lang + '>\n<head>\n' + title + charset + metadata + '</head>\n<body>\n' + text.trim() + '\n</body>\n</html>';

  text = globals.converter._dispatch('completeHTMLDocument.after', text, options, globals);
  return text;
});

/**
 * Convert all tabs to spaces
 */
showdown.subParser('detab', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('detab.before', text, options, globals);

  // expand first n-1 tabs
  text = text.replace(/\t(?=\t)/g, '    '); // g_tab_width

  // replace the nth with two sentinels
  text = text.replace(/\t/g, '¨A¨B');

  // use the sentinel to anchor our regex so it doesn't explode
  text = text.replace(/¨B(.+?)¨A/g, function (wholeMatch, m1) {
    var leadingText = m1,
        numSpaces = 4 - leadingText.length % 4;  // g_tab_width

    // there *must* be a better way to do this:
    for (var i = 0; i < numSpaces; i++) {
      leadingText += ' ';
    }

    return leadingText;
  });

  // clean up sentinels
  text = text.replace(/¨A/g, '    ');  // g_tab_width
  text = text.replace(/¨B/g, '');

  text = globals.converter._dispatch('detab.after', text, options, globals);
  return text;
});

showdown.subParser('ellipsis', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('ellipsis.before', text, options, globals);

  //text = text.replace(/\.\.\./g, '…');

  text = globals.converter._dispatch('ellipsis.after', text, options, globals);

  return text;
});

/**
 * Turn emoji codes into emojis
 *
 * List of supported emojis: https://github.com/showdownjs/showdown/wiki/Emojis
 */
showdown.subParser('emoji', function (text, options, globals) {
  'use strict';

  if (!options.emoji) {
    return text;
  }

  text = globals.converter._dispatch('emoji.before', text, options, globals);

  var emojiRgx = /:([\S]+?):/g;

  text = text.replace(emojiRgx, function (wm, emojiCode) {
    if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {
      return showdown.helper.emojis[emojiCode];
    }
    return wm;
  });

  text = globals.converter._dispatch('emoji.after', text, options, globals);

  return text;
});

/**
 * Smart processing for ampersands and angle brackets that need to be encoded.
 */
showdown.subParser('encodeAmpsAndAngles', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeAmpsAndAngles.before', text, options, globals);

  // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
  // http://bumppo.net/projects/amputator/
  text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, '&amp;');

  // Encode naked <'s
  text = text.replace(/<(?![a-z\/?$!])/gi, '&lt;');

  // Encode <
  text = text.replace(/</g, '&lt;');

  // Encode >
  text = text.replace(/>/g, '&gt;');

  text = globals.converter._dispatch('encodeAmpsAndAngles.after', text, options, globals);
  return text;
});

/**
 * Returns the string, with after processing the following backslash escape sequences.
 *
 * attacklab: The polite way to do this is with the new escapeCharacters() function:
 *
 *    text = escapeCharacters(text,"\\",true);
 *    text = escapeCharacters(text,"`*_{}[]()>#+-.!",true);
 *
 * ...but we're sidestepping its use of the (slow) RegExp constructor
 * as an optimization for Firefox.  This function gets called a LOT.
 */
showdown.subParser('encodeBackslashEscapes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('encodeBackslashEscapes.before', text, options, globals);

  text = text.replace(/\\(\\)/g, showdown.helper.escapeCharactersCallback);
  text = text.replace(/\\([`*_{}\[\]()>#+.!~=|-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeBackslashEscapes.after', text, options, globals);
  return text;
});

/**
 * Encode/escape certain characters inside Markdown code runs.
 * The point is that in code, these characters are literals,
 * and lose their special Markdown meanings.
 */
showdown.subParser('encodeCode', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('encodeCode.before', text, options, globals);

  // Encode all ampersands; HTML entities are not
  // entities within a Markdown code span.
  text = text
    .replace(/&/g, '&amp;')
  // Do the angle bracket song and dance:
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
  // Now, escape characters that are magic in Markdown:
    .replace(/([*_{}\[\]\\=~-])/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('encodeCode.after', text, options, globals);
  return text;
});

/**
 * Within tags -- meaning between < and > -- encode [\ ` * _ ~ =] so they
 * don't conflict with their use in Markdown for code, italics and strong.
 */
showdown.subParser('escapeSpecialCharsWithinTagAttributes', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.before', text, options, globals);

  // Build a regex to find HTML tags.
  var tags     = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
      comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;

  text = text.replace(tags, function (wholeMatch) {
    return wholeMatch
      .replace(/(.)<\/?code>(?=.)/g, '$1`')
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = text.replace(comments, function (wholeMatch) {
    return wholeMatch
      .replace(/([\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);
  });

  text = globals.converter._dispatch('escapeSpecialCharsWithinTagAttributes.after', text, options, globals);
  return text;
});

/**
 * Handle github codeblocks prior to running HashHTML so that
 * HTML contained within the codeblock gets escaped properly
 * Example:
 * ```ruby
 *     def hello_world(x)
 *       puts "Hello, #{x}"
 *     end
 * ```
 */
showdown.subParser('githubCodeBlocks', function (text, options, globals) {
  'use strict';

  // early exit if option is not enabled
  if (!options.ghCodeBlocks) {
    return text;
  }

  text = globals.converter._dispatch('githubCodeBlocks.before', text, options, globals);

  text += '¨0';

  text = text.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (wholeMatch, delim, language, codeblock) {
    var end = (options.omitExtraWLInCodeBlocks) ? '' : '\n';

    // First parse the github code block
    codeblock = showdown.subParser('encodeCode')(codeblock, options, globals);
    codeblock = showdown.subParser('detab')(codeblock, options, globals);
    codeblock = codeblock.replace(/^\n+/g, ''); // trim leading newlines
    codeblock = codeblock.replace(/\n+$/g, ''); // trim trailing whitespace

    codeblock = '<pre><code' + (language ? ' class="' + language + ' language-' + language + '"' : '') + '>' + codeblock + end + '</code></pre>';

    codeblock = showdown.subParser('hashBlock')(codeblock, options, globals);

    // Since GHCodeblocks can be false positives, we need to
    // store the primitive text and the parsed text in a global var,
    // and then return a token
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  });

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return globals.converter._dispatch('githubCodeBlocks.after', text, options, globals);
});

showdown.subParser('hashBlock', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashBlock.before', text, options, globals);
  text = text.replace(/(^\n+|\n+$)/g, '');
  text = '\n\n¨K' + (globals.gHtmlBlocks.push(text) - 1) + 'K\n\n';
  text = globals.converter._dispatch('hashBlock.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <code> elements that should not be parsed as markdown
 */
showdown.subParser('hashCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '¨C' + (globals.gHtmlSpans.push(codeblock) - 1) + 'C';
  };

  // Hash naked <code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '<code\\b[^>]*>', '</code>', 'gim');

  text = globals.converter._dispatch('hashCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('hashElement', function (text, options, globals) {
  'use strict';

  return function (wholeMatch, m1) {
    var blockText = m1;

    // Undo double lines
    blockText = blockText.replace(/\n\n/g, '\n');
    blockText = blockText.replace(/^\n/, '');

    // strip trailing blank lines
    blockText = blockText.replace(/\n+$/g, '');

    // Replace the element text with a marker ("¨KxK" where x is its key)
    blockText = '\n\n¨K' + (globals.gHtmlBlocks.push(blockText) - 1) + 'K\n\n';

    return blockText;
  };
});

showdown.subParser('hashHTMLBlocks', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLBlocks.before', text, options, globals);

  var blockTags = [
        'pre',
        'div',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'blockquote',
        'table',
        'dl',
        'ol',
        'ul',
        'script',
        'noscript',
        'form',
        'fieldset',
        'iframe',
        'math',
        'style',
        'section',
        'header',
        'footer',
        'nav',
        'article',
        'aside',
        'address',
        'audio',
        'canvas',
        'figure',
        'hgroup',
        'output',
        'video',
        'p'
      ],
      repFunc = function (wholeMatch, match, left, right) {
        var txt = wholeMatch;
        // check if this html element is marked as markdown
        // if so, it's contents should be parsed as markdown
        if (left.search(/\bmarkdown\b/) !== -1) {
          txt = left + globals.converter.makeHtml(match) + right;
        }
        return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
      };

  if (options.backslashEscapesHTMLTags) {
    // encode backslash escaped HTML tags
    text = text.replace(/\\<(\/?[^>]+?)>/g, function (wm, inside) {
      return '&lt;' + inside + '&gt;';
    });
  }

  // hash HTML Blocks
  for (var i = 0; i < blockTags.length; ++i) {

    var opTagPos,
        rgx1     = new RegExp('^ {0,3}(<' + blockTags[i] + '\\b[^>]*>)', 'im'),
        patLeft  = '<' + blockTags[i] + '\\b[^>]*>',
        patRight = '</' + blockTags[i] + '>';
    // 1. Look for the first position of the first opening HTML tag in the text
    while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {

      // if the HTML tag is \ escaped, we need to escape it and break


      //2. Split the text in that position
      var subTexts = showdown.helper.splitAtIndex(text, opTagPos),
          //3. Match recursively
          newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, 'im');

      // prevent an infinite loop
      if (newSubText1 === subTexts[1]) {
        break;
      }
      text = subTexts[0].concat(newSubText1);
    }
  }
  // HR SPECIAL CASE
  text = text.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  // Special case for standalone HTML comments
  text = showdown.helper.replaceRecursiveRegExp(text, function (txt) {
    return '\n\n¨K' + (globals.gHtmlBlocks.push(txt) - 1) + 'K\n\n';
  }, '^ {0,3}<!--', '-->', 'gm');

  // PHP and ASP-style processor instructions (<?...?> and <%...%>)
  text = text.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
    showdown.subParser('hashElement')(text, options, globals));

  text = globals.converter._dispatch('hashHTMLBlocks.after', text, options, globals);
  return text;
});

/**
 * Hash span elements that should not be parsed as markdown
 */
showdown.subParser('hashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashHTMLSpans.before', text, options, globals);

  function hashHTMLSpan (html) {
    return '¨C' + (globals.gHtmlSpans.push(html) - 1) + 'C';
  }

  // Hash Self Closing tags
  text = text.replace(/<[^>]+?\/>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags without properties
  text = text.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash tags with properties
  text = text.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (wm) {
    return hashHTMLSpan(wm);
  });

  // Hash self closing tags without />
  text = text.replace(/<[^>]+?>/gi, function (wm) {
    return hashHTMLSpan(wm);
  });

  /*showdown.helper.matchRecursiveRegExp(text, '<code\\b[^>]*>', '</code>', 'gi');*/

  text = globals.converter._dispatch('hashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Unhash HTML spans
 */
showdown.subParser('unhashHTMLSpans', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unhashHTMLSpans.before', text, options, globals);

  for (var i = 0; i < globals.gHtmlSpans.length; ++i) {
    var repText = globals.gHtmlSpans[i],
        // limiter to prevent infinite loop (assume 10 as limit for recurse)
        limit = 0;

    while (/¨C(\d+)C/.test(repText)) {
      var num = RegExp.$1;
      repText = repText.replace('¨C' + num + 'C', globals.gHtmlSpans[num]);
      if (limit === 10) {
        console.error('maximum nesting of 10 spans reached!!!');
        break;
      }
      ++limit;
    }
    text = text.replace('¨C' + i + 'C', repText);
  }

  text = globals.converter._dispatch('unhashHTMLSpans.after', text, options, globals);
  return text;
});

/**
 * Hash and escape <pre><code> elements that should not be parsed as markdown
 */
showdown.subParser('hashPreCodeTags', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('hashPreCodeTags.before', text, options, globals);

  var repFunc = function (wholeMatch, match, left, right) {
    // encode html entities
    var codeblock = left + showdown.subParser('encodeCode')(match, options, globals) + right;
    return '\n\n¨G' + (globals.ghCodeBlocks.push({text: wholeMatch, codeblock: codeblock}) - 1) + 'G\n\n';
  };

  // Hash <pre><code>
  text = showdown.helper.replaceRecursiveRegExp(text, repFunc, '^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>', '^ {0,3}</code>\\s*</pre>', 'gim');

  text = globals.converter._dispatch('hashPreCodeTags.after', text, options, globals);
  return text;
});

showdown.subParser('headers', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('headers.before', text, options, globals);

  var headerLevelStart = (isNaN(parseInt(options.headerLevelStart))) ? 1 : parseInt(options.headerLevelStart),

      // Set text-style headers:
      //	Header 1
      //	========
      //
      //	Header 2
      //	--------
      //
      setextRegexH1 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
      setextRegexH2 = (options.smoothLivePreview) ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;

  text = text.replace(setextRegexH1, function (wholeMatch, m1) {

    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  text = text.replace(setextRegexH2, function (matchFound, m1) {
    var spanGamut = showdown.subParser('spanGamut')(m1, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m1) + '"',
        hLevel = headerLevelStart + 1,
        hashBlock = '<h' + hLevel + hID + '>' + spanGamut + '</h' + hLevel + '>';
    return showdown.subParser('hashBlock')(hashBlock, options, globals);
  });

  // atx-style headers:
  //  # Header 1
  //  ## Header 2
  //  ## Header 2 with closing hashes ##
  //  ...
  //  ###### Header 6
  //
  var atxStyle = (options.requireSpaceBeforeHeadingText) ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;

  text = text.replace(atxStyle, function (wholeMatch, m1, m2) {
    var hText = m2;
    if (options.customizedHeaderId) {
      hText = m2.replace(/\s?\{([^{]+?)}\s*$/, '');
    }

    var span = showdown.subParser('spanGamut')(hText, options, globals),
        hID = (options.noHeaderId) ? '' : ' id="' + headerId(m2) + '"',
        hLevel = headerLevelStart - 1 + m1.length,
        header = '<h' + hLevel + hID + '>' + span + '</h' + hLevel + '>';

    return showdown.subParser('hashBlock')(header, options, globals);
  });

  function headerId (m) {
    var title,
        prefix;

    // It is separate from other options to allow combining prefix and customized
    if (options.customizedHeaderId) {
      var match = m.match(/\{([^{]+?)}\s*$/);
      if (match && match[1]) {
        m = match[1];
      }
    }

    title = m;

    // Prefix id to prevent causing inadvertent pre-existing style matches.
    if (showdown.helper.isString(options.prefixHeaderId)) {
      prefix = options.prefixHeaderId;
    } else if (options.prefixHeaderId === true) {
      prefix = 'section-';
    } else {
      prefix = '';
    }

    if (!options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (options.ghCompatibleHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '')
        .replace(/¨T/g, '')
        .replace(/¨D/g, '')
        // replace rest of the chars (&~$ are repeated as they might have been escaped)
        // borrowed from github's redcarpet (some they should produce similar results)
        .replace(/[&+$,\/:;=?@"#{}|^¨~\[\]`\\*)(%.!'<>]/g, '')
        .toLowerCase();
    } else if (options.rawHeaderId) {
      title = title
        .replace(/ /g, '-')
        // replace previously escaped chars (&, ¨ and $)
        .replace(/&amp;/g, '&')
        .replace(/¨T/g, '¨')
        .replace(/¨D/g, '$')
        // replace " and '
        .replace(/["']/g, '-')
        .toLowerCase();
    } else {
      title = title
        .replace(/[^\w]/g, '')
        .toLowerCase();
    }

    if (options.rawPrefixHeaderId) {
      title = prefix + title;
    }

    if (globals.hashLinkCounts[title]) {
      title = title + '-' + (globals.hashLinkCounts[title]++);
    } else {
      globals.hashLinkCounts[title] = 1;
    }
    return title;
  }

  text = globals.converter._dispatch('headers.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown link shortcuts into XHTML <a> tags.
 */
showdown.subParser('horizontalRule', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('horizontalRule.before', text, options, globals);

  var key = showdown.subParser('hashBlock')('<hr />', options, globals);
  text = text.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, key);
  text = text.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, key);

  text = globals.converter._dispatch('horizontalRule.after', text, options, globals);
  return text;
});

/**
 * Turn Markdown image shortcuts into <img> tags.
 */
showdown.subParser('images', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('images.before', text, options, globals);

  var inlineRegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      crazyRegExp       = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
      base64RegExp      = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
      referenceRegExp   = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
      refShortcutRegExp = /!\[([^\[\]]+)]()()()()()/g;

  function writeImageTagBase64 (wholeMatch, altText, linkId, url, width, height, m5, title) {
    url = url.replace(/\s/g, '');
    return writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title);
  }

  function writeImageTag (wholeMatch, altText, linkId, url, width, height, m5, title) {

    var gUrls   = globals.gUrls,
        gTitles = globals.gTitles,
        gDims   = globals.gDimensions;

    linkId = linkId.toLowerCase();

    if (!title) {
      title = '';
    }
    // Special case for explicit empty url
    if (wholeMatch.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) {
      url = '';

    } else if (url === '' || url === null) {
      if (linkId === '' || linkId === null) {
        // lower-case and turn embedded newlines into spaces
        linkId = altText.toLowerCase().replace(/ ?\n/g, ' ');
      }
      url = '#' + linkId;

      if (!showdown.helper.isUndefined(gUrls[linkId])) {
        url = gUrls[linkId];
        if (!showdown.helper.isUndefined(gTitles[linkId])) {
          title = gTitles[linkId];
        }
        if (!showdown.helper.isUndefined(gDims[linkId])) {
          width = gDims[linkId].width;
          height = gDims[linkId].height;
        }
      } else {
        return wholeMatch;
      }
    }

    altText = altText
      .replace(/"/g, '&quot;')
    //altText = showdown.helper.escapeCharacters(altText, '*_', false);
      .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    //url = showdown.helper.escapeCharacters(url, '*_', false);
    url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
    var result = '<img src="' + url + '" alt="' + altText + '"';

    if (title && showdown.helper.isString(title)) {
      title = title
        .replace(/"/g, '&quot;')
      //title = showdown.helper.escapeCharacters(title, '*_', false);
        .replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);
      result += ' title="' + title + '"';
    }

    if (width && height) {
      width  = (width === '*') ? 'auto' : width;
      height = (height === '*') ? 'auto' : height;

      result += ' width="' + width + '"';
      result += ' height="' + height + '"';
    }

    result += ' />';

    return result;
  }

  // First, handle reference-style labeled images: ![alt text][id]
  text = text.replace(referenceRegExp, writeImageTag);

  // Next, handle inline images:  ![alt text](url =<width>x<height> "optional title")

  // base64 encoded images
  text = text.replace(base64RegExp, writeImageTagBase64);

  // cases with crazy urls like ./image/cat1).png
  text = text.replace(crazyRegExp, writeImageTag);

  // normal cases
  text = text.replace(inlineRegExp, writeImageTag);

  // handle reference-style shortcuts: ![img text]
  text = text.replace(refShortcutRegExp, writeImageTag);

  text = globals.converter._dispatch('images.after', text, options, globals);
  return text;
});

showdown.subParser('italicsAndBold', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('italicsAndBold.before', text, options, globals);

  // it's faster to have 3 separate regexes for each case than have just one
  // because of backtracing, in some cases, it could lead to an exponential effect
  // called "catastrophic backtrace". Ominous!

  function parseInside (txt, left, right) {
    /*
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    */
    return left + txt + right;
  }

  // Parse underscores
  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return parseInside (txt, '<strong><em>', '</em></strong>');
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return parseInside (txt, '<strong>', '</strong>');
    });
    text = text.replace(/\b_(\S[\s\S]*?)_\b/g, function (wm, txt) {
      return parseInside (txt, '<em>', '</em>');
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/_([^\s_][\s\S]*?)_/g, function (wm, m) {
      // !/^_[^_]/.test(m) - test if it doesn't start with __ (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }

  // Now parse asterisks
  if (options.literalMidWordAsterisks) {
    text = text.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong><em>', '</em></strong>');
    });
    text = text.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<strong>', '</strong>');
    });
    text = text.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (wm, lead, txt) {
      return parseInside (txt, lead + '<em>', '</em>');
    });
  } else {
    text = text.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong><em>', '</em></strong>') : wm;
    });
    text = text.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (wm, m) {
      return (/\S$/.test(m)) ? parseInside (m, '<strong>', '</strong>') : wm;
    });
    text = text.replace(/\*([^\s*][\s\S]*?)\*/g, function (wm, m) {
      // !/^\*[^*]/.test(m) - test if it doesn't start with ** (since it seems redundant, we removed it)
      return (/\S$/.test(m)) ? parseInside (m, '<em>', '</em>') : wm;
    });
  }


  text = globals.converter._dispatch('italicsAndBold.after', text, options, globals);
  return text;
});

/**
 * Form HTML ordered (numbered) and unordered (bulleted) lists.
 */
showdown.subParser('lists', function (text, options, globals) {
  'use strict';

  /**
   * Process the contents of a single ordered or unordered list, splitting it
   * into individual list items.
   * @param {string} listStr
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function processListItems (listStr, trimTrailing) {
    // The $g_list_level global keeps track of when we're inside a list.
    // Each time we enter a list, we increment it; when we leave a list,
    // we decrement. If it's zero, we're not in a list anymore.
    //
    // We do this because when we're not inside a list, we want to treat
    // something like this:
    //
    //    I recommend upgrading to version
    //    8. Oops, now this line is treated
    //    as a sub-list.
    //
    // As a single paragraph, despite the fact that the second line starts
    // with a digit-period-space sequence.
    //
    // Whereas when we're inside a list (or sub-list), that line will be
    // treated as the start of a sub-list. What a kludge, huh? This is
    // an aspect of Markdown's syntax that's hard to parse perfectly
    // without resorting to mind-reading. Perhaps the solution is to
    // change the syntax rules such that sub-lists must start with a
    // starting cardinal number; e.g. "1." or "a.".
    globals.gListLevel++;

    // trim trailing blank lines:
    listStr = listStr.replace(/\n{2,}$/, '\n');

    // attacklab: add sentinel to emulate \z
    listStr += '¨0';

    var rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
        isParagraphed = (/\n[ \t]*\n(?!¨0)/.test(listStr));

    // Since version 1.5, nesting sublists requires 4 spaces (or 1 tab) indentation,
    // which is a syntax breaking change
    // activating this option reverts to old behavior
    if (options.disableForced4SpacesIndentedSublists) {
      rgx = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(¨0|\2([*+-]|\d+[.])[ \t]+))/gm;
    }

    listStr = listStr.replace(rgx, function (wholeMatch, m1, m2, m3, m4, taskbtn, checked) {
      checked = (checked && checked.trim() !== '');

      var item = showdown.subParser('outdent')(m4, options, globals),
          bulletStyle = '';

      // Support for github tasklists
      if (taskbtn && options.tasklists) {
        bulletStyle = ' class="task-list-item" style="list-style-type: none;"';
        item = item.replace(/^[ \t]*\[(x|X| )?]/m, function () {
          var otp = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
          if (checked) {
            otp += ' checked';
          }
          otp += '>';
          return otp;
        });
      }

      // ISSUE #312
      // This input: - - - a
      // causes trouble to the parser, since it interprets it as:
      // <ul><li><li><li>a</li></li></li></ul>
      // instead of:
      // <ul><li>- - a</li></ul>
      // So, to prevent it, we will put a marker (¨A)in the beginning of the line
      // Kind of hackish/monkey patching, but seems more effective than overcomplicating the list parser
      item = item.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (wm2) {
        return '¨A' + wm2;
      });

      // m1 - Leading line or
      // Has a double return (multi paragraph) or
      // Has sublist
      if (m1 || (item.search(/\n{2,}/) > -1)) {
        item = showdown.subParser('githubCodeBlocks')(item, options, globals);
        item = showdown.subParser('blockGamut')(item, options, globals);
      } else {
        // Recursion for sub-lists:
        item = showdown.subParser('lists')(item, options, globals);
        item = item.replace(/\n$/, ''); // chomp(item)
        item = showdown.subParser('hashHTMLBlocks')(item, options, globals);

        // Colapse double linebreaks
        item = item.replace(/\n\n+/g, '\n\n');
        if (isParagraphed) {
          item = showdown.subParser('paragraphs')(item, options, globals);
        } else {
          item = showdown.subParser('spanGamut')(item, options, globals);
        }
      }

      // now we need to remove the marker (¨A)
      item = item.replace('¨A', '');
      // we can finally wrap the line in list item tags
      item =  '<li' + bulletStyle + '>' + item + '</li>\n';

      return item;
    });

    // attacklab: strip sentinel
    listStr = listStr.replace(/¨0/g, '');

    globals.gListLevel--;

    if (trimTrailing) {
      listStr = listStr.replace(/\s+$/, '');
    }

    return listStr;
  }

  function styleStartNumber (list, listType) {
    // check if ol and starts by a number different than 1
    if (listType === 'ol') {
      var res = list.match(/^ *(\d+)\./);
      if (res && res[1] !== '1') {
        return ' start="' + res[1] + '"';
      }
    }
    return '';
  }

  /**
   * Check and parse consecutive lists (better fix for issue #142)
   * @param {string} list
   * @param {string} listType
   * @param {boolean} trimTrailing
   * @returns {string}
   */
  function parseConsecutiveLists (list, listType, trimTrailing) {
    // check if we caught 2 or more consecutive lists by mistake
    // we use the counterRgx, meaning if listType is UL we look for OL and vice versa
    var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm,
        ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm,
        counterRxg = (listType === 'ul') ? olRgx : ulRgx,
        result = '';

    if (list.search(counterRxg) !== -1) {
      (function parseCL (txt) {
        var pos = txt.search(counterRxg),
            style = styleStartNumber(list, listType);
        if (pos !== -1) {
          // slice
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\n';

          // invert counterType and listType
          listType = (listType === 'ul') ? 'ol' : 'ul';
          counterRxg = (listType === 'ul') ? olRgx : ulRgx;

          //recurse
          parseCL(txt.slice(pos));
        } else {
          result += '\n\n<' + listType + style + '>\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\n';
        }
      })(list);
    } else {
      var style = styleStartNumber(list, listType);
      result = '\n\n<' + listType + style + '>\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\n';
    }

    return result;
  }

  /** Start of list parsing **/
  text = globals.converter._dispatch('lists.before', text, options, globals);
  // add sentinel to hack around khtml/safari bug:
  // http://bugs.webkit.org/show_bug.cgi?id=11231
  text += '¨0';

  if (globals.gListLevel) {
    text = text.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, list, m2) {
        var listType = (m2.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, true);
      }
    );
  } else {
    text = text.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(¨0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
      function (wholeMatch, m1, list, m3) {
        var listType = (m3.search(/[*+-]/g) > -1) ? 'ul' : 'ol';
        return parseConsecutiveLists(list, listType, false);
      }
    );
  }

  // strip sentinel
  text = text.replace(/¨0/, '');
  text = globals.converter._dispatch('lists.after', text, options, globals);
  return text;
});

/**
 * Parse metadata at the top of the document
 */
showdown.subParser('metadata', function (text, options, globals) {
  'use strict';

  if (!options.metadata) {
    return text;
  }

  text = globals.converter._dispatch('metadata.before', text, options, globals);

  function parseMetadataContents (content) {
    // raw is raw so it's not changed in any way
    globals.metadata.raw = content;

    // escape chars forbidden in html attributes
    // double quotes
    content = content
      // ampersand first
      .replace(/&/g, '&amp;')
      // double quotes
      .replace(/"/g, '&quot;');

    content = content.replace(/\n {4}/g, ' ');
    content.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (wm, key, value) {
      globals.metadata.parsed[key] = value;
      return '';
    });
  }

  text = text.replace(/^\s*«««+(\S*?)\n([\s\S]+?)\n»»»+\n/, function (wholematch, format, content) {
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (wholematch, format, content) {
    if (format) {
      globals.metadata.format = format;
    }
    parseMetadataContents(content);
    return '¨M';
  });

  text = text.replace(/¨M/g, '');

  text = globals.converter._dispatch('metadata.after', text, options, globals);
  return text;
});

/**
 * Remove one level of line-leading tabs or spaces
 */
showdown.subParser('outdent', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('outdent.before', text, options, globals);

  // attacklab: hack around Konqueror 3.5.4 bug:
  // "----------bug".replace(/^-/g,"") == "bug"
  text = text.replace(/^(\t|[ ]{1,4})/gm, '¨0'); // attacklab: g_tab_width

  // attacklab: clean up hack
  text = text.replace(/¨0/g, '');

  text = globals.converter._dispatch('outdent.after', text, options, globals);
  return text;
});

/**
 *
 */
showdown.subParser('paragraphs', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('paragraphs.before', text, options, globals);
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');

  var grafs = text.split(/\n{2,}/g),
      grafsOut = [],
      end = grafs.length; // Wrap <p> tags

  for (var i = 0; i < end; i++) {
    var str = grafs[i];
    // if this is an HTML marker, copy it
    if (str.search(/¨(K|G)(\d+)\1/g) >= 0) {
      grafsOut.push(str);

    // test for presence of characters to prevent empty lines being parsed
    // as paragraphs (resulting in undesired extra empty paragraphs)
    } else if (str.search(/\S/) >= 0) {
      str = showdown.subParser('spanGamut')(str, options, globals);
      str = str.replace(/^([ \t]*)/g, '<p>');
      str += '</p>';
      grafsOut.push(str);
    }
  }

  /** Unhashify HTML blocks */
  end = grafsOut.length;
  for (i = 0; i < end; i++) {
    var blockText = '',
        grafsOutIt = grafsOut[i],
        codeFlag = false;
    // if this is a marker for an html block...
    // use RegExp.test instead of string.search because of QML bug
    while (/¨(K|G)(\d+)\1/.test(grafsOutIt)) {
      var delim = RegExp.$1,
          num   = RegExp.$2;

      if (delim === 'K') {
        blockText = globals.gHtmlBlocks[num];
      } else {
        // we need to check if ghBlock is a false positive
        if (codeFlag) {
          // use encoded version of all text
          blockText = showdown.subParser('encodeCode')(globals.ghCodeBlocks[num].text, options, globals);
        } else {
          blockText = globals.ghCodeBlocks[num].codeblock;
        }
      }
      blockText = blockText.replace(/\$/g, '$$$$'); // Escape any dollar signs

      grafsOutIt = grafsOutIt.replace(/(\n\n)?¨(K|G)\d+\2(\n\n)?/, blockText);
      // Check if grafsOutIt is a pre->code
      if (/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(grafsOutIt)) {
        codeFlag = true;
      }
    }
    grafsOut[i] = grafsOutIt;
  }
  text = grafsOut.join('\n');
  // Strip leading and trailing lines:
  text = text.replace(/^\n+/g, '');
  text = text.replace(/\n+$/g, '');
  return globals.converter._dispatch('paragraphs.after', text, options, globals);
});

/**
 * Run extension
 */
showdown.subParser('runExtension', function (ext, text, options, globals) {
  'use strict';

  if (ext.filter) {
    text = ext.filter(text, globals.converter, options);

  } else if (ext.regex) {
    // TODO remove this when old extension loading mechanism is deprecated
    var re = ext.regex;
    if (!(re instanceof RegExp)) {
      re = new RegExp(re, 'g');
    }
    text = text.replace(re, ext.replace);
  }

  return text;
});

/**
 * These are all the transformations that occur *within* block-level
 * tags like paragraphs, headers, and list items.
 */
showdown.subParser('spanGamut', function (text, options, globals) {
  'use strict';

  text = globals.converter._dispatch('spanGamut.before', text, options, globals);
  text = showdown.subParser('codeSpans')(text, options, globals);
  text = showdown.subParser('escapeSpecialCharsWithinTagAttributes')(text, options, globals);
  text = showdown.subParser('encodeBackslashEscapes')(text, options, globals);

  // Process anchor and image tags. Images must come first,
  // because ![foo][f] looks like an anchor.
  text = showdown.subParser('images')(text, options, globals);
  text = showdown.subParser('anchors')(text, options, globals);

  // Make links out of things like `<http://example.com/>`
  // Must come after anchors, because you can use < and >
  // delimiters in inline links like [this](<url>).
  text = showdown.subParser('autoLinks')(text, options, globals);
  text = showdown.subParser('simplifiedAutoLinks')(text, options, globals);
  text = showdown.subParser('emoji')(text, options, globals);
  text = showdown.subParser('underline')(text, options, globals);
  text = showdown.subParser('italicsAndBold')(text, options, globals);
  text = showdown.subParser('strikethrough')(text, options, globals);
  text = showdown.subParser('ellipsis')(text, options, globals);

  // we need to hash HTML tags inside spans
  text = showdown.subParser('hashHTMLSpans')(text, options, globals);

  // now we encode amps and angles
  text = showdown.subParser('encodeAmpsAndAngles')(text, options, globals);

  // Do hard breaks
  if (options.simpleLineBreaks) {
    // GFM style hard breaks
    // only add line breaks if the text does not contain a block (special case for lists)
    if (!/\n\n¨K/.test(text)) {
      text = text.replace(/\n+/g, '<br />\n');
    }
  } else {
    // Vanilla hard breaks
    text = text.replace(/  +\n/g, '<br />\n');
  }

  text = globals.converter._dispatch('spanGamut.after', text, options, globals);
  return text;
});

showdown.subParser('strikethrough', function (text, options, globals) {
  'use strict';

  function parseInside (txt) {
    if (options.simplifiedAutoLink) {
      txt = showdown.subParser('simplifiedAutoLinks')(txt, options, globals);
    }
    return '<del>' + txt + '</del>';
  }

  if (options.strikethrough) {
    text = globals.converter._dispatch('strikethrough.before', text, options, globals);
    text = text.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (wm, txt) { return parseInside(txt); });
    text = globals.converter._dispatch('strikethrough.after', text, options, globals);
  }

  return text;
});

/**
 * Strips link definitions from text, stores the URLs and titles in
 * hash references.
 * Link defs are in the form: ^[id]: url "optional title"
 */
showdown.subParser('stripLinkDefinitions', function (text, options, globals) {
  'use strict';

  var regex       = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=¨0))/gm,
      base64Regex = /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=¨0)|(?=\n\[))/gm;

  // attacklab: sentinel workarounds for lack of \A and \Z, safari\khtml bug
  text += '¨0';

  var replaceFunc = function (wholeMatch, linkId, url, width, height, blankLines, title) {
    linkId = linkId.toLowerCase();
    if (url.match(/^data:.+?\/.+?;base64,/)) {
      // remove newlines
      globals.gUrls[linkId] = url.replace(/\s/g, '');
    } else {
      globals.gUrls[linkId] = showdown.subParser('encodeAmpsAndAngles')(url, options, globals);  // Link IDs are case-insensitive
    }

    if (blankLines) {
      // Oops, found blank lines, so it's not a title.
      // Put back the parenthetical statement we stole.
      return blankLines + title;

    } else {
      if (title) {
        globals.gTitles[linkId] = title.replace(/"|'/g, '&quot;');
      }
      if (options.parseImgDimensions && width && height) {
        globals.gDimensions[linkId] = {
          width:  width,
          height: height
        };
      }
    }
    // Completely remove the definition from the text
    return '';
  };

  // first we try to find base64 link references
  text = text.replace(base64Regex, replaceFunc);

  text = text.replace(regex, replaceFunc);

  // attacklab: strip sentinel
  text = text.replace(/¨0/, '');

  return text;
});

showdown.subParser('tables', function (text, options, globals) {
  'use strict';

  if (!options.tables) {
    return text;
  }

  var tableRgx       = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|¨0)/gm,
      //singeColTblRgx = /^ {0,3}\|.+\|\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n(?: {0,3}\|.+\|\n)+(?:\n\n|¨0)/gm;
      singeColTblRgx = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|¨0)/gm;

  function parseStyles (sLine) {
    if (/^:[ \t]*--*$/.test(sLine)) {
      return ' style="text-align:left;"';
    } else if (/^--*[ \t]*:[ \t]*$/.test(sLine)) {
      return ' style="text-align:right;"';
    } else if (/^:[ \t]*--*[ \t]*:$/.test(sLine)) {
      return ' style="text-align:center;"';
    } else {
      return '';
    }
  }

  function parseHeaders (header, style) {
    var id = '';
    header = header.trim();
    // support both tablesHeaderId and tableHeaderId due to error in documentation so we don't break backwards compatibility
    if (options.tablesHeaderId || options.tableHeaderId) {
      id = ' id="' + header.replace(/ /g, '_').toLowerCase() + '"';
    }
    header = showdown.subParser('spanGamut')(header, options, globals);

    return '<th' + id + style + '>' + header + '</th>\n';
  }

  function parseCells (cell, style) {
    var subText = showdown.subParser('spanGamut')(cell, options, globals);
    return '<td' + style + '>' + subText + '</td>\n';
  }

  function buildTable (headers, cells) {
    var tb = '<table>\n<thead>\n<tr>\n',
        tblLgn = headers.length;

    for (var i = 0; i < tblLgn; ++i) {
      tb += headers[i];
    }
    tb += '</tr>\n</thead>\n<tbody>\n';

    for (i = 0; i < cells.length; ++i) {
      tb += '<tr>\n';
      for (var ii = 0; ii < tblLgn; ++ii) {
        tb += cells[i][ii];
      }
      tb += '</tr>\n';
    }
    tb += '</tbody>\n</table>\n';
    return tb;
  }

  function parseTable (rawTable) {
    var i, tableLines = rawTable.split('\n');

    for (i = 0; i < tableLines.length; ++i) {
      // strip wrong first and last column if wrapped tables are used
      if (/^ {0,3}\|/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/^ {0,3}\|/, '');
      }
      if (/\|[ \t]*$/.test(tableLines[i])) {
        tableLines[i] = tableLines[i].replace(/\|[ \t]*$/, '');
      }
      // parse code spans first, but we only support one line code spans
      tableLines[i] = showdown.subParser('codeSpans')(tableLines[i], options, globals);
    }

    var rawHeaders = tableLines[0].split('|').map(function (s) { return s.trim();}),
        rawStyles = tableLines[1].split('|').map(function (s) { return s.trim();}),
        rawCells = [],
        headers = [],
        styles = [],
        cells = [];

    tableLines.shift();
    tableLines.shift();

    for (i = 0; i < tableLines.length; ++i) {
      if (tableLines[i].trim() === '') {
        continue;
      }
      rawCells.push(
        tableLines[i]
          .split('|')
          .map(function (s) {
            return s.trim();
          })
      );
    }

    if (rawHeaders.length < rawStyles.length) {
      return rawTable;
    }

    for (i = 0; i < rawStyles.length; ++i) {
      styles.push(parseStyles(rawStyles[i]));
    }

    for (i = 0; i < rawHeaders.length; ++i) {
      if (showdown.helper.isUndefined(styles[i])) {
        styles[i] = '';
      }
      headers.push(parseHeaders(rawHeaders[i], styles[i]));
    }

    for (i = 0; i < rawCells.length; ++i) {
      var row = [];
      for (var ii = 0; ii < headers.length; ++ii) {
        if (showdown.helper.isUndefined(rawCells[i][ii])) {

        }
        row.push(parseCells(rawCells[i][ii], styles[ii]));
      }
      cells.push(row);
    }

    return buildTable(headers, cells);
  }

  text = globals.converter._dispatch('tables.before', text, options, globals);

  // find escaped pipe characters
  text = text.replace(/\\(\|)/g, showdown.helper.escapeCharactersCallback);

  // parse multi column tables
  text = text.replace(tableRgx, parseTable);

  // parse one column tables
  text = text.replace(singeColTblRgx, parseTable);

  text = globals.converter._dispatch('tables.after', text, options, globals);

  return text;
});

showdown.subParser('underline', function (text, options, globals) {
  'use strict';

  if (!options.underline) {
    return text;
  }

  text = globals.converter._dispatch('underline.before', text, options, globals);

  if (options.literalMidWordUnderscores) {
    text = text.replace(/\b___(\S[\s\S]*?)___\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
    text = text.replace(/\b__(\S[\s\S]*?)__\b/g, function (wm, txt) {
      return '<u>' + txt + '</u>';
    });
  } else {
    text = text.replace(/___(\S[\s\S]*?)___/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
    text = text.replace(/__(\S[\s\S]*?)__/g, function (wm, m) {
      return (/\S$/.test(m)) ? '<u>' + m + '</u>' : wm;
    });
  }

  // escape remaining underscores to prevent them being parsed by italic and bold
  text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);

  text = globals.converter._dispatch('underline.after', text, options, globals);

  return text;
});

/**
 * Swap back in all the special characters we've hidden.
 */
showdown.subParser('unescapeSpecialChars', function (text, options, globals) {
  'use strict';
  text = globals.converter._dispatch('unescapeSpecialChars.before', text, options, globals);

  text = text.replace(/¨E(\d+)E/g, function (wholeMatch, m1) {
    var charCodeToReplace = parseInt(m1);
    return String.fromCharCode(charCodeToReplace);
  });

  text = globals.converter._dispatch('unescapeSpecialChars.after', text, options, globals);
  return text;
});

showdown.subParser('makeMarkdown.blockquote', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      var innerTxt = showdown.subParser('makeMarkdown.node')(children[i], globals);

      if (innerTxt === '') {
        continue;
      }
      txt += innerTxt;
    }
  }
  // cleanup
  txt = txt.trim();
  txt = '> ' + txt.split('\n').join('\n> ');
  return txt;
});

showdown.subParser('makeMarkdown.codeBlock', function (node, globals) {
  'use strict';

  var lang = node.getAttribute('language'),
      num  = node.getAttribute('precodenum');
  return '```' + lang + '\n' + globals.preList[num] + '\n```';
});

showdown.subParser('makeMarkdown.codeSpan', function (node) {
  'use strict';

  return '`' + node.innerHTML + '`';
});

showdown.subParser('makeMarkdown.emphasis', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '*';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '*';
  }
  return txt;
});

showdown.subParser('makeMarkdown.header', function (node, globals, headerLevel) {
  'use strict';

  var headerMark = new Array(headerLevel + 1).join('#'),
      txt = '';

  if (node.hasChildNodes()) {
    txt = headerMark + ' ';
    var children = node.childNodes,
        childrenLength = children.length;

    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }
  return txt;
});

showdown.subParser('makeMarkdown.hr', function () {
  'use strict';

  return '---';
});

showdown.subParser('makeMarkdown.image', function (node) {
  'use strict';

  var txt = '';
  if (node.hasAttribute('src')) {
    txt += '![' + node.getAttribute('alt') + '](';
    txt += '<' + node.getAttribute('src') + '>';
    if (node.hasAttribute('width') && node.hasAttribute('height')) {
      txt += ' =' + node.getAttribute('width') + 'x' + node.getAttribute('height');
    }

    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.links', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes() && node.hasAttribute('href')) {
    var children = node.childNodes,
        childrenLength = children.length;
    txt = '[';
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '](';
    txt += '<' + node.getAttribute('href') + '>';
    if (node.hasAttribute('title')) {
      txt += ' "' + node.getAttribute('title') + '"';
    }
    txt += ')';
  }
  return txt;
});

showdown.subParser('makeMarkdown.list', function (node, globals, type) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var listItems       = node.childNodes,
      listItemsLenght = listItems.length,
      listNum = node.getAttribute('start') || 1;

  for (var i = 0; i < listItemsLenght; ++i) {
    if (typeof listItems[i].tagName === 'undefined' || listItems[i].tagName.toLowerCase() !== 'li') {
      continue;
    }

    // define the bullet to use in list
    var bullet = '';
    if (type === 'ol') {
      bullet = listNum.toString() + '. ';
    } else {
      bullet = '- ';
    }

    // parse list item
    txt += bullet + showdown.subParser('makeMarkdown.listItem')(listItems[i], globals);
    ++listNum;
  }

  // add comment at the end to prevent consecutive lists to be parsed as one
  txt += '\n<!-- -->\n';
  return txt.trim();
});

showdown.subParser('makeMarkdown.listItem', function (node, globals) {
  'use strict';

  var listItemTxt = '';

  var children = node.childNodes,
      childrenLenght = children.length;

  for (var i = 0; i < childrenLenght; ++i) {
    listItemTxt += showdown.subParser('makeMarkdown.node')(children[i], globals);
  }
  // if it's only one liner, we need to add a newline at the end
  if (!/\n$/.test(listItemTxt)) {
    listItemTxt += '\n';
  } else {
    // it's multiparagraph, so we need to indent
    listItemTxt = listItemTxt
      .split('\n')
      .join('\n    ')
      .replace(/^ {4}$/gm, '')
      .replace(/\n\n+/g, '\n\n');
  }

  return listItemTxt;
});



showdown.subParser('makeMarkdown.node', function (node, globals, spansOnly) {
  'use strict';

  spansOnly = spansOnly || false;

  var txt = '';

  // edge case of text without wrapper paragraph
  if (node.nodeType === 3) {
    return showdown.subParser('makeMarkdown.txt')(node, globals);
  }

  // HTML comment
  if (node.nodeType === 8) {
    return '<!--' + node.data + '-->\n\n';
  }

  // process only node elements
  if (node.nodeType !== 1) {
    return '';
  }

  var tagName = node.tagName.toLowerCase();

  switch (tagName) {

    //
    // BLOCKS
    //
    case 'h1':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 1) + '\n\n'; }
      break;
    case 'h2':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 2) + '\n\n'; }
      break;
    case 'h3':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 3) + '\n\n'; }
      break;
    case 'h4':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 4) + '\n\n'; }
      break;
    case 'h5':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 5) + '\n\n'; }
      break;
    case 'h6':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.header')(node, globals, 6) + '\n\n'; }
      break;

    case 'p':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.paragraph')(node, globals) + '\n\n'; }
      break;

    case 'blockquote':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.blockquote')(node, globals) + '\n\n'; }
      break;

    case 'hr':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.hr')(node, globals) + '\n\n'; }
      break;

    case 'ol':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ol') + '\n\n'; }
      break;

    case 'ul':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.list')(node, globals, 'ul') + '\n\n'; }
      break;

    case 'precode':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.codeBlock')(node, globals) + '\n\n'; }
      break;

    case 'pre':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.pre')(node, globals) + '\n\n'; }
      break;

    case 'table':
      if (!spansOnly) { txt = showdown.subParser('makeMarkdown.table')(node, globals) + '\n\n'; }
      break;

    //
    // SPANS
    //
    case 'code':
      txt = showdown.subParser('makeMarkdown.codeSpan')(node, globals);
      break;

    case 'em':
    case 'i':
      txt = showdown.subParser('makeMarkdown.emphasis')(node, globals);
      break;

    case 'strong':
    case 'b':
      txt = showdown.subParser('makeMarkdown.strong')(node, globals);
      break;

    case 'del':
      txt = showdown.subParser('makeMarkdown.strikethrough')(node, globals);
      break;

    case 'a':
      txt = showdown.subParser('makeMarkdown.links')(node, globals);
      break;

    case 'img':
      txt = showdown.subParser('makeMarkdown.image')(node, globals);
      break;

    default:
      txt = node.outerHTML + '\n\n';
  }

  // common normalization
  // TODO eventually

  return txt;
});

showdown.subParser('makeMarkdown.paragraph', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
  }

  // some text normalization
  txt = txt.trim();

  return txt;
});

showdown.subParser('makeMarkdown.pre', function (node, globals) {
  'use strict';

  var num  = node.getAttribute('prenum');
  return '<pre>' + globals.preList[num] + '</pre>';
});

showdown.subParser('makeMarkdown.strikethrough', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '~~';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '~~';
  }
  return txt;
});

showdown.subParser('makeMarkdown.strong', function (node, globals) {
  'use strict';

  var txt = '';
  if (node.hasChildNodes()) {
    txt += '**';
    var children = node.childNodes,
        childrenLength = children.length;
    for (var i = 0; i < childrenLength; ++i) {
      txt += showdown.subParser('makeMarkdown.node')(children[i], globals);
    }
    txt += '**';
  }
  return txt;
});

showdown.subParser('makeMarkdown.table', function (node, globals) {
  'use strict';

  var txt = '',
      tableArray = [[], []],
      headings   = node.querySelectorAll('thead>tr>th'),
      rows       = node.querySelectorAll('tbody>tr'),
      i, ii;
  for (i = 0; i < headings.length; ++i) {
    var headContent = showdown.subParser('makeMarkdown.tableCell')(headings[i], globals),
        allign = '---';

    if (headings[i].hasAttribute('style')) {
      var style = headings[i].getAttribute('style').toLowerCase().replace(/\s/g, '');
      switch (style) {
        case 'text-align:left;':
          allign = ':---';
          break;
        case 'text-align:right;':
          allign = '---:';
          break;
        case 'text-align:center;':
          allign = ':---:';
          break;
      }
    }
    tableArray[0][i] = headContent.trim();
    tableArray[1][i] = allign;
  }

  for (i = 0; i < rows.length; ++i) {
    var r = tableArray.push([]) - 1,
        cols = rows[i].getElementsByTagName('td');

    for (ii = 0; ii < headings.length; ++ii) {
      var cellContent = ' ';
      if (typeof cols[ii] !== 'undefined') {
        cellContent = showdown.subParser('makeMarkdown.tableCell')(cols[ii], globals);
      }
      tableArray[r].push(cellContent);
    }
  }

  var cellSpacesCount = 3;
  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      var strLen = tableArray[i][ii].length;
      if (strLen > cellSpacesCount) {
        cellSpacesCount = strLen;
      }
    }
  }

  for (i = 0; i < tableArray.length; ++i) {
    for (ii = 0; ii < tableArray[i].length; ++ii) {
      if (i === 1) {
        if (tableArray[i][ii].slice(-1) === ':') {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, '-') + ':';
        } else {
          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, '-');
        }
      } else {
        tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);
      }
    }
    txt += '| ' + tableArray[i].join(' | ') + ' |\n';
  }

  return txt.trim();
});

showdown.subParser('makeMarkdown.tableCell', function (node, globals) {
  'use strict';

  var txt = '';
  if (!node.hasChildNodes()) {
    return '';
  }
  var children = node.childNodes,
      childrenLength = children.length;

  for (var i = 0; i < childrenLength; ++i) {
    txt += showdown.subParser('makeMarkdown.node')(children[i], globals, true);
  }
  return txt.trim();
});

showdown.subParser('makeMarkdown.txt', function (node) {
  'use strict';

  var txt = node.nodeValue;

  // multiple spaces are collapsed
  txt = txt.replace(/ +/g, ' ');

  // replace the custom ¨NBSP; with a space
  txt = txt.replace(/¨NBSP;/g, ' ');

  // ", <, > and & should replace escaped html entities
  txt = showdown.helper.unescapeHTMLEntities(txt);

  // escape markdown magic characters
  // emphasis, strong and strikethrough - can appear everywhere
  // we also escape pipe (|) because of tables
  // and escape ` because of code blocks and spans
  txt = txt.replace(/([\\*_~|`])/g, '\\$1');
  // backport: escape escape characters!

  // escape > because of blockquotes
  txt = txt.replace(/^(\s*)>/g, '\\$1>');

  // hash character, only troublesome at the beginning of a line because of headers
  txt = txt.replace(/^#/gm, '\\#');

  // horizontal rules
  txt = txt.replace(/^(\s*)([-=]{3,})(\s*)$/, '$1\\$2$3');

  // dot, because of ordered lists, only troublesome at the beginning of a line when preceded by an integer
  txt = txt.replace(/^( {0,3}\d+)\./gm, '$1\\.');

  // +, * and -, at the beginning of a line becomes a list, so we need to escape them also (asterisk was already escaped)
  txt = txt.replace(/^( {0,3})([+-])/gm, '$1\\$2');

  // images and links, ] followed by ( is problematic, so we escape it
  txt = txt.replace(/]([\s]*)\(/g, '\\]$1\\(');

  // reference URIs must also be escaped
  txt = txt.replace(/^ {0,3}\[([\S \t]*?)]:/gm, '\\[$1]:');

  return txt;
});

var root = window;

// AMD Loader
if (typeof define === 'function' && define.amd) {
  define(function () {
    'use strict';
    return showdown;
  });

// CommonJS/nodeJS Loader
} else if (typeof module !== 'undefined' && module.exports) {
  module.exports = showdown;

// Regular Browser loader
} else {
  root.showdown = showdown;
}
}).call(this);


showdown.setOption("strikethrough", true);
showdown.setOption("ghMentions", true);
showdown.setOption("emoji", true);
showdown.setOption("tables", false);
showdown.setOption("simpleLineBreaks", true);
showdown.setOption("simplifiedAutoLink", true);
showdown.setOption("ghMentionsLink", "https://anilist.co/user/{u}/");
const converter = new showdown.Converter();

let makeHtml = function(markdown){
	markdown = markdown.replace("----","---");
	let centerSplit = markdown.split("~~~");
	let imgRegex = /img(\d+%?)?\(http.+?\)/gi;
	centerSplit = centerSplit.map(component => {
		let images = component.match(imgRegex);
		if(images){
			images.forEach(image => {
				let imageParts = image.match(/^img(\d+%?)?\((http.+?)\)$/i);
				component = component.replace(image,`<img width="${imageParts[1] || ""}" src="${imageParts[2]}">`)
			})
			return component
		}
		else{
			return component
		}
	})
	let webmRegex = /webm\(http.+?\)/gi;
	centerSplit = centerSplit.map(component => {
		let webms = component.match(webmRegex);
		if(webms){
			webms.forEach(webm => {
				let webmParts = webm.match(/^webm\((http.+?)\)$/i);
				component = component.replace(webm,`<video src="${webmParts[1]}" controls="true" loop="" ${useScripts.noAutoplay ? "" : 'autoplay="" '}muted=""></video>`)
			})
			return component
		}
		else{
			return component
		}
	})
	let youtubeRegex = /youtube\(.+?\)/gi;
	centerSplit = centerSplit.map(component => {
		let videos = component.match(youtubeRegex);
		if(videos){
			videos.forEach(video => {
				let videoParts = video.match(/^youtube\((.+?)\)$/i);
				component = component.replace(video,`<a href="${videoParts[1]}">${videoParts[1]}</a>`)
			})
		}
		return component
	});
	let preProcessed = [centerSplit[0]];
	let openCenter = false;
	for(let i=1;i<centerSplit.length;i++){
		if(openCenter){
			preProcessed.push("</center>");
		}
		else{
			preProcessed.push("<center>");
		}
		preProcessed.push(centerSplit[i]);
		openCenter = !openCenter
	}
	preProcessed = preProcessed.map(element => {
		if(/~!/.test(element) || /!~/.test(element)){
			return element.replace(/~!/g,"<span class=\"markdown_spoiler\">").replace(/!~/g,"</span>");
		}
		return element
		
	})
	return converter.makeHtml(preProcessed.join(""))
}

function returnList(list,skipProcessing){
	if(!list){
		return null
	}
	let retl = [];
	list.data.MediaListCollection.lists.forEach(mediaList => {
		mediaList.entries.forEach(entry => {
			if(!skipProcessing){
				entry.isCustomList = mediaList.isCustomList;
				if(entry.isCustomList){
					entry.listLocations = [mediaList.name]
				}
				else{
					entry.listLocations = []
				}
				entry.scoreRaw = Math.min(entry.scoreRaw,100);
				if(!entry.media.episodes && entry.media.nextAiringEpisode){
					entry.media.episodes = entry.media.nextAiringEpisode.episode - 1
				}
				if(entry.notes){
					entry.listJSON = parseListJSON(entry.notes)
				}
				if(entry.media.a){
					entry.media.staff = removeGroupedDuplicates(
						entry.media.a.nodes.concat(
							entry.media.b.nodes
						),
						e => e.id
					);
					delete entry.media.a;
					delete entry.media.b;
				}
				if(entry.repeat > 10000){//counting eps as repeat, 10x One Piece as the plausibility baseline
					entry.repeat = 0
				}
				if(entry.status === "REPEATING" && entry.repeat === 0){
					entry.repeat = 1
				}
			}
			retl.push(entry);
		})
	})
	return removeGroupedDuplicates(
		retl,
		e => e.mediaId,
		(oldElement,newElement) => {
			if(!skipProcessing){
				newElement.listLocations = newElement.listLocations.concat(oldElement.listLocations);
				newElement.isCustomList = oldElement.isCustomList || newElement.isCustomList;
			}
		}
	)
}

function parseListJSON(listNote){
	if(!listNote){
		return null
	}
	let commandMatches = listNote.match(/\$({.*})\$/);
	if(commandMatches){
		try{
			let noteContent = JSON.parse(commandMatches[1]);
			noteContent.adjustValue = noteContent.adjust || 0;
			let rangeParser = function(thing){
				if(typeof thing === "number"){
					return 1
				}
				else if(typeof thing === "string"){
					thing = thing.split(",").map(a => a.trim())
				}
				return thing.reduce(function(acc,item){
					if(typeof item === "number"){
						return acc + 1
					}
					let multiplierPresent = item.split("x").map(a => a.trim());
					let value = 1;
					let rangePresent = multiplierPresent[0].split("-").map(a => a.trim());
					if(rangePresent.length === 2){//range
						let minRange = parseFloat(rangePresent[0]);
						let maxRange = parseFloat(rangePresent[1]);
						if(minRange && maxRange){
							value = maxRange - minRange + 1
						}
					}
					if(multiplierPresent.length === 1){//no multiplier
						return acc + value
					}
					if(multiplierPresent.length === 2){//possible multiplier
						let multiplier = parseFloat(multiplierPresent[1]);
						if(multiplier || multiplier === 0){
							return acc + value*multiplier
						}
						else{
							return acc + 1
						}
					}
					else{//unparsable
						return acc + 1
					}
				},0);
			};
			if(noteContent.more){
				noteContent.adjustValue += rangeParser(noteContent.more)
			}
			if(noteContent.skip){
				noteContent.adjustValue -= rangeParser(noteContent.skip)
			}
			return noteContent;
		}
		catch(e){
			console.warn("Unable to parse JSON in list note",commandMatches)
		}
	}
	else{
		return null
	}
}


function formatCompat(compatData,targetLocation,name){
	let differenceSpan = create("span",false,compatData.difference.roundPlaces(3));
	if(compatData.difference < 0.9){
		differenceSpan.style.color = "green"
	}
	else if(compatData.difference > 1.1){
		differenceSpan.style.color = "red"
	}
	targetLocation.innerText = "";
	targetLocation.appendChild(differenceSpan);
	let countSpan = create("span",false," based on " + compatData.shared + " shared entries. Lower is better. 0.8 - 1.1 is common\nFormally, this is 'standard deviation between normalized ratings'",targetLocation);
	let canvas = create("canvas",false,false,targetLocation,"display:block;");
	canvas.title = "Blue = " + name + "\nRed = you";
	canvas.width = 200;
	canvas.height = 100;
	let r1 = Math.sqrt(compatData.list1/(compatData.list1 + compatData.list2));
	let r2 = Math.sqrt(compatData.list2/(compatData.list1 + compatData.list2));
	let distance;
	if(compatData.shared === compatData.list1 || compatData.shared === compatData.list2){
		distance = Math.abs(r1 - r2)
	}
	else if(compatData.shared === 0){
		distance = r1 + r2
	}
	else{
		let areaOfIntersection = function(d,r0,r1){
			let rr0 = r0 * r0;
			let rr1 = r1 * r1;
			let phi = (Math.acos((rr0 + (d * d) - rr1) / (2 * r0 * d))) * 2;
			let theta = (Math.acos((rr1 + (d * d) - rr0) / (2 * r1 * d))) * 2;
			let area1 = (theta * rr1 - rr1 * Math.sin(theta))/2;
			let area2 = (phi * rr0 - rr0 * Math.sin(phi))/2;
			return area1 + area2;
		};
		let overlapArea = Math.PI*compatData.shared/(compatData.list1 + compatData.list2);
		let pivot0 = Math.abs(r1 - r2);
		let pivot1 = r1 + r2;
		while(pivot1 - pivot0 > (r1 + r2)/100){
			distance = (pivot0 + pivot1)/2;
			if(areaOfIntersection(distance,r1,r2) > overlapArea){
				pivot0 = distance
			}
			else{
				pivot1 = distance
			}
		}
	}
	let ctx = canvas.getContext("2d");
	ctx.beginPath();
	ctx.fillStyle = "rgb(61,180,242)";
	ctx.arc(50,50,50*r1,0,2*Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.fillStyle = "rgb(250,122,122)";
	ctx.arc(50 + 50*distance,50,50*r2,0,2*Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.fillStyle = "rgb(61,180,242,0.5)";
	ctx.arc(50,50,50*r1,0,2*Math.PI);
	ctx.fill();
}

function compatCheck(list,name,type,callback){
	const variables = {
		name: name,
		listType: type
	};
	generalAPIcall(queryMediaListCompat,variables,function(data){
		list.sort((a,b) => a.mediaId - b.mediaId);
		let list2 = returnList(data).filter(element => element.scoreRaw);
		let list3 = [];
		let indeks1 = 0;
		let indeks2 = 0;
		while(indeks1 < list.length && indeks2 < list2.length){
			if(list2[indeks2].mediaId > list[indeks1].mediaId){
				indeks1++;
				continue
			}
			if(list2[indeks2].mediaId < list[indeks1].mediaId){
				indeks2++;
				continue
			}
			if(list2[indeks2].mediaId === list[indeks1].mediaId){
				list3.push({
					mediaId: list[indeks1].mediaId,
					score1: list[indeks1].scoreRaw,
					score2: list2[indeks2].scoreRaw
				});
				indeks1++;
				indeks2++
			}
		}
		let average1 = 0;
		let average2 = 0;
		list3.forEach(item => {
			average1 += item.score1;
			average2 += item.score2;
			item.sdiff = item.score1 - item.score2
		});
		average1 = average1/list3.length;
		average2 = average2/list3.length;
		let standev1 = 0;
		let standev2 = 0;
		list3.forEach(item => {
			standev1 += Math.pow(item.score1 - average1,2);
			standev2 += Math.pow(item.score2 - average2,2)
		});
		standev1 = Math.sqrt(standev1/(list3.length - 1));
		standev2 = Math.sqrt(standev2/(list3.length - 1));
		let difference = 0;
		list3.forEach(item => {
			difference += Math.abs(
				(item.score1 - average1)/standev1
				- (item.score2 - average2)/standev2
			)
		});
		difference = difference/list3.length;
		callback({
			difference: difference,
			shared: list3.length,
			list1: list.length,
			list2: list2.length,
			user: name
		})
	})
}

//used by the stats module, and to safeguard the manga chapter guesses
//publishing manga is a bit tricky, since Anilist doesn't track chapters
const commonUnfinishedManga = {
	"30002":{
		"chapters":363,
		"volumes":40,
		"comment":"berserk"
	},
	"30013":{
		"chapters":1034,
		"volumes":101,
		"comment":"one piece"
	},
	"85486":{
		"chapters":336,
		"volumes":32,
		"comment":"mha"
	},
	"74347":{
		"chapters":152,
		"volumes":24,
		"comment":"opm"
	},
	"30026":{
		"chapters":390,
		"volumes":36,
		"comment":"HxH"
	},
	"30656":{
		"chapters":327,
		"volumes":37,
		"comment":"vagabond"
	},
	"30105":{
		"chapters":106,
		"volumes":14,
		"comment":"yotsuba&"
	},
	"105398":{
		"chapters":173,
		"volumes":4,
		"comment":"solo leveling"
	},
	"86635":{
		"chapters":246,
		"volumes":23,
		"comment":"kaguya"
	},
	"101517":{
		"chapters":167,
		"volumes":17,
		"comment":"juju"
	},
	"97852":{
		"chapters":333,
		"volumes":23,
		"comment":"komi"
	},
	"102988":{
		"chapters":233,
		"volumes":24,
		"comment":"revengers"
	}
}

if(NOW() - new Date(2021,11,5) > 365*24*60*60*1000){
	console.log("remind hoh to update the commonUnfinishedManga list")
}

//idea by GoBusto: https://gitlab.com/gobusto/unicodifier
function emojiSanitize(string){
	return Array.from(string).map(char => {
		let codePoint = char.codePointAt(0);
		if(codePoint > 0xFFFF){
			return "&#" + codePoint + ";"
		}
		return char
	}).join("")
}

function looseMatcher(string,searcher){
	return string.toLowerCase().includes(searcher.toLowerCase())
	|| RegExp(searcher,"i").test(string.toLowerCase())
}

const titlePicker = function(media){
	let title = media.title.romaji
	if(aliases.has(media.id)){
		title = aliases.get(media.id)
	}
	else if(useScripts.titleLanguage === "NATIVE" && media.title.native){
		title = media.title.native
	}
	else if(useScripts.titleLanguage === "ENGLISH" && media.title.english){
		title = media.title.english
	}
	if(useScripts.SFWmode){
		badWords.forEach(word => {
			title = title.replace(word,"*")
		})
	}
	return title
}

function cheapReload(linkElement,vueData){
	linkElement.onclick = function(){
		try{
			document.getElementById('app').__vue__._router.push(vueData);
			return false
		}
		catch(e){
			console.warn("vue routes are outdated!")
		}
	}
}

/**
 * Check if a property exists in the given object
 * @param {object} obj
 * @param {string} prop
 * @returns {boolean}
 */
function hasOwn(obj, prop){
	return Object.hasOwn ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop)
}

/**
 * Watch for an element's existence
 * @param {string} selector
 * @param {any} [parent]
 * @returns {Promise<Element>}
 */
function watchElem(selector, parent) {
	return new Promise(resolve => {
		new MutationObserver((_mutations, observer) => {
			const elem = (parent || document).querySelector(selector);
			if (elem) {
				observer.disconnect()
				resolve(elem)
			}
		}).observe(parent || document.body, { subtree: true, childList: true })
	})
}
//end "utilities.js"

/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.DOMPurify = factory());
}(window, function () { 'use strict';

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.1';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify.
     *
     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
     * might cause XSS from attacks hidden in closed shadowroots in case the browser
     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
     */
    var RETURN_DOM_IMPORT = true;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = stringToLowerCase(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Mitigate a problem with templates inside select */
      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));

//begin "graphql.js"
const queryMediaListManga = `
query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			name
			isCustomList
			entries{
				... mediaListEntry
			}
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	progressVolumes
	repeat
	notes
	startedAt{
		year
		month
		day
	}
	media{
		chapters
		volumes
		format
		title{romaji native english}
		tags{name}
		genres
		meanScore
	}
	scoreRaw: score(format: POINT_100)
}
`;

const queryMediaListAnime = `
query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			name
			isCustomList
			entries{
				... mediaListEntry
			}
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	repeat
	notes
	startedAt{
		year
		month
		day
	}
	media{
		episodes
		duration
		nextAiringEpisode{episode}
		format
		title{romaji native english}
		tags{name}
		genres
		meanScore
		studios{nodes{isAnimationStudio id name}}
	}
	scoreRaw: score(format: POINT_100)
}
`;

const queryMediaListStaff = `
query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			entries{
				... mediaListEntry
			}
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	media{
		a:staff(sort:ID,page:1){nodes{id name{first last}}}
		b:staff(sort:ID,page:2){nodes{id name{first last}}}
	}
}
`;

const queryMediaListStaff_simple = `
query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			entries{
				mediaId
				media{
					staff{edges{node{id languageV2 name{first last} primaryOccupations} role}}
				}
			}
		}
	}
}
`;

const queryMediaListCompat = `
query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			name
			isCustomList
			entries{
				... mediaListEntry
			}
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	progressVolumes
	repeat
	notes
	startedAt{
		year
		month
		day
	}
	media{
		episodes
		chapters
		volumes
		duration
		nextAiringEpisode{episode}
		format
		title{romaji native english}
	}
	scoreRaw: score(format: POINT_100)
}
`;

const queryActivity = `
query($id: Int!){
	Activity(id: $id){
		... on TextActivity{
			id
			userId
			type
			text
			user{
				id
				name
				avatar{large}
			}
			likes{id}
			replies{
				text(asHtml: true)
				user{name}
				likes{name}
				id
			}
		}
		... on ListActivity {
			id
			userId
			type
			status
			progress
			user{
				id
				name
				avatar{large}
			}
			media{
				coverImage{large color}
				title{romaji native english}
			}
			likes{id}
			replies{
				text(asHtml: true)
				user{name}
				likes{name}
				id
			}
		}
		... on MessageActivity{
			id
			type
			likes{id}
			replies{
				text(asHtml: true)
				user{name}
				likes{name}
				id
			}
		}
	}
}
`;

const queryAuthNotifications = `
query($page: Int,$name: String){
	User(name: $name){unreadNotificationCount}
	Page(page: $page){
		notifications{
			... on AiringNotification{type}
			... on FollowingNotification{type user{name}}
			... on ActivityMessageNotification{type user{name}}
			... on ActivityMentionNotification{type user{name}}
			... on ActivityReplyNotification{type user{name}}
			... on ActivityLikeNotification{type user{name}}
			... on ActivityReplyLikeNotification{type user{name}}
			... on ThreadCommentMentionNotification{type user{name}}
			... on ThreadCommentReplyNotification{type user{name}}
			... on ThreadCommentSubscribedNotification{type user{name}}
			... on ThreadCommentLikeNotification{type user{name}}
			... on ThreadLikeNotification{type user{name}}
			... on ActivityReplySubscribedNotification{type user{name}}
			... on RelatedMediaAdditionNotification{type media{title{userPreferred}}}
			... on MediaDataChangeNotification{type media{title{userPreferred}}}
			... on MediaMergeNotification{type media{title{userPreferred}}}
			... on MediaDeletionNotification{type}
		}
	}
}
`;

const ANILIST_WEIGHT = 41;//weighting center for the weighted score formula

let APIlimit = 90;
let APIcallsUsed = 0;//this is NOT a reliable way to figure out how many more calls we can use, just a way to set some limit
let APIcallsUsed_shortTerm = 0;
let pending = {};
let APIcounter = setInterval(function(){
	APIcallsUsed = 0;
},60*1000);//reset counter every minute, as our quota grows back
let APIcounter2 = setInterval(function(){
	APIcallsUsed_shortTerm = 0;
},10*1000);//shortTerm

let handleResponse = function(response){
	APIlimit = response.headers.get("x-ratelimit-limit");
	APIcallsUsed = APIlimit - response.headers.get("x-ratelimit-remaining");
	try{
		return response.json().then(function(json){
			return (response.ok ? json : Promise.reject(json))
		})
	}
	catch(e){
		console.warn(e,response);
		throw e
	}
};
const url = "https://graphql.anilist.co";//Current Anilist API location
let authUrl = "https://anilist.co/api/v2/oauth/authorize?client_id=2751&response_type=token";//2751 = main, 1933 = aniscripts(legacy), 7895 boneless
if(script_type === "Boneless"){
	authUrl = "https://anilist.co/api/v2/oauth/authorize?client_id=7895&response_type=token"
}
if(useScripts.client_id){
	authUrl = "https://anilist.co/api/v2/oauth/authorize?client_id=" + useScripts.client_id + "&response_type=token"
}

if(useScripts.autoLogin && !useScripts.accessToken && !useScripts.loginAttempted){
	useScripts.loginAttempted = true;
	useScripts.save();
	window.location = authUrl
}

if(!window.MutationObserver){//either the older webkit implementation, or just a dummy object that doesn't throw any errors when used.
	window.MutationObserver = window.WebKitMutationObserver || function(){return {observe:function(){},disconnect:function(){}}}
}

let aniCast = {postMessage: function(){}};//dummy object for Safari
if(window.BroadcastChannel){
	aniCast = new BroadcastChannel("aniScripts");
	aniCast.onmessage = function(message){
		if(message.data.type){
			if(message.data.type === "cache"){
				sessionStorage.setItem(message.data.key,message.data.value)
			}
			else if(message.data.type === "cachev2"){
				cache.updateIfDifferent(message.data.mediaData,true)
			}
			else if(message.data.type === "sessionToken"){
				window.al_token = message.data.value
				//to prevent "session expired" messages
				//see "modules/keepAlive.js"
			}
		}
	}
}
else{
	/* Safari is the most common case where BroadcastChannel is not available.
	 * It *should* be available in most other browsers, so if it isn't here's a message to those where it fails
	 * Safari users can't really do anything about it, so there's no need to nag them, hence the window.safari test
	 * If Apple implements it in the future, the code should be updated, but the code doesn't do anything *wrong* then either
	 * it will just not print the warning when BroadcastChannel isn't available
	 */
	if(!window.safari){
		console.warn("BroadcastChannel not available. " + script_type + " will not be able to share cached data between tabs")
	}
}
//mandatory: query,variables,callback
//optional: cacheKey, and optionally even then, how long the item is fresh in the cache
function generalAPIcall(query,variables,callback,cacheKey,timeFresh,useLocalStorage,overWrite,oldCallback){
	if(APIcallsUsed_shortTerm > 18 || APIcallsUsed > (APIlimit - 2)){
		setTimeout(function(){
			generalAPIcall(query,variables,callback,cacheKey,timeFresh,useLocalStorage,overWrite,oldCallback);
		},1000*2);
		return
	}
	if(typeof query === "object"){
		variables = query.variables;
		callback = query.callback;
		cacheKey = query.cacheKey;
		timeFresh = query.timeFresh;
		useLocalStorage = query.useLocalStorage;
		overWrite = query.overWrite;
		oldCallback = query.oldCallback;
		query = query.query;
	}
	if(cacheKey && ((useLocalStorage && window.localStorage) || (!useLocalStorage && window.sessionStorage))){
		let cacheItem = JSON.parse(
			(useLocalStorage ? localStorage.getItem(cacheKey) : sessionStorage.getItem(cacheKey))
		);
		if(cacheItem){
			if(
				(
					!cacheItem.duration
					|| (NOW() < cacheItem.time + cacheItem.duration)
				) && !overWrite
			){
				callback(cacheItem.data,variables);
				return
			}
			else{
				if(oldCallback){
					oldCallback(cacheItem.data,variables)
				}
				(useLocalStorage ? localStorage.removeItem(cacheKey) : sessionStorage.removeItem(cacheKey))
			}
		}
	}
	let handleData = function(data,errors){
		callback(data,variables,errors);
		if(cacheKey && ((useLocalStorage && window.localStorage) || (!useLocalStorage && window.sessionStorage))){
			let saltedHam = JSON.stringify({
				data: data,
				time: NOW(),
				duration: timeFresh
			});
			if(useLocalStorage){
				localStorage.setItem(cacheKey,saltedHam)
			}
			else{
				try{
					sessionStorage.setItem(cacheKey,saltedHam)
				}
				catch(err){
					console.error(script_type + " cache is full. Searching for expired items...");
					let purgeCounter = 0;
					Object.keys(sessionStorage).forEach(key => {
						try{
							let item = JSON.parse(sessionStorage.getItem(key));
							if(item.time && (NOW() - item.time > item.duration)){
								sessionStorage.removeItem(key);
								purgeCounter++;
							}
						}
						catch(err){
							/*there may be non-JSON objects in session storage.
							the best way to check for JSON-ness is the JSON parser, so this needs a try wrapper
							*/
						}
					});
					if(purgeCounter){
						console.log("Purged " + purgeCounter + " expired items")
					}
					else{
						Object.keys(sessionStorage).slice(0,10).forEach(
							key => sessionStorage.removeItem(key)
						);
						console.log("Found no expired items. Deleted some at random to free up space.")
					}
					try{
						sessionStorage.setItem(cacheKey,saltedHam)
					}
					catch(err){
						console.error("The " + script_type + " cache failed for the key '" + cacheKey + "'. ");
						if(saltedHam.length > 50000){
							console.warn("The cache item is possibly too large (approx. " + saltedHam.length + " bytes)")
						}
						else{
							console.warn("Setting cache item failed. Please report or check your localStorage settings.")
						}
					}
				}
				aniCast.postMessage({type:"cache",key:cacheKey,value:saltedHam});
			}
		}
	};
	let options = {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
			"Accept": "application/json"
		},
		body: JSON.stringify({
			"query": query,
			"variables": variables
		})
	};
	let handleError = function(error){
		if(error.errors && error.errors.some(err => err.status === 404)){//not really an error
			handleData(null,error);
			return
		}
		console.error({error: error,variables: variables});
		handleData(null,error)
	};
	fetch(url,options).then(handleResponse).then(handleData).catch(handleError);
	APIcallsUsed++;
	APIcallsUsed_shortTerm++;
}
/*
rawQueries = [
	{
		query: a graphql query
		variables: variables like a normal API call
		callback: like in a normal API call
		cacheKey: [optional]
		duration: [optional]
	}
	...
]
*/
function deleteCacheItem(key){
	sessionStorage.removeItem(key);
	localStorage.removeItem(key)
}
function queryPacker(rawQueries,possibleCallback){//get a list of query calls, and pack them into one query. The result is then split up again and sent back to each call.
	let queries = rawQueries.filter(function(query){//filter out those that have data in our local cache
		if(query.cacheKey){
			let cacheItem = JSON.parse(sessionStorage.getItem(query.cacheKey));
			if(cacheItem){
				if(
					!cacheItem.duration
					|| (NOW() < cacheItem.time + cacheItem.duration)
				){
					query.callback(cacheItem.data);
					return false;
				}
				else{
					sessionStorage.removeItem(query.cacheKey);//expired data
				}
			}
		}
		return true
	});
	queries.forEach(function(query){//inline all variables
		query.query = query.query.trim().replace(/^query.*?{/,"").slice(0,-1).trim();
		const enums = ["type"];
		Object.keys(query.variables).forEach(variable => {
			let replacement = query.variables[variable];
			if(!enums.includes(variable) && typeof query.variables[variable] === "string"){
				replacement = "\"" + replacement + "\""
			}
			query.query = query.query.split("$" + variable).join(replacement)
		})
	});
	let enumeratedQueries = queries.map(function(query,index){
		query.getFields = [];
		let internalList = [];
		let partial = "";
		let getField = "";
		let collectGetField = true;
		let left = 0;
		Array.from(query.query).forEach(letter => {
			partial += letter;
			if(letter === "{"){
				left++;
				collectGetField = false
			}
			else if(letter === "("){
				collectGetField = false
			}
			else if(letter === "}"){
				left--;
				if(left === 0){
					internalList.push("a" + index + "a" + internalList.length + ":" + partial.trim());
					query.getFields.push(getField.trim());
					partial = "";
					getField = "";
					collectGetField = true
				}
			}
			else if(collectGetField){
				getField += letter
			}
		});
		return internalList.join();
	});
	let mainQuery = `
query{
	${enumeratedQueries.join("\n")}
}
	`;
	let queryUnpacker = function(data){
		if(!data){
			queries.forEach(
				query => query.callback(null)
			)
		}
		else{
			queries.forEach((query,index) => {
				let returnStructure = {data:{}};
				query.getFields.forEach(
					(field,fieldIndex) => returnStructure.data[field] = data.data["a" + index + "a" + fieldIndex]
				);
				query.callback(returnStructure);
				if(query.cacheKey){
					let cacheStrucuture = {
						data: returnStructure
					}
					if(query.duration){
						cacheStrucuture.time = NOW();
						cacheStrucuture.duration = query.duration;
					}
					sessionStorage.setItem(query.cacheKey,JSON.stringify(cacheStrucuture))
				}
			});
			if(possibleCallback){
				possibleCallback()
			}
		}
	}
	if(queries.length){//hey, they might all have been in cache
		generalAPIcall(mainQuery,{},queryUnpacker)//send our "superquery" to the regular API handler
	}
}

function accessTokenRetractedInfo(){
	console.warn("Access token retracted.");
	let box = createDisplayBox("width:600px;height:500px;top:100px;left:220px",script_type);
	let title = create("h4",false,"Access token retracted",box);
	let body = create("p",false,`
The authentication access token you gave ${script_type} has been retracted.

This means some modules that require elevated priviledges will not work. Other parts of the script will work fine.

There could be several reasons:
 - Anilist is experiencing heavy trafic, shutting down connected apps to try staying online.
 - It has expired.
 - You clicked "Revoke App" in https://anilist.co/settings/apps
 - The API or the script glitched.

You can try getting a new token by clicking this link:
`,box);
	let link = create("a",false,translate("$terms_signin_link"),box,"font-size: x-large;");
	link.href = authUrl;
	link.style.color = "rgb(var(--color-blue))";
	let note = create("p",false,`
(If you always want to sign in again when this happens, enable "Warn me when I get signed out from ${script_type}" in the settings. That will cause this dialogue to always pop up when the token is missing)
`,box);
}

function authAPIcall(query,variables,callback,cacheKey,timeFresh,useLocalStorage,overWrite,oldCallback){//only use this for queries explicitely requiring auth permissions
	if(!useScripts.accessToken){
		generalAPIcall(query,variables,callback,cacheKey,timeFresh,useLocalStorage,overWrite,oldCallback)
		return
	}
	if(APIcallsUsed_shortTerm > 18 || APIcallsUsed > (APIlimit - 2)){
		setTimeout(function(){
			authAPIcall(query,variables,callback,cacheKey,timeFresh,useLocalStorage,overWrite,oldCallback);
		},1000*2);
		return
	}
	if(typeof query === "object"){
		variables = query.variables;
		callback = query.callback;
		cacheKey = query.cacheKey;
		timeFresh = query.timeFresh;
		useLocalStorage = query.useLocalStorage;
		overWrite = query.overWrite;
		oldCallback = query.oldCallback;
		query = query.query;
	}
	if(cacheKey){
		let cacheItem = JSON.parse(
			(useLocalStorage ? localStorage.getItem(cacheKey) : sessionStorage.getItem(cacheKey))
		);
		if(cacheItem){
			if(
				(
					!cacheItem.duration
					|| (NOW() < cacheItem.time + cacheItem.duration)
				) && !overWrite
			){
				callback(cacheItem.data,variables);
				return
			}
			else{
				if(oldCallback){
					oldCallback(cacheItem.data,variables)
				}
				(useLocalStorage ? localStorage.removeItem(cacheKey) : sessionStorage.removeItem(cacheKey))
			}
		}
	}
	let handleData = function(data,errors){
		callback(data,variables,errors);
		if(cacheKey){
			let saltedHam = JSON.stringify({
				data: data,
				time: NOW(),
				duration: timeFresh
			});
			if(useLocalStorage){
				localStorage.setItem(cacheKey,saltedHam)
			}
			else{
				sessionStorage.setItem(cacheKey,saltedHam);
				aniCast.postMessage({type:"cache",key:cacheKey,value:saltedHam})
			}
		}
	};
	let options = {
		method: "POST",
		headers: {
			"Authorization": "Bearer " + useScripts.accessToken,
			"Content-Type": "application/json",
			"Accept": "application/json"
		},
		body: JSON.stringify({
			"query": query,
			"variables": variables
		})
	};
	let handleError = function(error){
		console.error(error);
		if(error.errors){
			if(
				error.errors.some(thing => thing.message === "Invalid token")
			){
				useScripts.accessToken = "";
				useScripts.save();
				accessTokenRetractedInfo();
				return
			}
		}
		if(query.includes("mutation")){
			callback(error.errors)
		}
		else{
			handleData(null,error)
		}
	};
	fetch(url,options).then(handleResponse).then(handleData).catch(handleError);
	APIcallsUsed++;
	APIcallsUsed_shortTerm++;
}
const ANILIST_QUERY_LIMIT = 90;

localforage.config({name: script_type.toLowerCase()});

//begin api v2
const apiCache = localforage.createInstance({name: script_type.toLowerCase(), storeName: "api"});
let apiResetLimit;

/** Provides default arguments for an {@link anilistAPI()} request */
class QueryOptions{
	/**
	 * Creates an arguments object
	 * @param {object} [args={}] - Contains the options which will override the default options for the request.
	 */
	constructor(args={}){
		this.variables = {};
		this.cacheKey = null;
		this.duration = null;
		this.overwrite = false;
		this.auth = false;
		this.internal = false;
		Object.assign(this, args);
	}
}

/** Configures options for a network request */
class RequestOptions{
	constructor(query, variables, auth, internal){
		this.method = "POST",
		this.headers = new Headers({
			"Content-Type": "application/json",
			"Accept": "application/json"
		}),
		this.body = JSON.stringify({
			"query": query,
			"variables": variables
		})
		this.isAuth(auth)
		this.isInternal(internal)
	}
	isAuth(auth){
		if(auth === true && useScripts.accessToken){
			this.headers.set("Authorization", "Bearer " + useScripts.accessToken)
		}
	}
	isInternal(internal){
		if(internal === true){
			if(al_token){
				this.headers.set("x-csrf-token", al_token)
			}
			this.headers.set("schema", "internal")
		}
	}
}

/**
 * Updates the variables tracking the API request limit
 * @param {Response} res - The Response object from a network request.
 */
function updateLimit(res){
	if(res.headers.has("x-ratelimit-limit")){
		APIlimit = res.headers.get("x-ratelimit-limit");
	}
	if(res.headers.has("x-ratelimit-remaining")){
		APIcallsUsed = APIlimit - res.headers.get("x-ratelimit-remaining");
	}
}

/**
 * Checks the API cache for an existing item and returns it if it has not expired
 * @param {string} key - The key to check for in the datastore.
 * @returns {Promise<object>} The cached data if found.
 */
async function checkCache(key){
	const item = await apiCache.getItem(key);
	if(item){
		if(!item.expiresAt || (NOW() < item.expiresAt)){
			return item.data;
		}
		else{
			return apiCache.removeItem(key);
		}
	}
	return;
}

/**
 * Iterates the API cache for expired items and removes them
 * @returns {Promise}
 */
async function flushCache(){
	return apiCache.iterate((item, key) => {
		if(NOW() > item.expiresAt){
			apiCache.removeItem(key);
		}
	})
}

/**
 * Saves data to the API cache
 * @param {string} key - The key used to store the data.
 * @param {object} data - The data to store.
 * @param {number} [duration] - The length of time to store in milliseconds.
 * @return {Promise}
 */
async function saveCache(key, data, duration){
	const saltedHam = {
		data: data,
		createdAt: NOW(),
		expiresAt: duration ? NOW() + duration : undefined
	};
	try{
		return apiCache.setItem(key, saltedHam);
	}
	catch(e){
		if(e.name === "QuotaExceededError"){
			console.error("Persistent storage quota exceeded. Attempting to purge expired items.")
			try{
				return flushCache();
			}
			catch(e){
				try{
					return apiCache.clear();//clear all items in the store if flushing fails
				}
				catch(e){
					throw new Error(e)
				}
			}
		}
		else{
			throw new Error(e)
		}
	}
}

/**
 * Updates data in the API cache
 * @param {string} key - The existing key to store updated data.
 * @param {object} newData - The new data to overwrite the existing data.
 * @returns {Promise}
 */
async function updateCache(key, newData){
	const data = await apiCache.getItem(key);
	if(data){
		Object.assign(data, {
			data: newData,
			updatedAt: NOW()
		});
		try{
			return apiCache.setItem(key, data);
		}
		catch(e){
			if(e.name === "QuotaExceededError"){
				console.error("Persistent storage quota exceeded. Attempting to purge expired items.")
				try{
					return flushCache();
				}
				catch(e){
					try{
						return apiCache.clear();//clear all items in the store if flushing fails
					}
					catch(e){
						throw new Error(e)
					}
				}
			}
			else{
				throw new Error(e)
			}
		}
	}
	else{
		throw new Error(`Key ${key} does not exist in cache.`)
	}
}

/**
 * Constructs and sends a request to the AniList GraphQL API
 * @param {string} query - A GraphQL query string.
 * @param {object} [queryArgs] - An object containing request parameters. (e.g. GraphQL variables)
 * @param {object} [queryArgs.variables] - GraphQL variables.
 * @param {string} [queryArgs.cacheKey] - A key used to cache API data.
 * @param {number} [queryArgs.duration] - How long data should remain cached (in milliseconds.)
 * @param {boolean} [queryArgs.overwrite] - Ignore cached data when making a request.
 * @param {boolean} [queryArgs.auth] - Make an authenticated request as the current user.
 * @param {boolean} [queryArgs.internal] - Make an internal request. Only uses the internal schema.
 * @returns {Promise<object>} Response data from the API or cached data.
 */
async function anilistAPI(query, queryArgs){
	if(!query){
		throw new Error("No query provided")
	}
	let apiUrl = url;
	const args = new QueryOptions(queryArgs);
	const options = new RequestOptions(query, args.variables, args.auth, args.internal);
	if(args.cacheKey && !args.overwrite){
		const cache = await checkCache(args.cacheKey);
		if(cache){
			return cache;
		}
	}
	if(apiResetLimit){
		if(NOW() < apiResetLimit*1000){
			return {
				"data": null,
				"errors": [{"message": "Too Many Requests.","status": 429}]
			};
		}
		apiResetLimit = undefined;
	}
	if(args.internal === true){
		apiUrl = "https://anilist.co/graphql";
	}
	try{
		const res = await fetch(apiUrl, options);
		if(args.internal !== true){
			updateLimit(res);
		}
		const data = await res.json();
		if(res.ok){
			if(args.cacheKey){
				saveCache(args.cacheKey, data, args.duration);
			}
		}
		else{
			if(data.errors){
				if(data.errors.some(thing => thing.message === "Invalid token")){//status 400
					useScripts.accessToken = "";
					useScripts.save();
					accessTokenRetractedInfo()
				}
			}
			if(res.status === 429){
				if(res.headers.has("retry-after")){
					console.warn(`Exceeded AniList API request limit. Limit resets in ${res.headers.get("retry-after")} seconds.`)
				}
				if(res.headers.has("x-ratelimit-reset")){
					apiResetLimit = res.headers.get("x-ratelimit-reset");
				}
				else{
					apiResetLimit = (NOW()+60*1000)/1000;
					throw new Error("Exceeded AniList API request limit. Please report the issue at https://github.com/hohMiyazawa/Automail/issues")
				}
			}
			else if(res.status !== 404){
				console.error(`AniList API returned ${res.status} ${res.statusText}`)
			}
		}
		return data;
	}
	catch(e){
		console.error(e)
		return {
			"data": null,
			"errors": [{"message": e,"status": null}]
		};
	}
}

/** Runs an API cache checkup weekly */
const cacheCheckup = () => {
	const check = localStorage.getItem("db-check")
	if(check){
		if(NOW() > check){
			localStorage.setItem("db-check", NOW()+7*24*60*60*1000)
			flushCache();
		}
	}
	else{
		localStorage.setItem("db-check", NOW()+7*24*60*60*1000)
	}
};
cacheCheckup()
//end api v2
//end "graphql.js"

//begin "cache.js"

let reliablePersistentStorage = true;
if (navigator.storage && navigator.storage.persist){
	navigator.storage.persist().then(function(persistent){
		if(!persistent){
			reliablePersistentStorage = false;
			console.log(script_type + " was denied persistent storage, and may run slower/use more data since it can't keep a cache. Consider enabling persistent storage in 'site info' > 'permissions'")
		}
	})
}

const cache = {
	list: {ANIME: null,MANGA: null},
	scheduled: false,
	lock: {ANIME: false,MANGA: false},
	lockedCallbacks: {ANIME: [],MANGA: []},
	listQuery: {
		get ANIME(){
			return `
query($name: String!){
	MediaListCollection(userName: $name, type: ANIME){
		lists{
			name
			isCustomList
			entries{
				mediaId
				status
				progress
				repeat
				notes
				${userObject.mediaListOptions.animeList.advancedScoringEnabled ? "advancedScores" : ""}
				startedAt{
					year
					month
					day
				}
				media{
					episodes
					duration
					nextAiringEpisode{episode}
					format
					title{romaji native english}
					tags{name}
					genres
					meanScore
					studios{nodes{isAnimationStudio id name}}
				}
				scoreRaw: score(format: POINT_100)
			}
		}
	}
}`;
		},
		get MANGA(){
			return `
query($name: String!){
	MediaListCollection(userName: $name, type: MANGA){
		lists{
			name
			isCustomList
			entries{
				mediaId
				status
				progress
				progressVolumes
				repeat
				notes
				${userObject.mediaListOptions.mangaList.advancedScoringEnabled ? "advancedScores" : ""}
				startedAt{
					year
					month
					day
				}
				media{
					chapters
					volumes
					format
					title{romaji native english}
					tags{name}
					genres
					meanScore
				}
				scoreRaw: score(format: POINT_100)
			}
		}
	}
}`;
		}
	},
	synch: function(){
		if(!cache.scheduled){
			cache.scheduled = true;
			setTimeout(function(){
				localStorage.setItem(script_type.toLowerCase() + "ListCache",cache.list);
				cache.scheduled = false
			},10*1000)
		}
	},
	forceUpdate: async function(type){
		const data = await anilistAPI(this.listQuery[type], {
			variables: {name: whoAmI},
			auth: true
		});
		if(data.errors){
			return
		}
		cache.list[type] = {
			time: NOW(),
			duration: 60*60*1000,
			data: data
		}
		localforage.setItem(script_type.toLowerCase() + "ListCache" + type,cache.list[type]);
		cache.lockedCallbacks[type].forEach(a => a.callback(cache.list[a.type].data));
		cache.lockedCallbacks[type] = [];
		cache.lock[type] = false;
		return
	},
	updateIfDifferent: function(mediaData,doNotWrite){
		let different = false;
		let found = false;
		//logic here
		if(different){
			aniCast.postMessage({type:"cachev2",mediaData: mediaData});
			if(!doNotWrite){
				cache.synch()
			}
		}
	},
	getList: function(type,callback){
		if(!cache.list[type]){
			cache.lockedCallbacks[type].push({callback: callback,type: type})
			if(!cache.lock[type]){
				cache.lock[type] = true;
				localforage.getItem(script_type.toLowerCase() + "ListCache" + type,function(err,value){
					if(err){
						console.log(err);
						return
					}
					if(value){
						if(NOW() - value.time > value.duration){
							cache.forceUpdate(type)
						}
						else{
							cache.list[type] = value;
							cache.lockedCallbacks[type].forEach(a => a.callback(cache.list[a.type].data));
							cache.lockedCallbacks[type] = [];
							cache.lock[type] = false;
						}
					}
					else{
						cache.forceUpdate(type)
					}
				})
			}
		}
		else{
			callback(cache.list[type].data)
		}
	}
}
//end "cache.js"

//begin "controller.js"
const modules = [];

let current = "";

function handleScripts(url,oldUrl){
	modules.forEach(module => {
		if(useScripts[module.id] && (script_type !== "Boneless" || !module.boneless_disable) && module.urlMatch && module.code && module.urlMatch(url,oldUrl)){
			module.code()
		}
	})
	if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
		let nav = document.getElementById("nav");
		if(nav){
			try{
				nav.querySelector('a[href="/home"].link').childNodes[0].textContent = translate("$menu_home");
				nav.querySelector('a[href^="/user/"].link').childNodes[0].textContent = translate("$menu_profile");
				nav.querySelector('a[href$="/animelist"].link').childNodes[0].textContent = translate("$menu_animelist");
				nav.querySelector('a[href$="/mangalist"].link').childNodes[0].textContent = translate("$menu_mangalist");
				nav.querySelector('a[href^="/search/"].link').childNodes[0].textContent = translate("$menu_browse");
				(nav.querySelector('a[href="/forum/overview"].link') || nav.querySelector('a[href="/forum/recent"].link')).childNodes[0].textContent = translate("$menu_forum");
				nav.querySelector('.user-wrap .dropdown a[href="/notifications"] .label').textContent = translate("$mainMenu_notifications");
				nav.querySelector('.user-wrap .dropdown a[href^="/user/"] .label').textContent = translate("$mainMenu_profile");
				nav.querySelector('.user-wrap .dropdown a[href="/settings"] .label').textContent = translate("$mainMenu_settings");
			}
			catch(e){
				console.log(e)
			}
		}
	}
	if((url === "https://anilist.co/notifications" || url === "https://anilist.co/notifications#") && useScripts.notifications){
		enhanceNotifications();
		return
	}
	else if(url === "https://anilist.co/user/" + whoAmI + "/social#my-threads"){
		selectMyThreads()
	}
	else if(url === "https://anilist.co/settings/import" && useScripts.moreImports){
		moreImports()
	}
	else if(url === "https://anilist.co/404"){
		possibleBlocked(oldUrl)
	}
	if(/^https:\/\/anilist\.co\/(anime|manga)\/\d*(\/[\w-]*)?\/social/.test(url)){
		if(useScripts.socialTab){
			enhanceSocialTab();
		}
		if(useScripts.socialTabFeed){
			enhanceSocialTabFeed()
		}
		if(useScripts.activityTimeline){
			addActivityTimeline()
		}
	}
	else{
		stats.element = null;
		stats.count = 0;
		stats.scoreSum = 0;
		stats.scoreCount = 0;
	}
	if(
		/\/stats\/?/.test(url)
		&& useScripts.moreStats
	){
		addMoreStats()
	}
	if(/^https:\/\/anilist\.co\/home#access_token/.test(url)){
		let tokenList = location.hash.split("&").map(a => a.split("="));
		useScripts.accessToken = tokenList[0][1];
		useScripts.save();
		location.replace(location.protocol + "//" + location.hostname + location.pathname);
	}
	if(/^https:\/\/anilist\.co\/home#aniscripts-login/.test(url)){
		if(useScripts.accessToken){
			alert("Already authorized. You can rewoke this under 'apps' in your Anilist settings")
		}
		else{
			location.href = authUrl
		}
	}
	if(/^https:\/\/anilist\.co\/user/.test(url)){
		if(
			useScripts.partialLocalisationLanguage !== "English"
		){
			addFeedFilters_user()
		}
		if(useScripts.completedScore || useScripts.droppedScore){//we also want this script to run on user pages
			addCompletedScores()
		}
		if(useScripts.embedHentai){
			embedHentai()
		}
		if(useScripts.noImagePolyfill || useScripts.SFWmode){
			addImageFallback()
		}
		let adder = function(){
			let banner = document.querySelector(".banner");
			if(banner && banner.style.backgroundImage !== "url(\"undefined\")"){
				if(banner.style.backgroundImage === `url("data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7")`){
					//edge case, no avaiable banner to show (private profiles, etc.)
					//do not create banner download icon
					return
				}
				let bannerLink = create("a","hohDownload","⭳",banner);
				const linkPlace = banner.style.backgroundImage.replace("url(","").replace(")","").replace('"',"").replace('"',"");
				bannerLink.href = linkPlace;
				bannerLink.title = translate("$download_banner_tooltip");
				if(linkPlace === "null"){
					bannerLink.style.display = "none"
				}
			}
			else{
				setTimeout(adder,500)
			}
		};adder();
		if(useScripts.milestones){
			meanScoreBack()
		}
		if(useScripts.profileBackground){
			profileBackground()
		}
		if(useScripts.customCSS){
			addCustomCSS()
		}
	}
	else{
		customStyle.textContent = ""
	}
	if(
		url.match(/^https:\/\/anilist\.co\/forum\/thread\/.*/)
	){
		if(useScripts.embedHentai){
			embedHentai()
		}
	}
	else if(/^https:\/\/anilist\.co\/forum\/?(overview|search\?.*|recent|new|subscribed)?$/.test(url)){
		if(useScripts.myThreads){
			addMyThreadsLink()
		}
	}
	else if(/^https:\/\/anilist\.co\/staff\/.*/.test(url)){
		if(useScripts.staffPages){
			enhanceStaff()
		}
	}
	else if(
		url.match(/^https:\/\/anilist\.co\/studio\/.*/)
	){
		if(useScripts.studioFavouriteCount){
			enhanceStudio()
		}
		if(useScripts.studioSorting){
			addStudioBrowseSwitch()
		}
	}
	if(
		url.match(/^https:\/\/anilist\.co\/user\/.*\/social/)
	){
		if(useScripts.CSSfollowCounter){
			addFollowCount()
		}
		addSocialThemeSwitch();
	}
	if(
		url.match(/^https:\/\/anilist\.co\/.+\/(anime|manga)list\/?(.*)?$/)
	){
		if(useScripts.viewAdvancedScores){
			viewAdvancedScores(url)
		}
	}
	if(
		url.match(/^https:\/\/anilist\.co\/user\/(.*)\/(anime|manga)list\/compare/)
		&& useScripts.comparissionPage//incorrect spelling to leave backwards compatibility with configs. Doesn't matter as it isn't visible
	){
		addComparisionPage()//this one on the other hand *should* be spelled correctly
	}
	else{
		let possibleHohCompareRemaining = document.querySelector(".hohCompare");
		if(possibleHohCompareRemaining){
			(document.querySelectorAll(".hohCompareUIfragment") || []).forEach(fragment => fragment.remove());
			possibleHohCompareRemaining.remove()
		}
	}
	if(url.match(/^https:\/\/anilist\.co\/search/) && useScripts.CSSverticalNav){
		let lamaDrama = document.querySelector(".nav .browse-wrap .router-link-exact-active.router-link-active");
		if(lamaDrama){
			lamaDrama.classList.remove("router-link-exact-active");
			lamaDrama.classList.remove("router-link-active");
			lamaDrama.parentNode.classList.add("router-link-exact-active");
			lamaDrama.parentNode.classList.add("router-link-active");
			Array.from(document.querySelectorAll(".nav .link")).forEach(link => {
				link.onclick = function(){
					lamaDrama.parentNode.classList.remove("router-link-exact-active");
					lamaDrama.parentNode.classList.remove("router-link-active")
				}
			})
		}
	}
	if(url.match(/^https:\/\/anilist\.co\/search\/staff/)){
		if(useScripts.staffPages){
			enhanceStaffBrowse()
		}
	}
	else if(url.match(/^https:\/\/anilist\.co\/search\/anime/)){
		if(useScripts.browseFilters){
			addBrowseFilters("anime")
		}
	}
	else if(url.match(/^https:\/\/anilist\.co\/search\/manga/)){
		if(useScripts.browseFilters){
			addBrowseFilters("manga")
		}
	}
	let mangaAnimeMatch = url.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
	if(mangaAnimeMatch){
		let adder = function(){
			if(!document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/?/)){
				return
			}
			let banner = document.querySelector(".media .banner");
			if(banner){
				let bannerLink = create("a","hohDownload","⭳",banner);
				bannerLink.title = translate("$download_banner_tooltip");
				bannerLink.href = banner.style.backgroundImage.replace("url(","").replace(")","").replace('"',"").replace('"',"");
			}
			else{
				setTimeout(adder,500)
			}
		};adder();
		if(useScripts.subTitleInfo){
			addSubTitleInfo()
		}
		if(useScripts.dubMarker && mangaAnimeMatch[1] === "anime"){
			dubMarker()
		}
		else if(useScripts.mangaGuess && mangaAnimeMatch[1] === "manga"){
			mangaGuess(false,parseInt(mangaAnimeMatch[2]))
		}
		if(useScripts.mangaGuess && mangaAnimeMatch[1] === "anime"){
			mangaGuess(true)
		}
		if(useScripts.MALscore || useScripts.MALserial || useScripts.MALrecs){
			addMALscore(mangaAnimeMatch[1],mangaAnimeMatch[2])
		}
		if(useScripts.accessToken){
			addRelationStatusDot(mangaAnimeMatch[2])
		}
		if(useScripts.entryScore && whoAmI){
			addEntryScore(mangaAnimeMatch[2])
		}
		if(useScripts.SFWmode){
			cencorMediaPage(mangaAnimeMatch[2])
		}

		const urlID = parseInt(mangaAnimeMatch[2]);
		if(aliases.has(urlID)){
			let alias = aliases.get(urlID);
			let newState = "/" + mangaAnimeMatch[1] + "/" + urlID + "/" + safeURL(alias) + "/";
			if(mangaAnimeMatch[4]){
				newState += mangaAnimeMatch[4]
			}
			history.replaceState({},"",newState);
			current = document.URL;
			let titleReplacer = () => {
				let mangaAnimeMatch2 = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
				if(!mangaAnimeMatch2 || mangaAnimeMatch[2] !== mangaAnimeMatch2[2]){
					return
				}
				let mainTitle = document.querySelector("h1");//fragile, just like your heterosexuality
				if(mainTitle){
					mainTitle.id = "hohAliasHeading";
					mainTitle.childNodes[0].textContent = alias
				}
				else{
					setTimeout(titleReplacer,100)
				}
			};
			titleReplacer()
		}
		else{
			let titleReplacer = () => {
				let mangaAnimeMatch2 = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
				if(!mangaAnimeMatch2 || mangaAnimeMatch[2] !== mangaAnimeMatch2[2]){
					return
				}
				let mainTitle = document.querySelector("h1");
				if(mainTitle){
					mainTitle.childNodes[0].textContent = mainTitle.childNodes[0].textContent.trim()
				}
				else{
					setTimeout(titleReplacer,1000)
				}
			};
			titleReplacer()
		}

		if(useScripts.socialTab){
			scoreOverviewFixer()
		}
	}
	if(url.match(/^https:\/\/anilist\.co\/home\/?$/)){
		if(useScripts.completedScore || useScripts.droppedScore){
			addCompletedScores()
		}
		if(useScripts.betterListPreview && whoAmI && useScripts.accessToken && (!useScripts.mobileFriendly)){
			betterListPreview()
		}
		if(useScripts.progressBar){
			addProgressBar()
		}
		if(
			(useScripts.feedCommentFilter && (!useScripts.mobileFriendly))
			|| localStorage.getItem("blockList")
			|| useScripts.blockWord
			|| useScripts.statusBorder
			|| useScripts.partialLocalisationLanguage !== "English"
		){
			addFeedFilters()
		}
		if(useScripts.expandRight){
			expandRight()
		}
		if(useScripts.embedHentai){
			embedHentai()
		}
		if(useScripts.hideAWC || useScripts.hideOtherThreads){
			addForumMediaNoAWC()
		}
		else if(useScripts.forumMedia){
			addForumMediaTitle()
		}
		if(useScripts.noImagePolyfill || useScripts.SFWmode){
			addImageFallback()
		}
		if(useScripts.hideGlobalFeed){
			hideGlobalFeed()
		}
		if(useScripts.betterReviewRatings){
			betterReviewRatings()
		}
		if(useScripts.homeScroll){
			let homeButton = document.querySelector(".nav .link[href=\"/home\"]");
			if(homeButton){
				homeButton.onclick = () => {
					if(document.URL.match(/^https:\/\/anilist\.co\/home\/?$/)){
						window.scrollTo({top: 0,behavior: "smooth"})
					}
				}
			}
		}
		linkFixer()
	}
	let activityMatch = url.match(/^https:\/\/anilist\.co\/activity\/(\d+)/);
	if(activityMatch){
		if(useScripts.completedScore || useScripts.droppedScore){
			addCompletedScores()
		}
		if(useScripts.activityTimeline){
			addActivityLinks(activityMatch[1])
		}
		if(useScripts.embedHentai){
			embedHentai()
		}
		if(useScripts.showMarkdown){
			showMarkdown(activityMatch[1])
		}
	}
	if(url.match(/^https:\/\/anilist\.co\/edit/)){//seems to give mixed results. At least it's better than nothing
		window.onbeforeunload = function(){
			return "Page refresh has been intercepted to avoid an accidental loss of work"
		}
	}
	if(useScripts.notifications && useScripts.accessToken && !useScripts.mobileFriendly){
		notificationCake()
	}
	[1,2,3,4,5/*no 6*/,7,8,9,10,11,12,13,14,15,16,17,18,19].forEach(forumCategory => {
		if(url === "https://anilist.co/forum/recent?category=" + forumCategory){
			document.title = translate("$documentTitle_forum_prefix") + " - " + translate("$forumCategory_" + forumCategory) + " · AniList"
		}
	})
}

let useScriptsDefinitions = [
{"id": "hideLikes",
	"description": "$hideLikes_description",
	"categories": ["Notifications"]
},{"id": "settingsTip",
	"description": "$settingsTip_description",
	"extendedDescription": "Options with the 🛈 button has more information available if you click it",
	"categories": ["Notifications"]
},{"id": "dismissDot",
	"description": "$dismissDot_description",
	"categories": ["Notifications","Login"]
},{"id": "socialTab",
	"description": "$socialTab_description",
	"categories": ["Media"]
},{"id": "socialTabFeed",
	"description": "$socialTabFeed_description",
	"extendedDescription": "'Has replies' is the only filter that works if not signed in with the script. A 'Following' filter becomes available if you do.",
	"categories": ["Media","Login"]
},{"id": "forumMedia",
	"description": "$forumMedia_description",
	"extendedDescription": "The forum preview only shows one tag by default, so it's just going to say 'anime' or 'manga' without telling you which media it's about. This module adds a second tag, shortening the title somewhat if there's not enough space.",
	"categories": ["Forum"]
},{"id": "draw3x3",
	"description": "$draw3x3_description",
	"categories": ["Lists"]
},{"id": "automailAPI",
	"boneless_disable": true,
	"description": "Enable an API for other scripts to control this script [Don't enable this unless you know what you are doing]",
	"categories": ["Script","Login"]
},{"id": "MALscore",
	"description": "$setting_MALscore",
	"categories": ["Media"]
},{"id": "MALserial",
	"description": "$setting_MALserial",
	"categories": ["Media"]
},{"id": "MALrecs",
	"description": "$setting_MALrecs",
	"categories": ["Media"]
},{"id": "subTitleInfo",
	"description": "$subTitleInfo_description",
	"categories": ["Media"]
},{"id": "entryScore",
	"description": "$entryScore_description",
	"categories": ["Media","Login"]
},{"id": "betterReviewRatings",
	"description": "$betterReviewRatings_description"
},{"id": "activityTimeline",
	"description": "$activityTimeline_description",
	"categories": ["Media","Navigation"]
},{"id": "browseFilters",
	"description": "$browseFilters_description",
	"categories": ["Browse"]
},{"id": "completedScore",
	"description": "$completedScore_description",
	"categories": ["Feeds"]
},{"id": "droppedScore",
	"description": "$droppedScore_description",
	"categories": ["Feeds"]
},{"id": "tagIndex",
	"description": "$tagIndex_description",
	"categories": ["Lists"]
},{"id": "CSSfollowCounter",
	"description": "$CSSfollowCounter_description",
	"categories": ["Profiles"]
},{
	"id": "dubMarker",
	"subSettings": ["dubMarkerLanguage"],
	"description": "$dubMarker_description",
	"extendedDescription": "Works by checking the database for voice actors",
	"categories": ["Media"]
},{
	"id": "dubMarkerLanguage",
	"requires": ["dubMarker"],
	"description": "",
	"type": "select",
	"categories": ["Media"],
	"displayValues": ["$language_English","$language_German","$language_Italian","$language_Spanish","$language_French","$language_Korean","$language_Portuguese","$language_Hebrew","$language_Hungarian","$language_Chinese","$language_Japanese","$language_Arabic","$language_Filipino","$language_Catalan","$language_Polish","$language_Norwegian"],
	"values": ["English","German","Italian","Spanish","French","Korean","Portuguese","Hebrew","Hungarian","Chinese","Japanese","Arabic","Filipino","Catalan","Polish","Norwegian"]
},{"id": "mangaGuess",
	"description": "$mangaGuess_description",
	"categories": ["Media"]
},{"id": "replaceNativeTags",
	"boneless_disable": true,
	"description": "$replaceNativeTags_description",
	"categories": ["Stats"]
},{"id": "allStudios",
	"boneless_disable": true,
	"description": "$allStudios_description",
	"categories": ["Stats"]
},{"id": "noRewatches",
	"description": "$noRewatches_description",
	"categories": ["Stats"]
},{"id": "hideCustomTags",
	"description": "$hideCustomTags_description",
	"categories": ["Stats"]
},{"id": "negativeCustomList",
	"description": "$negativeCustomList_description",
	"categories": ["Stats"]
},{"id": "globalCustomList",
	"description": "$globalCustomList_description",
	"categories": ["Stats"]
},{"id": "timeToCompleteColumn",
	"description": "$timeToCompleteColumn_description",
	"categories": ["Stats"]
},{"id": "comparissionPage",
	"description": "$setting_compare",
	"categories": ["Lists","Profiles"]
},{"id": "CSSsmileyScore",
	"description": "$setting_CSSsmileyScore",
	"categories": ["Lists","Media"]
},{"id": "hideGlobalFeed",
	"description": "$hideGlobalFeed_description",
	"categories": ["Feeds"]
},{"id": "feedCommentFilter",
	"description": "$feedCommentFilter_description",
	"categories": ["Feeds"]
},{"id": "statusBorder",
	"description": "$statusBorder_description",
	"categories": ["Feeds"]
},{"id": "blockWord",
	"description": "$blockWord_description",
	"extendedDescription": "RegEx syntax accepted too, do not use slash /delimeters/.\nMost common use, blocking multiple words: \"word1|word2|word3\"",
	"categories": ["Feeds"]
},{
	"id": "blockWordValue",
	"requires": ["blockWord"],
	"description": "",
	"type": "text",
	"categories": ["Feeds"]
},{"id": "profileBackground",
	"description": "Enable profile backgrounds",
	"categories": ["Profiles","Login"]
},{
	"id": "profileBackgroundValue",
	"requires": ["profileBackground"],
	"description": "",
	"visible": false,
	"type": "text",
	"categories": ["Profiles"]
},{"id": "colourPicker",
	"description": "Add a colour picker in the footer for adjusting the site themes",
	"categories": ["Script"]
},{"id": "progressBar",
	"description": "Add progress bars to the list previews",
	"categories": ["Feeds"]
},{"id": "embedHentai",
	"description": "Make cards for links to age restricted content",
	"categories": ["Feeds"]
},{"id": "betterListPreview",
	"description": "Alternative list preview",
	"categories": ["Feeds","Lists","Login"]
},{"id": "homeScroll",
	"description": "Make the 'home' button scroll to the top on the home feed",
	"categories": ["Feeds"]
},{"id": "CSSfavs",
	"description": "Use 5-width favourite layout at all screen sizes",
	"categories": ["Profiles"]
},{"id": "CSScompactBrowse",
	"description": "$CSScompactBrowse_description",
	"categories": ["Browse"]
},{"id": "customCSS",
	"boneless_disable": true,
	"description": "$customCSS_description",
	"categories": ["Profiles","Login"]
},{"id": "CSSgreenManga",
	"description": "$setting_CSSgreenManga",
	"categories": ["Media","Feeds"]
},{"id": "cleanSocial",
	"description": "$cleanSocial_description",
	"categories": ["Media","Forum"]
},{"id": "limitProgress10",
	"description": "Limit the 'in progress' sections to 10 entries",
	"categories": ["Feeds"]
},{"id": "limitProgress8",
	"description": "Limit the 'in progress' sections to 8 entries",
	"categories": ["Feeds"]
},{"id": "showRecVotes",
	"description": "Always show the recommendation voting data",
	"categories": ["Media"]
},{"id": "myThreads",
	"description": "Add a 'my threads' link in the forum",
	"categories": ["Forum","Profiles"]
},{"id": "hideAWC",
	"description": "Hide AWC threads from the forum preview on the home page. Number of AWC-free threads to display:",
	"categories": ["Forum"]
},{
	"id": "forumPreviewNumber",
	"requires": ["hideAWC"],
	"description": "",
	"type": "number",
	"min": 0,
	"max": 50,
	"categories": ["Forum"]
},{"id": "hideOtherThreads",
	"description": "Hide additional low-quality forum threads on the home page",
	"extendedDescription": "Curated list of high-volume threads with little reading value.\nRequest threads added: https://github.com/hohMiyazawa/Automail/issues\n\nhttps://anilist.co/forum/thread/15346\nhttps://anilist.co/forum/thread/2340/\nhttps://anilist.co/forum/thread/1\n\"Where can I watch/read/find\"",
	"categories": ["Forum"]
},{"id": "expandRight",
	"description": "Load the expanded view of 'in progress' in the usual place instead of full width if left in that state [weird hack]",
	"categories": ["Feeds"]
},{"id": "noImagePolyfill",
	"description": "Add fallback text for missing images in the sidebar and favourite sections",
	"categories": ["Feeds","Profiles"]
},{"id": "shortRomaji",
	"description": "Short romaji titles for everyday use. Life is too short for light novel titles",
	"categories": ["Feeds","Profiles","Lists"]
},{"id": "titlecaseRomaji",
	"description": "Uppercase killer. Title alias pack to turn unnecessary UPPERCASE to Titlecase",
	"categories": ["Feeds","Profiles","Lists"]
},{"id": "CSSprofileClutter",
	"description": "Remove clutter from profiles (milestones, history chart, genres)",
	"categories": ["Profiles"]
},{"id": "CSSdecimalPoint",
	"description": "Give whole numbers a \".0\" suffix when using the 10 point decimal scoring system",
	"categories": ["Lists"]
},{"id": "viewAdvancedScores",
	"description": "View advanced scores",
	"categories": ["Lists"]
},{"id": "rightToLeft",
	"description": "Support for right-to-left flow [under development]",
	"extendedDescription": "A baseline for adjusting Anilist to act more like a native RTL language site would.\nNot complete.",
	"categories": ["Script"]
},{"id": "termsFeedNoImages",
	"description": "Do not load images on the low bandwidth feed",
	"extendedDescription": "Refers to the feed located at https://anilist.co/terms if the setting 'low bandwidth feed' is turned on.\nFor very slow connections, images are going to be the most difficult part of the page to load.\nSee if your addblocker also supports setting a size limit for media, which may help if you are struggling.",
	"categories": ["Feeds","Login"]
},{"id": "CSSbannerShadow",
	"description": "$setting_CSSbannerShadow",
	"categories": ["Profiles","Media"]
},{"id": "milestones",
	"description": "Add total episodes and volumes to profile milestones",
	"categories": ["Profiles"]
},{"id": "CSSdarkDropdown",
	"description": "Use a dark menu dropdown in dark mode",
	"categories": ["Navigation"]
},{"id": "moreImports",
	"description": "Add more list import and list export options",
	"categories": ["Script","Login"]
},{"id": "plussMinus",
	"description": "Add + and - buttons to quickly change scores on your list",
	"categories": ["Lists","Login"]
},{"id": "navbarDroptext",
	"description": "Allow drag-and-drop of text into navbar for search",
	"categories": ["Navigation"]
},{"id": "SFWmode",
	"description": "A less flashy version of the site for school or the workplace",
	"categories": ["Script"]
},{"id": "annoyingAnimations",
	"description": "$annoyingAnimations_description",
	"categories": ["Navigation"]
},{"id": "CSSverticalNav",
	"description": "$CSSverticalNav_description",
	"extendedDescription": "hoh's personal preferences",
	"categories": ["Navigation"]
},{"id": "browseSubmenu",
	"description": "$browseSubmenu_description",
	"categories": ["Navigation"]
},{
	"id": "partialLocalisationLanguage",
	"description": "$settings_partialLocalisationLanguage_description",
	"extendedDescription": "Partial localisation, translates script-specific elements.\nCheck \"Translate additional parts of the Anilist UI\" for translating more fo the site.\nFor Japanese, you may also want to change your title language at https://anilist.co/settings/media\n\nWant to contribute? See: https://github.com/hohMiyazawa/Automail/issues/69",
	"type": "select",
	"importance": 100,
	"categories": ["Script"],
	"values": ["English","Español","Português","Norsk","日本語","Deutsch","Åarjelsaemie","Svenska","English (US)","English (short)"]
}
]

let mainLoop = setInterval(() => {
	if(document.URL !== current){
		let oldURL = current + "";
		current = document.URL;
		handleScripts(current,oldURL)
	}
	if(useScripts.expandDescriptions){
		let expandPossible = document.querySelector(".description-length-toggle");
		if(expandPossible){
			expandPossible.click()
		}
	}
},200);
console.log(script_type + " " + scriptInfo.version);
Object.keys(localStorage).forEach(key => {
	if(key.includes("hohListActivityCall")){
		let cacheItem = JSON.parse(localStorage.getItem(key));
		if(cacheItem){
			if(NOW() > cacheItem.time + cacheItem.duration){
				localStorage.removeItem(key)
			}
		}
	}
});

if(useScripts.tweets){
/*
https://developer.twitter.com/en/docs/twitter-for-websites/webpage-properties
According to Twitter, you can opt out from widgets using context data for "personalization".

Not that this tag has any force behind it, but we can at least kindly ask them.
*/
	let dnt_tag = document.createElement("meta");
	dnt_tag.setAttribute("name","twitter:dnt");
	dnt_tag.setAttribute("content","on");
	document.head.appendChild(dnt_tag)
}

if(useScripts[script_type.toLowerCase() + "API"]){
	if(document[script_type.toLowerCase() + "API"]){
		console.warn("Multiple copies of the script running? Shutting down this instance.");
		clearInterval(mainLoop);
		clearInterval(likeLoop);
		clearInterval(tweetLoop);
	}
	document[script_type.toLowerCase() + "API"] = {
		scriptInfo: scriptInfo,
		generalAPIcall: generalAPIcall,//query,variables,callback[,cacheKey[,timeFresh[,useLocalStorage]]]
		authAPIcall: authAPIcall,
		queryPacker: queryPacker,
		api: anilistAPI,//APIv2
		settings: useScripts,//this contains an access token, if granted. Be careful!
		logOut: function(){
			//makes the script forget the access token (but it's still valid)
			//to disable an access token, go to https://anilist.co/settings/apps, and click "revoke app".
			useScripts.accessToken = "";
			useScripts.save()
		}
	}
}

function exportModule(module){
	useScriptsDefinitions.push({
		id: module.id,
		description: module.description,
		categories: module.categories,
		visible: module.visible,
		importance: module.importance,
		extendedDescription: module.extendedDescription,
		css: module.css
	});
	if(!hasOwn(useScripts, module.id)){
		useScripts[module.id] = module.isDefault;
		useScripts.save()
	}
	if(module.css && useScripts[module.id]){
		moreStyle.textContent += module.css
	}
	modules.push(module)
}
//end "controller.js"

//begin modules/accessTokenWarning.js
exportModule({
	id: "accessTokenWarning",
	description: "Warn me when I get signed out from " + script_type,
	isDefault: false,
	importance: 0,
	categories: ["Login","Script","Newly Added"],
	visible: true
})

if(useScripts.accessTokenWarning && !useScripts.accessToken){
	accessTokenRetractedInfo()
}
//end modules/accessTokenWarning.js
//begin modules/addActivityLinks.js
async function addActivityLinks(activityID){
	async function arrowCallback(res){
		const {data, errors} = res;
		if(errors){
			return;
		}
		let adder = function(link){
			if(!location.pathname.includes("/activity/" + activityID)){
				return;
			}
			let activityLocation = document.querySelector(".activity-entry");
			if(activityLocation){
				activityLocation.appendChild(link);
				return;
			}
			else{
				setTimeout(function(){adder(link)},200);
			}
		};
		let queryPrevious;
		let queryNext;
		let variables = {
			userId: data.Activity.userId || data.Activity.recipientId,
			createdAt: data.Activity.createdAt
		};
		if(data.Activity.type === "ANIME_LIST" || data.Activity.type === "MANGA_LIST"){
			variables.mediaId = data.Activity.media.id;
			queryPrevious = `
query ($userId: Int,$mediaId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		mediaId: $mediaId,
		createdAt_lesser: $createdAt,
		sort: ID_DESC
	){
		... on ListActivity{siteUrl createdAt id}
	}
}`;
			queryNext = `
query($userId: Int,$mediaId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		mediaId: $mediaId,
		createdAt_greater: $createdAt,
		sort: ID
	){
		... on ListActivity{siteUrl createdAt id}
	}
}`;
		}
		else if(data.Activity.type === "TEXT"){
			queryPrevious = `
query($userId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		type: TEXT,
		createdAt_lesser: $createdAt,
		sort: ID_DESC
	){
		... on TextActivity{siteUrl createdAt id}
	}
}`;
			queryNext = `
query($userId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		type: TEXT,
		createdAt_greater: $createdAt,
		sort: ID
	){
		... on TextActivity{siteUrl createdAt id}
	}
}`;
		}
		else if(data.Activity.type === "MESSAGE"){
			let link = create("a","hohPostLink","↑",false,"left:-25px;top:25px;");
			link.href = "/user/" + data.Activity.recipient.name + "/";
			link.title = translate("$navigation_profileLink",data.Activity.recipient.name);
			adder(link);
			variables.messengerId = data.Activity.messengerId;
			queryPrevious = `
query($userId: Int,$messengerId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		type: MESSAGE,
		messengerId: $messengerId,
		createdAt_lesser: $createdAt,
		sort: ID_DESC
	){
		... on MessageActivity{siteUrl createdAt id}
	}
}`;
			queryNext = `
query($userId: Int,$messengerId: Int,$createdAt: Int){
	Activity(
		userId: $userId,
		type: MESSAGE,
		messengerId: $messengerId,
		createdAt_greater: $createdAt,
		sort: ID
	){
		... on MessageActivity{siteUrl createdAt id}
	}
}`;
		}
		else{//unknown new types of activities
			return;
		}
		if(res.previous){
			if(res.previous !== "FIRST"){
				let link = create("a","hohPostLink","←",false,"left:-25px;");
				link.href = res.previous;
				link.rel = "prev";
				link.title = "Previous activity";
				adder(link);
			}
		}
		else{
			res.previous = "FIRST";
			const prevRes = await anilistAPI(queryPrevious, {variables});
			const {data: pdata, errors} = prevRes;
			if(errors){
				return;
			}
			let link = create("a","hohPostLink","←",false,"left:-25px;");
			link.title = "Previous activity";
			link.rel = "prev";
			link.href = pdata.Activity.siteUrl;
			adder(link);
			res.previous = pdata.Activity.siteUrl;
			updateCache("hohActivity" + activityID, res);
			pdata.Activity.type = data.Activity.type;
			pdata.Activity.userId = variables.userId;
			pdata.Activity.media = data.Activity.media;
			pdata.Activity.messengerId = data.Activity.messengerId;
			pdata.Activity.recipientId = data.Activity.recipientId;
			pdata.Activity.recipient = data.Activity.recipient;
			prevRes.next = document.URL;
			saveCache("hohActivity" + pdata.Activity.id, Object.assign(prevRes,{data: pdata}), 20*60*1000);
		}
		if(res.next){
			let link = create("a","hohPostLink","→",false,"right:-25px;");
			link.href = res.next;
			link.rel = "next";
			link.title = "Next activity";
			adder(link);
		}
		else{
			const nextRes = await anilistAPI(queryNext, {variables});
			const {data: ndata, errors} = nextRes;
			if(errors){
				return;
			}
			let link = create("a","hohPostLink","→",false,"right:-25px;");
			link.href = ndata.Activity.siteUrl;
			link.rel = "next";
			link.title = "Next activity";
			adder(link);
			res.next = ndata.Activity.siteUrl;
			updateCache("hohActivity" + activityID, res);
			ndata.Activity.type = data.Activity.type;
			ndata.Activity.userId = variables.userId;
			ndata.Activity.media = data.Activity.media;
			ndata.Activity.messengerId = data.Activity.messengerId;
			ndata.Activity.recipientId = data.Activity.recipientId;
			ndata.Activity.recipient = data.Activity.recipient;
			nextRes.previous = document.URL;
			saveCache("hohActivity" + ndata.Activity.id, Object.assign(nextRes,{data: ndata}), 20*60*1000);
		}
		return;
	}

	const dataQuery = `
query($id: Int){
	Activity(id: $id){
		... on ListActivity{
			type
			userId
			createdAt
			media{id}
		}
		... on TextActivity{
			type
			userId
			createdAt
		}
		... on MessageActivity{
			type
			recipientId
			recipient{name}
			messengerId
			createdAt
		}
	}
}`
	//has to be auth now that private messages are a thing
	const data = await anilistAPI(dataQuery, {
		variables: {id: activityID},
		cacheKey: "hohActivity" + activityID,
		duration: 20*60*1000,
		auth: true
	})
	return arrowCallback(data)
}
//end modules/addActivityLinks.js
//begin modules/addActivityTimeline.js
async function addActivityTimeline(){
	const URLstuff = location.pathname.match(/^\/(anime|manga)\/(\d+)(\/[\w-]*)?\/social/);
	if(!URLstuff){
		return
	}
	if(document.getElementById("activityTimeline")){
		return
	}
	if(!whoAmIid){
		const {data, errors} = await anilistAPI("query($name:String){User(name:$name){id}}", {
			variables: {name: whoAmI},
			cacheKey: "hohIDlookup" + whoAmI.toLowerCase(),
			duration: 5*60*1000
		});
		if(errors){
			return
		}
		whoAmIid = data.User.id;
		addActivityTimeline()
		return
	}
	let followingLocation = document.querySelector(".following");
	if(!followingLocation){
		setTimeout(addActivityTimeline,200);
		return
	}
	const status = document.querySelector(".actions .list .add").innerText;
	let activityTimeline = create("div","#activityTimeline",false,followingLocation.parentNode);
	let variables = {
		mediaId: URLstuff[2],
		userId: whoAmIid,
		page: 1
	};
	const query = `
query($userId: Int,$mediaId: Int,$page: Int){
	Page(page: $page){
		pageInfo{
			currentPage
			lastPage
		}
		activities(userId: $userId, mediaId: $mediaId, sort: ID){
			... on ListActivity{
				siteUrl
				createdAt
				status
				progress
				replyCount
			}
		}
	}
}`;
	let previousTime = null;
	const lineCaller = async function(query,variables){
		const data = await anilistAPI(query, {
			variables,
			cacheKey: `hohMediaTimeline${variables.mediaId}u${variables.userId}p${variables.page}`,
			duration: 120*1000
		});
		if(data.errors){
			return
		}
		if(data.data.Page.pageInfo.currentPage === 1){
			previousTime = null;
			removeChildren(activityTimeline)
			if(data.data.Page.activities.length){
				create("h2",false,translate("$timeline_title"),activityTimeline)
			}
		}
		data.data.Page.activities.forEach(function(activity){
			let diffTime = activity.createdAt - previousTime;
			if(previousTime && diffTime > 60*60*24*30*3){//three months
				create("div","hohTimelineGap","--- " + formatTime(diffTime) + " ---",activityTimeline)
			}
			let activityEntry = create("div","hohTimelineEntry",false,activityTimeline);
			if(activity.replyCount){
				activityEntry.style.color = "rgb(var(--color-blue))"
			}
			let activityContext = create("a","newTab",capitalize(activity.status),activityEntry);
			if(URLstuff[1] === "manga"){
				if(activity.status === "read chapter" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MreadChapter_known",activity.progress))
				}
				else if(activity.status === "reread"){
					activityContext.innerText = capitalize(translate("$listActivity_repeatedManga_known"))
				}
				else if(activity.status === "reread chapter" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MrepeatingManga_known",activity.progress))
				}
				else if(activity.status === "dropped" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MdroppedManga_known",activity.progress))
				}
				else if(activity.status === "dropped"){
					activityContext.innerText = capitalize(translate("$listActivity_droppedManga_known",activity.progress))
				}
				else if(activity.status === "completed"){
					activityContext.innerText = capitalize(translate("$listActivity_completedManga_known"))
				}
				else if(activity.status === "plans to read"){
					activityContext.innerText = capitalize(translate("$listActivity_planningManga_known"))
				}
				else if(activity.status === "paused reading"){
					activityContext.innerText = capitalize(translate("$listActivity_pausedManga_known"))
				}
				else{
					console.warn("Missing listActivity translation key for:",activity.status)
				}
			}
			else{
				if(activity.status === "watched episode" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MwatchedEpisode_known",activity.progress))
				}
				else if(activity.status === "rewatched"){
					activityContext.innerText = capitalize(translate("$listActivity_repeatedAnime_known"))
				}
				else if(activity.status === "rewatched episode" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MrepeatingAnime_known",activity.progress))
				}
				else if(activity.status === "dropped" && activity.progress){
					activityContext.innerText = capitalize(translate("$listActivity_MdroppedAnime_known",activity.progress))
				}
				else if(activity.status === "dropped"){
					activityContext.innerText = capitalize(translate("$listActivity_droppedAnime_known",activity.progress))
				}
				else if(activity.status === "completed"){
					activityContext.innerText = capitalize(translate("$listActivity_completedAnime_known"))
				}
				else if(activity.status === "plans to watch"){
					activityContext.innerText = capitalize(translate("$listActivity_planningAnime_known"))
				}
				else if(activity.status === "paused watching"){
					activityContext.innerText = capitalize(translate("$listActivity_pausedAnime_known"))
				}
				else{
					console.warn("Missing listActivity translation key for:",activity.status)
				}
			}
			activityContext.href = activity.siteUrl;
			const options = {weekday: "short", year: "numeric", month: "short", day: "numeric"};
			let locale = languageFiles[useScripts.partialLocalisationLanguage].info.locale || "en-UK";
			let datestring = (new Date(activity.createdAt*1000)).toLocaleDateString(locale,options)
			create("span",false,
				" " + datestring,
				activityEntry,
				"position:absolute;right:7px;"
			).title = (new Date(activity.createdAt*1000)).toLocaleString();
			previousTime = activity.createdAt;
		});
		if(data.data.Page.pageInfo.currentPage < data.data.Page.pageInfo.lastPage && data.data.Page.pageInfo.currentPage < 10){//yet another workaround fro broken API
			variables.page++;
			lineCaller(query,variables)
		}
		return
	};
	if(status !== "Add To List"){
		lineCaller(query,variables)
	}
	let lookingElse = create("div",false,false,followingLocation.parentNode,"margin-top:30px;");
	create("div",false,translate("$timeline_search_description"),lookingElse);
	let lookingElseInput = create("input",false,false,lookingElse);
	lookingElseInput.placeholder = translate("$input_user_placeholder");
	lookingElseInput.setAttribute("list","socialUsers");
	let lookingElseButton = create("button",["button","hohButton"],translate("$button_search"),lookingElse);
	let lookingElseError = create("span",false,"",lookingElse);
	lookingElseButton.onclick = async function(){
		if(lookingElseInput.value){
			lookingElseError.innerText = "...";
			const {data, errors} = await anilistAPI("query($name:String){User(name:$name){id}}", {
				variables: {name: lookingElseInput.value.trim()},
				cacheKey: "hohIDlookup" + lookingElseInput.value.toLowerCase(),
				duration: 5*60*1000
			});
			if(errors){
				lookingElseError.innerText = translate("$error_userNotFound");
				return
			}
			lookingElseError.innerText = "";
			variables.userId = data.User.id;
			variables.page = 1;
			lineCaller(query,variables)
		}
		return
	}
	return
}
//end modules/addActivityTimeline.js
//begin modules/addBrowseFilters.js
function addBrowseFilters(type){
	if(! /^\/search/.test(location.pathname)){
		return
	}
	let sorts = document.querySelector(".hohAlready");
	if(!sorts){
		sorts = document.querySelector(".sort-wrap.sort-select");
		if(!sorts){
			setTimeout(function(){addBrowseFilters(type)},200);
			return
		}
		sorts.classList.add("hohAlready")
	}

	let applySorts = function(){
		if(! /^\/search/.test(location.pathname)){
			return
		}
		let dropdown = sorts.querySelector(".dropdown");
		if(!dropdown){
			setTimeout(applySorts,200);
			return
		}
		let alreadyAdded = document.querySelectorAll(".hohSorts");
		alreadyAdded.forEach(aready => aready.remove());
		let URLredirect = function(property,value){
			let url = new URLSearchParams(location.search);
			url.set(property,value);
			if(location.pathname.match(/\/top-manhwa$/)){
				url.set("country of origin","KR")
			}
			window.location.href = location.protocol
			+ "//"
			+ location.host
			+ location.pathname.replace(
				/\/(popular|top-100|next-season|this-season|trending|top-manhwa)$/,
				""
			)
			+ "?" + url.toString()
		};
		if(type === "anime"){
			let episodeSort = create("div",["option","hohSorts"],"Episodes ↓",dropdown);
			let episodeSortb = create("div",["option","hohSorts"],"Episodes ↑",dropdown);
			episodeSort.onclick = function(){
				URLredirect("sort","EPISODES_DESC")
			};
			episodeSortb.onclick = function(){
				URLredirect("sort","EPISODES")
			}
		}
		else if(type === "manga"){
			let chapterSort = create("div",["option","hohSorts"],"Chapters ↓",dropdown);
			let chapterSortb = create("div",["option","hohSorts"],"Chapters ↑",dropdown);
			let volumeSort = create("div",["option","hohSorts"],"Volumes ↓",dropdown);
			let volumeSortb = create("div",["option","hohSorts"],"Volumes ↑",dropdown);
			chapterSort.onclick = function(){
				URLredirect("sort","CHAPTERS_DESC")
			};
			chapterSortb.onclick = function(){
				URLredirect("sort","CHAPTERS")
			};
			volumeSort.onclick = function(){
				URLredirect("sort","VOLUMES_DESC")
			};
			volumeSortb.onclick = function(){
				URLredirect("sort","VOLUMES")
			}
		}
	}
	sorts.onclick = applySorts();
}
//end modules/addBrowseFilters.js
//begin modules/addComparisionPage.js
//TODO: many of the separate arrays here should really be a single array of objects instead
function addComparisionPage(){
	let URLstuff = document.URL.match(/^https:\/\/anilist\.co\/user\/(.*)\/(anime|manga)list\/compare/);
	if(!URLstuff){
		return
	}
	let userA = decodeURIComponent(URLstuff[1]);
	let type = URLstuff[2];
	let compareLocation = document.querySelector(".compare");
	let nativeCompareExists = true;
	if(!compareLocation){
		nativeCompareExists = false;
		compareLocation = document.querySelector(".medialist");
		if(!compareLocation){
			setTimeout(addComparisionPage,200);
			return
		}
	}
	if(document.querySelector(".hohCompare")){
		return
	}
	compareLocation.style.display = "none";
	let compareArea = create("div","hohCompare",false,compareLocation.parentNode);
	if(nativeCompareExists){
		let isDefaultCompare = false;
		let switchButton = create("span","hohCompareUIfragment",translate("$compare_default"),compareLocation.parentNode,"position:absolute;top:0px;right:0px;cursor:pointer;z-index:100;");
		switchButton.onclick = function(){
			isDefaultCompare = !isDefaultCompare;
			if(isDefaultCompare){
				switchButton.innerText = translate("$compare_hoh");
				compareLocation.style.display = "";
				compareArea.style.display = "none";
				switchButton.style.top = "-30px"
			}
			else{
				switchButton.innerText = translate("$compare_default");
				compareLocation.style.display = "none";
				compareArea.style.display = "";
				switchButton.style.top = "0px"
			}
		};
		compareLocation.parentNode.style.position = "relative"
	}
	let formatFilterLabel = create("span",false,"Filter:",compareArea);
	formatFilterLabel.style.padding = "5px";
	let formatFilter = create("select","hohNativeInput",false,compareArea);
	let addOption = function(value,text){
		let newOption = create("option",false,text,formatFilter);
		newOption.value = value
	};
	addOption("all","All");
	if(type === "anime"){
		addOption("TV","TV");
		addOption("MOVIE","Movie");
		addOption("TV_SHORT","TV Short");
		addOption("OVA","OVA");
		addOption("ONA","ONA");
		addOption("SPECIAL","Special");
		addOption("MUSIC","Music");
	}
	else if(type === "manga"){
		addOption("MANGA","Manga");
		addOption("NOVEL","Novel");
		addOption("ONE_SHOT","One Shot");
	}
	let ratingFilterLabel = create("span",false,translate("$compare_minRatings"),compareArea);
	ratingFilterLabel.style.padding = "5px";
	let ratingFilter = create("input","hohNativeInput",false,compareArea,"width:45px;color:rgb(var(--color-text))");
	ratingFilter.type = "number";
	ratingFilter.value = 1;
	ratingFilter.min = 0;
	let systemFilterLabel = create("span",false,translate("$compare_individualRatings"),compareArea,"padding:5px;");
	let systemFilter = createCheckbox(compareArea);
	systemFilter.checked = useScripts.comparisionSystemFilter;
	let normalFilterLabel = create("span",false,translate("$compare_normalizeRatings"),compareArea,"padding:5px;");
	let normalFilter = createCheckbox(compareArea);
	normalFilter.checked = false;
	let colourLabel = create("span",false,translate("$compare_colourCell"),compareArea,"padding:5px;");
	let colourFilter = createCheckbox(compareArea);
	colourFilter.checked = useScripts.comparisionColourFilter;		
	let tableContainer = create("table",false,false,compareArea);
	let table = create("tbody",false,false,tableContainer);
	let digestSelect = {value:"average"};//placeholder
	let shows = [];//the stuff we are displaying in the table
	let users = [];
	let listCache = {};//storing raw anime data
	let ratingMode = "average";let guser = 0;let inverse = false;
	let csvButton = create("button",["csvExport","button","hohButton","hohCompareUIfragment"],"CSV data",compareLocation.parentNode,"margin-top:10px;");
	let jsonButton = create("button",["jsonExport","button","hohButton","hohCompareUIfragment"],"JSON data",compareLocation.parentNode,"margin-top:10px;");
	csvButton.onclick = function(){
		let csvContent = "Title," + digestSelect.selectedOptions[0].text + "," + users.map(user => user.name).join(",") + "\n";
		shows.forEach(function(show){
			let display = users.every(function(user,index){
				if(user.demand === 1 && show.score[index] === 0){
					return false
				}
				else if(user.demand === -1 && show.score[index] !== 0){
					return false
				}
				return (!user.status || show.status[index] === user.status);
			});
			if(formatFilter.value !== "all"){
				if(formatFilter.value !== show.format){
					display = false
				}
			}
			if(show.numberWatched < ratingFilter.value){
				display = false;
			}
			if(!display){
				return
			}
			csvContent += csvEscape(show.title) + "," + show.digest + "," + show.score.join(",") + "\n"
		});
		let filename = capitalize(type) + " table";
		if(users.length === 1){
			filename += " for " + users[0].name
		}
		else if(users.length === 2){
			filename += " for " + users[0].name + " and " + users[1].name
		}
		else if(users.length > 2){
			filename += " for " + users[0].name + ", " + users[1].name + " and others"
		}
		filename += ".csv";
		saveAs(csvContent,filename,true)
	};
	jsonButton.onclick = function(){
		let jsonData = {
			users: users,
			formatFilter: formatFilter.value,
			digestValue: digestSelect.value,
			type: capitalize(type),
			version: "1.00",
			scriptInfo: scriptInfo,
			url: document.URL,
			timeStamp: NOW(),
			media: shows
		}
		let filename = capitalize(type) + " table";
		if(users.length === 1){
			filename += " for " + users[0].name
		}
		else if(users.length === 2){
			filename += " for " + users[0].name + " and " + users[1].name
		}
		else if(users.length > 2){
			filename += " for " + users[0].name + ", " + users[1].name + " and others"
		}
		filename += ".json";
		saveAs(jsonData,filename)
	}
	let sortShows = function(){
		let averageCalc = function(scoreArray,weight){//can maybe be delegated to the stats object? look into later
			let sum = 0;
			let dividents = 0;
			scoreArray.forEach(function(score){
				if(score !== null){
					sum += score;
					dividents++
				}
			});
			return {
				average: ((dividents + (weight || 0)) ? (sum/(dividents + (weight || 0))) : null),
				dividents: dividents
			}
		};
		let scoreField = (normalFilter.checked ? "scoreNormal" : "score");
		let sortingModes = {
			"average": function(show){
				show.digest = averageCalc(show[scoreField]).average
			},
			"average0": function(show){
				show.digest = averageCalc(show[scoreField],1).average
			},
			"standardDeviation": function(show){
				let average = averageCalc(show[scoreField]);
				let variance = 0;
				show.digest = null;
				if(average.dividents > 1){
					show[scoreField].forEach(score => {
						if(score !== null){
							variance += Math.pow(score - average.average,2)
						}
					});
					variance = variance/average.dividents;
					show.digest = Math.sqrt(variance)
				}
			},
			"absoluteDeviation": function(show){
				let average = averageCalc(show[scoreField]);
				let variance = 0;
				show.digest = null;
				if(average.dividents > 1){
					show[scoreField].forEach(score => {
						if(score !== null){
							variance += Math.abs(score - average.average)
						}
					});
					variance = variance/average.dividents;
					show.digest = variance
				}
			},
			"max": function(show){
				let newScores = show[scoreField].filter(score => score !== null);
				if(newScores.length){
					show.digest = Math.max(...newScores)
				}
				else{
					show.digest = null
				}
			},
			"min": function(show){
				let newScores = show[scoreField].filter(score => score !== null);
				if(newScores.length){
					show.digest = Math.min(...newScores)
				}
				else{
					show.digest = null
				}
			},
			"difference": function(show){
				if(show[scoreField].filter(score => score !== null).length){
					let mini = Math.min(...show[scoreField].filter(score => score !== null)) || 0;
					let maks = Math.max(...show[scoreField].filter(score => score !== null));
					show.digest = maks - mini
				}
				else{
					show.digest = null
				}
			},
			"ratings": function(show){
				show.digest = show[scoreField].filter(score => score !== null).length || null
			},
			"planned": function(show){
				show.digest = show.status.filter(value => value === "PLANNING").length || null
			},
			"current": function(show){
				show.digest = show.status.filter(value => (value === "CURRENT" || value === "REPEATING")).length || null
			},
			"favourites": function(show){
				show.digest = show.favourite.filter(TRUTHY).length || null
			},
			"median": function(show){
				let newScores = show[scoreField].filter(score => score !== null);
				if(newScores.length === 0){
					show.digest = null
				}
				else{
					show.digest = Stats.median(newScores)
				}
			},
			"popularity": function(show){
				show.digest = show.popularity
			},
			"averageScore": function(show){
				show.digest = show.averageScore
			},
			"averageScoreDiff": function(show){
				if(!show.averageScore){
					show.digest = 0;
					return
				}
				show.digest = averageCalc(show[scoreField]).average - show.averageScore
			}
		};
		if(ratingMode === "user"){
			shows.sort(
				(a,b) => b.score[guser] - a.score[guser]
			)
		}
		else if(ratingMode === "userInverse"){
			shows.sort(
				(b,a) => b.score[guser] - a.score[guser]
			)
		}
		else if(ratingMode === "title"){
			shows.sort(ALPHABETICAL(a => a.title))
		}
		else if(ratingMode === "titleInverse"){
			shows = shows.sort(ALPHABETICAL(a => a.title)).reverse()
		}
		else{
			shows.forEach(sortingModes[ratingMode]);
			if(inverse){
				shows.sort((b,a) => b.digest - a.digest)
			}
			else{
				shows.sort((a,b) => b.digest - a.digest)
			}
		}
	};
	let drawTable = function(){
		while(table.childElementCount > 2){
			table.lastChild.remove()
		}
		let columnAmounts = [];
		users.forEach(function(element){
			columnAmounts.push({sum:0,amount:0})
		})
		shows.forEach(function(show){
			let display = users.every(function(user,index){
				if(user.demand === 1 && show.score[index] === 0){
					return false
				}
				else if(user.demand === -1 && show.score[index] !== 0){
					return false
				}
				return (!user.status || show.status[index] === user.status);
			});
			if(formatFilter.value !== "all"){
				if(formatFilter.value !== show.format){
					display = false
				}
			}
			if(show.numberWatched < ratingFilter.value){
				display = false
			}
			if(!display){
				return
			}
			let row = create("tr","hohAnimeTable");
			row.onclick = function(){
				if(this.style.background === "rgb(var(--color-blue),0.5)"){
					this.style.background = "unset"
				}
				else{
					this.style.background = "rgb(var(--color-blue),0.5)"
				}
			}
			let showID = create("td",false,false,false,"max-width:250px;");
			create("a","newTab",show.title,showID)
				.href = "/" + type + "/" + show.id + "/" + safeURL(show.title);
			let showAverage = create("td");
			if(show.digest !== null){
				let fractional = show.digest % 1;
				showAverage.innerText = show.digest.roundPlaces(3);
				[
					{s:"½",v:1/2},
					{s:"⅓",v:1/3},
					{s:"¼",v:1/4},
					{s:"¾",v:3/4},
					{s:"⅔",v:2/3},
					{s:"⅙",v:1/6},
					{s:"⅚",v:5/6},
					{s:"⅐",v:1/7}
				].find(symbol => {
					if(Math.abs(fractional - symbol.v) < 0.0001){
						showAverage.innerText = Math.floor(show.digest) + " " + symbol.s;
						return true
					}
					return false
				})
			}
			row.appendChild(showID);
			row.appendChild(showAverage);
			for(var i=0;i<show.score.length;i++){
				let showUserScore = create("td",false,false,row);
				if(show.score[i]){
					if(systemFilter.checked){
						showUserScore.appendChild(scoreFormatter(
							show.scorePersonal[i],
							users[i].system
						))
					}
					else if(normalFilter.checked){
						showUserScore.innerText = show.scoreNormal[i].roundPlaces(3)
					}
					else{
						showUserScore.innerText = show.score[i]
					}
					columnAmounts[i].sum += show.score[i];
					columnAmounts[i].amount++
				}
				else{
					if(show.status[i] === "NOT"){
						showUserScore.innerText = " "
					}
					else{
						showUserScore.innerText = "–"//n-dash
					}
				}
				if(show.status[i] !== "NOT"){
					if(colourFilter.checked){
						showUserScore.style.backgroundImage = "linear-gradient(to right,rgb(0,0,0,0)," + distributionColours[show.status[i]] + ")";
					}
					else{
						let statusDot = create("div","hohStatusDot",false,showUserScore);
						statusDot.style.background = distributionColours[show.status[i]];
						statusDot.title = show.status[i].toLowerCase();
					}
				}
				if(show.progress[i]){
					create("span","hohStatusProgress",show.progress[i],showUserScore)
				}
				if(show.favourite[i]){
					let favStar = create("span",false,false,showUserScore,"color:gold;font-size:1rem;vertical-align:middle;padding-bottom:2px;");
					favStar.appendChild(svgAssets2.star.cloneNode(true))
				}
			}
			table.appendChild(row);
		});
		if(columnAmounts.some(amount => amount.amount > 0)){
			let lastRow = create("tr",false,false,table);
			create("td",false,"Average",lastRow,"border-left-width: 1px;padding-left: 15px;font-weight: bold;");
			create("td",false,false,lastRow);
			columnAmounts.forEach(amount => {
				let averageCel = create("td",false,"–",lastRow);
				if(amount.amount){
					averageCel.innerText = (amount.sum/amount.amount).roundPlaces(2)
				}
			})
		}
	};
	let changeUserURL = function(){
		const baseState = location.protocol + "//" + location.host + location.pathname;
		let params = "";
		if(users.length){
			params += "&users=" + users.map(user => user.name + (user.demand ? (user.demand === -1 ? "-" : "*") : "")).join(",")
		}
		if(formatFilter.value !== "all"){
			params += "&filter=" + encodeURIComponent(formatFilter.value)
		}
		if(ratingFilter.value !== 1){
			params += "&minRatings=" + encodeURIComponent(ratingFilter.value)
		}
		if(systemFilter.checked){
			params += "&ratingSystems=true"
		}
		if(normalFilter.checked){
			params += "&normalizeRatings=true"
		}
		if(colourFilter.checked){
			params += "&fullColour=true"
		}
		if(ratingMode !== "average"){
			params += "&sort=" + ratingMode
		}
		if(params.length){
			params = "?" + params.substring(1)
		}
		current = baseState + params;
		history.replaceState({},"",baseState + params)
	};
	let drawUsers = function(){
		removeChildren(table)
		let userRow = create("tr");
		let resetCel = create("td",false,false,userRow);
		let resetButton = create("button",["hohButton","button"],translate("$button_add"),resetCel,"margin-top:0px;");
		resetButton.onclick = function(){
			users = [];
			shows = [];
			drawUsers();
			changeUserURL()
		};
		let digestCel = create("td");
		digestSelect = create("select");
		let addOption = (value,text,title) => {
			let option = create("option",false,text,digestSelect);
			option.value = value;
			if(title){
				option.title = title
			}
		};
		addOption("average","Average");
		addOption("median","Median");
		addOption("average0","Average~0","Zero-weighted average. Good for sorting by 'best'");
		addOption("min","Minimum");
		addOption("max","Maximum");
		addOption("difference","Difference","Highest rating minus lowest rating");
		addOption("standardDeviation","Std. Deviation");
		addOption("absoluteDeviation","Abs. Deviation");
		addOption("ratings","#Ratings","Sort by number of users in table who have given a rating");
		addOption("planned","#Planning","Sort by number of users in table who have this as planning");
		addOption("current","#Current","Sort by number of users in table who have this as current");
		addOption("favourites","#Favourites","Sort by number of users in table who have this as a favourite");
		addOption("popularity","$Popularity","Sort by site-wide popularity");
		addOption("averageScore","$Score","Sort by site-wide score");
		addOption("averageScoreDiff","$Score diff.","Sort by difference between site-wide score and average score of the users in the table");
		if(["title","titleInverse","user","userInverse"].includes(ratingMode)){
			digestSelect.value = ratingMode;
		}
		digestSelect.oninput = function(){
			ratingMode = digestSelect.value;
			sortShows();
			drawTable();
			changeUserURL()
		};
		digestCel.appendChild(digestSelect);
		userRow.appendChild(digestCel);
		users.forEach(function(user,index){
			let userCel = create("td",false,false,userRow);
			let avatar = create("img",false,false,userCel);
			avatar.src = listCache[user.name].data.MediaListCollection.user.avatar.medium;
			let name = create("span",false,user.name,userCel);
			name.style.padding = "8px";
			let remove = create("span","hohAnimeTableRemove","✕",userCel);
			remove.onclick = function(){
				deleteUser(index)
			}
		});
		let addCel = create("td");
		let addInput = create("input","hohNativeInput",false,addCel);
		let addButton = create("button",["button","hohButton"],translate("$button_add"),addCel,"margin-top:0px;");
		addButton.style.cursor = "pointer";
		addButton.onclick = function(){
			if(addInput.value !== ""){
				addUser(addInput.value);
				addButton.innerText = "...";
				addButton.disabled = true;
				addInput.readOnly = true
			}
		};
		userRow.appendChild(addCel);
		let headerRow = create("tr");
		let typeCel = create("th");
		let downArrowa = create("span","hohArrowSort","▼",typeCel);
		downArrowa.onclick = function(){
			ratingMode = "title";
			sortShows();
			drawTable()
		};
		let typeCelLabel = create("span",false,capitalize(type),typeCel);
		let upArrowa = create("span","hohArrowSort","▲",typeCel);
		upArrowa.onclick = function(){
			ratingMode = "titleInverse";
			sortShows();
			drawTable()
		};
		headerRow.appendChild(typeCel);
		let digestSortCel = create("td");
		digestSortCel.style.textAlign = "center";
		let downArrow = create("span","hohArrowSort","▼",digestSortCel);
		downArrow.onclick = function(){
			ratingMode = digestSelect.value;
			inverse = false;
			sortShows(digestSelect.value);
			drawTable()
		};
		let upArrow = create("span","hohArrowSort","▲",digestSortCel);
		upArrow.onclick = function(){
			ratingMode = digestSelect.value;
			inverse = true;
			sortShows();
			drawTable()
		};
		headerRow.appendChild(digestSortCel);
		users.forEach(function(user,index){
			let userCel = create("td");
			userCel.style.textAlign = "center";
			userCel.style.position = "relative";
			let filter = create("span");
			if(user.demand === 0){
				filter.innerText = "☵"
			}
			else if(user.demand === 1){
				filter.innerText = "✓";
				filter.style.color = "green"
			}
			else{
				filter.innerText = "✕";
				filter.style.color = "red"
			}
			filter.classList.add("hohFilterSort");
			filter.onclick = function(){
				if(filter.innerText === "☵"){
					filter.innerText = "✓";
					filter.style.color = "green";
					user.demand = 1
				}
				else if(filter.innerText === "✓"){
					filter.innerText = "✕";
					filter.style.color = "red";
					user.demand = -1
				}
				else{
					filter.innerText = "☵";
					filter.style.color = "";
					user.demand = 0
				}
				drawTable();
				changeUserURL()
			};
			let downArrow = create("span","hohArrowSort","▼");
			downArrow.onclick = function(){
				ratingMode = "user";
				guser = index;
				sortShows();
				drawTable()
			};
			let upArrow = create("span","hohArrowSort","▲");
			upArrow.onclick = function(){
				ratingMode = "userInverse";
				guser = index;
				sortShows();
				drawTable()
			};
			let statusFilterDot = create("div","hohStatusDot");
			if(user.status === false){
				statusFilterDot.title = translate("$compare_listStatus")
			}
			const stati = ["COMPLETED","CURRENT","PLANNING","PAUSED","DROPPED","REPEATING","NOT"];
			statusFilterDot.onclick = function(){
				if(user.status === "NOT"){
					user.status = false;
					statusFilterDot.style.background = "rgb(var(--color-background))";
					statusFilterDot.title = translate("$compare_listStatus")
				}
				else if(user.status === "REPEATING"){
					user.status = "NOT";
					statusFilterDot.style.background = `center / contain no-repeat url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="96" height="96" viewBox="0 0 10 10"><line stroke="red" x1="0" y1="0" x2="10" y2="10"/><line x1="0" y1="10" x2="10" y2="0" stroke="red"/></svg>')`;
					statusFilterDot.title = "no status";
				}
				else if(user.status === false){
					user.status = "COMPLETED";
					statusFilterDot.style.background = distributionColours["COMPLETED"];
					statusFilterDot.title = "completed"
				}
				else{
					user.status = stati[stati.indexOf(user.status) + 1];
					statusFilterDot.style.background = distributionColours[user.status];
					statusFilterDot.title = user.status.toLowerCase()
				}
				drawTable()
			};
			userCel.appendChild(downArrow);
			userCel.appendChild(filter);
			userCel.appendChild(upArrow);
			userCel.appendChild(statusFilterDot);
			headerRow.appendChild(userCel);
		});
		userRow.classList.add("hohUserRow");
		headerRow.classList.add("hohHeaderRow");
		table.appendChild(userRow);
		table.appendChild(headerRow)
	};
	let addUser = async function(userName,paramDemand){
		let handleData = function(data,cached){
			users.push({
				name: userName,
				demand: (paramDemand ? (paramDemand === "-" ? -1 : 1) : 0),
				system: data.data.MediaListCollection.user.mediaListOptions.scoreFormat,
				status: false
			});
			let list = returnList(data,true);
			if(!cached){
				let averageSum = 0;
				let averageCount = 0;
				list.forEach(alia => {
					alia.media.id = alia.mediaId;
					alia.media.title = titlePicker(alia.media);
					alia.scoreRaw = convertScore(alia.score,data.data.MediaListCollection.user.mediaListOptions.scoreFormat);
					if(alia.scoreRaw){
						averageSum += alia.scoreRaw;
						averageCount++
					}
				});
				averageSum = averageSum/averageCount;
				let varianceSum = 0;
				list.forEach(alia => {
					if(alia.scoreRaw){
						varianceSum += Math.pow(alia.scoreRaw - averageSum,2)
					}
				})
				let std = Math.sqrt(varianceSum/averageCount);
				list.forEach(alia => {
					if(alia.scoreRaw){
						alia.scoreNormal = (alia.scoreRaw - averageSum)/std
					}
					else{
						alia.scoreNormal = null
					}
				})
			}
			shows.sort(function(a,b){return a.id - b.id});
			let listPointer = 0;
			let userIndeks = 0;
			if(shows.length){
				userIndeks = shows[0].score.length
			}
			let favs = data.data.MediaListCollection.user.favourites.fav.nodes.concat(
				data.data.MediaListCollection.user.favourites.fav2.nodes
			).concat(
				data.data.MediaListCollection.user.favourites.fav3.nodes
			).map(media => media.id);
			let createEntry = function(mediaEntry){
				let entry = {
					id: mediaEntry.mediaId,
					average: mediaEntry.scoreRaw,
					title: mediaEntry.media.title,
					format: mediaEntry.media.format,
					score: Array(userIndeks).fill(null),
					scorePersonal: Array(userIndeks).fill(null),
					scoreNormal: Array(userIndeks).fill(null),
					status: Array(userIndeks).fill("NOT"),
					progress: Array(userIndeks).fill(false),
					numberWatched: mediaEntry.scoreRaw ? 1 : 0,
					favourite: Array(userIndeks).fill(false),
					averageScore: mediaEntry.media.averageScore,
					popularity: mediaEntry.media.popularity
				};
				entry.score.push(mediaEntry.scoreRaw || null);
				entry.scorePersonal.push(mediaEntry.score || null);
				entry.scoreNormal.push(mediaEntry.scoreNormal);
				entry.status.push(mediaEntry.status);
				if(mediaEntry.status !== "PLANNING" && mediaEntry.status !== "COMPLETED"){
					entry.progress.push(mediaEntry.progress + "/" + (mediaEntry.media.chapters || mediaEntry.media.episodes || ""))
				}
				else{
					entry.progress.push(false)
				}
				entry.favourite.push(favs.includes(entry.id));
				return entry
			};
			shows.forEach(show => {
				show.score.push(null);
				show.scorePersonal.push(null);
				show.scoreNormal.push(null);
				show.status.push("NOT");
				show.progress.push(false);
				show.favourite.push(false)
			});
			for(var i=0;i<shows.length && listPointer < list.length;i++){
				if(shows[i].id < list[listPointer].mediaId){
					continue
				}
				else if(shows[i].id === list[listPointer].mediaId){
					shows[i].score[userIndeks] = list[listPointer].scoreRaw || null;
					shows[i].scorePersonal[userIndeks] = list[listPointer].score || null;
					shows[i].scoreNormal[userIndeks] = list[listPointer].scoreNormal;
					shows[i].status[userIndeks] = list[listPointer].status;
					if(list[listPointer].scoreRaw){
						shows[i].numberWatched++
					}
					if(list[listPointer].status !== "PLANNING" && list[listPointer].status !== "COMPLETED"){
						shows[i].progress[userIndeks] =
							list[listPointer].progress
							+ "/"
							+ (
								list[listPointer].media.chapters
								|| list[listPointer].media.episodes
								|| ""
							)
					}
					else{
						shows[i].progress[userIndeks] = false
					}
					shows[i].favourite[userIndeks] = favs.includes(shows[i].id);
					listPointer++
				}
				else{
					shows.splice(i,0,createEntry(list[listPointer]));
					listPointer++
				}
			}
			for(;listPointer < list.length;listPointer++){
				shows.push(createEntry(list[listPointer]))
			}
			sortShows();
			drawUsers();
			drawTable();
			changeUserURL()
		};
		if(hasOwn(listCache, userName)){
			handleData(listCache[userName],true)
		}
		else{
			const listQuery = `
query($name: String, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			entries{
			... mediaListEntry
			}
		}
		user{
			id
			name
			avatar{medium}
			mediaListOptions{scoreFormat}
			favourites{
				fav:${type.toLowerCase()}(page:1){
					nodes{
						id
					}
				}
				fav2:${type.toLowerCase()}(page:2){
					nodes{
						id
					}
				}
				fav3:${type.toLowerCase()}(page:3){
					nodes{
						id
					}
				}
			}
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	score
	media{
		episodes
		chapters
		format
		title{romaji native english}
		averageScore
		popularity
	}
}`
			const data = await anilistAPI(listQuery, {
				variables: {name:userName,listType:type.toUpperCase()}
			})
			if(data.errors){
				return
			}
			listCache[userName] = data;
			handleData(data,false)
		}
		return
	};
	let deleteUser = function(index){
		users.splice(index,1);
		shows.forEach(function(show){
			show.score.splice(index,1);
			show.scorePersonal.splice(index,1);
			show.status.splice(index,1);
			show.progress.splice(index,1);
			show.favourite.splice(index,1)
		});
		shows = shows.filter(function(show){
			return !show.status.every(status => status === "NOT")
		});
		if(guser === index){
			guser = false
		}
		else if(guser > index){
			guser--
		}
		sortShows();
		drawUsers();
		drawTable();
		changeUserURL()
	};
	formatFilter.oninput = function(){drawTable();changeUserURL()};
	ratingFilter.oninput = function(){drawTable();changeUserURL()};
	systemFilter.onclick = function(){
		useScripts.comparisionSystemFilter = systemFilter.checked;
		useScripts.save();
		if(systemFilter.checked){
			normalFilter.checked = false;
			sortShows()
		}
		drawTable();changeUserURL()
	};
	normalFilter.onclick = function(){
		if(normalFilter.checked){
			systemFilter.checked = false;
			useScripts.comparisionSystemFilter = false;
			useScripts.save();
		}
		sortShows();drawTable();changeUserURL()
	}
	colourFilter.onclick = function(){
		useScripts.comparisionColourFilter = colourFilter.checked;
		useScripts.save();
		drawTable();changeUserURL()
	};
	let searchParams = new URLSearchParams(location.search);
	let paramFormat = searchParams.get("filter");
	if(paramFormat){
		formatFilter.value = paramFormat
	}
	let paramRating = searchParams.get("minRatings");
	if(paramRating){
		ratingFilter.value = paramRating
	}
	let paramSystem = searchParams.get("ratingSystems");
	if(paramSystem){
		systemFilter.checked = (paramSystem === "true")
	}
	let normalSystem = searchParams.get("normalizeRatings");
	if(normalSystem){
		normalFilter.checked = (normalSystem === "true")
	}
	let paramColour = searchParams.get("fullColour");
	if(paramColour){
		colourFilter.checked = (paramColour === "true")
	}
	let paramSort = searchParams.get("sort");
	if(paramSort){
		ratingMode = paramSort
	}
	let paramUsers = searchParams.get("users");
	if(paramUsers){
		paramUsers.split(",").forEach(user => {
			let paramDemand = user.match(/(\*|-)$/);
			if(paramDemand){
				paramDemand = paramDemand[0]
			}
			user = user.replace(/(\*|-)$/,"");
			if(user === "~"){
				addUser(whoAmI,paramDemand)
			}
			else{
				addUser(user,paramDemand)
			}
		})
	}
	else{
		addUser(whoAmI);
		addUser(userA)
	}
}
//end modules/addComparisionPage.js
//begin modules/addCompletedScores.js
function addCompletedScores(){
	//also for dropped, if in the settings
	if(! /^\/(home|user|activity)\/?([\w-]+)?\/?$/.test(location.pathname)){
		return
	}
	setTimeout(addCompletedScores,1000);
	let bigQuery = [];
	let statusCollection = document.querySelectorAll(".status");
	statusCollection.forEach(function(status){
		if(
			(useScripts.completedScore
				&& (
					/^completed/i.test(status.innerText)
					|| status.childNodes[0].textContent.trim() === "Rewatched"
					|| status.childNodes[0].textContent.trim() === "Reread"
					|| status.classList.contains("activityCompleted")
					|| status.classList.contains("activityRewatched")
					|| status.classList.contains("activityReread")
				)
			)
			|| (useScripts.droppedScore && (/^dropped/i.test(status.innerText) || status.classList.contains("activityDropped")))
			|| /^\/activity/.test(location.pathname)
		){
			if(!hasOwn(status, "hohScoreMatched")){
				status.hohScoreMatched = true;
				let scoreInfo = create("span","hohFeedScore",false,status);
				const mediaId = /\/(\d+)\//.exec(status.children[0].href);
				if(!mediaId || !mediaId.length){
					return
				}
				scoreInfo.style.display = "none";
				let callback = function(data){
					if(!data){
						return
					}
					data = data.data.MediaList;
					let scoreSuffix = scoreFormatter(
						data.score,
						data.user.mediaListOptions.scoreFormat
					);
					let noteContent = parseListJSON(data.notes);
					let noteSuffix = "";
					if(noteContent){
						if(hasOwn(noteContent, "message")){
							noteSuffix += " " + noteContent.message
						}
					}
					let rewatchSuffix = "";
					if(data.repeat > 0){
						if(data.media.type === "ANIME"){
							if(data.repeat === 1){
								rewatchSuffix = " " + translate("$rewatch_suffix_1")
							}
							else{
								rewatchSuffix = " " + translate("$rewatch_suffix_M",data.repeat)
							}
						}
						else{
							if(data.repeat === 1){
								rewatchSuffix = " " + translate("$reread_suffix_1")
							}
							else{
								rewatchSuffix = " " + translate("$reread_suffix_M",data.repeat)
							}
						}
					}
					if(data.score){
						//depends on the parameters score and scoreFormat, which are defined as a float and an enum in the Anilist API docs
						if(
							/^completed/i.test(status.innerText)
							|| status.classList.contains("activityCompleted")
							|| status.classList.contains("activityRewatched")
							|| status.classList.contains("activityReread")
						){
							scoreInfo.appendChild(scoreSuffix);
							create("span","hohNoteSuffix",noteSuffix,scoreInfo);
							create("span","hohRewatchSuffix",rewatchSuffix,scoreInfo)
						}
						else{
							scoreInfo.appendChild(scoreSuffix);
							create("span","hohNoteSuffix",noteSuffix,scoreInfo)
						}
						scoreInfo.style.display = "inline"
					}
				};
				const variables = {
					userName: status.parentNode.children[0].innerText.trim(),
					mediaId: +mediaId[1]
				};
				const query = `
query($userName: String,$mediaId: Int){
	MediaList(
		userName: $userName,
		mediaId: $mediaId
	){
		score
		mediaId
		notes
		repeat
		media{type}
		user{
			name
			mediaListOptions{scoreFormat}
		}
	}
}`;
				//generalAPIcall(query,variables,callback,"hohCompletedScores" + variables.mediaId + variables.userName,60*1000)
				bigQuery.push({
					query: query,
					variables: variables,
					callback: callback,
					cacheKey: "hohCompletedScores" + variables.mediaId + variables.userName,
					duration: 60*1000
				})
			}
		}
		else if(status.children.length === 2 && !status.classList.contains("form")){
			status.children[1].remove()
		}
	});
	queryPacker(bigQuery)
}
//end modules/addCompletedScores.js
//begin modules/addCustomCSS.js
function addCustomCSS(){
	if(useScripts.SFWmode || script_type === "Boneless"){
		return
	}
	let URLstuff = location.pathname.match(/^\/user\/([^/]*)\/?/);
	if(!customStyle.textContent || (decodeURIComponent(URLstuff[1]) !== currentUserCSS)){
		const query = `
		query($userName: String) {
			User(name: $userName){
				about
			}
		}`;
		let variables = {
			userName: decodeURIComponent(URLstuff[1])
		}
		let css_handler = function(data){
			customStyle.textContent = "";
			let external = document.getElementById("customExternalCSS");
			if(external){
				external.remove()
			}
			if(!data){
				return
			}
			if(!(/anilist\.co\/user\//.test(document.URL))){
				return
			}
			let jsonMatch = (data.data.User.about || "").match(/^\[\]\(json([A-Za-z0-9+/=]+)\)/);
			if(!jsonMatch){
				return
			}
			try{
				let jsonData;
				try{
					jsonData = JSON.parse(atob(jsonMatch[1]))
				}
				catch(e){
					jsonData = JSON.parse(LZString.decompressFromBase64(jsonMatch[1]))
				}
				if(jsonData.customCSS){
					if(jsonData.customCSS.match(/^https.*\.css$/)){
						let styleRef = document.createElement("link");
						styleRef.id = "customExternalCSS";
						styleRef.rel = "stylesheet";
						styleRef.type = "text/css";
						styleRef.href = jsonData.customCSS;
						document.getElementsByTagName("head")[0].appendChild(styleRef)
					}
					else{
						customStyle.textContent = jsonData.customCSS
					}
					currentUserCSS = decodeURIComponent(URLstuff[1])
				}
				if(jsonData.pinned){
					try{
						generalAPIcall(
`
query{
	Activity(id: ${jsonData.pinned}){
		... on ListActivity{
			type
			id
			user{id name avatar{medium}}
			replyCount
			likes{name}
			status
			progress
			media{
				type
				title{native romaji english}
				id
				coverImage{large}
			}
			createdAt
		}
		... on MessageActivity{
			type
			id
			text:message(asHtml: false)
			user:messenger{id name avatar{medium}}
			replyCount
			likes{name}
			createdAt
		}
		... on TextActivity{
			type
			id
			text(asHtml: false)
			user{id name avatar{medium}}
			replyCount
			likes{name}
			createdAt
		}
	}
}
`,
							{},
							function(data){
								if(!data){
									return
								}
								let adder = function(){
									let URLstuff2 = location.pathname.match(/^\/user\/([^/]*)\/?/);
									if(!URLstuff2 || decodeURIComponent(URLstuff2[1]) !== decodeURIComponent(URLstuff[1])){
										return
									}
									let feed = document.querySelector(".activity-feed-wrap");
									if(feed){
										let entry = create("div",["activity-entry","hohPinned"]);
										feed.insertBefore(entry,feed.children[0]);
										let act = data.data.Activity;
										if(act.type === "TEXT"){
											entry.classList.add("activity-text")
										}
										else if(act.type === "MESSAGE"){
											entry.classList.add("activity-message")
										}
										else if(act.type === "ANIME_LIST"){
											entry.classList.add("activity-anime_list")
										}
										else if(act.type === "MANGA_LIST"){
											entry.classList.add("activity-manga_list")
										}
let wrap = create("div","wrap",false,entry);
	let content = create("div",false,false,wrap);
		if(act.type === "TEXT" || act.type === "MESSAGE"){
			content.classList.add("text");
			let header = create("div","header",false,content);
				let avatar = create("a",["avatar","router-link-exact-active","router-link-active"],false,header);
				avatar.href = "/user/" + act.user.name + "/";
				avatar.style.backgroundImage = 'url("' + act.user.avatar.medium + '")';
				let avatarName = create("a",["name","router-link-exact-active","router-link-active"],act.user.name,header);
				avatarName.href = "/user/" + act.user.name + "/";
			let markdownWrapper = create("div","activity-markdown",false,content);
				let markdown = create("div","markdown",false,markdownWrapper);
				markdown.innerHTML = DOMPurify.sanitize(makeHtml(act.text))
		}
		else if(act.type === "ANIME_LIST" || act.type === "MANGA_LIST"){
			content.classList.add("list");
			let cover = create("a","cover",false,content);
			const linkURL = "/" + (act.type === "ANIME_LIST" ? "anime" : "manga") + "/" + act.media.id + "/" + safeURL(titlePicker(act.media)) + "/";
			cover.href = linkURL;
			cover.style.backgroundImage = 'url("' + act.media.coverImage.large + '")';
			let details = create("div","details",false,content);
				if(act.user.name !== decodeURIComponent(URLstuff[1])){
					let name = create("a",["name","router-link-exact-active","router-link-active"],act.user.name,details);
					name.href = "/user/" + act.user.name + "/"
				}
				let status = create("div","status",act.status + (act.progress ? " " + act.progress + " of " : " "),details);
				let title = create("a","title",titlePicker(act.media),status);
				title.href = linkURL
		}
	let time = create("div","time",false,wrap);
		let postLink = create("a","icon",false,time,"margin-right: 10px;");
			postLink.appendChild(svgAssets2.link.cloneNode(true));
			postLink.href = "/activity/" + act.id + "/";
			cheapReload(postLink,{name: "Activity", params: {id: act.id}});
		let pinnedLabel = create("div","pinned",false,time,"display: inline-block;padding-right: 5px;color: rgba(var(--color-blue),.9);");
			pinnedLabel.appendChild(svgAssets2.pinned.cloneNode(true));
			pinnedLabel.appendChild(document.createTextNode(" " + translate("$pinned")));
		time.appendChild(nativeTimeElement(act.createdAt));
	let actions = create("div","actions",false,wrap);
		let actionReplies = create("a",["action","replies"],false,actions);
			let replyCount = create("span",["count"],act.replyCount || "",actionReplies);
			replyCount.appendChild(document.createTextNode(" "));
			actionReplies.appendChild(svgAssets2.reply.cloneNode(true));
			actionReplies.href = "/activity/" + act.id + "/";
			cheapReload(actionReplies,{name: "Activity", params: {id: act.id}});
		actions.appendChild(document.createTextNode(" "));
		let actionLikes = create("div",["action","likes","hohHandledLike","hohLoadedLikes"],false,actions);
			actionLikes.title = act.likes.map(like => like.name).join("\n");
			let likeWrap = create("div",["like-wrap","activity"],false,actionLikes);
				let likeButton = create("div","button",false,likeWrap);
					let likeCount = create("span","count",act.likes.length || "",likeButton);
					likeButton.appendChild(document.createTextNode(" "));
					likeButton.appendChild(svgAssets2.likeNative.cloneNode(true));
					if(act.likes.findIndex(thing => thing.name === whoAmI) !== -1){
						likeButton.classList.add("liked")
					}
					if(useScripts.accessToken){
						likeButton.onclick = function(){
							let indexPlace = act.likes.findIndex(thing => thing.name === whoAmI);
							if(indexPlace === -1){
								act.likes.push({name: whoAmI});
								likeButton.classList.add("liked")
							}
							else{
								act.likes.splice(indexPlace,1);
								likeButton.classList.remove("liked")
							}
							likeCount.innerText = act.likes.length || "";
							authAPIcall(
								"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY){id}}",
								{id: act.id},
								function(data){
									if(!data){
										authAPIcall(//try again once if it fails
											"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY){id}}",
											{id: act.id},
											data => {}
										)
									}
								}
							);
							deleteCacheItem("hohPinned" + jsonData.pinned)
						}
					}
									}
									else{
										setTimeout(adder,500)
									}
								};
								adder()
							},"hohPinned" + jsonData.pinned,60*1000
						)
					}
					catch(e){
						console.warn("pinned activity error",jsonData.pinned,e)
					}
				}
				else{
					let carriedOver = document.querySelector(".hohPinned");
					if(carriedOver){
						carriedOver.remove()
					}
				}
			}
			catch(e){
				console.warn("Invalid profile JSON for " + variables.userName + ". Aborting.");
				console.log(e);
				console.log(atob(jsonMatch[1]));
			}
		};
		if(variables.userName === whoAmI){
			authAPIcall(query,variables,css_handler,"hohProfileBackground" + variables.userName,5*60*1000)
		}
		else{
			generalAPIcall(query,variables,css_handler,"hohProfileBackground" + variables.userName,5*60*1000)
		}
	}
}
//end modules/addCustomCSS.js
//begin modules/addDblclickZoom.js
exportModule({
	id: "dblclickZoom",
	description: "$dblclickZoom_description",
	extendedDescription: "$dblclickZoom_extendedDescription",
	isDefault: false,
	importance: -1,
	categories: ["Feeds"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return location.pathname.match(/^\/home\/?$/)
	},
	code: function(){
		function addDblclickZoom(){
			if(!location.pathname.match(/^\/home\/?$/)){
				return
			}
			let activityFeedWrap = document.querySelector(".activity-feed-wrap");
			if(!activityFeedWrap){
				setTimeout(addDblclickZoom,200);
				return
			}
			activityFeedWrap.addEventListener("dblclick",function(e){
				e = e || window.event;
				let target = e.target || e.srcElement;
				while(target.classList){
					if(target.classList.contains("activity-entry")){
						target.classList.toggle("hohZoom");
						break
					}
					target = target.parentNode
				}  
			},false)
		}
	},
	css: `
.hohZoom{
	transform: scale(1.5);
	transform-origin: 0 0;
	transition: transform 0.4s;
	z-index: 200;
	box-shadow: 5px 5px 5px black;
}
.hohZoom .reply-wrap{
	background: rgb(var(--color-background));
}`
})
//end modules/addDblclickZoom.js
//begin modules/addEntryScore.js
function addEntryScore(id,tries){
	if(!location.pathname.match(/^\/(anime|manga)/)){
		return
	}
	let existing = document.getElementById("hohEntryScore");
	if(existing){
		if(existing.dataset.mediaId === id && !tries){
			return
		}
		else{
			existing.remove()
		}
	}
	let possibleLocation = document.querySelector(".actions .list .add");
	if(possibleLocation){
		let miniHolder = create("div","#hohEntryScore",false,possibleLocation.parentNode.parentNode,"position:relative;");
		miniHolder.dataset.mediaId = id;
		let type = possibleLocation.innerText;
		if(["Reading","Completed","Watching","Paused","Repeating","Dropped"].includes(type)){
			let updateSubInfo = function(override){
				generalAPIcall(
					"query($id:Int,$name:String){MediaList(mediaId:$id,userName:$name){score progress}}",
					{id: id,name: whoAmI},
					function(data){
						removeChildren(miniHolder);
						let MediaList = data.data.MediaList;
						let scoreSpanContainer = create("div","hohMediaScore",false,miniHolder);
						let scoreSpan = create("span",false,false,scoreSpanContainer);
						let minScore = 1;
						let maxScore = 100;
						let stepSize = 1;
						if(["POINT_10","POINT_10_DECIMAL"].includes(userObject.mediaListOptions.scoreFormat)){
							maxScore = 10
						}
						if(userObject.mediaListOptions.scoreFormat === "POINT_10_DECIMAL"){
							minScore = 0.1;
							stepSize = 0.1
						}
						if(userObject.mediaListOptions.scoreFormat === "POINT_5"){
							maxScore = 5
						}
						if(MediaList.score){
							scoreSpan.appendChild(scoreFormatter(MediaList.score,userObject.mediaListOptions.scoreFormat));
							if(useScripts.accessToken && ["POINT_100","POINT_10","POINT_10_DECIMAL","POINT_5"].includes(userObject.mediaListOptions.scoreFormat)){
								let updateScore = function(isUp){
									let score = MediaList.score;
									if(isUp){
										MediaList.score += stepSize
									}
									else{
										MediaList.score -= stepSize
									}
									if(MediaList.score >= minScore && MediaList.score <= maxScore){
										scoreSpan.lastChild.remove();
										scoreSpan.appendChild(scoreFormatter(MediaList.score,userObject.mediaListOptions.scoreFormat));
										authAPIcall(
											`mutation($id:Int,$score:Float){
												SaveMediaListEntry(mediaId:$id,score:$score){
													score
												}
											}`,
											{id: id,score: MediaList.score},
											data => {
												if(!data){
													if(isUp){
														MediaList.score -= stepSize
													}
													else{
														MediaList.score += stepSize
													}
													scoreSpanContainer.style.color = "rgb(var(--color-red))";
													scoreSpanContainer.title = "Updating score failed"
												}
											}
										);
										let blockingCache = JSON.parse(sessionStorage.getItem("hohEntryScore" + id + whoAmI));
										blockingCache.data.data.MediaList.score = MediaList.score.roundPlaces(1);
										blockingCache.time = NOW();
										sessionStorage.setItem("hohEntryScore" + id + whoAmI,JSON.stringify(blockingCache));
									}
									else if(MediaList.score < minScore){
										MediaList.score = minScore
									}
									else if(MediaList.score > maxScore){
										MediaList.score = maxScore
									}
								};
								let changeMinus = create("span","hohChangeScore","-",false,"padding:2px;position:absolute;left:-1px;top:-2.5px;");
								scoreSpanContainer.insertBefore(changeMinus,scoreSpanContainer.firstChild);
								let changePluss = create("span","hohChangeScore","+",scoreSpanContainer,"padding:2px;");
								changeMinus.onclick = function(){updateScore(false)};
								changePluss.onclick = function(){updateScore(true)};
							}
						}
						if(type !== "Completed"){
							let progressPlace = create("span","hohMediaScore",false,miniHolder,"right:0px;");
							let progressVal = create("span",false,MediaList.progress,progressPlace);
							if(useScripts.accessToken){
								let changePluss = create("span","hohChangeScore","+",progressPlace,"padding:2px;position:absolute;top:-2.5px;");
								changePluss.onclick = function(){
									MediaList.progress++;
									authAPIcall(
										`mutation($id:Int,$progress:Int){
											SaveMediaListEntry(mediaId:$id,progress:$progress){
												progress
											}
										}`,
										{id: id,progress: MediaList.progress},
										data => {
											if(!data){
												MediaList.progress--;
												progressVal.innerText = MediaList.progress;
												progressVal.style.color = "rgb(var(--color-red))";
												progressVal.title = "Updating progress failed"
											}
										}
									);
									progressVal.innerText = MediaList.progress;
									let hohGuesses = Array.from(document.querySelectorAll(".hohGuess"));
									if(hohGuesses.length === 2){
										let oldProgress = parseInt(hohGuesses[0].innerText.match(/\d+/));
										if(MediaList.progress >= oldProgress){
											hohGuesses[1].remove()
										}
										else{
											hohGuesses[1].innerText = "[+" + (MediaList.progress - oldProgress) + "]"
										}
									}
								}
							}
						}
					},
					"hohEntryScore" + id + whoAmI,30*1000,undefined,override
				)
			};
			updateSubInfo();
			let editorOpen = false;
			//try to detect if the user has recently edited the media. If so, update the info to match
			let editorChecker = function(){
				if(document.querySelector(".list-editor-wrap")){
					editorOpen = true
				}
				else if(editorOpen){
					editorOpen = false;
					updateSubInfo(true)
				}
				setTimeout(function(){
					if(!location.pathname.match(/^\/(anime|manga)/)){
						return
					}
					editorChecker()
				},1000)
			};
			editorChecker()
		}
		else if(type === "Add to List" && (tries || 0) < 10){
			setTimeout(function(){addEntryScore(id,(tries || 0) + 1)},200);
		}
	}
	else{
		setTimeout(function(){addEntryScore(id)},200)
	}
}
//end modules/addEntryScore.js
//begin modules/addFeedFilters.js
function addFeedFilters(){
	if(!location.pathname.match(/^\/home\/?$/)){
		return
	}
	let filterBox = document.querySelector(".hohFeedFilter");
	if(filterBox){
		return
	}
	let activityFeedWrap = document.querySelector(".activity-feed-wrap");
	if(!activityFeedWrap){
		setTimeout(addFeedFilters,100);
		return
	}
	let activityFeed = activityFeedWrap.querySelector(".activity-feed");
	if(!activityFeed){
		setTimeout(addFeedFilters,100);
		return
	}
	let commentFilterBoxInput;
	let commentFilterBoxLabel;
	let likeFilterBoxInput;
	let likeFilterBoxLabel;
	let allFilterBox;
	let blockList = localStorage.getItem("blockList");
	if(blockList){
		blockList = JSON.parse(blockList)
	}
	else{
		blockList = []
	}
	let postRemover = function(){
		if(!location.pathname.match(/^\/home\/?$/)){
			return
		}
		for(var i=0;i<activityFeed.children.length;i++){
			if(activityFeed.children[i].querySelector(".el-dialog__wrapper")){
				continue
			}
			let actionLikes = activityFeed.children[i].querySelector(".action.likes .button .count");
			if(actionLikes){
				actionLikes = parseInt(actionLikes.innerText)
			}
			else{
				actionLikes = 0
			}
			let actionReplies = activityFeed.children[i].querySelector(".action.replies .count");
			if(actionReplies){
				actionReplies = parseInt(actionReplies.innerText)
			}
			else{
				actionReplies = 0
			}
			let blockRequire = true;
			if(useScripts.blockWord && activityFeed.children[i].classList.contains("activity-text")){
				try{
					if(activityFeed.children[i].innerText.match(new RegExp(blockWordValue,"i"))){
						blockRequire = false
					}
				}
				catch(err){
					if(activityFeed.children[i].innerText.toLowerCase().match(useScripts.blockWordValue.toLowerCase())){
						blockRequire = false
					}
				}
			}
			if(useScripts.statusBorder){
				let blockerMap = {
					"plans": "PLANNING",
					"watched": "CURRENT",
					"read": "CURRENT",
					"completed": "COMPLETED",
					"paused": "PAUSED",
					"dropped": "DROPPED",
					"rewatched": "REPEATING",
					"reread": "REPEATING"
				};
				let blockerClassMap = {
					"activityPlanning": "PLANNING",
					"activityWatching": "CURRENT",
					"activityReading": "CURRENT",
					"activityCompleted": "COMPLETED",
					"activityPaused": "PAUSED",
					"activityDropped": "DROPPED",
					"activityRewatching": "REPEATING",
					"activityRewatched": "REPEATING",
					"activityRereading": "REPEATING",
					"activityReread": "REPEATING"
				};
				if(activityFeed.children[i].classList.contains("activity-anime_list") || activityFeed.children[i].classList.contains("activity-manga_list")){
					let status = blockerClassMap[
							activityFeed.children[i].querySelector(".status").classList[1]
						] || blockerMap[
						Object.keys(blockerMap).find(
							key => activityFeed.children[i].querySelector(".status").innerText.toLowerCase().includes(key)
						)
					]
					if(status === "CURRENT"){
						activityFeed.children[i].children[0].style.borderRightWidth = "0px";
						activityFeed.children[i].children[0].style.marginRight = "0px"
					}
					else if(status === "COMPLETED"){
						activityFeed.children[i].children[0].style.borderRightStyle = "solid";
						activityFeed.children[i].children[0].style.borderRightWidth = "5px";
						if(useScripts.CSSgreenManga && activityFeed.children[i].classList.contains("activity-anime_list")){
							activityFeed.children[i].children[0].style.borderRightColor = "rgb(var(--color-blue))"
						}
						else{
							activityFeed.children[i].children[0].style.borderRightColor = "rgb(var(--color-green))"
						}
						activityFeed.children[i].children[0].style.marginRight = "-5px"
					}
					else{
						activityFeed.children[i].children[0].style.borderRightStyle = "solid";
						activityFeed.children[i].children[0].style.borderRightWidth = "5px";
						activityFeed.children[i].children[0].style.marginRight = "-5px";
						activityFeed.children[i].children[0].style.borderRightColor = distributionColours[status];
					}
				}	
			}
			const statusCheck = {
				"planning": /^plans/i,
				"watching": /^watched/i,
				"reading": /^read/i,
				"completing": /^completed/i,
				"pausing": /^paused/i,
				"dropping": /^dropped/i,
				"rewatching": /^rewatched/i,
				"rereading": /^reread/i
			}
			if(
				(!useScripts.feedCommentFilter || (
					actionLikes >= likeFilterBoxInput.value
					&& (likeFilterBoxInput.value >= 0 || actionLikes < -likeFilterBoxInput.value)
					&& actionReplies >= commentFilterBoxInput.value
					&& (commentFilterBoxInput.value >= 0 || actionReplies < -commentFilterBoxInput.value)
				))
				&& blockRequire
				&& blockList.every(
					blocker => (
						blocker.user
						&& activityFeed.children[i].querySelector(".name").textContent.trim().toLowerCase() !== blocker.user.toLowerCase()
					)
					|| (
						blocker.media
						&& (
							activityFeed.children[i].classList.contains("activity-text")
							|| activityFeed.children[i].querySelector(".status .title").href.match(/\/(anime|manga)\/(\d+)/)[2] !== blocker.media
						)
					)
					|| (
						blocker.status
						&& (
							activityFeed.children[i].classList.contains("activity-text")
							|| blocker.status == "status"
							|| (
								blocker.status === "anime"
								&& !activityFeed.children[i].classList.contains("activity-anime_list")
							)
							|| (
								blocker.status === "manga"
								&& !activityFeed.children[i].classList.contains("activity-manga_list")
							)
							|| (
								statusCheck[blocker.status]
								&& !activityFeed.children[i].querySelector(".status").textContent.trim().match(statusCheck[blocker.status])
							)
						)
					)
				)
			){
				if(
					useScripts.SFWmode
					&& activityFeed.children[i].classList.contains("activity-text")
					&& badWords.some(word => activityFeed.children[i].querySelector(".activity-markdown").innerText.match(word))
				){
					activityFeed.children[i].style.opacity= 0.5
				}
				else{
					activityFeed.children[i].style.display = ""
				}
			}
			else{
				activityFeed.children[i].style.display = "none"
			}
		}
	};
	let postTranslator = function(){
		Array.from(activityFeed.children).forEach(activity => {
			try{
				let timeElement = activity.querySelector(".time time");
				if(timeElement && !timeElement.classList.contains("hohTimeGeneric")){
					let seconds = new Date(timeElement.dateTime).valueOf()/1000;
					let replacement = nativeTimeElement(seconds);
					timeElement.style.display = "none";
					replacement.style.position = "relative";
					replacement.style.right = "unset";
					replacement.style.top = "unset";
					timeElement.parentNode.insertBefore(replacement, timeElement)
				}
			}
			catch(e){
				console.warn("time element translation is broken")
			}
			let statusParent = activity.querySelector(".status");
			if(!statusParent){
				return
			}
			let status = statusParent.childNodes[0];
			let cont = status.textContent.trim().match(/(.+?)(\s(\d+|\d+ - \d+) of)?$/);
			if(cont){
				let prog = cont[3];
				let type = cont[1];
				if(activity.classList.contains("activity-anime_list")){
					if(type === "Completed"){
						status.textContent = translate("$listActivity_completedAnime");
						statusParent.classList.add("activityCompleted")
					}
					else if(type === "Watched episode" && prog){
						status.textContent = translate("$listActivity_MwatchedEpisode",prog);
						statusParent.classList.add("activityWatching")
					}
					else if(type === "Dropped" && prog){
						status.textContent = translate("$listActivity_MdroppedAnime",prog);
						statusParent.classList.add("activityDropped")
					}
					else if(type === "Dropped"){
						status.textContent = translate("$listActivity_droppedAnime");
						statusParent.classList.add("activityDropped")
					}
					else if(type === "Rewatched episode" && prog){
						status.textContent = translate("$listActivity_MrepeatingAnime",prog);
						statusParent.classList.add("activityRewatching")
					}
					else if(type === "Rewatched"){
						status.textContent = translate("$listActivity_repeatedAnime");
						statusParent.classList.add("activityRewatched")
					}
					else if(type === "Paused watching"){
						status.textContent = translate("$listActivity_pausedAnime");
						statusParent.classList.add("activityPaused")
					}
					else if(type === "Plans to watch"){
						status.textContent = translate("$listActivity_planningAnime");
						statusParent.classList.add("activityPlanning")
					}
				}
				else if(activity.classList.contains("activity-manga_list")){
					if(type === "Completed"){
						status.textContent = translate("$listActivity_completedManga");
						statusParent.classList.add("activityCompleted")
					}
					else if(type === "Read chapter" && prog){
						status.textContent = translate("$listActivity_MreadChapter",prog);
						statusParent.classList.add("activityReading")
					}
					else if(type === "Dropped" && prog){
						status.textContent = translate("$listActivity_MdroppedManga",prog);
						statusParent.classList.add("activityDropped")
					}
					else if(type === "Dropped"){
						status.textContent = translate("$listActivity_droppedManga");
						statusParent.classList.add("activityDropped")
					}
					else if(type === "Reread chapter" && prog){
						status.textContent = translate("$listActivity_MrepeatingManga",prog);
						statusParent.classList.add("activityRereading")
					}
					else if(type === "Reread"){
						status.textContent = translate("$listActivity_repeatedManga");
						statusParent.classList.add("activityReread")
					}
					else if(type === "Paused reading"){
						status.textContent = translate("$listActivity_pausedManga");
						statusParent.classList.add("activityPaused")
					}
					else if(type === "Plans to read"){
						status.textContent = translate("$listActivity_planningManga");
						statusParent.classList.add("activityPlanning")
					}
				}
				if(useScripts.partialLocalisationLanguage === "日本語"){
					statusParent.classList.add("hohReverseTitle")
				}
			}
		})
	}
	if(useScripts.feedCommentFilter){
		filterBox = create("div","hohFeedFilter",false,activityFeedWrap);
		create("span","hohDescription","At least ",filterBox);
		activityFeedWrap.style.position = "relative";
		activityFeedWrap.children[0].childNodes[0].nodeValue = "";
		commentFilterBoxInput = create("input",false,false,filterBox);
		commentFilterBoxInput.type = "number";
		commentFilterBoxInput.value = useScripts.feedCommentComments;
		commentFilterBoxLabel = create("span",false," comments, ",filterBox);
		likeFilterBoxInput = create("input",false,false,filterBox);
		likeFilterBoxInput.type = "number";
		likeFilterBoxInput.value = useScripts.feedCommentLikes;
		likeFilterBoxLabel = create("span",false," likes",filterBox);
		allFilterBox = create("button",false,"⟳",filterBox,"padding:0px;");
		commentFilterBoxInput.onchange = function(){
			useScripts.feedCommentComments = commentFilterBoxInput.value;
			useScripts.save();
			postRemover();
		};
		likeFilterBoxInput.onchange = function(){
			useScripts.feedCommentLikes = likeFilterBoxInput.value;
			useScripts.save();
			postRemover();
		};
		allFilterBox.onclick = function(){
			commentFilterBoxInput.value = 0;
			likeFilterBoxInput.value = 0;
			useScripts.feedCommentComments = 0;
			useScripts.feedCommentLikes = 0;
			useScripts.save();
			postRemover();
		};
	}
	let mutationConfig = {
		attributes: false,
		childList: true,
		subtree: false
	};
	let observer = new MutationObserver(function(){
		postRemover();
		if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
			postTranslator()
		}
		setTimeout(postRemover,500);
	});
	observer.observe(activityFeed,mutationConfig);
	let observerObserver = new MutationObserver(function(){//Who police police? The police police police police
		activityFeed = activityFeedWrap.querySelector(".activity-feed");
		if(activityFeed){
			observer.disconnect();
			observer = new MutationObserver(function(){
				postRemover();
				if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
					postTranslator()
				}
				setTimeout(postRemover,500);
			});
			observer.observe(activityFeed,mutationConfig);
		}
	});
	observerObserver.observe(activityFeedWrap,mutationConfig);
	postRemover();
	if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
		postTranslator()
	}
	let waiter = function(){
		setTimeout(function(){
			if(location.pathname.match(/^\/home\/?$/)){
				postRemover();
				waiter();
			}
		},5*1000);
	};waiter();
}
//end modules/addFeedFilters.js
//begin modules/addFeedFilters_user.js
function addFeedFilters_user(){
	if(!/^https:\/\/anilist\.co\/user/.test(document.URL)){
		return
	}
	let activityFeed = document.querySelector(".activity-feed");
	if(!activityFeed){
		setTimeout(addFeedFilters_user,100);
		return
	}
	if(activityFeed.classList.contains("hohTranslated")){
		return
	}
	activityFeed.classList.add("hohTranslated");
	let postTranslator = function(){
		Array.from(activityFeed.children).forEach(activity => {
			try{
				let timeElement = activity.querySelector(".time time");
				if(timeElement && !timeElement.classList.contains("hohTimeGeneric")){
					let seconds = new Date(timeElement.dateTime).valueOf()/1000;
					let replacement = nativeTimeElement(seconds);
					timeElement.style.display = "none";
					replacement.style.position = "relative";
					replacement.style.right = "unset";
					replacement.style.top = "unset";
					timeElement.parentNode.insertBefore(replacement, timeElement)
				}
			}
			catch(e){
				console.warn("time element translation is broken")
			}
		})
	}
	let mutationConfig = {
		attributes: false,
		childList: true,
		subtree: false
	};
	let observer = new MutationObserver(function(){
		if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
			postTranslator()
		}
	});
	observer.observe(activityFeed,mutationConfig);
	let observerObserver = new MutationObserver(function(){
		activityFeed = document.querySelector(".activity-feed");
		if(activityFeed){
			observer.disconnect();
			observer = new MutationObserver(function(){
				postRemover();
				if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
					postTranslator()
				}
			});
			observer.observe(activityFeed,mutationConfig);
		}
	});
	observerObserver.observe(activityFeed,mutationConfig);
	if(useScripts.additionalTranslation && useScripts.partialLocalisationLanguage !== "English"){
		postTranslator()
	}
}
//end modules/addFeedFilters_user.js
//begin modules/addFollowCount.js
async function addFollowCount(){
	let URLstuff = location.pathname.match(/^\/user\/(.*)\/social/)
	if(!URLstuff){
		return
	}
	const userData = await anilistAPI("query($name:String){User(name:$name){id}}", {
		variables: {name: decodeURIComponent(URLstuff[1])},
		cacheKey: "hohIDlookup" + decodeURIComponent(URLstuff[1]).toLowerCase(),
		duration: 5*60*1000
	});
	if(userData.errors){
		return
	}
	//these two must be separate calls, because they are allowed to fail individually (too many followers)
	const followerData = await anilistAPI("query($id:Int!){Page(perPage:1){pageInfo{total} followers(userId:$id){id}}}", {
		variables: {id:userData.data.User.id}
	});
	const followingData = await anilistAPI("query($id:Int!){Page(perPage:1){pageInfo{total} following(userId:$id){id}}}", {
		variables: {id:userData.data.User.id}
	});
	const insertCount = function(data, id, pos){
		const target = document.querySelector(".filter-group");
		if(target){
			target.style.position = "relative";
			let followCount = "65536+";
			if(!data.errors){
				followCount = data.data.Page.pageInfo.total
			}
			create("span",[id,"hohCount"],followCount,target.children[pos]);
		}
	}
	insertCount(followerData, "#hohFollowersCount", 2)
	insertCount(followingData, "#hohFollowingCount", 1)
	return
}
//end modules/addFollowCount.js
//begin modules/addForumMedia.js
exportModule({
	id: "addForumMedia",
	description: "$forumMedia_backlink",
	isDefault: true,
	importance: -1,
	categories: ["Forum","Navigation"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url.includes("https://anilist.co/forum/recent?media=")
	},
	code: async function(){
		let id = parseInt(document.URL.match(/\d+$/)[0]);
		let adder = function(data){
			if(!document.URL.includes(id) || !data){
				return
			}
			let feed = document.querySelector(".feed");
			if(!feed){
				setTimeout(function(){adder(data)},200);
				return
			}
			data.data.Media.id = id;
			let mediaLink = create("a",false,titlePicker(data.data.Media),false,"padding:10px;display:block;");
			mediaLink.href = data.data.Media.siteUrl;
			cheapReload(mediaLink,{path: mediaLink.pathname})
			if(data.data.Media.siteUrl.includes("manga") && useScripts.CSSgreenManga){
				mediaLink.style.color = "rgb(var(--color-green))"
			}
			else{
				mediaLink.style.color = "rgb(var(--color-blue))"
			}
			feed.insertBefore(mediaLink,feed.firstChild);
		}
		const data = await anilistAPI("query($id:Int){Media(id:$id){title{native english romaji} siteUrl}}", {
			variables: {id},
			cacheKey: "hohMediaLookup" + id,
			duration: 30*60*1000
		})
		if(data.errors){
			return
		}
		adder(data)
		return
	}
})
//end modules/addForumMedia.js
//begin modules/addForumMediaNoAWC.js
async function addForumMediaNoAWC(){
	if(location.pathname !== "/home"){
		return
	}
	let buildPreview = function(data){
		if(location.pathname !== "/home"){
			return
		}
		let forumPreview = document.querySelector(".recent-threads .forum-wrap");
		if(!(forumPreview && forumPreview.childElementCount)){
			setTimeout(function(){buildPreview(data)},400);
			return;
		}
		forumPreview.classList.add("hohNoAWC");
		removeChildren(forumPreview)
		data.Page.threads.filter(
			thread => !(
				(useScripts.hideAWC && thread.title.match(/^(AWC|Anime\sWatching\s(Challenge|Club)|MRC)/))
				|| (useScripts.hideOtherThreads && thread.title.match(/(Boys\svs\sGirls|New\sUser\sIntro\sThread|Support\sAniList\s&\sAniChart|Where\scan\sI\s(watch|read|find))/i))
			)
		).slice(0,parseInt(useScripts.forumPreviewNumber)).forEach(thread => {
			let card = create("div",["thread-card","small"],false,forumPreview);
			create("a","title",thread.title,card).href = "/forum/thread/" + thread.id;
			let footer = create("div","footer",false,card);
			let avatar = create("a","avatar",false,footer);
			avatar.href = "/user/" + (thread.replyUser || thread.user).name;
			avatar.style.backgroundImage = "url(\"" + (thread.replyUser || thread.user).avatar.large + "\")";
			let name = create("div","name",false,footer);
			if(thread.replyCount === 0){
				let contextText = create("a",false,"By",name);
				name.appendChild(document.createTextNode(" "));
				let nameWrap = create("a",false,false,name);
				nameWrap.href = (thread.replyUser || thread.user).name;
				contextText.href = "/forum/thread/" + thread.id + "/comment/" + thread.replyCommentId;
				let nameInner = create("span",false,(thread.replyUser || thread.user).name,nameWrap);
			}
			else if(!thread.replyUser){
				let contextText = create("a",false,"By",name);
				name.appendChild(document.createTextNode(" "));
				let nameWrap = create("a",false,false,name);
				nameWrap.href = "/user/" + thread.user.name;
				contextText.href = "/forum/thread/" + thread.id;
				let nameInner = create("span",false,thread.user.name,nameWrap);
			}
			else{
				let nameWrap = create("a",false,false,name);
				nameWrap.href = "/user/" + thread.replyUser.name;
				let nameInner = create("span",false,thread.replyUser.name,nameWrap);
				name.appendChild(document.createTextNode(" "));
				let contextText = create("a",false,translate("$forum_preview_reply"),name);
				contextText.href = "/forum/thread/" + thread.id + "/comment/" + thread.replyCommentId;
				let timer = nativeTimeElement(thread.repliedAt);
				timer.style.position = "relative";
				timer.style.right = "unset";
				timer.style.top = "unset";
				timer.style.fontSize = "1.3rem";
				contextText.appendChild(timer);
			}
			let categories = create("div","categories",false,footer);
			thread.categories.forEach(category => {
				category.name = translate("$forumCategory_" + category.id,null,category.name)
			});
			if(thread.mediaCategories.length === 0){
				if(thread.categories.length){
					let catWrap = create("span",false,false,categories);
					let category = create("a",["category","default"],thread.categories[0].name,catWrap);
					category.href = "/forum/recent?category=" + thread.categories[0].id;
					category.style.background = (categoryColours.get(thread.categories[0].id) || "rgb(78, 163, 230)") + " none repeat scroll 0% 0%";
				}
			}
			else{
				let mediaTitle = titlePicker(thread.mediaCategories[0]);
				if(mediaTitle.length > 25){
					mediaTitle = mediaTitle.replace(/(2nd|Second) Season/,"2").replace(/\((\d+)\)/g,(string,year) => year);
					let lastIndex = mediaTitle.slice(0,25).lastIndexOf(" ");
					if(lastIndex > 20){
						mediaTitle.slice(0,lastIndex);
					}
					else{
						mediaTitle = mediaTitle.slice(0,20)
					}
				}
				let catWrap;
				if(
					thread.categories.length && thread.categories[0].id !== 1 && thread.categories[0].id !== 2
					&& !(mediaTitle.length > 30 && thread.categories[0].id === 5)//give priority to showing the whole title if it's just a release discussion
				){
					catWrap = create("span",false,false,categories);
					let category = create("a",["category","default"],thread.categories[0].name,catWrap);
					category.href = "/forum/recent?category=" + thread.categories[0].id;
					category.style.background = (categoryColours.get(thread.categories[0].id) || "rgb(78, 163, 230)") + " none repeat scroll 0% 0%";
				}
				catWrap = create("span",false,false,categories);
				let mediaCategory = create("a","category",mediaTitle,catWrap);
				mediaCategory.href = "/forum/recent?media=" + thread.mediaCategories[0].id;
				mediaCategory.style.background = (thread.mediaCategories[0].type === "ANIME" ? "rgb(var(--color-blue))" : "rgb(var(--color-green))") + " none repeat scroll 0% 0%";
			}
			let info = create("div","info",false,footer);
			let viewCount = create("span",false,false,info);
			viewCount.appendChild(svgAssets2.eye.cloneNode(true));
			viewCount.appendChild(document.createTextNode(" "));
			viewCount.appendChild(create("span",false,thread.viewCount,false,"padding-left: 0px;"))
			if(thread.replyCount){
				info.appendChild(document.createTextNode(" "));
				let replyCount = create("span",false,false,info);
				replyCount.appendChild(svgAssets2.reply.cloneNode(true));
				replyCount.appendChild(document.createTextNode(" "));
				replyCount.appendChild(create("span",false,thread.replyCount,false,"padding-left: 0px;"))
			}
		})
	};
	if(useScripts.forumPreviewNumber > 0){
		const {data, errors} = await anilistAPI(
			`query{
				Page(perPage:${parseInt(useScripts.forumPreviewNumber) + 12},page:1){
					threads(sort:REPLIED_AT_DESC){
						id
						viewCount
						replyCount
						title
						repliedAt
						replyCommentId
						user{
							name
							avatar{large}
						}
						replyUser{
							name
							avatar{large}
						}
						categories{
							id
							name
						}
						mediaCategories{
							id
							type
							title{romaji native english}
						}
					}
				}
			}`
		);
		if(errors){
			return
		}
		buildPreview(data)
	}
	return
}
//end modules/addForumMediaNoAWC.js
//begin modules/addForumMediaTitle.js
async function addForumMediaTitle(){
	if(location.pathname !== "/home"){
		return
	}
	// Forum previews may contain multiple categories but only show the first one
	let forumThreads = Array.from(document.querySelectorAll(".home .forum-wrap .thread-card .categories span:first-child .category"));
	if(!forumThreads.length){
		setTimeout(addForumMediaTitle,200);
		return;
	}
	if(forumThreads.some(
		thread => thread && ["anime","manga"].includes(thread.innerText.toLowerCase())
	)){
		const {data, errors} = await anilistAPI("query{Page(perPage:3){threads(sort:REPLIED_AT_DESC){title mediaCategories{id title{romaji native english}}}}}");
		if(errors){
			return
		}
		if(location.pathname !== "/home"){
			return
		}
		data.Page.threads.forEach((thread,index) => {
			if(thread.mediaCategories.length && ["anime","manga"].includes(forumThreads[index].innerText.toLowerCase())){
				let title = titlePicker(thread.mediaCategories[0]);
				if(title.length > 40){
					forumThreads[index].title = title;
					title = title.slice(0,35) + "…";
				}
				forumThreads[index].innerText = title;
			}
		})
	}
	return
}
//end modules/addForumMediaTitle.js
//begin modules/addImageFallback.js
function addImageFallback(){
	if(!document.URL.match(/(\/home|\/user\/)/)){
		return
	}
	setTimeout(addImageFallback,1000);
	let mediaImages = document.querySelectorAll(".media-preview-card:not(.hohFallback) .content .title");
	mediaImages.forEach(cover => {
		cover.parentNode.parentNode.classList.add("hohFallback");
		if(cover.parentNode.parentNode.querySelector(".hohFallback")){
			return
		}
		let fallback = create("span","hohFallback",cover.textContent,cover.parentNode.parentNode);
		if(useScripts.titleLanguage === "ROMAJI"){
			fallback.textContent = cover.textContent;
		}
	})
}
//end modules/addImageFallback.js
//begin modules/additionalTranslation.js
exportModule({
	id: "additionalTranslation",
	description: "$additionalTranslation_description",
	extendedDescription: `Use "Automail language" to translate some native parts of the site too`,
	isDefault: true,//logic: if translation is turned on, it should be comprehensive. Turning *off* parts of it should be the active opt
	importance: 0,
	categories: ["Script","Newly Added"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return useScripts.partialLocalisationLanguage !== "English"
	},
	code: function(){
		let times = [100,200,400,1000,2000,3000,5000,7000,10000,15000];
		let caller = function(url,element,counter){
			if(!document.URL.match(url)){
				return
			}
			if(element.multiple){
				let place = document.querySelectorAll(element.lookup);
				if(place){
					Array.from(place).forEach(elem => {
						element.multiple.forEach(possible => {
							if(elem.childNodes[0].textContent.trim() === possible.ofText){
								elem.childNodes[0].textContent = translate(possible.replacement)
								possible.translated = true
							}
						})
					})
					if(counter < times.length && !element.multiple.every(possible => possible.translated)){
						setTimeout(function(){
							caller(url,element,counter + 1)
						},times[counter])
					}
				}
				else if(counter < times.length){
					setTimeout(function(){
						caller(url,element,counter + 1)
					},times[counter])
				}
			}
			else{
				let place = document.querySelector(element.lookup);
				if(place){
					if(element.textType === "placeholder"){
						place.placeholder = translate(element.replacement)
					}
					else{
						place.childNodes[element.selectIndex || 0].textContent = translate(element.replacement)
					}
				}
				else if(counter < times.length){
					setTimeout(function(){
						caller(url,element,counter + 1)
					},times[counter])
				}
			}
		};
		[
			{
				regex: /./,
				elements: [
					{
						lookup: ".theme-selector > h2",
						replacement: "$footer_siteTheme"
					},
					{
						lookup: ".footer [href=\"https://submission-manual.anilist.co/\"]",
						replacement: "$footer_addData"
					},
					{
						lookup: ".footer [href=\"/moderators\"]",
						replacement: "$footer_moderators"
					},
					{
						lookup: ".footer [href=\"mailto:contact@anilist.co\"]",
						replacement: "$footer_contact"
					},
					{
						lookup: ".footer [href=\"/terms\"]",
						replacement: "$footer_terms"
					},
					{
						lookup: ".footer [href=\"/sitemap/index.xml\"]",
						replacement: "$footer_siteMap"
					},
					{
						lookup: ".footer [href=\"/site-stats\"]",
						replacement: "$stats_siteStats_title"
					},
					{
						lookup: ".footer [href=\"/recommendations\"]",
						replacement: "$submenu_recommendations"
					}
				]
			},
			{
				regex: /\/user\/([^/]+)\/?$/,
				elements: [
					{
						lookup: ".activity-edit .el-textarea__inner",
						textType: "placeholder",
						replacement: "$placeholder_status"
					},
					{
						lookup: ".activity-feed-wrap h2.section-header",
						replacement: "$feed_header"
					},
					{
						lookup: ".activity-feed-wrap .load-more",
						replacement: "$load_more"
					},
					{
						lookup: ".activity-feed-wrap ul li:nth-child(1)",
						selectIndex: 1,
						replacement: "$feedSelect_all"
					},
					{
						lookup: ".activity-feed-wrap ul li:nth-child(2)",
						selectIndex: 1,
						replacement: "$feedSelect_status"
					},
					{
						lookup: ".activity-feed-wrap ul li:nth-child(3)",
						selectIndex: 1,
						replacement: "$feedSelect_message"
					},
					{
						lookup: ".activity-feed-wrap ul li:nth-child(4)",
						selectIndex: 1,
						replacement: "$feedSelect_list"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 0,
						replacement: "$menu_overview"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 2,
						replacement: "$menu_animelist"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 4,
						replacement: "$menu_mangalist"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 6,
						replacement: "$submenu_favourites"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 8,
						replacement: "$submenu_stats"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 10,
						replacement: "$submenu_social"
					},
					{
						lookup: ".user .nav.container",
						selectIndex: 12,
						replacement: "$submenu_reviews"
					},
					{
						lookup: ".user .nav.container [href$=submissions]",
						replacement: "$submenu_submissions"
					}
				]
			},
			{
				regex: /\.co\/forum\/thread\/\d+\/comment\//,
				elements: [
					{
						lookup: ".comments-header a",
						replacement: "$forum_singleThread"
					}
				]
			},
			{
				regex: /\.co\/(manga|anime)\//,
				elements: [
					{
						lookup: ".media .nav",
						selectIndex: 0,
						replacement: "$menu_overview"
					},
					{
						lookup: ".media .nav [href$=characters]",
						replacement: "$submenu_characters"
					},
					{
						lookup: ".media .nav [href$=staff]",
						replacement: "$submenu_staff"
					},
					{
						lookup: ".media .nav [href$=reviews]",
						replacement: "$submenu_reviews"
					},
					{
						lookup: ".media .nav [href$=stats]",
						replacement: "$submenu_stats"
					},
					{
						lookup: ".media .nav [href$=social]",
						replacement: "$submenu_social"
					},
					{
						lookup: ".overview .characters > h2",
						replacement: "$submenu_characters"
					},
					{
						lookup: ".overview .staff > h2",
						replacement: "$submenu_staff"
					},
					{
						lookup: ".overview .recommendations > h2",
						replacement: "$submenu_recommendations"
					},
					{
						lookup: ".overview .reviews > h2",
						replacement: "$submenu_reviews"
					}
				]
			},
			{
				regex: /\/user\/([^/]+)\/(animelist|mangalist)\/?/,
				elements: [
					{
						lookup: ".filters-wrap [placeholder='Filter']",
						textType: "placeholder",
						replacement: "$mediaStaff_filter"
					},
					{
						lookup: ".filters-wrap [placeholder='Genres']",
						textType: "placeholder",
						replacement: "$stats_genre"
					},
					{
						lookup: ".filters .filter-group .group-header",
						multiple: [
							{
								ofText: "Lists",
								replacement: "$filters_lists"
							},
							{
								ofText: "Filters",
								replacement: "$filters"
							},
							{
								ofText: "Year",
								replacement: "$filters_year"
							},
							{
								ofText: "Sort",
								replacement: "$staff_sort"
							}
						]
					}
				]
			},
			{
				regex: /\/home\/?$/,
				elements: [
					{
						lookup: ".activity-edit .el-textarea__inner",
						textType: "placeholder",
						replacement: "$placeholder_status"
					},
					{
						lookup: ".activity-feed-wrap h2.section-header",
						replacement: "$feed_header"
					},
					{
						lookup: ".activity-feed-wrap .load-more",
						replacement: "$load_more"
					},
					{
						lookup: ".feed-select ul li:nth-child(1)",
						selectIndex: 1,
						replacement: " " + translate("$feedSelect_all") + " "
					},
					{
						lookup: ".feed-select ul li:nth-child(2)",
						selectIndex: 1,
						replacement: " " + translate("$feedSelect_text") + " "
					},
					{
						lookup: ".feed-select ul li:nth-child(3)",
						selectIndex: 1,
						replacement: " " + translate("$feedSelect_list") + " "
					},
					{
						lookup: ".feed-select .feed-type-toggle div:nth-child(1)",
						replacement: "$filter_following"
					},
					{
						lookup: ".feed-select .feed-type-toggle div:nth-child(2)",
						replacement: "$terms_option_global"
					},
					{
						lookup: ".list-preview-wrap .section-header h2",
						multiple: [
							{
								ofText: "Manga in Progress",
								replacement: "$preview_mangaSection_title"
							},
							{
								ofText: "Anime in Progress",
								replacement: "$preview_animeSection_title"
							}
						]
					}
					//see also: middleClickLinkFixer.js
				]
			},
			{
				regex: /\/reviews\/?$/,
				elements: [
					{
						lookup: ".load-more",
						replacement: "$load_more"
					}
				]
			},
			{
				regex: /\/forum\/(overview|recent)\/?$/,
				elements: [
					{
						lookup: ".overview-header[href='/forum/recent']",
						replacement: "$forumHeading_recentlyActive"
					},
					{
						lookup: ".overview-header[href='/forum/recent?category=5']",
						replacement: "$forumHeading_releaseDiscussion"
					},
					{
						lookup: ".overview-header[href='/forum/new']",
						replacement: "$forumHeading_newThreads"
					}
				]
			},
		].forEach(matchset => {
			if(document.URL.match(matchset.regex)){
				matchset.elements.forEach(element => {
					caller(matchset.regex,element,0)
				})
			}
		})
	}
})
//end modules/additionalTranslation.js
//begin modules/addMALscore.js
async function addMALscore(type,id){
	if(!location.pathname.match(/^\/(anime|manga)/)){
		return
	}
	let MALscore = document.getElementById("hohMALscore");
	if(MALscore){
		if(parseInt(MALscore.dataset.id) === id){
			return
		}
		else{
			MALscore.remove()
		}
	}
	let MALserial = document.getElementById("hohMALserialization");
	if(MALserial){
		if(parseInt(MALserial.dataset.id) === id){
			return
		}
		else{
			MALserial.remove()
		}
	}
	let possibleReleaseStatus = Array.from(document.querySelectorAll(".data-set .type"));
	const MALlocation = possibleReleaseStatus.find(element => element.innerText === "Mean Score");
	if(MALlocation){
		MALscore = create("div","data-set");
		MALscore.id = "hohMALscore";
		MALscore.dataset.id = id;
		MALlocation.parentNode.parentNode.insertBefore(MALscore,MALlocation.parentNode.nextSibling);
		if(type === "manga"){
			MALserial = create("div","data-set");
			MALserial.id = "hohMALserialization";
			MALserial.dataset.id = id;
			MALlocation.parentNode.parentNode.insertBefore(MALserial,MALlocation.parentNode.nextSibling.nextSibling)
		}
		const data = await anilistAPI("query($id:Int){Media(id:$id){idMal}}", {
			variables: {id},
			cacheKey: "hohIDmal" + id,
			duration: 30*60*1000
		});
		if(data.errors){
			return
		}
		if(data.data.Media.idMal){
			let handler = function(response){
				let score = response.responseText.match(/ratingValue.+?(\d+\.\d+)/);
				if(score && useScripts.MALscore){
					MALscore.style.paddingBottom = "14px";
					create("a",["type","newTab","external"],translate("$MAL_score"),MALscore)
						.href = "https://myanimelist.net/" + type + "/" + data.data.Media.idMal;
					create("div","value",score[1],MALscore)
				}
				if(type === "manga" && useScripts.MALserial){
					let serialization = response.responseText.match(/Serialization:<\/span>\n.*?href="(.*?)"\stitle="(.*?)"/);
					if(serialization){
						create("div","type",translate("$MAL_serialization"),MALserial);
						let link = create("a",["value","newTab","external"],serialization[2].replace(/&#039;/g,"'").replace(/&quot;/g,'"'),MALserial)
						link.href = "https://myanimelist.net" + serialization[1]
					}
				}
				let adder = function(){
					let possibleOverview = document.querySelector(".overview .grid-section-wrap:last-child");
					if(!possibleOverview){
						setTimeout(adder,500);
						return
					}
					(possibleOverview.querySelector(".hohRecContainer") || {remove: ()=>{}}).remove();
					let recContainer = create("div",["grid-section-wrap","hohRecContainer"],false,possibleOverview);
					create("h2",false,"MAL Recommendations",recContainer);
					let pattern = /class="picSurround"><a href="https:\/\/myanimelist\.net\/(anime|manga)\/(\d+)\/[\s\S]*?detail-user-recs-text.*?">([\s\S]*?)<\/div>/g;
					let matching = [];
					let matchingItem;
					while((matchingItem = pattern.exec(response.responseText)) && matching.length < 5){//single "=" is intended, we are setting the value of each match, not comparing
						matching.push(matchingItem)
					}
					if(!matching.length){
						recContainer.style.display = "none"
					}
					matching.forEach(async function(item){
						let idMal = item[2];
						let description = item[3];
						let rec = create("div","hohRec",false,recContainer);
						let recImage = create("a","hohBackgroundCover",false,rec,"border-radius: 3px;");
						let recTitle = create("a","title",false,rec,"position:absolute;top:35px;left:80px;color:rgb(var(--color-blue));");
						recTitle.innerText = "MAL ID " + idMal;
						let recDescription = create("p",false,false,rec,"font-size: 1.4rem;line-height: 1.5;");
						recDescription.innerText = new DOMParser().parseFromString(description, 'text/html').body.textContent.replace(/\s*?read more\s*?$/,"") || "";
						const reverseData = await anilistAPI(
							"query($idMal:Int,$type:MediaType){Media(idMal:$idMal,type:$type){id title{romaji native english} coverImage{large color} siteUrl}}",
							{
								variables: {idMal:idMal,type:item[1].toUpperCase()},
								cacheKey: "hohIDmalReverse" + idMal,
								duration: 30*60*1000
							}
						);
						if(reverseData.errors){
							return
						}
						recImage.style.backgroundColor = reverseData.data.Media.coverImage.color || "rgb(var(--color-foreground))";
						recImage.style.backgroundImage = "url(\"" + reverseData.data.Media.coverImage.large + "\")";
						recImage.href = reverseData.data.Media.siteUrl;
						cheapReload(recImage,{path: recImage.pathname})
						recTitle.innerText = titlePicker(reverseData.data.Media);
						recTitle.href = reverseData.data.Media.siteUrl
						cheapReload(recTitle,{path: recTitle.pathname})
						return
					})
				};
				if(useScripts.MALrecs){
					adder()
				}
			}
			if(window.GM_xmlhttpRequest){
				GM_xmlhttpRequest({
					method: "GET",
					anonymous: true,
					url: "https://myanimelist.net/" + type + "/" + data.data.Media.idMal + "/placeholder/userrecs",
					onload: function(response){handler(response)}
				})
			}
			else{
				let oReq = new XMLHttpRequest();
				oReq.addEventListener("load",function(){handler(this)});
				oReq.open("GET","https://myanimelist.net/" + type + "/" + data.data.Media.idMal + "/placeholder/userrecs");
				oReq.send()
			}
		}
	}
	else{
		setTimeout(() => {addMALscore(type,id)},200)
	}
	return
}
//end modules/addMALscore.js
//begin modules/addMediaReviewConfidence.js
exportModule({
	id: "addMediaReviewConfidence",
	description: "Add confidence scores to reviews on media pages",
	isDefault: true,
	categories: ["Media"],
	visible: true,
	urlMatch: function(url){
		return /^https:\/\/anilist\.co\/(anime|manga)\/[0-9]+\/.*\/reviews/.test(url)
	},
	code: function(){
		const [,id] = location.pathname.match(/^\/(?:anime|manga)\/([0-9]+)\/.*\/reviews/)
		const query = `
query media($id: Int, $page: Int) {
	Media(id: $id) {
		reviews(page: $page, sort: [RATING_DESC, ID]) {
			pageInfo {
				total
				perPage
				hasNextPage
			}
			nodes {
				id
				rating
				ratingAmount
			}
		}
	}
}
`
		let pageCount = 0;
		let reviewCount = 0;

		const addConfidence = async function(){
			pageCount++
			const {data, errors} = await anilistAPI(query, {
				variables: {id, page: pageCount},
				cacheKey: "recentMediaReviews" + id + "Page" + pageCount,
				duration: 30*60*1000
			})
			if(errors){
				return;
			}
			const adder = function(){
				const reviewWrap = document.querySelector(".media-reviews .review-wrap");
				if(!reviewWrap){
					setTimeout(adder,200);
					return;
				}
				data.Media.reviews.nodes.forEach(review => {
					reviewCount++
					const wilsonLowerBound = wilson(review.rating,review.ratingAmount).left
					const extraScore = create("span",false,"~" + Math.round(100*wilsonLowerBound));
					extraScore.style.color = "hsl(" + wilsonLowerBound*120 + ",100%,50%)";
					extraScore.style.marginRight = "3px";
					const findParent = function(){
						const parent = reviewWrap.querySelector('[href="/review/' + review.id + '"] .votes');
						if(!parent){
							setTimeout(findParent,200);
							return;
						}
						parent.insertBefore(extraScore,parent.firstChild);
						if(wilsonLowerBound < 0.05){
							reviewWrap.children[reviewCount - 1].style.opacity = "0.5"
						}
					}; findParent();
				})
				return;
			};adder();
		}
		addConfidence()

		const checkMore = function(){
			const loadMore = document.querySelector(".media-reviews .load-more");
			if(!loadMore){
				setTimeout(checkMore,200);
				return;
			}
			loadMore.addEventListener("click", addConfidence)
		};checkMore();
	},
	css: `
	.media-reviews .review-wrap .review-card .summary {
		margin-bottom: 15px;
	}
	`
})
//end modules/addMediaReviewConfidence.js
//begin modules/addMoreStats.js
exportModule({
	id: "moreStats",
	description: "$setting_moreStats",
	extendedDescription: `
On every users' stats page, there will be an additonal tab called "more stats".
The "more stats" page also has a section for running various statistical queries about the site or specific users.

There will also be a tab called "Genres & Tags", which contains aggregate stats for anime and manga.

In addition, the individual sections for anime/manga staff and tags will have full tables not limited to the default 30.
In these tables, you can click the rows to see the individual works contributing to the stats.
	`,
	isDefault: true,
	importance: 9,
	categories: ["Stats"],
	visible: true
})

function addMoreStats(){
	if(!document.URL.match(/\/stats\/?/)){
		return
	}
	if(document.querySelector(".hohStatsTrigger")){
		return
	}
	let filterGroup = document.querySelector(".filter-wrap");
	if(!filterGroup){
		setTimeout(function(){
			addMoreStats()
		},200);//takes some time to load
		return;
	}
	let hohStats;
	let hohGenres;
	let regularFilterHeading;
	let regularGenresTable;
	let regularTagsTable;
	let regularAnimeTable;
	let regularMangaTable;
	let animeStaff;
	let mangaStaff;
	let animeStudios;
	let hohStatsTrigger = create("span","hohStatsTrigger",translate("$stats_moreStats_title"),filterGroup);
	let hohGenresTrigger = create("span","hohStatsTrigger",translate("$stats_genresTags_title"),filterGroup);
	let hohSiteStats = create("a","hohStatsTrigger",translate("$stats_siteStats_title"),filterGroup);
	hohSiteStats.href = "/site-stats";
	cheapReload(hohSiteStats,{name: "SiteStats"});
	let generateStatPage = async function(){
		let personalStats = create("div","#personalStats",translate("$stats_loadingAnime"),hohStats);
		let personalStatsManga = create("div","#personalStatsManga",translate("$stats_loadingManga"),hohStats);
		let miscQueries = create("div","#miscQueries",false,hohStats);
		create("hr","hohSeparator",false,miscQueries);
		create("h1","hohStatHeading",translate("$stats_varousStats_heading"),miscQueries);
		let miscInput = create("div",false,false,miscQueries,"padding-top:10px;padding-bottom:10px;");
		let miscOptions = create("div","#queryOptions",false,miscQueries);
		let miscResults = create("div","#queryResults",false,miscQueries);
		let nameContainer = document.querySelector(".banner-content h1.name");
		let user;
		if(nameContainer){
			user = nameContainer.innerText
		}
		else{
			user = decodeURIComponent(document.URL.match(/user\/(.+)\/stats\/?/)[1])
		}
		const loginMessage = "Requires being signed in to the script. You can do that at the bottom of the settings page https://anilist.co/settings/apps";
		let statusSearchCache = [];
		let availableQueries = [
			{name: translate("$query_firstActivity"),code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		let userId = data.data.User.id;
		let userFirstQuery =
		`query ($userId: Int) {
			Activity(sort: ID,userId: $userId){
				... on MessageActivity {
					id
					createdAt
				}
				... on TextActivity {
					id
					createdAt
				}
				... on ListActivity {
					id
					createdAt
				}
			}
		}`;
		generalAPIcall(userFirstQuery,{userId: userId},function(data){
			miscResults.innerText = "";
			let newPage = create("a",false,"https://anilist.co/activity/" + data.data.Activity.id,miscResults,"color:rgb(var(--color-blue));padding-right:30px;");
			newPage.href = "/activity/" + data.data.Activity.id;
			let createdAt = data.data.Activity.createdAt;
			create("span",false," " + (new Date(createdAt*1000)),miscResults);
			let possibleOlder = create("p",false,false,miscResults);
			for(var i=1;i<=15;i++){
				generalAPIcall(userFirstQuery,{userId: userId + i},function(data){
					if(!data){return};
					if(data.data.Activity.createdAt < createdAt){
						createdAt = data.data.Activity.createdAt;
						possibleOlder.innerText = "But the account is known to exist already at " + (new Date(createdAt * 1000));
					}
				})
			}
		},"hohFirstActivity" + data.data.User.id,60*1000);
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Rank",code: function(){
	generalAPIcall(
		"query($name:String){User(name:$name){name stats{watchedTime chaptersRead}}}",
		{name: user},
		function(data){
			miscResults.innerText = "";
			create("p",false,"NOTE: Due to an unfixed bug in the Anilist API, these results are increasingly out of date. This query is just kept here in case future changes allows it to work properly again.",miscResults);
			create("p",false,"Time watched: " + (data.data.User.stats.watchedTime/(60*24)).roundPlaces(1) + " days",miscResults);
			create("p",false,"Chapters read: " + data.data.User.stats.chaptersRead,miscResults);
			let ranks = {
				"anime": create("p",false,false,miscResults),
				"manga": create("p",false,false,miscResults)
			};
			let recursiveCall = function(userName,amount,currentPage,minPage,maxPage,type){
				ranks[type].innerText = capitalize(type) + " rank: [calculating...] range " + ((minPage - 1)*50 + 1) + " - " + (maxPage ? maxPage*50 : "");
				generalAPIcall(
					`
query($page:Int){
	Page(page:$page){
		pageInfo{lastPage}
			users(sort:${type === "anime" ? "WATCHED_TIME_DESC" : "CHAPTERS_READ_DESC"}){
			stats{${type === "anime" ? "watchedTime" : "chaptersRead"}}
		}
	}
}`,
					{page: currentPage},
					function(data){
						if(!maxPage){
							maxPage = data.data.Page.pageInfo.lastPage
						}
						let block = (
							type === "anime"
							? Array.from(data.data.Page.users,(a) => a.stats.watchedTime)
							: Array.from(data.data.Page.users,(a) => a.stats.chaptersRead)
						);
						if(block[block.length - 1] > amount){
							recursiveCall(userName,amount,Math.floor((currentPage + 1 + maxPage)/2),currentPage + 1,maxPage,type);
							return;
						}
						else if(block[0] > amount){
							block.forEach(function(item,index){
								if(amount === item){
									ranks[type].innerText = capitalize(type) + " rank: " + ((currentPage - 1)*50 + index + 1);
									return;
								}
							})
						}
						else if(block[0] === amount){
							if(minPage === currentPage){
								ranks[type].innerText = capitalize(type) + " rank: " + ((currentPage-1)*50 + 1)
							}
							else{
								recursiveCall(userName,amount,Math.floor((minPage + currentPage)/2),minPage,currentPage,type)
							};
							return;
						}
						else{
							recursiveCall(userName,amount,Math.floor((minPage + currentPage - 1)/2),minPage,currentPage - 1,type);
							return;
						};
					},"hohRank" + type + currentPage,60*60*1000
				);
			};
			recursiveCall(user,data.data.User.stats.watchedTime,1000,1,undefined,"anime");
			recursiveCall(user,data.data.User.stats.chaptersRead,500,1,undefined,"manga");
		},"hohRankStats" + user,2*60*1000
	);
}},

{name: "Hidden media entries",code: function(){
	miscResults.innerText = "";
	let pageCounter = create("p",false,false,miscResults);
	let pager = function(page,user){
		generalAPIcall(
`query ($userName: String,$page:Int) {
	Page(page:$page){
		pageInfo{
			currentPage
			lastPage
		}
		mediaList(userName:$userName){
			hiddenFromStatusLists
			mediaId
			media{
				type
				title{romaji}
			}
			customLists(asArray:true)
		}
	}
}`,
			{
			  	page: page,
				userName: user
			},
			function(data){
				if(data.data.Page.pageInfo.currentPage < data.data.Page.pageInfo.lastPage){
					setTimeout(function(){
						pager(data.data.Page.pageInfo.currentPage + 1,user)
					},800);
				}
				pageCounter.innerText = "Searching page " + data.data.Page.pageInfo.currentPage + " of " + data.data.Page.pageInfo.lastPage;
				data.data.Page.mediaList.forEach(function(media){
					if(
						media.hiddenFromStatusLists
						&& media.customLists.every(cl => cl.enabled === false)
					){
						create("a","newTab",media.media.title.romaji,miscResults,"display:block;")
							.href = "/" + media.media.type.toLowerCase() + "/" + media.mediaId
					}
				})
			}
		);
	};pager(1,user);
}},

{name: "Related anime not on list",code: function(){
	generalAPIcall(
`query($name: String!){
	MediaListCollection(userName: $name,type: ANIME){
		lists{
			entries{
				mediaId
				score
				status
				media{
					relations{
						edges{
							relationType(version: 2)
							node{
								id
								title{romaji}
								type
							}
						}
					}
				}
			}
		}
	}
}`,
	{name: user},function(data){
		let list = returnList(data,true);
		let listEntries = new Set(list.map(a => a.mediaId));
		let found = [];
		list.forEach(function(media){
			if(media.status !== "PLANNING"){
				media.media.relations.edges.forEach(relation => {
					if(!listEntries.has(relation.node.id) && relation.node.type === "ANIME"){
						relation.host = media.score;
						relation.relationType = [relation.relationType];
						relation.isDropped = [media.status === "DROPPED"];
						found.push(relation);
					}
				})
			}
		});
		found = removeGroupedDuplicates(
			found,
			e => e.node.id,
			(oldElement,newElement) => {
				newElement.relationType = [...oldElement.relationType,...newElement.relationType];
				newElement.isDropped = [...oldElement.isDropped,...newElement.isDropped];
				newElement.host = Math.max(oldElement.host,newElement.host)
			}
		).sort(
			(b,a) => a.host - b.host
		);
		miscResults.innerText = "";
		let foundCount = create("p",false,"Found " + found.length + " anime:",miscResults);
		let filters = create("div",false,false,miscResults);

		let row1 = create("p",false,false,filters);
		let checkBox1 = createCheckbox(row1);
		let label1 = create("span",false,"Prequel",row1);

		let row2 = create("p",false,false,filters);
		let checkBox2 = createCheckbox(row2);
		let label2 = create("span",false,"Sequel",row2);

		let row3 = create("p",false,false,filters);
		let checkBox3 = createCheckbox(row3);
		let label3 = create("span",false,"Side Story",row3);

		let row4 = create("p",false,false,filters);
		let checkBox4 = createCheckbox(row4);
		let label4 = create("span",false,"Alternative",row4);

		let row5 = create("p",false,false,filters);
		let checkBox5 = createCheckbox(row5);
		let label5 = create("span",false,"Other Relation",row5);

		let row6 = create("p",false,false,filters);
		let checkBox6 = createCheckbox(row6);
		let label6 = create("span",false,"Include media related to dropped anime",row6);

		checkBox1.checked = true;
		checkBox2.checked = true;
		checkBox3.checked = true;
		checkBox4.checked = true;
		checkBox5.checked = true;

		let f_results = create("div",false,false,miscResults);
		let render = function(){
			removeChildren(f_results);
			let count = 0;
			found.forEach(item => {
				if(
					(
						(checkBox1.checked && item.relationType.includes("PREQUEL"))
						|| (checkBox2.checked && item.relationType.includes("SEQUEL"))
						|| (checkBox3.checked && item.relationType.includes("SIDE_STORY"))
						|| (checkBox4.checked && item.relationType.includes("ALTERNATIVE"))
						|| (checkBox5.checked && item.relationType.some(type => ["ADAPTATION","CHARACTER","SUMMARY","SPIN_OFF","OTHER","SOURCE","COMPILATION","CONTAINS"].includes(type)))
					)
					&& (checkBox6.checked || item.isDropped.some(val => !val))
				){
					create("a",["link","newTab"],item.node.title.romaji,f_results,"display:block;padding:5px;")
						.href = "/anime/" + item.node.id;
					count++;
				}
			});
			foundCount.innerText = "Found " + count + " anime:";
		};
		checkBox1.onchange = render;
		checkBox2.onchange = render;
		checkBox3.onchange = render;
		checkBox4.onchange = render;
		checkBox5.onchange = render;
		checkBox6.onchange = render;
		render();
	})
}},

{name: "Related manga not on list",code: function(){
	generalAPIcall(
`query($name: String!){
	MediaListCollection(userName: $name,type: MANGA){
		lists{
			entries{
				mediaId
				score
				status
				media{
					relations{
						edges{
							relationType(version: 2)
							node{
								id
								title{romaji}
								type
							}
						}
					}
				}
			}
		}
	}
}`,
	{name: user},function(data){
		let list = returnList(data,true);
		let listEntries = new Set(list.map(a => a.mediaId));
		let found = [];
		list.forEach(function(media){
			if(media.status !== "PLANNING"){
				media.media.relations.edges.forEach(relation => {
					if(!listEntries.has(relation.node.id) && relation.node.type === "MANGA"){
						relation.host = media.score;
						relation.relationType = [relation.relationType];
						relation.isDropped = [media.status === "DROPPED"];
						found.push(relation);
					}
				})
			}
		});
		found = removeGroupedDuplicates(
			found,
			e => e.node.id,
			(oldElement,newElement) => {
				newElement.relationType = [...oldElement.relationType,...newElement.relationType];
				newElement.isDropped = [...oldElement.isDropped,...newElement.isDropped];
				newElement.host = Math.max(oldElement.host,newElement.host)
			}
		).sort(
			(b,a) => a.host - b.host
		);
		miscResults.innerText = "";
		let foundCount = create("p",false,"Found " + found.length + " manga:",miscResults);
		let filters = create("div",false,false,miscResults);

		let row1 = create("p",false,false,filters);
		let checkBox1 = createCheckbox(row1);
		let label1 = create("span",false,"Prequel",row1);

		let row2 = create("p",false,false,filters);
		let checkBox2 = createCheckbox(row2);
		let label2 = create("span",false,"Sequel",row2);

		let row3 = create("p",false,false,filters);
		let checkBox3 = createCheckbox(row3);
		let label3 = create("span",false,"Side Story",row3);

		let row4 = create("p",false,false,filters);
		let checkBox4 = createCheckbox(row4);
		let label4 = create("span",false,"Alternative",row4);

		let row5 = create("p",false,false,filters);
		let checkBox5 = createCheckbox(row5);
		let label5 = create("span",false,"Other Relation",row5);

		let row6 = create("p",false,false,filters);
		let checkBox6 = createCheckbox(row6);
		let label6 = create("span",false,"Include media related to dropped manga",row6);

		checkBox1.checked = true;
		checkBox2.checked = true;
		checkBox3.checked = true;
		checkBox4.checked = true;
		checkBox5.checked = true;

		let f_results = create("div",false,false,miscResults);
		let render = function(){
			removeChildren(f_results);
			let count = 0;
			found.forEach(item => {
				if(
					(
						(checkBox1.checked && item.relationType.includes("PREQUEL"))
						|| (checkBox2.checked && item.relationType.includes("SEQUEL"))
						|| (checkBox3.checked && item.relationType.includes("SIDE_STORY"))
						|| (checkBox4.checked && item.relationType.includes("ALTERNATIVE"))
						|| (checkBox5.checked && item.relationType.some(type => ["ADAPTATION","CHARACTER","SUMMARY","SPIN_OFF","OTHER","SOURCE","COMPILATION","CONTAINS"].includes(type)))
					)
					&& (checkBox6.checked || item.isDropped.some(val => !val))
				){
					create("a",["link","newTab"],item.node.title.romaji,f_results,"display:block;padding:5px;")
						.href = "/manga/" + item.node.id;
					count++
				}
			});
			foundCount.innerText = "Found " + count + " manga:";
		};
		checkBox1.onchange = render;
		checkBox2.onchange = render;
		checkBox3.onchange = render;
		checkBox4.onchange = render;
		checkBox5.onchange = render;
		checkBox6.onchange = render;
		render();
	})
}},

{name: "Check compatibility with all following (slow)",setup: function(){
	create("span",false,"List Type: ",miscOptions);
	let select = create("select","#typeSelect",false,miscOptions);
	let animeOption = create("option",false,"Anime",select);
	let mangaOption = create("option",false,"Manga",select);
	animeOption.value = "ANIME";
	mangaOption.value = "MANGA";
},code: function(){
	miscResults.innerText = "";
	let loadingStatus = create("p",false,false,miscResults);
	loadingStatus.innerText = "Looking up ID...";
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		let userId = data.data.User.id;
		let currentLocation = location.pathname;
		loadingStatus.innerText = "Loading media list...";
		let typeList = document.getElementById("typeSelect").value + "";
		generalAPIcall(
			queryMediaListCompat,
			{
				name: user,
				listType: typeList
			},
			function(data){
				loadingStatus.innerText = "Loading users...";
				let comDisplay = create("div","hohComDisplay",false,miscResults);
				let list = returnList(data).filter(element => element.scoreRaw);
				let comCache = [];
				let drawComCache = function(){
					removeChildren(comDisplay)
					comCache.forEach(function(friend){
						let userRow = create("p",false,false,comDisplay);
						let differenceSpan = create("span",false,
							(friend.difference.toPrecision(3).includes("e") ? "0.000" : friend.difference.toPrecision(3)),
							userRow,"min-width:50px;display:inline-block;"
						);
						if(friend.difference < 0.9){
							differenceSpan.style.color = "green"
						}
						else if(friend.difference > 1.1){
							differenceSpan.style.color = "red"
						};
						userRow.appendChild(document.createTextNode(" "))
						let friendLink = create("a","newTab",friend.user,userRow,"color:rgb(var(--color-blue))");
						friendLink.href = "/user/" + friend.user;
						create("span",false,", " + friend.shared + " shared.",userRow)
					})
				};
				let friendsCaller = function(page){
					if(document.getElementById("typeSelect").value !== typeList){
						loadingStatus.innerText = "Query aborted";
						return
					}
					generalAPIcall(
						`query($id: Int!,$page: Int){
							Page(page: $page){
								pageInfo{
									lastPage
								}
								following(userId: $id,sort: USERNAME){
									name
								}
							}
						}`,
						{id: userId,page: page},
						function(data){
							let index = 0;
							let delayer = function(){
								if(location.pathname !== currentLocation){
									return
								}
								if(document.getElementById("typeSelect").value !== typeList){
									loadingStatus.innerText = "Query aborted";
									return
								}
								loadingStatus.innerText = "Comparing with " + data.data.Page.following[index].name + "...";
								compatCheck(list,data.data.Page.following[index].name,typeList,function(data){
									if(data.difference){
										comCache.push(data);
										comCache.sort((a,b) => a.difference - b.difference);
										drawComCache();
									}
								});
								if(++index < data.data.Page.following.length){
									setTimeout(delayer,1000)
								}
								else{
									if(page < data.data.Page.pageInfo.lastPage){
										friendsCaller(page + 1)
									}
									else{
										loadingStatus.innerText = ""
									}
								}
							};delayer(index);
						}
					)
				};friendsCaller(1);
			},"hohCompat" + typeList + user,5*60*1000
		);
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Message spy",code: function(){
	miscResults.innerText = "";
	let page = 1;
	let results = create("div",false,false,miscResults);
	let moreButton = create("button",["button","hohButton"],"Load more",miscResults);
	let getPage = function(page){
		generalAPIcall(`
query($page: Int){
	Page(page: $page){
		activities(type: MESSAGE,sort: ID_DESC){
			... on MessageActivity{
				id
				recipient{name}
				message(asHtml: true)
				pure:message(asHtml: false)
				createdAt
				messenger{name}
			}
		}
	}
}`,
			{page: page},
			data => {
				data.data.Page.activities.forEach(function(message){
					if(
						message.pure.includes("AWC")
						|| message.pure.match(/^.{0,8}(thanks|tha?n?x|thank|ty).*follow.{0,10}(http.*(jpg|png|gif))?.{0,10}$/i)
						|| message.pure.match(/for( the)? follow/i)
					){
						return
					};
					let time = new Date(message.createdAt*1000);
					let newElem = create("div","message",false,results);
					create("span","time",time.toISOString().match(/^(.*)\.000Z$/)[1] + " ",newElem);
					let user = create("a",["link","newTab"],message.messenger.name,newElem,"color:rgb(var(--color-blue))");
					user.href = "/user/" + message.messenger.name;
					create("span",false," sent a message to ",newElem);
					let user2 = create("a",["link","newTab"],message.recipient.name,newElem,"color:rgb(var(--color-blue))");
					user2.href = "/user/" + message.recipient.name;
					let link = create("a",["link","newTab"]," Link",newElem);
					link.href = "/activity/" + message.id;
					newElem.innerHTML += DOMPurify.sanitize(message.message);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
					create("hr",false,false,results);
				})
			}
		);
	};getPage(page);
	moreButton.onclick = function(){
		page++;
		getPage(page);
	}
}},

{name: "Media statistics of friends",code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		generalAPIcall(
			`
query($userId: Int!){
a1:Page(page:1){following(userId: $userId,sort: ID){... stuff}}
a2:Page(page:2){following(userId: $userId,sort: ID){... stuff}}
a3:Page(page:3){following(userId: $userId,sort: ID){... stuff}}
a4:Page(page:4){following(userId: $userId,sort: ID){... stuff}}
a5:Page(page:5){following(userId: $userId,sort: ID){... stuff}}
a6:Page(page:6){following(userId: $userId,sort: ID){... stuff}}
a7:Page(page:7){following(userId: $userId,sort: ID){... stuff}}
a8:Page(page:8){following(userId: $userId,sort: ID){... stuff}}
a9:Page(page:9){following(userId: $userId,sort: ID){... stuff}}
a10:Page(page:10){following(userId: $userId,sort: ID){... stuff}}
User(id: $userId){... stuff}
}

fragment stuff on User{
	name
	statistics{
		anime{
			count
			minutesWatched
		}
		manga{
			count
			chaptersRead
			volumesRead
		}
	}
	stats{
		watchedTime
		chaptersRead
	}
}`,
			{userId: data.data.User.id},
			function(stats){
				let userList = [].concat(
					...Object.keys(stats.data).map(
						a => stats.data[a].following || []
					)
				);
				userList.push(stats.data.User);
				//API error polyfill
				userList.forEach(function(wrong){
					if(!wrong.statistics.anime.minutesWatched){
						wrong.statistics.anime.minutesWatched = wrong.stats.watchedTime
					}
					if(!wrong.statistics.manga.chaptersRead){
						wrong.statistics.manga.chaptersRead = wrong.stats.chaptersRead
					}
				});
				userList.sort((b,a) => a.statistics.anime.minutesWatched - b.statistics.anime.minutesWatched);
				miscResults.innerText = "";
				let drawUserList = function(){
					removeChildren(miscResults)
					let table = create("div",["table","hohTable","hohNoPointer","good"],false,miscResults);
					let headerRow = create("div",["header","row"],false,table);
					let nameHeading = create("div",false,"Name",headerRow,"cursor:pointer;");
					let animeCountHeading = create("div",false,"Anime Count",headerRow,"cursor:pointer;");
					let animeTimeHeading = create("div",false,"Time Watched",headerRow,"cursor:pointer;");
					let mangaCountHeading = create("div",false,"Manga Count",headerRow,"cursor:pointer;");
					let mangaChapterHeading = create("div",false,"Chapters Read",headerRow,"cursor:pointer;");
					let mangaVolumeHeading = create("div",false,"Volumes Read",headerRow,"cursor:pointer;");
					userList.forEach(function(user,index){
						let row = create("div","row",false,table);
						if(user.name === stats.data.User.name || user.name === whoAmI){
							row.style.color = "rgb(var(--color-blue))";
							row.style.background = "rgb(var(--color-background))";
						}
						let nameCel = create("div",false,(index + 1) + " ",row);
						let userLink = create("a",["link","newTab"],user.name,nameCel);
						userLink.href = "/user/" + user.name;
						create("div",false,user.statistics.anime.count,row);
						let timeString = formatTime(user.statistics.anime.minutesWatched*60);
						if(!user.statistics.anime.minutesWatched){
							timeString = "-"
						}
						create("div",false,timeString,row).title = Math.round(user.statistics.anime.minutesWatched/60) + " hours";
						create("div",false,user.statistics.manga.count,row);
						if(user.statistics.manga.chaptersRead){
							create("div",false,user.statistics.manga.chaptersRead,row)
						}
						else{
							create("div",false,"-",row)
						}
						if(user.statistics.manga.volumesRead){
							create("div",false,user.statistics.manga.volumesRead,row)
						}
						else{
							create("div",false,"-",row)
						}
					});
					nameHeading.onclick = function(){
						userList.sort(ALPHABETICAL(a => a.name));
						drawUserList();
					};
					animeCountHeading.onclick = function(){
						userList.sort((b,a) => a.statistics.anime.count - b.statistics.anime.count);
						drawUserList();
					};
					animeTimeHeading.onclick = function(){
						userList.sort((b,a) => a.statistics.anime.minutesWatched - b.statistics.anime.minutesWatched);
						drawUserList();
					};
					mangaCountHeading.onclick = function(){
						userList.sort((b,a) => a.statistics.manga.count - b.statistics.manga.count);
						drawUserList();
					};
					mangaChapterHeading.onclick = function(){
						userList.sort((b,a) => a.statistics.manga.chaptersRead - b.statistics.manga.chaptersRead);
						drawUserList();
					};
					mangaVolumeHeading.onclick = function(){
						userList.sort((b,a) => a.statistics.manga.volumesRead - b.statistics.manga.volumesRead);
						drawUserList();
					};
				};drawUserList();
			}
		)
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Most popular favourites of friends",code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		generalAPIcall(
			`
query($userId: Int!){
a1:Page(page:1){following(userId: $userId,sort: ID){... stuff}}
a2:Page(page:2){following(userId: $userId,sort: ID){... stuff}}
a3:Page(page:3){following(userId: $userId,sort: ID){... stuff}}
a4:Page(page:4){following(userId: $userId,sort: ID){... stuff}}
a5:Page(page:5){following(userId: $userId,sort: ID){... stuff}}
a6:Page(page:6){following(userId: $userId,sort: ID){... stuff}}
a7:Page(page:7){following(userId: $userId,sort: ID){... stuff}}
a8:Page(page:8){following(userId: $userId,sort: ID){... stuff}}
a9:Page(page:9){following(userId: $userId,sort: ID){... stuff}}
a10:Page(page:10){following(userId: $userId,sort: ID){... stuff}}
User(id: $userId){... stuff}
}

fragment stuff on User{
	name
	favourites{
		anime1:anime(page:1){
			nodes{
				id
				title{romaji}
			}
		}
		anime2:anime(page:2){
			nodes{
				id
				title{romaji}
			}
		}
		manga1:manga(page:1){
			nodes{
				id
				title{romaji}
			}
		}
		manga2:manga(page:2){
			nodes{
				id
				title{romaji}
			}
		}
	}
}`,
			{userId: data.data.User.id},
			function(foll){
				if(!foll){
					create("h1",false,"Query failed!",miscResults,"color:rgb(var(--color-red))")
					return
				}
				let userList = [].concat(
					...Object.keys(foll.data).map(
						a => foll.data[a].following || []
					)
				);
				let me = foll.data.User;
				me.favourites.anime = me.favourites.anime1.nodes.concat(me.favourites.anime2.nodes);
				delete me.favourites.anime1;
				delete me.favourites.anime2;
				me.favourites.manga = me.favourites.manga1.nodes.concat(me.favourites.manga2.nodes);
				delete me.favourites.manga1;
				delete me.favourites.manga2;
				let animeFavs = {};
				let mangaFavs = {};
				userList.forEach(function(user){
					user.favourites.anime = user.favourites.anime1.nodes.concat(user.favourites.anime2.nodes);
					delete user.favourites.anime1;
					delete user.favourites.anime2;
					user.favourites.anime.forEach(fav => {
						if(animeFavs[fav.id]){
							animeFavs[fav.id].count++
						}
						else{
							animeFavs[fav.id] = {
								count: 1,
								title: fav.title.romaji
							}
						}
					});
					user.favourites.manga = user.favourites.manga1.nodes.concat(user.favourites.manga2.nodes);
					delete user.favourites.manga1;
					delete user.favourites.manga2;
					user.favourites.manga.forEach(fav => {
						if(mangaFavs[fav.id]){
							mangaFavs[fav.id].count++
						}
						else{
							mangaFavs[fav.id] = {
								count: 1,
								title: fav.title.romaji
							}
						}
					})
				});
				miscResults.innerText = "";
				create("h1",false,translate("$heading_anime"),miscResults,"color:rgb(var(--color-blue))");
				Object.keys(animeFavs).map(key => animeFavs[key]).sort((b,a) => a.count - b.count).slice(0,25).forEach(function(entry){
					create("p",false,entry.count + ": " + titlePicker({//pretend we have all this fancy API info
						title: {
							native: entry.title,
							romaji: entry.title,
							english: entry.title
						},
						id: parseInt(key)
					}),miscResults)
				});
				create("h1",false,translate("$heading_manga"),miscResults,"color:rgb(var(--color-blue))");
				Object.keys(mangaFavs).map(key => mangaFavs[key]).sort((b,a) => a.count - b.count).slice(0,25).forEach(function(entry){
					create("p",false,entry.count + ": " + titlePicker({
						title: {
							native: entry.title,
							romaji: entry.title,
							english: entry.title
						},
						id: parseInt(key)
					}),miscResults)
				});
				create("h1",false,translate("$heading_similarFavs"),miscResults,"color:rgb(var(--color-blue))");
				let sharePerc = user => {
					let total = user.favourites.anime.length + user.favourites.manga.length + me.favourites.anime.length + me.favourites.manga.length;
					let shared = user.favourites.anime.filter(
						a => me.favourites.anime.some(
							b => a.id === b.id
						)
					).length + user.favourites.manga.filter(
						a => me.favourites.manga.some(
							b => a.id === b.id
						)
					).length;
					return shared/total
				};
				userList.sort((b,a) => sharePerc(a) - sharePerc(b));
				userList.slice(0,20).forEach(entry => {
					let row = create("p",false,false,miscResults,"position: relative");
					create("a","newTab",entry.name,row)
						.href = "/user/" + entry.name;
					create("span",false,(sharePerc(entry)*200).toPrecision(3) + "%",row,"left: 300px;position: absolute")
				})
			}
		)
	},"hohIDlookup" + user.toLowerCase())
}},

{name: "Fix your dating mess",code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(iddata){
		let delay = 0;
		miscResults.innerText = "";
		removeChildren(miscResults)
		removeChildren(miscOptions)
		let config = [
			{
				description: "Completion date before start date",
				code: media => fuzzyDateCompare(media.startedAt,media.completedAt) === 0
			},{
				description: "Completion date before official end date",
				code: media => fuzzyDateCompare(media.media.endDate,media.completedAt) === 0
			},{
				description: "Start date before official release date",
				code: media => fuzzyDateCompare(media.media.startDate,media.startedAt) === 0
			},{
				description: "Status completed but no completion date set",
				code: media => media.status === "COMPLETED" && !media.completedAt.year
			},{
				description: "Status completed but no start date set",
				code: media => media.status === "COMPLETED" && !media.startedAt.year
			},{
				description: "Status dropped but no start date set",
				code: media => media.status === "DROPPED" && !media.startedAt.year
			},{
				description: "Status current but no start date set",
				code: media => media.status === "CURRENT" && !media.startedAt.year
			},{
				description: "Planning entry with start date",
				code: media => media.status === "PLANNING" && media.startedAt.year
			},{
				description: "Dates in the far future or past",
				code: media => (
						media.startedAt.year && (media.startedAt.year < 1960 || media.startedAt.year > (new Date().getFullYear() + 3))
					) || (
						media.completedAt.year && (media.completedAt.year < 1960 || media.completedAt.year > (new Date().getFullYear() + 3))
					)
			}
		];
		config.forEach(function(setting){
			let row = create("p",false,false,miscOptions);
			let checkBox = createCheckbox(row);
			let label = create("span",false,setting.description,row);
			checkBox.checked = true;
			checkBox.onchange = function(){
				Array.from(miscResults.children).forEach(res => {
					if(res.children[1].innerText === setting.description){
						if(checkBox.checked){
							res.style.display = "block"
						}
						else{
							res.style.display = "none"
						}
					}
				})
			}
		});
		let proc = function(data,type){
			let list = returnList(data,true);
			list.forEach(function(item){
				let matches = [];
				config.forEach(setting => {
					if(setting.code(item)){
						matches.push(setting.description)
					}
				});
				if(matches.length){
					let row = create("p",false,false,miscResults);
					let link = create("a",["link","newTab"],item.media.title.romaji,row,"width:440px;display:inline-block;");
					link.href = "/" + item.media.type.toLowerCase() + "/" + item.mediaId + "/" + safeURL(item.media.title.romaji);
					create("span",false,matches.join(", "),row);
					let chance = create("p",false,false,row,"margin-left:20px;margin-top: 2px;");
					create("span",false,"Entry created: " + (new Date(item.createdAt*1000)).toISOString().split("T")[0] + " \n",chance);
					if(
						(new Date(item.createdAt*1000)).toISOString().split("T")[0]
						!== (new Date(item.updatedAt*1000)).toISOString().split("T")[0]
					){
						create("span",false,"Entry updated: " + (new Date(item.updatedAt*1000)).toISOString().split("T")[0] + " \n",chance);
					}
					if(item.repeat){
						create("span",false,"Repeats: " + item.repeat + " \n",chance);
					}
					setTimeout(function(){
						generalAPIcall(
							`
							query($userId: Int,$mediaId: Int){
								first:Activity(userId: $userId,mediaId: $mediaId,sort: ID){... on ListActivity{createdAt siteUrl status progress}}
								last:Activity(userId: $userId,mediaId: $mediaId,sort: ID_DESC){... on ListActivity{createdAt siteUrl status progress}}
							}
							`,
							{
								userId: iddata.data.User.id,
								mediaId: item.mediaId
							},
							function(act){
								if(!act){return};
								let progressFirst = [act.data.first.status,act.data.first.progress].filter(TRUTHY).join(" ");
								progressFirst = (progressFirst ? " (" + progressFirst + ")" : "");
								let progressLast = [act.data.last.status,act.data.last.progress].filter(TRUTHY).join(" ");
								progressLast = (progressLast ? " (" + progressLast + ")" : "");
								if(act.data.first.siteUrl === act.data.last.siteUrl){
									let firstLink = create("a",["link","newTab"],"Only activity" + progressFirst + ": ",chance,"color:rgb(var(--color-blue));");
									firstLink.href = act.data.first.siteUrl;
									create("span",false,(new Date(act.data.first.createdAt*1000)).toISOString().split("T")[0] + " ",chance);
								}
								else{
									let firstLink = create("a",["link","newTab"],"First activity" + progressFirst + ": ",chance,"color:rgb(var(--color-blue));");
									firstLink.href = act.data.first.siteUrl;
									create("span",false,(new Date(act.data.first.createdAt*1000)).toISOString().split("T")[0] + " \n",chance);
									let lastLink = create("a",["link","newTab"],"Last activity" + progressLast + ": ",chance,"color:rgb(var(--color-blue));");
									lastLink.href = act.data.last.siteUrl;
									create("span",false,(new Date(act.data.last.createdAt*1000)).toISOString().split("T")[0] + " ",chance);
								}
							}
						);
					},delay);
					delay += 1000;
				}
			})
			create("p",false,type.toLowerCase() + " list completely scanned",miscResults)
		};
		const query = `query($name: String!, $listType: MediaType){
				MediaListCollection(userName: $name, type: $listType){
					lists{
						entries{
							startedAt{year month day}
							completedAt{year month day}
							mediaId
							status
							createdAt
							updatedAt
							repeat
							media{
								title{romaji english native}
								startDate{year month day}
								endDate{year month day}
								type
							}
						}
					}
				}
			}`;
		generalAPIcall(
			query,
			{
				name: user,
				listType: "MANGA"
			},
			function(data){proc(data,"MANGA")}
		);
		generalAPIcall(
			query,
			{
				name: user,
				listType: "ANIME"
			},
			function(data){proc(data,"ANIME")}
		)
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Fix your dating mess [Dangerous edition]",setup: function(){
	if(!useScripts.accessToken){
		miscResults.innerText = loginMessage;
		return
	};
	if(user.toLowerCase() !== whoAmI.toLowerCase()){
		miscResults.innerText = "This is the profile of\"" + user + "\", but currently signed in as \"" + whoAmI + "\". Are you sure this is right?";
		return
	};
	let warning = create("b",false,"Clicking on red buttons means changes to your data!",miscResults);
	let description = create("p",false,"When run, this will do the following:",miscResults);
	create("p",false,"- Completed entries with 1 episode/chapter, no rewatches, no start date, but a completion date will have the start date set equal to the completion date",miscResults);
	create("p",false,"- A list of all the changes will be printed.",miscResults);
	create("p",false,"- This will run slowly, and can be stopped at any time.",miscResults);
	let dryRun = create("button",["button","hohButton"],"Dry run",miscResults);
	let dryRunDesc = create("span",false,"(no changes made)",miscResults);
	create("hr",false,false,miscResults);
	let fullRun = create("button",["button","hohButton","danger"],"RUN",miscResults);
	let stopRun = create("button",["button","hohButton"],"Abort!",miscResults);
	create("hr",false,false,miscResults);
	let changeLog = create("div",false,false,miscResults);
	let allowRunner = true;
	let allowRun = true;
	let isDryRun = true;
	let list = [];
	let firstTime = true;
	let runner = function(){
		if(!allowRunner){
			return
		}
		allowRunner = false;
		fullRun.disabled = true;	
		dryRun.disabled = true;
		generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(iddata){
			let proc = function(data){
				list = list.concat((returnList(data,true) || []).filter(
					item => item.status === "COMPLETED" && (item.media.episodes || item.media.chapters) === 1 && (!item.startedAt.year) && item.completedAt.year && !item.repeat
				));
				if(firstTime){
					firstTime = false;
					return
				};
				if(isDryRun){
					create("p",false,"DRY RUN",changeLog)
				};
				if(!list.length){
					changeLog.innerText = "Found no entries to change";
					return
				};
				create("p",false,"Found " + list.length + " entries.",changeLog);
				let changer = function(index){
					if(!allowRun){
						return
					};
					create("p",false,list[index].media.title.romaji + " start date set to " + list[index].completedAt.year + "-" + list[index].completedAt.month + "-" + list[index].completedAt.day,changeLog);
					if(!isDryRun){
						authAPIcall(
							`mutation($date: FuzzyDateInput,$mediaId: Int){
								SaveMediaListEntry(startedAt: $date,mediaId: $mediaId){
									id
								}
							}`,
							{mediaId: list[index].mediaId,date: list[index].completedAt},
							data => {}
						)
					};
					index++;
					if(index < list.length){
						setTimeout(function(){changer(index)},1000)
					};
				};changer(0);
			};
			const query = `query($name: String!, $listType: MediaType){
					MediaListCollection(userName: $name, type: $listType){
						lists{
							entries{
								startedAt{year month day}
								completedAt{year month day}
								mediaId
								status
								repeat
								media{
									title{romaji english native}
									chapters
									episodes
								}
							}
						}
					}
				}`;
			generalAPIcall(
				query,
				{
					name: user,
					listType: "MANGA"
				},
				proc
			);
			generalAPIcall(
				query,
				{
					name: user,
					listType: "ANIME"
				},
				proc
			);
		},"hohIDlookup" + user.toLowerCase())
	};
	stopRun.onclick = function(){
		allowRun = false;
		stopRun.disable = true;
		alert("Stopped!")
	};
	fullRun.onclick = function(){
		isDryRun = false;
		runner()
	};
	dryRun.onclick = function(){
		runner()
	};
},code: function(){
	alert("Read the description first!")
}},

{name: "Note cleaner",
setup: function(){
	if(!useScripts.accessToken){
		miscResults.innerText = loginMessage;
		return
	};
	if(user.toLowerCase() !== whoAmI.toLowerCase()){
		miscResults.innerText = "This is the profile of\"" + user + "\", but currently signed in as \"" + whoAmI + "\". Are you sure this is right?";
		return
	};
	let warning = create("b",false,"Clicking on the red button means changes to your data!",miscResults);
	let description = create("p",false,"When run, this will remove all your list notes. You can not get them back",miscResults);
	create("hr",false,false,miscResults);
	let select = create("select","#typeSelect",false,miscOptions);
	let animeOption = create("option",false,"Anime",select);
	let mangaOption = create("option",false,"Manga",select);
	animeOption.value = "ANIME";
	mangaOption.value = "MANGA";
	let fullRun = create("button",["button","hohButton","danger"],"RUN",miscResults);
	create("hr",false,false,miscResults);
	let changeLog = create("div",false,false,miscResults);

	let runner = function(){
		authAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(iddata,error){
			if(!iddata){
				alert("ID lookup failed!");
				console.log(iddata,error);
				return
			}
			authAPIcall(` 
query ($type: MediaType $userId: Int) {
	MediaListCollection (type: $type userId: $userId ) {
		user {
			name
		}
		lists {
			entries {
				id
				notes
			}
		}
	}
}`,
			{type: select.value,userId: iddata.data.User.id},
			function(data){
				if(!data){
					alert("loading list failed!");
					return
				};
                   		let t = {};
				let mediaEntries = [];

				// Go through all lists
				data.data.MediaListCollection.lists.forEach((list) => {
					// Go through all entries of each list
					list.entries.forEach((entry) => {
						// If entry has notes, add it to the array
						if(entry.notes){
							mediaEntries.push(entry.id);
							t[entry.id] = entry.notes;
						}
					})
				});

				// Remove duplicates from the array
				mediaEntries = [... new Set(mediaEntries)];
				changeLog.innerText = JSON.stringify(t, null, 2);
				authAPIcall(
`mutation ($ids: [Int]) {
	UpdateMediaListEntries (ids: $ids notes: "") {
		id
		notes
	}
}`,
					{ids: mediaEntries},
					function(data){
						if(!data){
							alert("deleting notes failed!");
						}
						else{
							alert("notes deleted!");
						}
					}
				)
			})
		},"hohIDlookup" + user.toLowerCase())
	};
	fullRun.onclick = function(){
		runner()
	}
},code: function(){
	alert("Read the description first!")
}},

{name: "Reviews",code: function(){
	miscResults.innerText = "";
	let dataHeader = create("div",false,false,miscResults);
	create("span",false,"There are ",dataHeader);
	let data_amount = create("span",false,"[" + translate("$loading") + "]",dataHeader);
	create("span",false," reviews on Anilist, with ",dataHeader);
	let data_ratingAmount = create("span",false,"[" + translate("$loading") + "]",dataHeader);
	create("span",false," ratings (",dataHeader);
	let data_ratingPositive = create("span",false,"[" + translate("$loading") + "]",dataHeader);
	create("span",false,"% positive)",dataHeader);
	generalAPIcall(
		`query ($page: Int) {
			Page (page: $page) {
				pageInfo {
					total
					perPage
					currentPage
					lastPage
					hasNextPage
				}
				reviews {
					id
				}
			}
		}`,
		{page: 1},
		function(data){
			data_amount.innerText = data.data.Page.pageInfo.total;
			let list = [];
			let hasErrors = 0;
			for(var i=1;i<=data.data.Page.pageInfo.lastPage;i++){
				generalAPIcall(
					`query ($page: Int){
						Page (page: $page){
							pageInfo{
								total
								perPage
								currentPage
								lastPage
								hasNextPage
							}
							reviews{
								id
								rating
								ratingAmount
								score
								user{
									name
									id
								}
								media{
									id
									title{romaji}
								}
							}
						}
					}`,
					{page: i},
					function(reviewData){
						if(!reviewData){
							hasErrors++;
							if(i !== data.data.Page.pageInfo.lastPage){
								return
							}
						}
						list = list.concat(reviewData.data.Page.reviews);
						if(list.length !== reviewData.data.Page.pageInfo.total && (!hasErrors || i !== data.data.Page.pageInfo.lastPage)){
							return
						};
						list.sort((b,a) => wilson(a.rating,a.ratingAmount).left - wilson(b.rating,b.ratingAmount).left);
						if(hasErrors){
							create("p",false,"loading failed for " + (reviewData.data.Page.pageInfo.total - list.length) + " reviews!",miscResults)
						}
						create("h3",false,"100 best reviews on Anilist",miscResults);
						let datalist1 = create("div",false,false,miscResults);
						list.slice(0,100).forEach((review,index) => {
							let dataCel = create("p",false,false,datalist1);
							create("span",false,(index + 1) + ". ",dataCel,"width:35px;display:inline-block;");
							create("span","hohMonospace",wilson(review.rating,review.ratingAmount).left.toPrecision(3) + " ",dataCel);
							let userName = "[error]";
							if(review.user){
								if(review.user.name){
									userName = review.user.name
								}
							};
							create("a",["link","newTab"],userName + "'s  review of " + review.media.title.romaji,dataCel)
								.href = "/review/" + review.id
						});
						list.sort((a,b)=>wilson(a.rating,a.ratingAmount).right - wilson(b.rating,b.ratingAmount).right);
						create("h3",false,"100 worst reviews on Anilist",miscResults);
						let datalist2 = create("div",false,false,miscResults);
						list.slice(0,100).forEach((review,index) => {
							let dataCel = create("p",false,false,datalist2);
							create("span",false,(index + 1) + ". ",dataCel,"width:35px;display:inline-block;");
							create("span","hohMonospace",wilson(review.rating,review.ratingAmount).right.toPrecision(3) + " ",dataCel);
							let userName = "[error]";
							if(review.user){
								if(review.user.name){
									userName = review.user.name
								}
							};
							create("a",["link","newTab"],userName + "'s  review of " + review.media.title.romaji,dataCel)
								.href = "/review/" + review.id
						});
						let reviewers = new Map();
						let ratings = 0;
						let positiveRatings = 0;
						list.forEach(rev => {
							ratings += rev.ratingAmount;
							positiveRatings += rev.rating;
							if(rev.user){
								if(rev.user.id){
									if(!reviewers.has(rev.user.id)){
										reviewers.set(rev.user.id,{
											id: rev.user.id,
											name: rev.user.name,
											rating: 0,
											ratingAmount: 0,
											amount: 0
										})
									}
									let person = reviewers.get(rev.user.id);
									person.rating += rev.rating;
									person.ratingAmount += rev.ratingAmount;
									person.amount++;
								}
							}
						});
						data_ratingAmount.innerText = ratings;
						data_ratingPositive.innerText = Math.round(100 * positiveRatings/ratings);
						reviewers = [...reviewers].map(
							pair => pair[1]
						).sort(
							(b,a) => wilson(a.rating,a.ratingAmount).left - wilson(b.rating,b.ratingAmount).left
						);
						create("h3",false,"10 best reviewers on Anilist",miscResults);
						let datalist3 = create("div",false,false,miscResults);
						reviewers.filter(person => person.amount > 1).slice(0,10).forEach((rev,index) => {
							let dataCel = create("p",false,false,datalist3);
							create("span",false,(index + 1) + ". ",dataCel,"width:35px;display:inline-block;");
							create("span","hohMonospace",wilson(rev.rating,rev.ratingAmount).left.toPrecision(3) + " ",dataCel);
							let userName = rev.name || "[private or deleted]";
							let link = create("a",["link","newTab"],userName,dataCel,"color:rgb(var(--color-blue));");
							link.href = "/user/" + rev.name || "removed"
						});
						reviewers.sort((a,b) => wilson(a.rating,a.ratingAmount).right - wilson(b.rating,b.ratingAmount).right);
						create("h3",false,"10 worst reviewers on Anilist",miscResults);
						let datalist4 = create("div",false,false,miscResults);
						reviewers.slice(0,10).forEach((rev,index) => {
							let dataCel = create("p",false,false,datalist4);
							create("span",false,(index + 1) + ". ",dataCel,"width:35px;display:inline-block;");
							create("span","hohMonospace",wilson(rev.rating,rev.ratingAmount).right.toPrecision(3) + " ",dataCel);
							let userName = rev.name || "[private or deleted]";
							let link = create("a",["link","newTab"],userName,dataCel,"color:rgb(var(--color-blue));");
							link.href = "/user/" + rev.name || "removed"
						});
						reviewers.sort(function(b,a){
							if(a.amount === b.amount){//rating as tie-breaker
								return a.rating/a.ratingAmount - b.rating/b.ratingAmount;
							}
							else{
								return a.amount - b.amount
							}
						});
						create("h3",false,"25 most prolific reviewers on Anilist",miscResults);
						let datalist5 = create("div",false,false,miscResults);
						let profilicSum = 0;
						reviewers.slice(0,25).forEach((rev,index) => {
							profilicSum += rev.amount;
							let dataCel = create("p",false,false,datalist5);
							create("span",false,(index + 1) + ". ",dataCel,"width:35px;display:inline-block;");
							create("span","hohMonospace",rev.amount + " ",dataCel);
							let userName = rev.name || "[private or deleted]";
							let link = create("a",["link","newTab"],userName,dataCel,"color:rgb(var(--color-blue));");
							link.href = "/user/" + rev.name || "removed";
							create("span",false," average rating: " + (100*rev.rating/rev.ratingAmount).toPrecision(2) + "%",dataCel)
						});
						create("p",false,"That's " + Math.round(100*profilicSum/list.length) + "% of all reviews on Anilist",miscResults);
						let average = (data.data.Page.pageInfo.total/reviewers.length).toPrecision(2);
						let median = Stats.median(reviewers.map(e => e.amount));
						let mode = Stats.mode(reviewers.map(e => e.amount));
						create("p",false,`${reviewers.length} users have contributed reviews (${average} reviews each on average, median ${median}, mode ${mode})`,miscResults);
						let lowRatingRating = 0;
						let lowRatingAmount = 0;
						let lowRatingCount = 0;
						let highRatingRating = 0;
						let highRatingAmount = 0;
						let highRatingCount = 0;
						let topRatingRating = 0;
						let topRatingAmount = 0;
						let topRatingCount = 0;
						let distribution = new Array(101).fill(0);//0 to 100 inclusive, since 0 is a valid review score
						create("hr",false,false,miscResults);
						list.forEach(review => {
							distribution[review.score]++;
							if(review.score <= 50){
								lowRatingRating += review.rating;
								lowRatingAmount+= review.ratingAmount;
								lowRatingCount++
							}
							else{
								highRatingRating += review.rating;
								highRatingAmount+= review.ratingAmount;
								highRatingCount++;
								if(review.score == 100){
									topRatingRating += review.rating;
									topRatingAmount+= review.ratingAmount;
									topRatingCount++
								}
							}
						});
						create("p",false,"The " + lowRatingCount + " reviews with a score 0-50 are rated " + (100*lowRatingRating/lowRatingAmount).toPrecision(2) + "% on average.",miscResults);
						create("p",false,"The " + highRatingCount + " reviews with a score 51-100 are rated " + (100*highRatingRating/highRatingAmount).toPrecision(2) + "% on average.",miscResults);
						create("p",false,"The " + topRatingCount + " reviews with a score 100/100 are rated " + (100*topRatingRating/topRatingAmount).toPrecision(2) + "% on average.",miscResults);

						create("p",false,"The average score for a review to give is " + Stats.average(list.map(e => e.score)).toPrecision(3) + "/100.",miscResults);
						create("p",false,"The median score for a review to give is " + Stats.median(list.map(e => e.score)).toPrecision(3) + "/100.",miscResults);
						create("p",false,"The most common score for a review to give is " + Stats.mode(list.map(e => e.score)).toPrecision(3) + "/100.",miscResults);
						const height = 250;
						const width = 700;
						let dia = svgShape("svg",miscResults,{
							width: width,
							height: height,
							viewBox: "0 0 " + width + " " + height
						});
						dia.style.borderRadius = "3px";
						let background = svgShape("rect",dia,{
							fill: "rgb(var(--color-foreground))",
							x: 0,
							y: 0,
							width: "100%",
							height: "100%"
						});
						let margin = {
							bottom: 30,
							top: 30,
							left: 20,
							right: 20
						};
						const bars = 101;
						const barWidth = 0.74 * (width - margin.left - margin.right)/bars;
						const barSpacing = 0.24 * (width - margin.left - margin.right)/bars;
						let maxVal = Math.max(...distribution);
						let magnitude = Math.pow(10,Math.floor(Math.log10(maxVal)));
						let mantissa = maxVal/magnitude;
						if(mantissa < 1.95){
							maxVal = 2*magnitude
						}
						else if(mantissa < 2.95){
							maxVal = 3*magnitude
						}
						else if(mantissa < 4.9){
							maxVal = 5*magnitude
						}
						else if(mantissa < 9.8){
							maxVal = 10*magnitude
						}
						else{
							maxVal = 15*magnitude
						};
						let valueFunction = function(val){
							return height - margin.bottom - (val/maxVal) * (height - margin.bottom - margin.top)
						};
						let title = svgShape("text",dia,{
							x: 10,
							y: 20,
							fill: "rgb(var(--color-text))"
						});
						title.textContent = "Review score distribution";
						distribution.forEach((val,index) => {
							if(!val){
								return;
							}
							let colour = "rgb(var(--color-text))";
							if(index % 10 === 0){
								colour = "rgb(61,180,242)";
								let text = svgShape("text",dia,{
									x: margin.left + index*barWidth + index*barSpacing + barWidth/2,
									y: valueFunction(val) - barWidth,
									fill: colour,
									"text-anchor": "middle",
								});
								text.textContent = val;
								let text2 = svgShape("text",dia,{
									x: margin.left + index*barWidth + index*barSpacing + barWidth/2,
									y: height - margin.bottom + 3*barWidth,
									fill: colour,
									"text-anchor": "middle",
								});
								text2.textContent = index;
							}
							else if(index % 10 === 5){
								colour = "rgb(123,213,85)"
							}
							svgShape("rect",dia,{
								x: margin.left + index*barWidth + index*barSpacing,
								y: valueFunction(val),
								width: barWidth,
								height: height - valueFunction(val) - margin.bottom,
								fill: colour
							})
						})
					}
				)
			}
		}
	)
}},

{name: "How many people have blocked you",code: function(){
	if(!useScripts.accessToken){
		miscResults.innerText = loginMessage;
		return
	}
	authAPIcall("query{Page{pageInfo{total}users{id}}}",{},function(data){
		generalAPIcall("query{Page{pageInfo{total}users{id}}}",{},function(data2){
			miscResults.innerText = "This only applies to you, regardless of what stats page you ran this query from.";
			if(data.data.Page.pageInfo.total === data2.data.Page.pageInfo.total){
				create("p",false,"No users have blocked you",miscResults)
			}
			else if((data2.data.Page.pageInfo.total - data.data.Page.pageInfo.total) < 0){
				create("p",false,"Error: The elevated privileges of moderators makes this query fail",miscResults)
			}
			else{
				create("p",false,(data2.data.Page.pageInfo.total - data.data.Page.pageInfo.total) + " users have blocked you",miscResults)
			}
		})
	})
}},

{name: "Find people you have blocked/are blocked by",code: function(){
	if(!useScripts.accessToken){
		miscResults.innerText = loginMessage;
		return
	}
	miscResults.innerText = `This only applies to you, regardless of what stats page you ran this query from. Furthermore, it probably won't find everyone.
Use the other query if you just want the number.`;
	let flag = true;
	let stopButton = create("button",["button","hohButton"],"Stop",miscResults,"display:block");
	let progress = create("p",false,false,miscResults);
	stopButton.onclick = function(){
		flag = false
	};
	let blocks = new Set();
	progress.innerText = "1 try..."
	let caller = function(page,page2){
		generalAPIcall(`
query($page: Int){
	Page(page: $page){
		activities(sort: ID_DESC,type: TEXT){
			... on TextActivity{
				id
				user{name}
			}
		}
	}
}`,
		{page: page},function(data){
			progress.innerText = (page + 1) + " tries...";
			authAPIcall(`
query($page: Int){
	Page(page: $page){
		activities(sort: ID_DESC,type: TEXT){
			... on TextActivity{
				id
			}
		}
	}
}`,						{page: page2},function(data2){
				let offset = 0;
				while(data2.data.Page.activities[offset].id > data.data.Page.activities[0].id){
					offset++
				};
				while(data2.data.Page.activities[0].id < data.data.Page.activities[-offset].id){
					offset--
				};
				for(var k=Math.max(-offset,0);k<data.data.Page.activities.length && (k + offset)<data2.data.Page.activities.length;k++){
					if(data.data.Page.activities[k].id !== data2.data.Page.activities[k + offset].id){
						offset--;
						if(!blocks.has(data.data.Page.activities[k].user.name)){
							let row = create("p",false,false,miscResults);
							let link = create("a",["link","newTab"],data.data.Page.activities[k].user.name,row);
							link.href = "/user/" + data.data.Page.activities[k].user.name;
							blocks.add(data.data.Page.activities[k].user.name)
						}
					};
				};
				if(flag){
					if(offset < -50){
						page2--
					};
					setTimeout(function(){caller(page + 1,page2 + 1)},2000)
				}
			})
		});
	};caller(1,1);
}},

{name: "BroomCat linter",setup: function(){
	create("p",false,"Welcome to BroomCat. It will help you find stray database items",miscOptions);
	let select = create("select","#typeSelect",false,miscOptions);
	let animeOption = create("option",false,"Anime",select);
	let mangaOption = create("option",false,"Manga",select);
	animeOption.value = "ANIME";
	mangaOption.value = "MANGA";
	createCheckbox(miscOptions,"restrictToList");
	create("span",false,"Restrict to personal list",miscOptions);
	create("h3",false,"Config",miscOptions);
	let conf = function(description,id,defaultValue,titleText){
		let option = create("p",false,false,miscOptions);
		let check = createCheckbox(option,id);
		let descriptionText = create("span",false,description + " ",option);
		if(defaultValue){
			check.checked = defaultValue
		}
		if(titleText){
			descriptionText.title = titleText
		}
	};
	[
		["End date before start date","startEnd",true],
		["Dates before 1900","earlyDates",true],
		["Missing dates","missingDates",true],
		["Incomplete dates","incompleteDates"],
		["No tags","noTags"],
		["No genres","noGenres"],
		["Duplicate tags","doubleTags",false,"Has a tag appearing twice, which is not valid"],
		["Has tag below 20%","lowTag",false,"Tags start out at 20%, so if it's below it's controversial"],
		["Has invalid genre","badGenre",true,"There's a fixed list of 19 genres, so anything else must be wrong"],
		["Missing banner","noBanner"],
		["Oneshot without one chapter","oneshot",false,"This is a requirement in the documentation"],
		["Missing MAL ID","idMal",false,"Anilist stores MAL IDs to make list imports and interactions between databases simpler"],
		["Duplicated MAL ID","duplicatedMALID"],
		["Missing native title","nativeTitle",true,"Everything has a native title, even if it's the same"],
		["Missing english title","englishTitle",false,"Not necessarily wrong, not everything is licensed"],
		["No duration","noDuration",true],
		["No chapter or episode count","noLength",true],
		["Multiple demographic tags","demographics"],
		["No studios","noStudios"],
		["Unusual length","unusualLength",true,"Doesn't have to be wrong, just check them"],
		["No source","noSource"],
		["Source = other","otherSource",false,"Anilist introduced new sources, so some of these may need to be changed"],
		["Source = original, but has source relation","badOriginalSource"],
		["More than one source","moreSource",false,"Doesn't have to be wrong, but many of these are"],
		["Adaptation older than source","newSource"],
		["Source field not equal to source media format","formatSource"],
		["Hentai with isAdult = false","nonAdultHentai"],
		["Synonym equal to title","redundantSynonym",true],
		["No extraLarge cover image","extraLarge"],
		["Temporary title","tempTitle",true,"Common for manga announcements"],
		["Romaji inconsistencies","badRomaji",true,"Catches some common romanisation errors"],
		["Weird spacing in title","weirdSpace",true],
		["TV/TV Short mixup","tvShort"],
		["Duplicated studio","duplicatedStudio"],
		["Has Twitter hashtag","hashtag",false,"Keep up with news"],
		["Releasing manga with non-zero chapter or volume count","releasingZero"],
		["Bad character encoding in description","badEncoding"],
		["Commonly misspelled words in description","badSpelling",true],
		["No description (or very short)","noDescription",true],
		["Very long description","longDescription"],
		["Likely outdated description","outdatedDescription",true,"Checks if the description appears to have been written before the series aired"]
	].forEach(ig => conf(...ig));
},code: function(){
	let type = document.getElementById("typeSelect").value;
	let restrict = document.getElementById("restrictToList").checked;
	let require = new Set();
	let malIDs = new Set();
	let config = [
		{name: "startEnd",description: "End date before start date",code: function(media){
			if(!media.startDate.year || !media.endDate.year){
				return false
			}
			if(media.startDate.year > media.endDate.year){
				return true
			}
			else if(media.startDate.year < media.endDate.year){
				return false
			}
			if(!media.startDate.month || !media.endDate.month){
				return false
			}
			if(media.startDate.month > media.endDate.month){
				return true
			}
			else if(media.startDate.month < media.endDate.month){
				return false
			}
			if(!media.startDate.day || !media.endDate.day){
				return false
			}
			if(media.startDate.day > media.endDate.day){
				return true
			}
			return false;
		},require: ["startDate{year month day}","endDate{year month day}"]},
		{name: "earlyDates",description: "Dates before 1900",code: function(media){
			return (media.startDate.year && media.startDate.year < 1900) || (media.endDate.year && media.endDate.year < 1900)
		},require: ["startDate{year month day}","endDate{year month day}"]},
		{name: "missingDates",description: "Missing dates",code: function(media){
			if(media.status === "FINISHED"){
				return (!media.startDate.year) || (!media.endDate.year);
			}
			else if(media.status === "RELEASING"){
				return !media.startDate.year;
			}
			return false;
		},require: ["startDate{year month day}","endDate{year month day}","status"]}
,
		{name: "incompleteDates",description: "Incomplete dates",code: function(media){
			if(media.status === "FINISHED"){
				return (!media.startDate.year) || (!media.startDate.month) || (!media.startDate.day) || (!media.endDate.year) || (!media.endDate.month) || (!media.endDate.day);
			}
			else if(media.status === "RELEASING"){
				return (!media.startDate.year) || (!media.startDate.month) || (!media.startDate.day)
			}
			return false;
		},require: ["startDate{year month day}","endDate{year month day}","status"]},
		{name: "noTags",description: "No tags",code: function(media){
			return media.tags.length === 0;
		},require: ["tags{rank name}"]},
		{name: "doubleTags",description: "Duplicate tags",code: function(media){
			return new Set(media.tags.map(a => a.name)).size !== media.tags.length
		},require: ["tags{rank name}"]},
		{name: "noGenres",description: "No genres",code: function(media){
			return media.genres.length === 0;
		},require: ["genres"]},
		{name: "lowTag",description: "Has tag below 20%",code: function(media){
			return media.tags.some(tag => tag.rank < 20);
		},require: ["tags{rank name}"]},
		{name: "demographics",description: "Multiple demographic tags",code: function(media){
			return media.tags.filter(tag => ["Shounen","Shoujo","Josei","Seinen","Kids"].includes(tag.name)).length > 1;
		},require: ["tags{rank name}"]},
		{name: "badGenre",description: "Has invalid genre",code: function(media){
			return media.genres.some(genre => !["Action","Adventure","Comedy","Drama","Ecchi","Fantasy","Hentai","Horror","Mahou Shoujo","Mecha","Music","Mystery","Psychological","Romance","Sci-Fi","Slice of Life","Sports","Supernatural","Thriller"].includes(genre));
		},require: ["genres"]},
		{name: "noBanner",description: "Missing banner",code: function(media){
			return !media.bannerImage
		},require: ["bannerImage"]},
		{name: "oneshot",description: "Oneshot without one chapter",code: function(media){
			return media.format === "ONE_SHOT" && media.chapters !== 1;
		},require: ["chapters"]},
		{name: "idMal",description: "Missing MAL ID",code: function(media){
			return !media.idMal
		},require: ["idMal"]},
		{name: "duplicatedMALID",description: "Duplicated MAL ID",code: function(media){
			if(media.idMal){
				if(malIDs.has(media.idMal)){
					return true
				}
				else{
					malIDs.add(media.idMal)
					return false
				}
			}
		},require: ["idMal"]},
		{name: "nativeTitle",description: "Missing native title",code: function(media){
			return !media.title.native
		}},
		{name: "englishTitle",description: "Missing english title",code: function(media){
			return !media.title.english
		}},
		{name: "noDuration",description: "No duration",code: function(media){
			return media.type === "ANIME" && media.status !== "NOT_YET_RELEASED" && !media.duration;
		},require: ["type","duration","status"]},
		{name: "noLength",description: "No chapter or episode count",code: function(media){
			if(media.status !== "FINISHED"){
				return false
			}
			if(media.type === "ANIME"){
				return !media.episodes
			}
			else{
				return !media.chapters
			}
		},require: ["type","chapters","episodes","status"]},
		{name: "noStudios",description: "No studios",code: function(media){
			return media.type === "ANIME" && !media.studios.nodes.length;
		},require: ["type","studios{nodes{id}}"]},
		{name: "unusualLength",description: "Unusual Length",code: function(media){
			if(media.type === "ANIME"){
				return (media.episodes && media.episodes > 1000) || (media.duration && media.duration > 180);
			}
			else{
				return (media.cahpters && media.chapters > 2000) || (media.volumes && media.volumes > 150);
			}
		},require: ["type","chapters","volumes","duration","episodes"]},
		{name: "noSource",description: "No source",code: function(media){
			return !media.source;
		},require: ["source(version: 2)"]},
		{name: "otherSource",description: "Source = other",code: function(media){
			return (media.source && media.source === "OTHER");
		},require: ["source(version: 2)"]},
		{name: "badOriginalSource",description: "Source = original, but has source relation",code: function(media){
			let source = media.sourcing.edges.filter(edge => edge.relationType === "SOURCE");
			return source.length && (media.source && media.source === "ORIGINAL")
		},require: ["source(version: 2)","sourcing:relations{edges{relationType(version: 2) node{format startDate{year month day}}}}"]},
		{name: "redundantSynonym",description: "Synonym equal to title",code: function(media){
			return media.synonyms.some(
				word => word === media.title.romaji
			)
			|| (media.title.native && media.synonyms.some(
				word => word === media.title.native
			))
			|| (media.title.english && media.synonyms.some(
				word => word === media.title.english
			));
		},require: ["synonyms"]},
		{name: "hashtag",description: "Has Twitter hashtag",code: function(media){
			return !!media.hashtag;
		},require: ["hashtag"]},
		{name: "nonAdultHentai",description: "Hentai with isAdult = false",code: function(media){
			return (media.genres.includes("Hentai") && !media.isAdult);
		},require: ["genres","isAdult"]},
		{name: "extraLarge",description: "No extraLarge cover image",code: function(media){
			return media.coverImage.large && media.coverImage.large === media.coverImage.extraLarge;
		},require: ["coverImage{large extraLarge}"]},
		{name: "tempTitle",description: "Temporary title",code: function(media){
			return media.title.romaji.toLowerCase() === "(Title to be Announced)".toLowerCase()
				|| (media.title.native && media.title.native.toLowerCase() === "(Title to be Announced)".toLowerCase())
				|| media.title.romaji.includes("(Provisional Title)")
				|| (media.title.native && media.title.native.includes("（仮）"));
		}},
		{name: "badRomaji",description: "Romaji inconsistencies",code: media =>
			["～","「","」","ō","ū","。","！","？","Toukyou","Oosaka"].some(
				char => media.title.romaji.includes(char)
			) || (
				media.title.native && (
					(media.title.native.includes("っち") && media.title.romaji.includes("tchi"))
					|| (media.title.native.includes("っちゃ") && media.title.romaji.includes("tcha"))
					|| (media.title.native.includes("っちょ") && media.title.romaji.includes("tcho"))
					|| (media.title.native.includes("☆") && !media.title.romaji.includes("☆"))
					|| (media.title.native.includes("♪") && !media.title.romaji.includes("♪"))
				)
			)
		},
		{name: "weirdSpace",description: "Weird spacing in title",code: function(media){
			return (
				(media.title.native || "").trim().replace("  "," ") !== (media.title.native || "")
				|| (media.title.romaji || "").trim().replace("  "," ") !== (media.title.romaji || "")
				|| (media.title.english || "").trim().replace("  "," ") !== (media.title.english || "")
			)
		},require: ["duration"]},
		{name: "tvShort",description: "TV/TV Short mixup",code: function(media){
			if(media.duration){
				return (media.format === "TV" && media.duration < 15) || (media.format === "TV_SHORT" && media.duration >= 15)
			}
			return false;
		},require: ["duration"]},
		{name: "newSource",description: "Adaptation older than source",code: function(media){
			return media.sourcing.edges.some(function(edge){
				if(edge.relationType === "SOURCE"){
					return fuzzyDateCompare(edge.node.startDate,media.startDate) === 0
				}
				return false
			})
		},require: ["startDate{year month day}","sourcing:relations{edges{relationType(version: 2) node{format startDate{year month day}}}}"]},
		{
			name: "moreSource",
			description: "More than one source",
			code: media => media.sourcing.edges.filter(edge => edge.relationType === "SOURCE").length > 1
				&& ![477,6].includes(media.id),//aria, trigun
			require: ["startDate{year month day}","sourcing:relations{edges{relationType(version: 2) node{format startDate{year month day}}}}"]
		},
		{name: "formatSource",description: "Source field not equal to source media format",code: function(media){
			let source = media.sourcing.edges.filter(edge => edge.relationType === "SOURCE");
			return source.length && media.source
				&& (
					(source[0].node.format !== media.source)
					&& !(source[0].node.format === "NOVEL" && media.source === "LIGHT_NOVEL")
				)
		},require: ["source(version: 2)","sourcing:relations{edges{relationType(version: 2) node{format startDate{year month day}}}}"]},
		{name: "releasingZero",description: "Releasing manga with non-zero chapter or volume count",code: function(media){
			return media.format === "MANGA" && media.status === "RELEASING" && (media.chapters || media.volumes)
		},require: ["status","chapters","volumes"]},
		{name: "duplicatedStudio",description: "Duplicated studio",code: function(media){
			return (new Set(media.studios.nodes)).size !== media.studios.nodes.length;
		},require: ["studios{nodes{id}}"]},
		{
			name: "badEncoding",
			description: "Bad character encoding in description",
			code: media => {
				return ["</br>","&#39","[1]","[2]","â€™"].some(error => media.description.includes(error))
			},
			require: ["description"]
		},
		{
			name: "badSpelling",
			description: "Bad character encoding in description",
			code: media => {
				return ["animes ","mangas "].some(error => media.description.includes(error))
			},
			require: ["description"]
		},
		{
			name: "noDescription",
			description: "No description",
			code: media => media.description.length < 15,
			require: ["description"]
		},
		{
			name: "longDescription",
			description: "Very long description",
			code: media => media.description.length > 4000,
			require: ["description"]
		},
		{
			name: "outdatedDescription",
			description: "Likely outdated description",
			code: media => [
"upcoming adaptation","will cover","sceduled for","next year","will adapt","announced","will air"," tba"
			].some(text => media.description.toLowerCase().includes(text)) && media.status === "FINISHED",
			require: ["description","status"]
		}
	];
	config.forEach(function(setting){
		setting.active = document.getElementById(setting.name).checked;
		if(setting.active && setting.require){
			setting.require.forEach(field => require.add(field))
		}
	});
	let query = `
query($type: MediaType,$page: Int){
	Page(page: $page){
		pageInfo{
		currentPage
		lastPage
	}
	media(type: $type,sort: POPULARITY_DESC){
		id
		title{romaji native english}
		format
		${[...require].join(" ")}
		}
	}
}`;
	if(restrict){
		query = `
query($type: MediaType,$page: Int){
	Page(page: $page){
		pageInfo{
			currentPage
			lastPage
		}
		mediaList(type: $type,sort: MEDIA_ID,userName: "${user}"){
			media{
				id
				title{romaji native english}
				format
				${[...require].join(" ")}
			}
		}
	}
}`;
	}
	miscResults.innerText = "";
	let flag = true;
	let stopButton = create("button",["button","hohButton"],"Stop",miscResults);
	let progress = create("p",false,false,miscResults);
	stopButton.onclick = function(){
		flag = false;
	};
	let caller = function(page){
		generalAPIcall(query,{type: type,page: page},function(data){
			data = data.data.Page;
			if(data.mediaList){
				data.media = data.mediaList.map(item => item.media);
			};
			data.media.forEach(media => {
				progress.innerText = "Page " + page + " of " + data.pageInfo.lastPage;
				let matches = config.filter(
					setting => setting.active && setting.code(media)
				).map(setting => setting.description);
				if(matches.length){
					let row = create("p",false,false,miscResults);
					create("a",["link","newTab"],"[" + media.format + "] " + media.title.romaji,row,"width:440px;display:inline-block;")
						.href = "/" + type.toLowerCase() + "/" + media.id;
					create("span",false,matches.join(", "),row);
				};
			});
			if(flag && data.pageInfo.currentPage < data.pageInfo.lastPage && document.getElementById("queryOptions")){
				setTimeout(function(){caller(page + 1)},1000)
			}
		});
	};caller(1);
}},

{name: translate("$query_autorecs"),
	setup: function(){
		let select = create("select","#typeSelect",false,miscOptions);
		let animeOption = create("option",false,translate("$generic_anime"),select);
		let mangaOption = create("option",false,translate("$generic_manga"),select);
		animeOption.value = "ANIME";
		mangaOption.value = "MANGA";
		if(useScripts.mangaBrowse){
			select.selectedIndex = 1
		}
	},
	code: function(){
	miscResults.innerText = translate("$query_autorecs_collecting");
	generalAPIcall(
		`query($name: String!){
			User(name: $name){
				statistics{
					${document.getElementById("typeSelect").value.toLowerCase()}{
						meanScore
						standardDeviation
					}
				}
			}
			MediaListCollection(userName: $name,type: ${document.getElementById("typeSelect").value}){
				lists{
					entries{
						mediaId
						score(format: POINT_100)
						status
						media{
							recommendations(sort:RATING_DESC,perPage:5){
								nodes{
									rating
									mediaRecommendation{
										id
										title{romaji native english}
									}
								}
							}
						}
					}
				}
			}
		}`,
		{name: user},function(data){
			miscResults.innerText = translate("$query_autorecs_processing");
			if(!data){
				miscResults.innerText = translate("$error_connection");
				return
			}
			const filtered = returnList(data,true);
			const list = filtered.filter(
				media => media.status !== "PLANNING"
			);
			const existingSet = new Set(
				list.map(media => media.mediaId)
			);
			const existingSet_planning = new Set(
				filtered.filter(
					media => media.status === "PLANNING"
				).map(media => media.mediaId)
			);
			const statistics = data.data.User.statistics[document.getElementById("typeSelect").value.toLowerCase()];
			const recsMap = new Map();
			list.filter(
				media => media.score
			).forEach(media => {
				let adjustedScore = (media.score - statistics.meanScore)/statistics.standardDeviation;
				media.media.recommendations.nodes.forEach(rec => {
					if(
						rec.mediaRecommendation
						&& !existingSet.has(rec.mediaRecommendation.id)
						&& rec.rating > 0
					){
						if(!recsMap.has(rec.mediaRecommendation.id)){
							recsMap.set(
								rec.mediaRecommendation.id,
								{title: titlePicker(rec.mediaRecommendation),score: 0}
							)
						}
						recsMap.get(rec.mediaRecommendation.id).score += adjustedScore * (2 - 1/rec.rating)
					}
				})
			});
			miscResults.innerText = translate("$query_autorecs_info");
			[...recsMap].map(
				pair => ({
					id: pair[0],
					title: pair[1].title,
					score: (existingSet_planning.has(pair[0]) ? pair[1].score - 2 : pair[1].score)//punish stuff already on planning
				})
			).sort(
				(b,a) => a.score - b.score
			).slice(0,25).forEach(rec => {
				let card = create("p",false,false,miscResults);
				let score = create("span","hohMonospace",rec.score.toPrecision(3) + " ",card,"margin-right:10px;");
				create("a",false,rec.title,card)
					.href = "/" + document.getElementById("typeSelect").value.toLowerCase() + "/" + rec.id + "/"
			})
		}
	)
}},

{name: "Find a status",setup: function(){
	let input = create("input","#searchInput",false,miscOptions);
	input.placeholder = "text or regex to match";
},code: function(){
	let searchQuery = document.getElementById("searchInput").value;
	if(statusSearchCache.length){
		miscResults.innerText = "";
		let results = create("p",false,false,miscResults);
		statusSearchCache.forEach(act => {
			if(act.text.match(new RegExp(searchQuery,"i")) || act.text.includes(searchQuery)){
				let newDate = create("p",false,false,results,"font-family:monospace;margin-right:10px;");
				let newPage = create("a","newTab",act.siteUrl,newDate,"color:rgb(var(--color-blue));");
				newPage.href = act.siteUrl;
				newDate.innerHTML += DOMPurify.sanitize(act.text);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
				create("hr",false,false,results)
			}
		})
	}
	else{
		generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
			const query = `
			query($userId: Int,$page: Int){
				Page(page: $page){
					pageInfo{
						currentPage
						total
						lastPage
					}
					activities (userId: $userId, sort: ID_DESC, type: TEXT){
						... on TextActivity{
							siteUrl
							text(asHtml: true)
						}
					}
				}
			}`;
			miscResults.innerText = "";
			let results = create("p",false,false,miscResults);
			let posts = 0;
			let progress = create("p",false,false,miscResults);
			let userId = data.data.User.id;
			let addNewUserData = function(data){
				console.log(data);
				if(!data){
					return
				}
				if(data.data.Page.pageInfo.currentPage === 1){
					for(var i=2;i<=data.data.Page.pageInfo.lastPage && i < ANILIST_QUERY_LIMIT;i++){
						generalAPIcall(query,{userId: userId,page: i},addNewUserData)
					}
				};
				posts += data.data.Page.activities.length;
				progress.innerText = "Searching status post " + posts + "/" + data.data.Page.pageInfo.total;
				data.data.Page.activities.forEach(act => {
					if(act.text.match(new RegExp(searchQuery,"i")) || act.text.includes(searchQuery)){
						let newDate = create("p",false,false,results,"font-family:monospace;margin-right:10px;");
						let newPage = create("a","newTab",act.siteUrl,newDate,"color:rgb(var(--color-blue));");
						newPage.href = act.siteUrl;
						newDate.innerHTML += DOMPurify.sanitize(act.text);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
						create("hr",false,false,results)
					}
					statusSearchCache.push(act)
				})
			};
			generalAPIcall(query,{userId: userId,page: 1},addNewUserData);
		},"hohIDlookup" + user.toLowerCase())
	}
}},

{name: "Find a message",setup: function(){
	let input = create("input","#searchInput",false,miscOptions);
	input.placeholder = "text or regex to match";
},code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		let userId = data.data.User.id;
		miscResults.innerText = "";
		let posts = 0;
		let progress = create("p",false,false,miscResults);
		let results = create("p",false,false,miscResults);
		let searchQuery = document.getElementById("searchInput").value;
		const query = `
		query($userId: Int,$page: Int){
			Page(page: $page){
				pageInfo{
					currentPage
					total
					lastPage
				}
				activities (userId: $userId, sort: ID_DESC, type: MESSAGE){
					... on MessageActivity{
						siteUrl
						message(asHtml: true)
					}
				}
			}
		}`;
		let addNewUserData = function(data){
			if(data.data.Page.pageInfo.currentPage === 1){
				for(var i=2;i<=data.data.Page.pageInfo.lastPage;i++){
					generalAPIcall(query,{userId: userId,page: i},addNewUserData)
				}
			};
			posts += data.data.Page.activities.length;
			progress.innerText = "Searching message post " + posts + "/" + data.data.Page.pageInfo.total;
			data.data.Page.activities.forEach(function(act){
				if(act.message.match(new RegExp(searchQuery,"i"))){
					let newDate = create("p",false,false,results,"font-family:monospace;margin-right:10px;");
					let newPage = create("a","newTab",act.siteUrl,newDate,"color:rgb(var(--color-blue));");
					newPage.href = act.siteUrl;
					newDate.innerHTML += DOMPurify.sanitize(act.message);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
					create("hr",false,false,results)
				}
			})
		};
		generalAPIcall(query,{userId: userId,page: 1},addNewUserData);
	},"hohIDlookup" + user.toLowerCase())
}},

{name: "Most liked status posts",code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		let userId = data.data.User.id;
		let list = [];
		miscResults.innerText = "";
		let progress = create("p",false,false,miscResults);
		let results = create("p",false,false,miscResults);
		const query = `
		query($userId: Int,$page: Int){
			Page(page: $page){
				pageInfo{
					currentPage
					total
					lastPage
				}
				activities (userId: $userId, sort: ID_DESC, type: TEXT){
					... on TextActivity{
						siteUrl
						likes{id}
					}
				}
			}
		}`;
		let addNewUserData = function(data){
			list = list.concat(data.data.Page.activities);
			if(data.data.Page.pageInfo.currentPage === 1){
				for(var i=2;i<=Math.min(data.data.Page.pageInfo.lastPage,50);i++){//FIXME temporary workaround to prevent crashes until anilist fixes the page API. Limits to 2500 posts
					generalAPIcall(query,{userId: userId,page: i},addNewUserData);
				};
			};
			list.sort(function(b,a){return a.likes.length - b.likes.length});
			progress.innerText = "Searching status post " + list.length + "/" + data.data.Page.pageInfo.total + " [total is incorrect until an Anilist bug is fixed. Query limited to 2500]";
			removeChildren(results)
			for(var i=0;i<20;i++){
				let newDate = create("p",false,list[i].likes.length + " likes ",results,"font-family:monospace;margin-right:10px;");
				let newPage = create("a","newTab",list[i].siteUrl,newDate,"color:rgb(var(--color-blue));");
				newPage.href = list[i].siteUrl;
			};
		};
		generalAPIcall(query,{userId: userId,page: 1},addNewUserData);
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Monthly stats",code: function(){
	generalAPIcall("query($name:String){User(name:$name){id}}",{name: user},function(data){
		let userId = data.data.User.id;
		let currentYear = new Date().getFullYear();
		let presentTime = new Date();
		let limitTime;
		for(let i=1;i<12;i++){
			if(new Date(currentYear,i,1) > presentTime){
				limitTime = new Date(currentYear,i - 1,1).valueOf();
				break
			}
			if(i === 11){
				limitTime = new Date(currentYear,11,1).valueOf()
			}
		}
		let activityQuery =
		`query ($userId: Int, $page: Int) {
			Page(perPage: 50, page: $page){
				activities(sort: ID_DESC,userId: $userId){
					... on MessageActivity {
						type
						createdAt
					}
					... on TextActivity {
						type
						createdAt
					}
					... on ListActivity {
						type
						createdAt
						status
						progress
						media{
							episodes
							chapters
							duration
							format
							id
						}
					}
				}
			}
		}`;
		let statsBuffer = [];
		let currentPage = 1;
		let getData = function(){
			generalAPIcall(activityQuery,{userId: userId,page: currentPage},function(data){
				statsBuffer = statsBuffer.concat(data.data.Page.activities.filter(act => act.createdAt*1000 >= limitTime));
				miscResults.innerText = `This month (since ${new Date().getFullYear()}-${("0" + (new Date().getMonth() + 1)).slice(-2)}-01):`;
				let messageCount = statsBuffer.filter(activity => activity.type === "MESSAGE").length;
				let statusCount = statsBuffer.filter(activity => activity.type === "TEXT").length;
				let animeCount = statsBuffer.filter(activity => activity.type === "ANIME_LIST").length;
				let mangaCount = statsBuffer.filter(activity => activity.type === "MANGA_LIST").length;
				create("p",false,"Messages received: " +messageCount,miscResults);
				create("p",false,"Status posts: " + statusCount,miscResults);
				create("p",false,"Anime feed items: " + animeCount,miscResults);
				create("p",false,"Manga feed items: " + mangaCount,miscResults);
				let animeEntries = {};
				let mangaEntries = {};
				statsBuffer.forEach(entry => {
					if(entry.type === "ANIME_LIST"){
						let addDefault = function(){
							animeEntries[entry.media.id] = animeEntries[entry.media.id] || {
								completionCount: 0,
								lowestProgress: entry.media.episodes || Number.MAX_SAFE_INTEGER,
								highestProgress: 0,
								duration: entry.media.duration || 1,
								format: entry.media.format,
								total: entry.media.episodes || 1
							}
						}
						if(entry.status === "watched episode" || entry.status === "rewatched episode"){
							addDefault();
							let splitProgress = entry.progress.split(" - ").map(num => parseInt(num));
							animeEntries[entry.media.id].lowestProgress = Math.min(
								animeEntries[entry.media.id].lowestProgress,
								splitProgress[0]
							)
							animeEntries[entry.media.id].highestProgress = Math.max(
								animeEntries[entry.media.id].highestProgress,
								splitProgress[splitProgress.length - 1]
							)
						}
						else if(entry.status === "completed"){
							addDefault();
							animeEntries[entry.media.id].highestProgress = animeEntries[entry.media.id].total || 1;
							animeEntries[entry.media.id].completionCount++
						}
					}
					else if(entry.type === "MANGA_LIST"){
						let addDefault = function(){
							mangaEntries[entry.media.id] = mangaEntries[entry.media.id] || {
								completionCount: 0,
								lowestProgress: entry.media.chapters || Number.MAX_SAFE_INTEGER,
								highestProgress: 0,
								format: entry.media.format,
								total: entry.media.chapters || 1
							}
						}
						if(entry.status === "read chapter" || entry.status === "reread chapter"){
							addDefault();
							let splitProgress = entry.progress.split(" - ").map(num => parseInt(num));
							mangaEntries[entry.media.id].lowestProgress = Math.min(
								mangaEntries[entry.media.id].lowestProgress,
								splitProgress[0]
							)
							mangaEntries[entry.media.id].highestProgress = Math.max(
								mangaEntries[entry.media.id].highestProgress,
								splitProgress[splitProgress.length - 1]
							)
						}
						else if(entry.status === "completed"){
							addDefault();
							mangaEntries[entry.media.id].highestProgress = mangaEntries[entry.media.id].total || 1;
							mangaEntries[entry.media.id].completionCount++
						}
					}
				});
				let formatDigest = {};
				Object.keys(distributionFormats).forEach(key => formatDigest[key] = 0);
				let digestMinutesAnime = 0;
				Object.keys(animeEntries).forEach(key => {
					let epCount = Math.max(0,animeEntries[key].highestProgress - animeEntries[key].lowestProgress + 1);
					if(animeEntries[key].completionCount > 1){
						epCount += animeEntries[key].completionCount - 1
					}
					digestMinutesAnime += epCount * animeEntries[key].duration;
					formatDigest[animeEntries[key].format] += epCount
				});
				Object.keys(mangaEntries).forEach(key => {
					let chCount = Math.max(0,mangaEntries[key].highestProgress - mangaEntries[key].lowestProgress + 1);
					if(mangaEntries[key].completionCount > 1){
						chCount += mangaEntries[key].completionCount - 1
					}
					formatDigest[mangaEntries[key].format] += chCount
				});
				create("hr",false,false,miscResults);
				create("p",false,"Time Watched: " + formatTime(digestMinutesAnime * 60),miscResults);
				if(formatDigest["TV"]){
					create("p",false,"TV eps: " + formatDigest["TV"],miscResults)
				}
				if(formatDigest["OVA"]){
					create("p",false,"OVA eps: " + formatDigest["OVA"],miscResults)
				}
				if(formatDigest["ONA"]){
					create("p",false,"ONA eps: " + formatDigest["ONA"],miscResults)
				}
				if(formatDigest["MOVIE"]){
					create("p",false,"Movies: " + formatDigest["MOVIE"],miscResults)
				}
				if(formatDigest["TV_SHORT"]){
					create("p",false,"Short TV eps: " + formatDigest["TV_SHORT"],miscResults)
				}
				if(formatDigest["SPECIAL"]){
					create("p",false,"Specials: " + formatDigest["SPECIAL"],miscResults)
				}
				if(formatDigest["MUSIC"]){
					create("p",false,"Music vids: " + formatDigest["MUSIC"],miscResults)
				}
				create("hr",false,false,miscResults);
				if(formatDigest["MANGA"]){
					create("p",false,"Manga chapters: " + formatDigest["MANGA"],miscResults)
				}
				if(formatDigest["NOVEL"]){
					create("p",false,"LN chapters: " + formatDigest["NOVEL"],miscResults)
				}
				if(formatDigest["ONE_SHOT"]){
					create("p",false,"One shots: " + formatDigest["ONE_SHOT"],miscResults)
				}
				if(data.data.Page.activities[data.data.Page.activities.length - 1].createdAt*1000 >= limitTime){
					currentPage++;
					create("p",false,"Loading more activities...",miscResults);
					getData();
				}
			})
		};getData()
	},"hohIDlookup" + user.toLowerCase());
}},

{name: "Submission stats",code: async function(){
	const query = `
query ($id: Int) {
	anime_total: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: ANIME, userId: $id, sort: ID) { createdAt }
	},
	anime_pending: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: ANIME, userId: $id, status: PENDING) { id }
	},
	anime_rejected: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: ANIME, userId: $id, status: REJECTED) { id }
	},
	anime_partially_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: ANIME, userId: $id, status: PARTIALLY_ACCEPTED) { id }
	},
	anime_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: ANIME, userId: $id, status: ACCEPTED) { id }
	},
	manga_total: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: MANGA, userId: $id, sort: ID) { createdAt }
	},
	manga_pending: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: MANGA, userId: $id, status: PENDING) { id }
	},
	manga_rejected: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: MANGA, userId: $id, status: REJECTED) { id }
	},
	manga_partially_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: MANGA, userId: $id, status: PARTIALLY_ACCEPTED) { id }
	},
	manga_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: mediaSubmissions(type: MANGA, userId: $id, status: ACCEPTED) { id }
	},
	characters_total: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: characterSubmissions(userId: $id, sort: ID) { createdAt }
	},
	characters_pending: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: characterSubmissions(userId: $id, status: PENDING) { id }
	},
	characters_rejected: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: characterSubmissions(userId: $id, status: REJECTED) { id }
	},
	characters_partially_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: characterSubmissions(userId: $id, status: PARTIALLY_ACCEPTED) { id }
	},
	characters_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: characterSubmissions(userId: $id, status: ACCEPTED) { id }
	},
	staff_total: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: staffSubmissions(userId: $id, sort: ID) { createdAt }
	},
	staff_pending: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: staffSubmissions(userId: $id, status: PENDING) { id }
	},
	staff_rejected: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: staffSubmissions(userId: $id, status: REJECTED) { id }
	},
	staff_partially_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: staffSubmissions(userId: $id, status: PARTIALLY_ACCEPTED) { id }
	},
	staff_accepted: Page(page: 1, perPage: 1) {
		pageInfo { total } submissions: staffSubmissions(userId: $id, status: ACCEPTED) { id }
	}
}
`
	const subTypes = ["anime", "manga", "characters", "staff"];
	const statusTypes = ["pending", "rejected", "partially_accepted", "accepted"];

	function parseStats(data){
		let grandTotal = 0;
		subTypes.forEach(subtype => {
			create("h1", null, capitalize(subtype), miscResults)
			statusTypes.forEach(status => {
				const statusWrap = create("p", null, null, miscResults);
				create("span", null, capitalize(status.replace("_", " ")) + ": ", statusWrap)
				create("span", "hohStatValue", data[subtype + "_" + status].pageInfo.total, statusWrap)
			})
			const total = data[subtype + "_total"].pageInfo.total;
			grandTotal += total
			const totalWrap = create("p", null, null, miscResults);
			create("span", null, "Total: ", totalWrap)
			create("span", "hohStatValue", total, totalWrap)
			const firstSub = data[subtype + "_total"].submissions[0] ? data[subtype + "_total"].submissions[0].createdAt : undefined;
			if(firstSub) create("p", null, "First submission created on " + new Date(firstSub*1000).toLocaleString(), miscResults)
			create("br", null, null, miscResults)
		})
		create("br", null, null, miscResults)
		const grandTotalWrap = create("p", null, null, miscResults);
		create("span", null, "You have made a grand total of ", grandTotalWrap)
		create("span", "hohStatValue", grandTotal, grandTotalWrap)
		create("span", null, " submissions.", grandTotalWrap)
	}

	miscResults.innerText = "";
	const {data, errors} = await anilistAPI(query, {
		variables: {id: whoAmIid},
		cacheKey: "submissionStats",
		duration: 20*60*1000,
		internal: true
	})
	if(!errors) parseStats(data)
	else miscResults.innerText = "API error occurred"
}},


		];
		let miscInputSelect = create("select",false,false,miscInput);
		let miscInputButton = create("button",["button","hohButton"],translate("$button_run"),miscInput);
		availableQueries.forEach(que => {
			create("option",false,que.name,miscInputSelect).value = que.name
		});
		miscInputSelect.oninput = function(){
			miscOptions.innerText = "";
			let relevant = availableQueries.find(que => que.name === miscInputSelect.value);
			miscResults.innerText = "";
			if(relevant.setup){
				relevant.setup()
			}
		};
		miscInputButton.onclick = function(){
			miscResults.innerText = translate("$loading");
			availableQueries.find(que => que.name === miscInputSelect.value).code()
		}

		let customTagsCollection = function(list,title,fields){
			let customTags = new Map();
			let regularTags = new Map();
			let customLists = new Map();
			(
				JSON.parse(localStorage.getItem("regularTags" + title)) || []
			).forEach(
				tag => regularTags.set(tag,{
					name : tag,
					list : []
				})
			);
			customLists.set("Not on custom list",{name: "Not on custom list",list: []});
			customLists.set("All media",{name: "All media",list: []});
			list.forEach(media => {
				let item = {};
				fields.forEach(field => {
					item[field.key] = field.method(media)
				});
				if(media.notes){
					(
						media.notes.match(/(#(\\\s|\S)+)/g) || []
					).filter(
						tagMatch => !tagMatch.match(/^#039/)
					).map(
						tagMatch => evalBackslash(tagMatch)
					).forEach(tagMatch => {
						if(!customTags.has(tagMatch)){
							customTags.set(tagMatch,{name: tagMatch,list: []})
						}
						customTags.get(tagMatch).list.push(item)
					});
					(//candidates for multi word tags, which we try to detect even if they are not allowed
						media.notes.match(/(#\S+ [^#]\S+)/g) || []
					).filter(
						tagMatch => !tagMatch.match(/^#039/)
					).map(
						tagMatch => evalBackslash(tagMatch)
					).forEach(tagMatch => {
						if(!customTags.has(tagMatch)){
							customTags.set(tagMatch,{name: tagMatch,list: []})
						}
						customTags.get(tagMatch).list.push(item)
					})
				}
				media.media.tags.forEach(mediaTag => {
					if(regularTags.has(mediaTag.name)){
						regularTags.get(mediaTag.name).list.push(item)
					}
				});
				if(media.isCustomList){
					media.listLocations.forEach(location => {
						if(!customLists.has(location)){
							customLists.set(location,{name: location,list: []})
						}
						customLists.get(location).list.push(item)
					})
				}
				else if(useScripts.negativeCustomList){
					customLists.get("Not on custom list").list.push(item)
				}
				if(useScripts.globalCustomList){
					customLists.get("All media").list.push(item)
				}
			});
			if(customTags.has("##STRICT")){
				customTags.delete("##STRICT")
			}
			else{
				for(let [key,value] of customTags){//filter our multi word candidates
					if(key.includes(" ")){
						if(value.list.length === 1){//if it's just one of them, the prefix tag takes priority
							customTags.delete(key)
						}
						else{
							let prefix = key.split(" ")[0];
							if(customTags.has(prefix)){
								if(customTags.get(prefix).list.length === value.list.length){
									customTags.delete(prefix)
								}
								else{
									customTags.delete(key)
								}
							}
						}
					}
				}
				for(let [key,value] of customTags){//fix the basic casing error, like #shoujo vs #Shoujo. Will only merge if one is of length 1
					if(key[1] === key[1].toUpperCase()){
						let lowerCaseKey = "#" + key[1].toLowerCase() + key.slice(2);
						let lowerCaseValue = customTags.get(lowerCaseKey);
						if(lowerCaseValue){
							if(value.list.length === 1){
								lowerCaseValue.list = lowerCaseValue.list.concat(value.list);
								customTags.delete(key)
							}
							else if(lowerCaseValue.list.length === 1){
								value.list = value.list.concat(lowerCaseValue.list);
								customTags.delete(lowerCaseKey)
							}
						}
					}
				}
			}
			if(!customLists.get("Not on custom list").list.length){
				customLists.delete("Not on custom list")
			}
			if(!customLists.get("All media").list.length){
				customLists.delete("All media")
			}
			return [...customTags, ...regularTags, ...customLists].map(
				pair => pair[1]
			).map(tag => {
				let amountCount = 0;
				let average = 0;
				tag.list.forEach(item => {
					if(item.score !== 0){
						amountCount++;
						average += item.score;
					}
					fields.forEach(field => {
						if(field.sumable){
							tag[field.key] = field.sumable(tag[field.key],item[field.key]);
						}
					})
				});
				tag.average = average/amountCount || 0;
				tag.list.sort((b,a) => a.score - b.score);
				return tag;
			}).sort(
				(b,a) => a.list.length - b.list.length || b.name.localeCompare(a.name)
			)
		};
		let regularTagsCollection = function(list,fields,extracter){
			let tags = new Map();
			list.forEach(media => {
				let item = {};
				fields.forEach(field => {
					item[field.key] = field.method(media)
				});
				extracter(media).forEach(tag => {
					if(useScripts.SFWmode && tag.name === "Hentai"){
						return
					}
					if(!tags.has(tag.name)){
						tags.set(tag.name,{name: tag.name,list: []})
					}
					tags.get(tag.name).list.push(item)
				})
			});
			tags.forEach(tag => {
				tag.amountCount = 0;
				tag.average = 0;
				tag.list.forEach(item => {
					if(item.score){
						tag.amountCount++;
						tag.average += item.score;
					}
					fields.forEach(field => {
						if(field.sumable){
							tag[field.key] = field.sumable(tag[field.key],item[field.key])
						}
					})
				});
				tag.average = tag.average/tag.amountCount || 0;
				tag.list.sort((b,a) => a.score - b.score)
			});
			return [...tags].map(
				tag => tag[1]
			).sort(
				(b,a) => (a.average*a.amountCount + ANILIST_WEIGHT)/(a.amountCount + 1) - (b.average*b.amountCount + ANILIST_WEIGHT)/(b.amountCount + 1) || a.list.length - b.list.length
			)
		};
		let drawTable = function(data,formatter,tableLocation,isTag,autoHide){
			removeChildren(tableLocation)
			tableLocation.innerText = "";
			let hasScores = data.some(elem => elem.average);
			let header = create("p",false,formatter.title);
			let tableContent = create("div",["table","hohTable"]);
			let headerRow = create("div",["header","row"],false,tableContent);
			let indexAccumulator = 0;
			formatter.headings.forEach(function(heading){
				if(!hasScores && heading === "Mean Score"){
					return
				}
				let columnTitle = create("div",false,heading,headerRow);
				if((heading === "Tag" || heading === translate("$stats_tag")) && !isTag && formatter.isMixed){
					columnTitle.innerText = translate("$stats_genre")
				}
				if(formatter.focus === indexAccumulator){
					columnTitle.innerText += " ";
					columnTitle.appendChild(svgAssets2.angleDown.cloneNode(true))
				}
				columnTitle.index = +indexAccumulator;
				columnTitle.addEventListener("click",function(){
					formatter.focus = this.index;
					data.sort(formatter.sorting[this.index]);
					drawTable(data,formatter,tableLocation,isTag,autoHide)
				});
				indexAccumulator++;
			});
			for(let i=0;i<data.length;i++){
				let row = create("div","row");
				formatter.celData.forEach((celData,index) => {
					if(index === 2 && !hasScores){
						return
					}
					celData(
						create("div",false,false,row),
						data,i,true,isTag
					)
				});
				row.onclick = function(){
					if(this.nextSibling.style.display === "none"){
						this.nextSibling.style.display = "block"
					}
					else{
						this.nextSibling.style.display = "none"
					}
				};
				tableContent.appendChild(row);
				let showList = create("div");

				if(formatter.focus === 1){//sorting by count is meaningless, sort alphabetically instead
					data[i].list.sort(formatter.sorting[0])
				}
				else if(formatter.focus === 2){//average != score
					data[i].list.sort((b,a) => a.score - b.score)
				}
				else if(formatter.focus === -1){//average != score
					//nothing, duh
				}
				else{
					data[i].list.sort(formatter.sorting[formatter.focus]);
				}
				data[i].list.forEach((nil,ind) => {
					let secondaryRow = create("div",["row","hohSecondaryRow"]);
					formatter.celData.forEach(celData => {
						let cel = create("div");
						celData(cel,data[i].list,ind,false,isTag);
						secondaryRow.appendChild(cel)
					});
					showList.appendChild(secondaryRow)
				});
				showList.style.display = "none";
				tableContent.insertBefore(showList,row.nextSibling);
			}
			tableLocation.appendChild(header);
			tableLocation.appendChild(tableContent);
			if(autoHide){
				let tableHider = create("span",["hohMonospace","hohTableHider"],"[-]",header);
				let regularTagsSetting = create("p",false,false,tableLocation);
				let regularTagsSettingLabel = create("span",false,translate("$stats_regularTags"),regularTagsSetting);
				let regularTagsSettingContent = create("span",false,false,regularTagsSetting);
				let regularTagsSettingNew = create("input",false,false,regularTagsSetting);
				let regularTagsSettingAdd = create("button",["hohButton","button"],"+",regularTagsSetting);
				let regularTags = JSON.parse(localStorage.getItem("regularTags" + formatter.title)) || [];
				for(let i=0;i<regularTags.length;i++){
					let tag = create("span","hohRegularTag",false,regularTagsSettingContent);
					let tagContent = create("span",false,regularTags[i],tag);
					let tagCross = create("span","hohCross",svgAssets.cross,tag);
					tagCross.regularTag = regularTags[i] + "";
					tagCross.addEventListener("click",function(){
						for(let j=0;j<regularTags.length;j++){
							if(regularTags[j] === this.regularTag){
								regularTags.splice(j,1);
								localStorage.setItem("regularTags" + formatter.title,JSON.stringify(regularTags));
								break
							}
						}
						this.parentNode.remove();
					})
				}
				regularTagsSettingAdd.addEventListener("click",function(){
					let newTagName = this.previousSibling.value;
					if(!newTagName){
						return
					}
					newTagName = capitalize(newTagName);
					regularTags.push(newTagName);
					let tag = create("span","hohRegularTag");
					let tagContent = create("span",false,newTagName,tag);
					let tagCross = create("span","hohCross",svgAssets.cross,tag);
					tagCross.regularTag = newTagName + "";
					tagCross.addEventListener("click",function(){
						for(let j=0;j<regularTags.length;j++){
							if(regularTags[j] === this.regularTag){
								regularTags.splice(j,1);
								localStorage.setItem("regularTags" + formatter.title,JSON.stringify(regularTags));
								break
							}
						}
						this.parentNode.remove();
					});
					this.previousSibling.previousSibling.appendChild(tag);
					localStorage.setItem("regularTags" + formatter.title,JSON.stringify(regularTags));
				});
				tableHider.onclick = function(){
					if(this.innerText === "[-]"){
						tableHider.innerText = "[+]";
						tableContent.style.display = "none";
						regularTagsSetting.style.display = "none";
						formatter.display = false
					}
					else{
						tableHider.innerText = "[-]";
						tableContent.style.display = "block";
						regularTagsSetting.style.display = "block";
						formatter.display = true
					}
				};
				if(!formatter.display){
					tableHider.innerText = "[+]";
					tableContent.style.display = "none";
					regularTagsSetting.style.display = "none";
				}
			}
		};
		let semaPhoreAnime = false;//I have no idea what "semaphore" means in software
		let semaPhoreManga = false;//but it sounds cool so this is a semaphore
//
		let nativeTagsReplacer = function(){
			if(useScripts.replaceNativeTags === false || semaPhoreAnime === false || semaPhoreManga === false){
				return
			}
			const mixedFields = [
				{
					key : "name",
					method : function(media){
						return titlePicker({
							id: media.mediaId,
							title: media.media.title
						})
					}
				},{
					key : "repeat",
					method : media => media.repeat
				},{
					key : "status",
					sumable : function(acc,val){
						if(!acc){
							acc = {};
							Object.keys(distributionColours).forEach(function(key){
								acc[key] = 0
							})
						}
						acc[val]++;
						return acc;
					},
					method : media => media.status
				},{
					key : "type",
					method : function(media){
						if(!media.progressVolumes && !(media.progressVolumes === 0)){
							return "ANIME"
						}
						return "MANGA"
					}
				},{
					key : "mediaId",
					method : media => media.mediaId
				},{
					key : "score",
					method : media => media.scoreRaw
				},{
					key : "duration",
					sumable : ACCUMULATE,
					method : media => media.watchedDuration || 0
				},{
					key : "chaptersRead",
					sumable : ACCUMULATE,
					method : media => media.chaptersRead || 0
				}
			];
			let mixedFormatter = {
				title: "",
				display: true,
				isMixed: true,
				headings: [translate("$stats_tag"),translate("$stats_count"),"Mean Score","Time Watched","Chapters Read"],
				focus: -1,
				anime: true,
				manga: true,
				celData: [
					function(cel,data,index,isPrimary,isTag){
						if(isPrimary){
							let nameCellCount = create("div","count",(index+1),cel);
							let nameCellTag = create("a",false,data[index].name,cel,"cursor:pointer;");
							if(isTag){
								if(mixedFormatter.anime && data[index].list.some(media => media.type === "ANIME")){
									nameCellTag.href = "/search/anime?includedTags=" + data[index].name + "&onList=true";
								}
								else{
									nameCellTag.href = "/search/manga?includedTags=" + data[index].name + "&onList=true"
								}
							}
							else{
								if(mixedFormatter.anime && data[index].list.some(media => media.type === "ANIME")){
									nameCellTag.href = "/search/anime?includedGenres=" + data[index].name + "&onList=true"
								}
								else{
									nameCellTag.href = "/search/manga?includedGenres=" + data[index].name + "&onList=true"
								}
								if(data[index].name === "Hentai"){
									nameCellTag.href += "&adult=true"
								}
							}
							let nameCellStatus = create("span","hohSummableStatusContainer",false,cel);
							semmanticStatusOrder.forEach(function(status){
								if(data[index].status[status]){
									let statusSumDot = create("div","hohSummableStatus",data[index].status[status],nameCellStatus);
									statusSumDot.style.background = distributionColours[status];
									statusSumDot.title = data[index].status[status] + " " + capitalize(statusTypes[status]);
									if(data[index].status[status] > 99){
										statusSumDot.style.fontSize = "8px"
									}
									if(data[index].status[status] > 999){
										statusSumDot.style.fontSize = "6px"
									}
									statusSumDot.onclick = function(e){
										e.stopPropagation();
										Array.from(cel.parentNode.nextSibling.children).forEach(child => {
											if(child.children[1].children[0].title === status.toLowerCase()){
												child.style.display = "grid"
											}
											else{
												child.style.display = "none"
											}
										})
									}
								}
							})
						}
						else{
							let nameCellTag = create("a",["title","hohNameCel"],data[index].name,cel);
							if(data[index].type === "ANIME"){
								nameCellTag.href = "/anime/" + data[index].mediaId + "/";
								nameCellTag.style.color = "rgb(var(--color-blue))"
							}
							else{
								nameCellTag.href = "/manga/" + data[index].mediaId + "/";
								nameCellTag.style.color = "rgb(var(--color-green))"
							}
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							cel.innerText = data[index].list.length
						}
						else{
							let statusDot = create("div","hohStatusDot",false,cel);
							statusDot.style.backgroundColor = distributionColours[data[index].status];
							statusDot.title = data[index].status.toLowerCase();
							if(data[index].status === "COMPLETED"){
								statusDot.style.backgroundColor = "transparent"//default case
							}
							if(data[index].repeat === 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true))
							}
							else if(data[index].repeat > 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true));
								create("span",false,data[index].repeat,cel)
							}
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							cel.innerText = (data[index].average).roundPlaces(1) || "-"
						}
						else{
							cel.innerText = (data[index].score).roundPlaces(1) || "-"
						}
					},
					function(cel,data,index,isPrimary){
						if(!isPrimary && data[index].type === "MANGA"){
							cel.innerText = "-"
						}
						else if(data[index].duration === 0){
							cel.innerText = "-"
						}
						else if(data[index].duration < 60){
							cel.innerText = Math.round(data[index].duration) + "min"
						}
						else{
							cel.innerText = Math.round(data[index].duration/60) + "h"
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary || data[index].type === "MANGA"){
							cel.innerText = data[index].chaptersRead;
						}
						else{
							cel.innerText = "-"
						}
					}
				],
				sorting : [
					ALPHABETICAL(a => a.name),
					(b,a) => a.list.length - b.list.length,
					(b,a) => a.average - b.average,
					(b,a) => a.duration - b.duration,
					(b,a) => a.chaptersRead - b.chaptersRead
				]
			};
			let collectedMedia = semaPhoreAnime.concat(semaPhoreManga);
			let listOfTags = regularTagsCollection(collectedMedia,mixedFields,media => media.media.tags);
			if(!document.URL.match(/\/stats/)){
				return
			}
			let drawer = function(){
				if(regularFilterHeading.children.length === 0){
					let filterWrap = create("div",false,false,regularFilterHeading);
					create("p",false,"tip: click a row to show individual media entries",regularFilterHeading);
					let filterLabel = create("span",false,translate("$filters"),filterWrap);
					let tableHider = create("span",["hohMonospace","hohTableHider"],"[+]",filterWrap);
					let filters = create("div",false,false,filterWrap,"display: none");

					let animeSetting = create("p","hohSetting",false,filters);
					let input_a = createCheckbox(animeSetting);
					input_a.checked = true;
					create("span",false,translate("$generic_anime"),animeSetting);

					let mangaSetting = create("p","hohSetting",false,filters);
					let input_m = createCheckbox(mangaSetting);
					input_m.checked = true;
					create("span",false,translate("$generic_manga"),mangaSetting);

					let minSetting = create("p","hohSetting",false,filters);
					let min_s_input = create("input","hohNativeInput",false,minSetting,"width: 80px;margin-right: 10px;");
					min_s_input.type = "number";
					min_s_input.min = 0;
					min_s_input.max = 100;
					min_s_input.step = 1;
					min_s_input.value = 0;
					create("span",false,"Minimum rating",minSetting);

					let minEpisodeSetting = create("p","hohSetting",false,filters);
					let min_e_input = create("input","hohNativeInput",false,minEpisodeSetting,"width: 80px;margin-right: 10px;");
					min_e_input.type = "number";
					min_e_input.min = 0;
					min_e_input.step = 1;
					min_e_input.value = 0;
					create("span",false,"Minimum episode progress",minEpisodeSetting);

					let minChapterSetting = create("p","hohSetting",false,filters);
					let min_c_input = create("input","hohNativeInput",false,minChapterSetting,"width: 80px;margin-right: 10px;");
					min_c_input.type = "number";
					min_c_input.min = 0;
					min_c_input.step = 1;
					min_c_input.value = 0;
					create("span",false,"Minimum chapter progress",minChapterSetting);

					let statusFilter = {};
					create("p",false,"Status",filters);
					let statusLine = create("p","hohSetting",false,filters);
					Object.keys(statusTypes).sort().forEach(key => {
						statusFilter[key] = true;
						let input_status = createCheckbox(statusLine);
						input_status.checked = true;
						create("span",false,capitalize(statusTypes[key]),statusLine,"margin-right: 20px");
						input_status.onchange = function(){
							statusFilter[key] = input_status.checked
						}
					})

					let formatFilter = {};
					create("p",false,"Format",filters);
					let formatLine_a = create("p","hohSetting",false,filters);
					let formatLine_m = create("p","hohSetting",false,filters);
					Object.keys(distributionFormats).forEach(key => {
						formatFilter[key] = true;
						let input_format;
						if(["MANGA","NOVEL","ONE_SHOT"].includes(key)){
							input_format = createCheckbox(formatLine_m);
							create("span",false,distributionFormats[key],formatLine_m,"margin-right: 20px")
						}
						else{
							input_format = createCheckbox(formatLine_a);
							create("span",false,distributionFormats[key],formatLine_a,"margin-right: 20px")
						}
						input_format.checked = true;
						input_format.onchange = function(){
							formatFilter[key] = input_format.checked
						}
					})

					input_m.onchange = function(){
						if(input_m.checked){
							minChapterSetting.style.opacity = 1;
							formatLine_m.style.opacity = 1;
						}
						else{
							input_a.checked = true;
							minEpisodeSetting.style.opacity = 1;
							minChapterSetting.style.opacity = 0.5;
							formatLine_m.style.opacity = 0.5;
							formatLine_a.style.opacity = 1;
						}
					}
					input_a.onchange = function(){
						if(input_a.checked){
							minEpisodeSetting.style.opacity = 1;
							formatLine_a.style.opacity = 1;
						}
						else{
							input_m.checked = true;
							minEpisodeSetting.style.opacity = 0.5;
							minChapterSetting.style.opacity = 1;
							formatLine_m.style.opacity = 1;
							formatLine_a.style.opacity = 0.5;
						}
					}

					let applyButton = create("button",["hohButton","button"],translate("$button_submit"),filters);
					applyButton.onclick = function(){
						let base_media = collectedMedia;
						if(!input_a.checked){
							base_media = semaPhoreManga
						}
						else if(!input_m.checked){
							base_media = semaPhoreAnime
						}
						mixedFormatter.anime = input_a.checked;
						mixedFormatter.manga = input_m.checked;
						base_media = base_media.filter(mediaEntry => {
							if(hasOwn(mediaEntry, "progressVolumes")){
								if(mediaEntry.progress < parseInt(min_c_input.value)){
									return false
								}
							}
							else{
								if(mediaEntry.progress < parseInt(min_e_input.value)){
									return false
								}
							}
							return mediaEntry.scoreRaw >= parseInt(min_s_input.value)
								&& statusFilter[mediaEntry.status]
								&& formatFilter[mediaEntry.media.format]
						})
						listOfTags = regularTagsCollection(base_media,mixedFields,media => media.media.tags);
						drawTable(listOfTags,mixedFormatter,regularTagsTable,true);
						drawTable(
							regularTagsCollection(
								base_media,
								mixedFields,
								media => media.media.genres.map(a => ({name: a}))
							),
							mixedFormatter,
							regularGenresTable
						)
					}

					tableHider.onclick = function(){
						if(this.innerText === "[-]"){
							tableHider.innerText = "[+]";
							filters.style.display = "none"
						}
						else{
							tableHider.innerText = "[-]";
							filters.style.display = "block"
						}
					}

				}
				drawTable(listOfTags,mixedFormatter,regularTagsTable,true);
				//recycle most of the formatter for genres
				drawTable(
					regularTagsCollection(
						collectedMedia,
						mixedFields,
						media => media.media.genres.map(a => ({name: a}))
					),
					mixedFormatter,
					regularGenresTable
				);
				hohGenresTrigger.removeEventListener("mouseover",drawer);
			}
			hohGenresTrigger.addEventListener("mouseover",drawer);
			if(hohGenresTrigger.classList.contains("hohActive")){
				drawer()
			}
		};
//get anime list
		let personalStatsCallback = async function(data,filterSettings,onlyStats){
			personalStats.innerText = "";
			create("hr","hohSeparator",false,personalStats);

			let regularFilterHeading = create("div",false,false,personalStats,"margin-bottom: 10px;");
			let filterWrap = create("div",false,false,regularFilterHeading);
			let filterLabel = create("span",false,translate("$filters"),filterWrap);
			let tableHider = create("span",["hohMonospace","hohTableHider"],"[+]",filterWrap);
			let filters = create("div",false,false,filterWrap,"display: none");

			let listFilterHeading = create("p",false,translate("$filters_lists"),filters);
			filterSettings = filterSettings || {
				lists: {}
			};
			data.data.MediaListCollection.lists.forEach(mediaList => {
				let listSetting = create("p","hohSetting",false,filters);
				let listSetting_input = createCheckbox(listSetting);
				if(!hasOwn(filterSettings.lists, mediaList.name) || filterSettings.lists[mediaList.name]){
					listSetting_input.checked = true;
					filterSettings.lists[mediaList.name] = true
				}
				listSetting_input.oninput = function(){
					filterSettings.lists[mediaList.name] = listSetting_input.checked
				}
				create("span",false,mediaList.name,listSetting);
			});

			let applyButton = create("button",["hohButton","button"],translate("$button_submit"),filters);
			applyButton.onclick = function(){
				personalStatsCallback(data,filterSettings,true);
			}

			tableHider.onclick = function(){
				if(this.innerText === "[-]"){
					tableHider.innerText = "[+]";
					filters.style.display = "none"
				}
				else{
					tableHider.innerText = "[-]";
					filters.style.display = "block"
				}
			}

			create("h1","hohStatHeading",translate("$stats_anime_heading",user),personalStats);
			let list = returnList({
				data: {
					MediaListCollection: {
						lists: data.data.MediaListCollection.lists.filter(
							mediaList => filterSettings.lists[mediaList.name]
						)
					}
				}
			});
			let scoreList = list.filter(element => element.scoreRaw);
			if(whoAmI && whoAmI !== user){
				let compatabilityButton = create("button",["button","hohButton"],"Compatibility",personalStats);
				let compatLocation = create("div","#hohCheckCompat",false,personalStats);
				compatabilityButton.onclick = function(){
					compatLocation.innerText = translate("$loading");
					compatLocation.style.marginTop = "5px";
					compatCheck(
						scoreList,
						whoAmI,
						"ANIME",
						data => formatCompat(data,compatLocation,user)
					)
				};
			}
			let addStat = function(text,value,comment){//value,value,html
				let newStat = create("p","hohStat",false,personalStats);
				create("span",false,text,newStat);
				create("span","hohStatValue",value,newStat);
				if(comment){
					create("span",false,false,newStat)
						.innerText = comment
				}
			};
//first activity
			let oldest = list.filter(
				item => item.startedAt.year
			).map(
				item => item.startedAt
			).sort((b,a) =>
				(a.year < b.year)
				|| (a.year === b.year && a.month < b.month)
				|| (a.year === b.year && a.month === b.month && a.day < b.day)
			)[0];
//scoring stats
			let previouScore = 0;
			let maxRunLength = 0;
			let maxRunLengthScore = 0;
			let runLength = 0;
			let sumEntries = 0;
			let amount = scoreList.length;
			let sumWeight = 0;
			let sumEntriesWeight = 0;
			let average = 0;
			let median = (scoreList.length ? Stats.median(scoreList.map(e => e.scoreRaw)) : 0);
			let sumDuration = 0;
			let publicDeviation = 0;
			let publicDifference = 0;
			let histogram = new Array(100).fill(0);
			let longestDuration = {
				time: 0,
				name: "",
				status: "",
				rewatch: 0,
				id: 0
			};
			scoreList.sort((a,b) => a.scoreRaw - b.scoreRaw);
			list.forEach(item => {
				let entryDuration = (item.media.duration || 1)*(item.progress || 0);//current round
				item.episodes = item.progress || 0;
				if(useScripts.noRewatches && item.repeat){
					entryDuration = Math.max(
						item.progress || 0,
						item.media.episodes || 1,
					) * (item.media.duration || 1);//first round
					item.episodes = Math.max(
						item.progress || 0,
						item.media.episodes || 1
					)
				}
				else{
					entryDuration += (item.repeat || 0) * Math.max(
						item.progress || 0,
						item.media.episodes || 1
					) * (item.media.duration || 1);//repeats
					item.episodes += (item.repeat || 0) * Math.max(
						item.progress || 0,
						item.media.episodes || 1
					)
				}
				if(item.listJSON && item.listJSON.adjustValue){
					item.episodes = Math.max(0,item.episodes + item.listJSON.adjustValue);
					entryDuration = Math.max(0,entryDuration + item.listJSON.adjustValue*(item.media.duration || 1));
				}
				item.watchedDuration = entryDuration;
				sumDuration += entryDuration;
				if(entryDuration > longestDuration.time){
					longestDuration.time = entryDuration;
					longestDuration.name = item.media.title.romaji;
					longestDuration.status = item.status;
					longestDuration.rewatch = item.repeat;
					longestDuration.id = item.mediaId
				}
			});
			scoreList.forEach(item => {
				sumEntries += item.scoreRaw;
				if(item.scoreRaw === previouScore){
					runLength++;
					if(runLength > maxRunLength){
						maxRunLength = runLength;
						maxRunLengthScore = item.scoreRaw
					}
				}
				else{
					runLength = 1;
					previouScore = item.scoreRaw
				}
				sumWeight += (item.media.duration || 1) * (item.media.episodes || 0);
				sumEntriesWeight += item.scoreRaw*(item.media.duration || 1) * (item.media.episodes || 0);
				histogram[item.scoreRaw - 1]++
			});
			if(amount){
				average = sumEntries/amount
			}
			if(scoreList.length){
				publicDeviation = Math.sqrt(
					scoreList.reduce(function(accum,element){
						if(!element.media.meanScore){
							return accum
						}
						return accum + Math.pow(element.media.meanScore - element.scoreRaw,2)
					},0)/amount
				);
				publicDifference = scoreList.reduce(function(accum,element){
					if(!element.media.meanScore){
						return accum
					}
					return accum + (element.scoreRaw - element.media.meanScore)
				},0)/amount
			}
			list.sort((a,b) => a.mediaId - b.mediaId);
//display scoring stats
			addStat(translate("$stats_animeOnList"),list.length);
			addStat(translate("$stats_animeRated"),amount);
			if(amount !== 0){//no scores
				if(amount === 1){
					addStat(translate("$stats_onlyOne"),maxRunLengthScore)
				}
				else{
					addStat(
						translate("$stats_averageScore"),
						average.toPrecision(4)
					);
					addStat(
						translate("$stats_averageScore"),
						(sumEntriesWeight/sumWeight).toPrecision(4),
						translate("$stats_weightComment_duration")
					);
					addStat(translate("$stats_medianScore"),median);
					addStat(
						translate("$stats_globalDifference"),
						publicDifference.roundPlaces(2),
						translate("$stats_globalDifference_comment")
					);
					addStat(
						translate("$stats_globalDeviation"),
						publicDeviation.roundPlaces(2),
						translate("$stats_globalDeviation_comment")
					);
					addStat(
						translate("$stats_ratingEntropy"),
						-histogram.reduce((acc,val) => {
							if(val){
								return acc + Math.log2(val/amount) * val/amount
							}
							return acc
						},0).toPrecision(3),
						translate("$stats_ratingEntropy_comment")
					);
					if(maxRunLength > 1){
						addStat(translate("$stats_mostCommonScore"),maxRunLengthScore, " " + translate("$stats_instances",maxRunLength))
					}
					else{
						addStat(translate("$stats_mostCommonScore"),"",translate("$stats_instances_unique"))
					}
				}
//longest activity
			}
			let singleText = translate("$stats_longestTime",[(100*longestDuration.time/sumDuration).roundPlaces(2),longestDuration.name]) + ". ";
			if(longestDuration.rewatch === 0){
				if(longestDuration.status === "CURRENT"){
					singleText += translate("$stats_longest_watching")
				}
				else if(longestDuration.status === "PAUSED"){
					singleText += translate("$stats_longest_paused")
				}
				else if(longestDuration.status === "DROPPED"){
					singleText += translate("$stats_longest_dropped")
				}
			}
			else{
				if(longestDuration.status === "COMPLETED"){
					if(longestDuration.rewatch === 1){
						singleText += translate("$stats_longest_1rewatch")
					}
					else if(longestDuration.rewatch === 2){
						singleText += translate("$stats_longest_2rewatch")
					}
					else{
						singleText += translate("$stats_longest_Mrewatch",longestDuration.rewatch)
					}
				}
				else if(longestDuration.status === "CURRENT" || status === "REPEATING"){
					if(longestDuration.rewatch === 1){
						singleText += translate("$stats_longest_1rewatching")
					}
					else if(longestDuration.rewatch === 2){
						singleText += translate("$stats_longest_2rewatching")
					}
					else{
						singleText += translate("$stats_longest_Mrewatching",longestDuration.rewatch)
					}
				}
				else if(longestDuration.status === "PAUSED"){
					if(longestDuration.rewatch === 1){
						singleText += translate("$stats_longest_1rewatchPaused")
					}
					else if(longestDuration.rewatch === 2){
						singleText += translate("$stats_longest_2rewatchPaused")
					}
					else{
						singleText += translate("$stats_longest_MrewatchPaused",longestDuration.rewatch)
					}
				}
				else if(longestDuration.status === "DROPPED"){
					if(longestDuration.rewatch === 1){
						singleText += translate("$stats_longest_1rewatchDropped")
					}
					else if(longestDuration.rewatch === 2){
						singleText += translate("$stats_longest_2rewatchDropped")
					}
					else{
						singleText += translate("$stats_longest_MrewatchDropped",longestDuration.rewatch)
					}
				}
			}
			addStat(
				translate("$stats_timeWatched"),
				(sumDuration/(60*24)).roundPlaces(2),
				" " + translate("$time_medium_Mday") + " (" + singleText + ")"
			)
			let TVepisodes = 0;
			let TVepisodesLeft = 0;
			list.filter(show => show.media.format === "TV").forEach(function(show){
				TVepisodes += show.progress;
				TVepisodes += show.repeat * Math.max(1,(show.media.episodes || 0),show.progress);
				if(show.status === "CURRENT"){
					TVepisodesLeft += Math.max((show.media.episodes || 0) - show.progress,0)
				}
			});
			addStat(translate("$stats_TVEpisodesWatched"),TVepisodes);
			addStat(translate("$stats_TVEpisodesRemaining"),TVepisodesLeft);
			if(oldest){
				create("p",false,translate("$stats_firstLoggedAnime") + [oldest.year, oldest.month, oldest.day].filter(TRUTHY).join("-") + ". " + translate("$stats_firstLoggedAnime_note"),personalStats)
			}
			let animeFormatter = {
				title: translate("$stats_customTagsAnime"),
				display: !useScripts.hideCustomTags,
				headings: [translate("$stats_tag"),translate("$stats_count"),translate("$stats_meanScore"),"Time Watched","Episodes","Eps remaining"],
				focus: -1,
				celData: [
					function(cel,data,index,isPrimary){
						if(isPrimary){
							let nameCellCount = create("div","count",(index+1),cel);
							let nameCellTag = create("a",false,data[index].name,cel,"cursor:pointer;");
							let nameCellStatus = create("span","hohSummableStatusContainer",false,cel);
							semmanticStatusOrder.forEach(function(status){
								if(data[index].status && data[index].status[status]){
									let statusSumDot = create("div","hohSummableStatus",data[index].status[status],nameCellStatus);
									statusSumDot.style.background = distributionColours[status];
									statusSumDot.title = data[index].status[status] + " " + capitalize(status.toLowerCase());
									if(data[index].status[status] > 99){
										statusSumDot.style.fontSize = "8px"
									}
									if(data[index].status[status] > 999){
										statusSumDot.style.fontSize = "6px"
									}
									statusSumDot.onclick = function(e){
										e.stopPropagation();
										Array.from(cel.parentNode.nextSibling.children).forEach(function(child){
											if(child.children[1].children[0].title === status.toLowerCase()){
												child.style.display = "grid"
											}
											else{
												child.style.display = "none"
											}
										})
									}
								}
							})
						}
						else{
							create("a","hohNameCel",data[index].name,cel)
								.href = "/anime/" + data[index].mediaId + "/" + safeURL(data[index].name)
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							cel.innerText = data[index].list.length
						}
						else{
							let statusDot = create("div","hohStatusDot",false,cel);
							statusDot.style.backgroundColor = distributionColours[data[index].status];
							statusDot.title = data[index].status.toLowerCase();
							if(data[index].status === "COMPLETED"){
								statusDot.style.backgroundColor = "transparent"//default case
							}
							if(data[index].repeat === 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true))
							}
							else if(data[index].repeat > 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true));
								create("span",false,data[index].repeat,cel)
							}
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							if(data[index].average === 0){
								cel.innerText = "-"
							}
							else{
								cel.innerText = (data[index].average).roundPlaces(1)
							}
						}
						else{
							if(data[index].score === 0){
								cel.innerText = "-"
							}
							else{
								cel.innerText = (data[index].score).roundPlaces(1)
							}
						}
					},
					function(cel,data,index){
						if(!data[index].duration){
							cel.innerText = "-"
						}
						else{
							cel.innerText = formatTime(data[index].duration*60,"short");
							cel.title = (data[index].duration/60).roundPlaces(1) + " " + translate("$time_medium_Mhour")
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							if(!data[index].list.length){
								cel.innerText = translate("$missing_N/A_data")
							}
							else{
								cel.innerText = data[index].episodes
							}
						}
						else{
							cel.innerText = data[index].episodes
						}
					},
					function(cel,data,index,isPrimary){
						if(data[index].episodes === 0 && data[index].remaining === 0 || isPrimary && !data[index].list.length){
							cel.innerText = translate("$missing_N/A_data")
						}
						else if(data[index].remaining === 0){
							cel.innerText = translate("$mediaStatus_completed")
						}
						else{
							if(useScripts.timeToCompleteColumn){
								cel.innerText = data[index].remaining + " (" + formatTime(data[index].remainingTime*60,"short") + ")"
							}
							else{
								cel.innerText = data[index].remaining
							}
						}
					}
				],
				sorting: [
					ALPHABETICAL(a => a.name),
					(b,a) => a.list.length - b.list.length,
					(b,a) => a.average - b.average,
					(b,a) => a.duration - b.duration,
					(b,a) => a.episodes - b.episodes,
					(b,a) => a.remaining - b.remaining
				]
			};
			const animeFields = [
				{
					key : "name",
					method : function(media){
						return titlePicker({
							id: media.mediaId,
							title: media.media.title
						})
					}
				},{
					key : "mediaId",
					method : media => media.mediaId
				},{
					key : "score",
					method : media => media.scoreRaw
				},{
					key : "repeat",
					method : media => media.repeat
				},{
					key : "status",
					sumable : function(acc,val){
						if(!acc){
							acc = {};
							Object.keys(distributionColours).forEach(function(key){
								acc[key] = 0
							})
						}
						acc[val]++;
						return acc
					},
					method : media => media.status
				},{
					key : "duration",
					sumable : ACCUMULATE,
					method : media => media.watchedDuration
				},{
					key : "episodes",
					sumable : ACCUMULATE,
					method : media => media.episodes
				},{
					key : "remaining",
					sumable : ACCUMULATE,
					method : function(media){
						return Math.max((media.media.episodes || 0) - media.progress,0)
					}
				},{
					key : "remainingTime",
					sumable : ACCUMULATE,
					method : function(media){
						return Math.max(((media.media.episodes || 0) - media.progress) * (media.media.duration || 1),0)
					}
				}
			];
			let customTags = customTagsCollection(list,animeFormatter.title,animeFields);
			if(customTags.length){
				let customTagsAnimeTable = create("div","#customTagsAnimeTable",false,personalStats);
				drawTable(customTags,animeFormatter,customTagsAnimeTable,true,true)
			}

			if(onlyStats){
				return
			}

			let listOfTags = regularTagsCollection(list,animeFields,media => media.media.tags);
			if(listOfTags.length > 50){
				listOfTags = listOfTags.filter(a => a.list.length >= 3)
			}
			semaPhoreAnime = list;
	if(script_type !== "Boneless"){
			drawTable(listOfTags,animeFormatter,regularAnimeTable,true,false);
			nativeTagsReplacer();
			const staffData = await anilistAPI(queryMediaListStaff, {
				variables: {name: user,listType: "ANIME"},
				cacheKey: "hohListCacheAnimeStaff" + user,
				duration: 15*60*1000
			})
			if(staffData.errors){
				return
			}
			let rawStaff = returnList(staffData);
			rawStaff.forEach((raw,index) => {
				raw.status = list[index].status;
				raw.watchedDuration = list[index].watchedDuration;
				raw.scoreRaw = list[index].scoreRaw
			});
			let staffMap = {};
			rawStaff.filter(obj => obj.status !== "PLANNING").forEach(media => {
				media.media.staff.forEach(staff => {
					if(!staffMap[staff.id]){
						staffMap[staff.id] = {
							watchedDuration: 0,
							count: 0,
							scoreCount: 0,
							scoreSum: 0,
							id: staff.id,
							name: staff.name
						}
					}
					if(media.watchedDuration){
						staffMap[staff.id].watchedDuration += media.watchedDuration;
						staffMap[staff.id].count++
					}
					if(media.scoreRaw){
						staffMap[staff.id].scoreSum += media.scoreRaw;
						staffMap[staff.id].scoreCount++
					}
				})
			});
			let staffList = [];
			Object.keys(staffMap).forEach(
				key => staffList.push(staffMap[key])
			);
			staffList = staffList.filter(
				obj => obj.count >= 1
			).sort(
				(b,a) => a.count - b.count || a.watchedDuration - b.watchedDuration
			);
			if(staffList.length > 300){
				staffList = staffList.filter(obj => obj.count >= 3)
			}
			if(staffList.length > 300){
				staffList = staffList.filter(obj => obj.count >= 5)
			}
			if(staffList.length > 300){
				staffList = staffList.filter(obj => obj.count >= 10)
			}
			let staffHasScores = staffList.some(a => a.scoreCount);
			let drawStaffList = function(){
				removeChildren(animeStaff)
				animeStaff.innerText = "";
				let table        = create("div",["table","hohTable","hohNoPointer"],false,animeStaff);
				let headerRow    = create("div",["header","row","good"],false,table);
				let nameHeading  = create("div",false,translate("$stats_name"),headerRow,"cursor:pointer;");
				let countHeading = create("div",false,translate("$stats_count"),headerRow,"cursor:pointer;");
				let scoreHeading = create("div",false,translate("$stats_meanScore"),headerRow,"cursor:pointer;");
				if(!staffHasScores){
					scoreHeading.style.display = "none"
				}
				let timeHeading = create("div",false,"Time Watched",headerRow,"cursor:pointer;");
				staffList.forEach(function(staff,index){
					let row = create("div",["row","good"],false,table);
					let nameCel = create("div",false,(index + 1) + " ",row);
					let staffLink = create("a",["link","newTab"],(staff.name.first + " " + (staff.name.last || "")).trim(),nameCel);
					staffLink.href = "/staff/" + staff.id;
					create("div",false,staff.count,row);
					if(staffHasScores){
						create("div",false,(staff.scoreSum/staff.scoreCount).roundPlaces(2),row);
					}
					let timeCel = create("div",false,formatTime(staff.watchedDuration*60),row);
					timeCel.title = (staff.watchedDuration/60).roundPlaces(1) + " hours";
				});
				let csvButton = create("button",["csvExport","button","hohButton"],"CSV data",animeStaff,"margin-top:10px;");
				let jsonButton = create("button",["jsonExport","button","hohButton"],"JSON data",animeStaff,"margin-top:10px;");
				csvButton.onclick = function(){
					let csvContent = 'Staff,Count,"Mean Score","Time Watched"\n';
					staffList.forEach(staff => {
						csvContent += csvEscape(
							[staff.name.first,staff.name.last].filter(TRUTHY).join(" ")
						) + ",";
						csvContent += staff.count + ",";
						csvContent += (staff.scoreSum/staff.scoreCount).roundPlaces(2) + ",";
						csvContent += (staff.watchedDuration/60).roundPlaces(1) + "\n"
					});
					saveAs(csvContent,"Anime staff stats for " + user + ".csv",true)
				};
				jsonButton.onclick = function(){
					saveAs({
						type: "ANIME",
						user: user,
						timeStamp: NOW(),
						version: "1.00",
						scriptInfo: scriptInfo,
						url: document.URL,
						description: "Anilist anime staff stats for " + user,
						fields: [
							{name: "name",   description: "The full name of the staff member, as firstname lastname"},
							{name: "staffID",description: "The staff member's database number in the Anilist database"},
							{name: "count",  description: "The total number of media this staff member has credits for, for the current user"},
							{name: "score",  description: "The current user's mean score for the staff member out of 100"},
							{name: "minutesWatched",description: "How many minutes of this staff member's credited media the current user has watched"}
						],
						data: staffList.map(staff => {
							return {
								name: (staff.name.first + " " + (staff.name.last || "")).trim(),
								staffID: staff.id,
								count: staff.count,
								score: (staff.scoreSum/staff.scoreCount).roundPlaces(2),
								minutesWatched: staff.watchedDuration
							}
						})
					},"Anime staff stats for " + user + ".json");
				}
				nameHeading.onclick = function(){
					staffList.sort(ALPHABETICAL(a => a.name.first + " " + (a.name.last || "")));
					drawStaffList()
				};
				countHeading.onclick = function(){
					staffList.sort((b,a) => a.count - b.count || a.watchedDuration - b.watchedDuration);
					drawStaffList()
				};
				scoreHeading.onclick = function(){
					staffList.sort((b,a) => a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount);
					drawStaffList()
				};
				timeHeading.onclick = function(){
					staffList.sort((b,a) => a.watchedDuration - b.watchedDuration);
					drawStaffList()
				}
			};
			let staffClickOnce = function(){
				drawStaffList();
				let place = document.querySelector(`[href$="/stats/anime/staff"]`);
				if(place){
					place.removeEventListener("click",staffClickOnce)
				}
			}
			let staffWaiter = function(){
				if(location.pathname.includes("/stats/anime/staff")){
					staffClickOnce();
					return
				}
				let place = document.querySelector(`[href$="/stats/anime/staff"]`);
				if(place){
					place.addEventListener("click",staffClickOnce)
				}
				else{
					setTimeout(staffWaiter,200)
				}
			};staffWaiter();


			let studioMap = {};
			list.forEach(function(anime){
				anime.media.studios.nodes.forEach(function(studio){
					if(!useScripts.allStudios && !studio.isAnimationStudio){
						return
					}
					if(!studioMap[studio.name]){
						studioMap[studio.name] = {
							watchedDuration: 0,
							count: 0,
							scoreCount: 0,
							scoreSum: 0,
							id: studio.id,
							isAnimationStudio: studio.isAnimationStudio,
							name: studio.name,
							media: []
						}
					}
					if(anime.watchedDuration){
						studioMap[studio.name].watchedDuration += anime.watchedDuration;
						studioMap[studio.name].count++
					}
					if(anime.scoreRaw){
						studioMap[studio.name].scoreSum += anime.scoreRaw;
						studioMap[studio.name].scoreCount++
					}
					let title = anime.media.title.romaji;
					if(anime.status !== "PLANNING"){
						if(useScripts.titleLanguage === "NATIVE" && anime.media.title.native){
							title = anime.media.title.native
						}
						else if(useScripts.titleLanguage === "ENGLISH" && anime.media.title.english){
							title = anime.media.title.english
						}
						studioMap[studio.name].media.push({
							watchedDuration: anime.watchedDuration,
							score: anime.scoreRaw,
							title: title,
							id: anime.mediaId,
							repeat: anime.repeat,
							status: anime.status
						})
					}
				})
			});
			let studioList = [];
			Object.keys(studioMap).forEach(
				key => studioList.push(studioMap[key])
			);
			studioList = studioList.filter(
				studio => studio.count >= 1
			).sort(
				(b,a) => a.count - b.count || a.watchedDuration - b.watchedDuration
			);
			studioList.forEach(
				studio => studio.media.sort((b,a) => a.score - b.score)
			);
			let studioHasScores = studioList.some(a => a.scoreCount);
			let drawStudioList = function(){
				removeChildren(animeStudios)
				animeStudios.innerText = "";
				let table = create("div",["table","hohTable"],false,animeStudios);
				let headerRow = create("div",["header","row","good"],false,table);
				let nameHeading = create("div",false,translate("$stats_name"),headerRow,"cursor:pointer;");
				let countHeading = create("div",false,translate("$stats_count"),headerRow,"cursor:pointer;");
				let scoreHeading = create("div",false,"Mean Score",headerRow,"cursor:pointer;");
				if(!studioHasScores){
					scoreHeading.style.display = "none"
				}
				let timeHeading = create("div",false,"Time Watched",headerRow,"cursor:pointer;");
				studioList.forEach(function(studio,index){
					let row = create("div",["row","good"],false,table);
					let nameCel = create("div",false,(index + 1) + " ",row);
					let studioLink = create("a",["link","newTab"],studio.name,nameCel);
					studioLink.href = "/studio/" + studio.id;
					if(!studio.isAnimationStudio){
						studioLink.style.color = "rgb(var(--color-green))"
					}
					let nameCellStatus = create("span","hohSummableStatusContainer",false,nameCel);
					semmanticStatusOrder.forEach(status => {
						let statCount = studio.media.filter(media => media.status === status).length;
						if(statCount){
							let statusSumDot = create("div","hohSummableStatus",statCount,nameCellStatus);
							statusSumDot.style.background = distributionColours[status];
							statusSumDot.title = statCount + " " + capitalize(status.toLowerCase());
							if(statCount > 99){
								statusSumDot.style.fontSize = "8px"
							}
							if(statCount > 999){
								statusSumDot.style.fontSize = "6px"
							}
							statusSumDot.onclick = function(e){
								e.stopPropagation();
								Array.from(nameCel.parentNode.nextSibling.children).forEach(function(child){
									if(child.children[1].children[0].title === status.toLowerCase()){
										child.style.display = "grid"
									}
									else{
										child.style.display = "none"
									}
								})
							}
						}
					});
					create("div",false,studio.count,row);
					if(studioHasScores){
						let scoreCel = create("div",false,(studio.scoreSum/studio.scoreCount).roundPlaces(2),row);
						scoreCel.title = studio.scoreCount + " ratings";
					}
					let timeString = formatTime(studio.watchedDuration*60);
					let timeCel = create("div",false,timeString,row);
					timeCel.title = (studio.watchedDuration/60).roundPlaces(1) + " hours";
					let showRow = create("div",false,false,table,"display:none;");
					studio.media.forEach(top => {
						let secondRow = create("div",["row","hohSecondaryRow","good"],false,showRow);
						let titleCel = create("div",false,false,secondRow,"margin-left:50px;");
						let titleLink = create("a","link",top.title,titleCel);
						titleLink.href = "/anime/" + top.id + "/" + safeURL(top.title);
						let countCel = create("div",false,false,secondRow);
						let statusDot = create("div","hohStatusDot",false,countCel);
						statusDot.style.backgroundColor = distributionColours[top.status];
						statusDot.title = top.status.toLowerCase();
						if(top.status === "COMPLETED"){
							statusDot.style.backgroundColor = "transparent";//default case
						}
						if(top.repeat === 1){
							countCel.appendChild(svgAssets2.repeat.cloneNode(true));
						}
						else if(top.repeat > 1){
							countCel.appendChild(svgAssets2.repeat.cloneNode(true));
							create("span",false,top.repeat,countCel)
						}
						create("div",false,(top.score ? top.score : "-"),secondRow);
						let timeString = formatTime(top.watchedDuration*60);
						let timeCel = create("div",false,timeString,secondRow);
						timeCel.title = (top.watchedDuration/60).roundPlaces(1) + " hours";
					});
					row.onclick = function(){
						if(showRow.style.display === "none"){
							showRow.style.display = "block"
						}
						else{
							showRow.style.display = "none"
						}
					}
				});
				let csvButton = create("button",["csvExport","button","hohButton"],"CSV data",animeStudios,"margin-top:10px;");
				let jsonButton = create("button",["jsonExport","button","hohButton"],"JSON data",animeStudios,"margin-top:10px;");
				csvButton.onclick = function(){
					let csvContent = 'Studio,Count,"Mean Score","Time Watched"\n';
					studioList.forEach(function(studio){
						csvContent += csvEscape(studio.name) + ",";
						csvContent += studio.count + ",";
						csvContent += (studio.scoreSum/studio.scoreCount).roundPlaces(2) + ",";
						csvContent += (studio.watchedDuration/60).roundPlaces(1) + "\n";
					});
					saveAs(csvContent,"Anime studio stats for " + user + ".csv",true);
				};
				jsonButton.onclick = function(){
					saveAs({
						type: "ANIME",
						user: user,
						timeStamp: NOW(),
						version: "1.00",
						scriptInfo: scriptInfo,
						url: document.URL,
						description: "Anilist anime studio stats for " + user,
						fields: [
							{name: "studio",description: "The name of the studio. (Can also be other companies, depending on the user's settings)"},
							{name: "studioID",description: "The studio's database number in the Anilist database"},
							{name: "count",description: "The total number of media this studio has credits for, for the current user"},
							{name: "score",description: "The current user's mean score for the studio out of 100"},
							{name: "minutesWatched",description: "How many minutes of this studio's credited media the current user has watched"},
							{
								name: "media",
								description: "A list of the media associated with this studio",
								subSelection: [
									{name: "title",description: "The title of the media (language depends on user settings)"},
									{name: "ID",description: "The media's database number in the Anilist database"},
									{name: "score",description: "The current user's mean score for the media out of 100"},
									{name: "minutesWatched",description: "How many minutes of the media the current user has watched"},
									{name: "status",description: "The current user's watching status for the media"},
								]
							}
						],
						data: studioList.map(studio => {
							return {
								studio: studio.name,
								studioID: studio.id,
								count: studio.count,
								score: (studio.scoreSum/studio.scoreCount).roundPlaces(2),
								minutesWatched: studio.watchedDuration,
								media: studio.media.map(media => {
									return {
										title: media.title,
										ID: media.id,
										score: media.score,
										minutesWatched: media.watchedDuration,
										status: media.status
									}
								})
							}
						})
					},"Anime studio stats for " + user + ".json");
				}
				nameHeading.onclick = function(){
					studioList.sort(ALPHABETICAL(a => a.name));
					studioList.forEach(studio => {
						studio.media.sort(ALPHABETICAL(a => a.title))
					});
					drawStudioList();
				};
				countHeading.onclick = function(){
					studioList.sort((b,a) => a.count - b.count || a.watchedDuration - b.watchedDuration);
					drawStudioList();
				};
				scoreHeading.onclick = function(){
					studioList.sort((b,a) => a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount);
					studioList.forEach(studio => {
						studio.media.sort((b,a) => a.score - b.score)
					});
					drawStudioList();
				};
				timeHeading.onclick = function(){
					studioList.sort((b,a) => a.watchedDuration - b.watchedDuration);
					studioList.forEach(function(studio){
						studio.media.sort((b,a) => a.watchedDuration - b.watchedDuration);
					});
					drawStudioList();
				};
			};
			let studioClickOnce = function(){
				drawStudioList();
				let place = document.querySelector(`[href$="/stats/anime/studios"]`);
				if(place){
					place.removeEventListener("click",studioClickOnce)
				}
			}
			let studioWaiter = function(){
				if(location.pathname.includes("/stats/anime/studios")){
					studioClickOnce();
					return;
				}
				let place = document.querySelector(`[href$="/stats/anime/studios"]`);
				if(place){
					place.addEventListener("click",studioClickOnce)
				}
				else{
					setTimeout(studioWaiter,200)
				}
			};studioWaiter();
	}//end boneless check
			return
		};
		if(user === whoAmI && reliablePersistentStorage){
			cache.getList("ANIME",function(data){
				personalStatsCallback(data)
			})
		}
		else{
			const animeData = await anilistAPI(queryMediaListAnime, {
				variables: {name: user, listType: "ANIME"}
			})
			if(animeData.errors){
				return
			}
			personalStatsCallback(animeData)
		}
//manga stats
		let personalStatsMangaCallback = async function(data){
			personalStatsManga.innerText = "";
			create("hr","hohSeparator",false,personalStatsManga);
			create("h1","hohStatHeading",translate("$stats_manga_heading",user),personalStatsManga);
			let list = returnList(data);
			let scoreList = list.filter(element => element.scoreRaw);
			let personalStatsMangaContainer = create("div",false,false,personalStatsManga);
			if(whoAmI && whoAmI !== user){
				let compatabilityButton = create("button",["button","hohButton"],"Compatibility",personalStatsManga);
				let compatLocation = create("div","#hohCheckCompatManga",false,personalStatsManga);
				compatabilityButton.onclick = function(){
					compatLocation.innerText = translate("$loading");
					compatLocation.style.marginTop = "5px";
					compatCheck(
						scoreList,
						whoAmI,
						"MANGA",
						function(data){
							formatCompat(data,compatLocation,user)
						}
					)
				}
			}
			let addStat = function(text,value,comment){//value,value,html
				let newStat = create("p","hohStat",false,personalStatsManga);
				create("span",false,text,newStat);
				create("span","hohStatValue",value,newStat);
				if(comment){
					let newStatComment = create("span",false,false,newStat);
					newStatComment.innerText = comment
				}
			};
			let chapters = 0;
			let volumes = 0;
			/*
			For most airing anime, Anilist provides "media.nextAiringEpisode.episode"
			Unfortunately, the same is not the case for releasing manga.
			THIS DOESN'T MATTER the first time a user is reading something, as we are then just using the current progress.
			But on a re-read, we need the total length to count all the chapters read.
			I can (and do) get a lower bound for this by using the current progress (this is what Anilist does),
			but this is not quite accurate, especially early in a re-read.
			The list below is to catch some of those exceptions
			*/
			let unfinishedLookup = function(mediaId,mode,mediaStatus,mediaProgress){//wow, this is a mess. But it works
				if(mediaStatus === "FINISHED"){
					return 0//it may have finished since the list was updated
				}
				if(hasOwn(commonUnfinishedManga, mediaId)){
					if(mode === "chapters"){
						return commonUnfinishedManga[mediaId].chapters
					}
					else if(mode === "volumes"){
						return commonUnfinishedManga[mediaId].volumes
					}
					else if(mode === "volumesNow"){
						if(commonUnfinishedManga[mediaId].chapters <= (mediaProgress || 0)){
							return commonUnfinishedManga[mediaId].volumes
						}
						else{
							//if much behind, assume volumes scale linearly
							return Math.floor(commonUnfinishedManga[mediaId].volumes * mediaProgress/commonUnfinishedManga[mediaId].chapters)
						}
					}
					return 0;//fallback
				}
				else{
					return 0//not in our list
				}
			};
			list.forEach(function(item){
				let chaptersRead = 0;
				let volumesRead = 0;
				if(item.status === "COMPLETED"){//if it's completed, we can make some safe assumptions
					chaptersRead += Math.max(//chapter progress on the current read
						item.media.chapters,//in most cases, it has a chapter count
						item.media.volumes,//if not, there's at least 1 chapter per volume
						item.progress,//if it doesn't have a volume count either, the current progress is probably not out of date
						item.progressVolumes,//if it doesn't have a chapter progress, count at least 1 chapter per volume
						1//finally, an entry has at least 1 chapter
					);
					volumesRead += Math.max(
						item.progressVolumes,
						item.media.volumes,
						unfinishedLookup(item.mediaId+"","volumesNow",item.media.status,item.progress)//if people have forgotten to update their volume count and have caught up.
					)
				}
				else{//we may only assume what's on the user's list.
					chaptersRead += Math.max(
						item.progress,
						item.progressVolumes
					);
					volumesRead += Math.max(
						item.progressVolumes,
						unfinishedLookup(item.mediaId+"","volumesNow",item.media.status,item.progress)
					)
				}
				if(useScripts.noRewatches && item.repeat){//if they have a reread, they have at least completed it
					chaptersRead = Math.max(//first round
						item.media.chapters,
						item.media.volumes,
						item.progress,
						item.progressVolumes,
						unfinishedLookup(item.mediaId+"","chapters",item.media.status),//use our lookup table
						1
					);
					volumesRead = Math.max(
						item.media.volumes,
						item.progressVolumes,
						unfinishedLookup(item.mediaId+"","volumes",item.media.status)
					)
				}
				else{
					chaptersRead += item.repeat * Math.max(//chapters from rereads
						item.media.chapters,
						item.media.volumes,
						item.progress,
						item.progressVolumes,
						unfinishedLookup(item.mediaId+"","chapters",item.media.status),//use our lookup table
						1
					);
					volumesRead += item.repeat * Math.max(//many manga have no volumes, so we can't make all of the same assumptions
						item.media.volumes,
						item.progressVolumes,//better than nothing if a volume count is missing
						unfinishedLookup(item.mediaId+"","volumes",item.media.status)
					)
				}
				if(item.listJSON && item.listJSON.adjustValue){
					chaptersRead = Math.max(0,chaptersRead + item.listJSON.adjustValue)
				}
				chapters += chaptersRead;
				volumes += volumesRead;
				item.volumesRead = volumesRead;
				item.chaptersRead = chaptersRead;
			});
//
			let previouScore = 0;
			let maxRunLength = 0;
			let maxRunLengthScore = 0;
			let runLength = 0;
			let sumEntries = 0;
			let average = 0;
			let publicDeviation = 0;
			let publicDifference = 0;
			let histogram = new Array(100).fill(0);
			let amount = scoreList.length;
			let median = (scoreList.length ? Stats.median(scoreList.map(e => e.scoreRaw)) : 0);
			let sumWeight = 0;
			let sumEntriesWeight = 0;

			scoreList.sort((a,b) => a.scoreRaw - b.scoreRaw);
			scoreList.forEach(function(item){
				sumEntries += item.scoreRaw;
				if(item.scoreRaw === previouScore){
					runLength++;
					if(runLength > maxRunLength){
						maxRunLength = runLength;
						maxRunLengthScore = item.scoreRaw
					}
				}
				else{	
					runLength = 1;
					previouScore = item.scoreRaw
				}
				sumWeight += item.chaptersRead;
				sumEntriesWeight += item.scoreRaw * item.chaptersRead;
				histogram[item.scoreRaw - 1]++
			});
			addStat(translate("$stats_mangaOnList"),list.length);
			addStat(translate("$stats_mangaRated"),amount);
			addStat(translate("$stats_totalChapters"),chapters);
			addStat(translate("$stats_totalVolumes"),volumes);
			if(amount){
				average = sumEntries/amount
			}
			if(scoreList.length){
				publicDeviation = Math.sqrt(
					scoreList.reduce(function(accum,element){
						if(!element.media.meanScore){
							return accum
						}
						return accum + Math.pow(element.media.meanScore - element.scoreRaw,2);
					},0)/amount
				);
				publicDifference = scoreList.reduce(function(accum,element){
					if(!element.media.meanScore){
						return accum
					}
					return accum + (element.scoreRaw - element.media.meanScore);
				},0)/amount
			}
			list.sort((a,b) => a.mediaId - b.mediaId);
			if(amount){//no scores
				if(amount === 1){
					addStat(
						translate("$stats_onlyOne"),
						maxRunLengthScore
					)
				}
				else{
					addStat(
						translate("$stats_averageScore"),
						average.toPrecision(4)
					);
					addStat(
						translate("$stats_averageScore"),
						(sumEntriesWeight/sumWeight).toPrecision(4),
						translate("$stats_weightComment_chapers")
					);
					addStat(translate("$stats_medianScore"),median);
					addStat(
						translate("$stats_globalDifference"),
						publicDifference.roundPlaces(2),
						translate("$stats_globalDifference_comment")
					);
					addStat(
						translate("$stats_globalDeviation"),
						publicDeviation.roundPlaces(2),
						translate("$stats_globalDeviation_comment")
					);
					addStat(
						translate("$stats_ratingEntropy"),
						-histogram.reduce((acc,val) => {
							if(val){
								return acc + Math.log2(val/amount) * val/amount
							}
							return acc
						},0).toPrecision(3),
						translate("$stats_ratingEntropy_comment")
					);
					if(maxRunLength > 1){
						addStat(translate("$stats_mostCommonScore"),maxRunLengthScore, " " + translate("$stats_instances",maxRunLength))
					}
					else{
						addStat(translate("$stats_mostCommonScore"),"","no two scores alike")
					}
				}
			}
//
			let mangaFormatter = {
				title: translate("$stats_customTagsManga"),
				display: !useScripts.hideCustomTags,
				headings: [translate("$stats_tag"),translate("$stats_count"),translate("$stats_meanScore"),translate("$stats_chapters"),translate("$stats_volumes")],
				focus: -1,
				celData: [
					function(cel,data,index,isPrimary){
						if(isPrimary){
							let nameCellCount = create("div","count",(index+1),cel);
							create("a",false,data[index].name,cel,"cursor:pointer;");
							let nameCellStatus = create("span","hohSummableStatusContainer",false,cel);
							semmanticStatusOrder.forEach(function(status){
								if(data[index].status && data[index].status[status]){
									let statusSumDot = create("div","hohSummableStatus",data[index].status[status],nameCellStatus);
									statusSumDot.style.background = distributionColours[status];
									statusSumDot.title = data[index].status[status] + " " + capitalize(statusTypes[status]);
									if(data[index].status[status] > 99){
										statusSumDot.style.fontSize = "8px"
									}
									if(data[index].status[status] > 999){
										statusSumDot.style.fontSize = "6px"
									}
									statusSumDot.onclick = function(e){
										e.stopPropagation();
										Array.from(cel.parentNode.nextSibling.children).forEach(function(child){
											if(child.children[1].children[0].title === status.toLowerCase()){
												child.style.display = "grid"
											}
											else{
												child.style.display = "none"
											}
										})
									}
								}
							})
						}
						else{
							create("a","hohNameCel",data[index].name,cel)
								.href = "/manga/" + data[index].mediaId + "/" + safeURL(data[index].name)
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							cel.innerText = data[index].list.length
						}
						else{
							let statusDot = create("div","hohStatusDot",false,cel);
							statusDot.style.backgroundColor = distributionColours[data[index].status];
							statusDot.title = data[index].status.toLowerCase();
							if(data[index].status === "COMPLETED"){
								statusDot.style.backgroundColor = "transparent"//default case
							}
							if(data[index].repeat === 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true));
							}
							else if(data[index].repeat > 1){
								cel.appendChild(svgAssets2.repeat.cloneNode(true));
								create("span",false,data[index].repeat,cel)
							}
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary){
							if(data[index].average === 0){
								cel.innerText = "-"
							}
							else{
								cel.innerText = (data[index].average).roundPlaces(1)
							}
						}
						else{
							if(data[index].score === 0){
								cel.innerText = "-"
							}
							else{
								cel.innerText = (data[index].score).roundPlaces(1)
							}
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary && !data[index].list.length){
							cel.innerText = "-"
						}
						else{
							cel.innerText = data[index].chaptersRead
						}
					},
					function(cel,data,index,isPrimary){
						if(isPrimary && !data[index].list.length){
							cel.innerText = "-"
						}
						else{
							cel.innerText = data[index].volumesRead
						}
					}
				],
				sorting: [
					ALPHABETICAL(a => a.name),
					(b,a) => a.list.length - b.list.length,
					(b,a) => a.average - b.average,
					(b,a) => a.chaptersRead - b.chaptersRead,
					(b,a) => a.volumesRead - b.volumesRead
				]
			};
			const mangaFields = [
				{
					key : "name",
					method : function(media){
						return titlePicker({
							id: media.mediaId,
							title: media.media.title
						})
					}
				},{
					key : "repeat",
					method : media => media.repeat
				},{
					key : "status",
					sumable : function(acc,val){
						if(!acc){
							acc = {};
							Object.keys(distributionColours).forEach(function(key){
								acc[key] = 0
							})
						}
						acc[val]++;
						return acc
					},
					method : media => media.status
				},{
					key : "mediaId",
					method : media => media.mediaId
				},{
					key : "score",
					method : media => media.scoreRaw
				},{
					key : "chaptersRead",
					sumable : ACCUMULATE,
					method : media => media.chaptersRead
				},{
					key : "volumesRead",
					sumable : ACCUMULATE,
					method : media => media.volumesRead
				}
			];
			let customTags = customTagsCollection(list,mangaFormatter.title,mangaFields);
			if(customTags.length){
				let customTagsMangaTable = create("div","#customTagsMangaTable",false,personalStatsManga);
				drawTable(customTags,mangaFormatter,customTagsMangaTable,true,true)
			}
			let listOfTags = regularTagsCollection(list,mangaFields,media => media.media.tags);
			if(listOfTags.length > 50){
				listOfTags = listOfTags.filter(a => a.list.length >= 3)
			}
			semaPhoreManga = list;
	if(script_type !== "Boneless"){
			drawTable(listOfTags,mangaFormatter,regularMangaTable,true,false);
			nativeTagsReplacer();
	}

			const staffSimpleData = await anilistAPI(queryMediaListStaff_simple, {
				variables: {name: user,listType: "MANGA"},
				cacheKey: "hohListCacheMangaStaff" + user,
				duration: 10*60*1000
			})
			if(staffSimpleData.errors){
				return
			}
			let rawStaff = returnList(staffSimpleData);
			let cacheOffset = 0;
			rawStaff.forEach(function(raw,index){
				if(raw.mediaId === list[index - cacheOffset].mediaId){
					raw.status = list[index - cacheOffset].status;
					raw.chaptersRead = list[index - cacheOffset].chaptersRead;
					raw.volumesRead = list[index - cacheOffset].volumesRead;
					raw.scoreRaw = list[index - cacheOffset].scoreRaw
				}
				else{
					cacheOffset++;
					raw.status = "CURRENT";
					raw.chaptersRead = 0;
					raw.volumesRead = 0;
					raw.scoreRaw = 0
				}
			});
			let staffMap = {};
			rawStaff.filter(obj => obj.status !== "PLANNING").forEach(function(media){
				media.media.staff.edges.forEach(function(staff){
					if(!staffMap[staff.node.id]){
						staffMap[staff.node.id] = {
							chaptersRead: 0,
							volumesRead: 0,
							count: 0,
							scoreCount: 0,
							scoreSum: 0,
							id: staff.node.id,
							name: staff.node.name,
							roles: []
						}
					}
					staffMap[staff.node.id].roles.push(staff.role);
					if(media.chaptersRead || media.volumesRead){
						staffMap[staff.node.id].volumesRead += media.volumesRead;
						staffMap[staff.node.id].chaptersRead += media.chaptersRead;
						staffMap[staff.node.id].count++
					}
					if(media.scoreRaw){
						staffMap[staff.node.id].scoreSum += media.scoreRaw;
						staffMap[staff.node.id].scoreCount++
					}
				})
			});
			let staffList = [];
			Object.keys(staffMap).forEach(
				key => staffList.push(staffMap[key])
			);
			staffList = staffList.filter(obj => obj.count >= 1).sort(
				(b,a) => a.count - b.count || a.chaptersRead - b.chaptersRead || a.volumesRead - b.volumesRead
			);
			if(staffList.length > 300){
				staffList = staffList.filter(
					obj => obj.count >= 3
					|| (obj.count >= 2 && obj.chaptersRead > 100)
					|| obj.chaptersRead > 200
				)
			}
			if(staffList.length > 300){
				staffList = staffList.filter(
					obj => obj.count >= 5
					|| (obj.count >= 2 && obj.chaptersRead > 200)
					|| obj.chaptersRead > 300
				)
			}
			if(staffList.length > 300){
				staffList = staffList.filter(
					obj => obj.count >= 10
					|| (obj.count >= 2 && obj.chaptersRead > 300)
					|| obj.chaptersRead > 400
				)
			}
			let hasScores = staffList.some(a => a.scoreCount);
			let story_filter;
			let art_filter;
			let assistant_filter;
			let translator_filter;
			let drawStaffList = function(){
				if(mangaStaff.querySelector(".table")){
					mangaStaff.querySelector(".table").remove()
				}
				if(mangaStaff.querySelector(".jsonExport")){
					mangaStaff.querySelector(".jsonExport").remove();
					mangaStaff.querySelector(".csvExport").remove()
				}
				else{
					mangaStaff.innerText = "";
					story_filter = createCheckbox(mangaStaff);
					create("span",false,translate("$role_Story",null,"Story"),mangaStaff,"margin-right:5px;");
					art_filter = createCheckbox(mangaStaff);
					create("span",false,translate("$role_Art",null,"Art"),mangaStaff,"margin-right:5px;");
					assistant_filter = createCheckbox(mangaStaff);
					create("span",false,"Assistants",mangaStaff,"margin-right:5px;");
					translator_filter = createCheckbox(mangaStaff);
					create("span",false,"Translators",mangaStaff,"margin-right:5px;");
					story_filter.checked = true;
					art_filter.checked = true;
					assistant_filter.checked = true;
					translator_filter.checked = true;
					story_filter.oninput = drawStaffList;
					art_filter.oninput = drawStaffList;
					assistant_filter.oninput = drawStaffList;
					translator_filter.oninput = drawStaffList;
				}
				let table = create("div",["table","hohTable","hohNoPointer"],false,mangaStaff);
				let headerRow = create("div",["header","row","good"],false,table);
				let nameHeading = create("div",false,translate("$stats_name"),headerRow,"cursor:pointer;");
				let countHeading = create("div",false,translate("$stats_count"),headerRow,"cursor:pointer;");
				let scoreHeading = create("div",false,translate("$stats_meanScore"),headerRow,"cursor:pointer;");
				if(!hasScores){
					scoreHeading.style.display = "none"
				}
				let timeHeading = create("div",false,"Chapters Read",headerRow,"cursor:pointer;");
				let volumeHeading = create("div",false,"Volumes Read",headerRow,"cursor:pointer;");
				staffList.forEach(function(staff,index){
					if(
						(!story_filter.checked && art_filter.checked && staff.roles.every(role => role.toLowerCase().match(/story/) && !role.toLowerCase().match(/art/)))
						|| (story_filter.checked && !art_filter.checked && staff.roles.every(role => role.toLowerCase().match(/art/) && !role.toLowerCase().match(/story/)))
						|| (
							!story_filter.checked
							&& !art_filter.checked
							&& (
								staff.roles.every(role => role.toLowerCase().match(/art|story/))
								|| !staff.roles.some(role => role.toLowerCase().match(/translator|lettering|touch-up|assistant|assistance/))
							)
						)
						|| (!assistant_filter.checked && staff.roles.every(role => role.toLowerCase().match(/assistant|assistance/)))
						|| (!translator_filter.checked && staff.roles.some(role => role.toLowerCase().match(/translator|lettering|touch-up/)))
					){
						return
					}
					let row = create("div",["row","good"],false,table);
					let nameCel = create("div",false,(index + 1) + " ",row);
					create("a","newTab",staff.name.first + " " + (staff.name.last || ""),nameCel)
						.href = "/staff/" + staff.id;
					create("div",false,staff.count,row);
					if(hasScores){
						create("div",false,(staff.scoreSum/staff.scoreCount).roundPlaces(2),row)
					}
					create("div",false,staff.chaptersRead,row);
					create("div",false,staff.volumesRead,row)
				});
				let csvButton = create("button",["csvExport","button","hohButton"],"CSV data",mangaStaff,"margin-top:10px;");
				let jsonButton = create("button",["jsonExport","button","hohButton"],"JSON data",mangaStaff,"margin-top:10px;");
				csvButton.onclick = function(){
					let csvContent = 'Staff,Count,"Mean Score","Chapters Read","Volumes Read"\n';
					staffList.forEach(staff => {
						csvContent += csvEscape(
							[staff.name.first,staff.name.last].filter(TRUTHY).join(" ")
						) + ",";
						csvContent += staff.count + ",";
						csvContent += (staff.scoreSum/staff.scoreCount).roundPlaces(2) + ",";
						csvContent += staff.chaptersRead + ",";
						csvContent += staff.volumesRead + "\n";
					});
					saveAs(csvContent,"Manga staff stats for " + user + ".csv",true)
				};
				jsonButton.onclick = function(){
					saveAs({
						type: "MANGA",
						user: user,
						timeStamp: NOW(),
						version: "1.00",
						scriptInfo: scriptInfo,
						url: document.URL,
						description: "Anilist manga staff stats for " + user,
						fields: [
							{name: "name",description: "The full name of the staff member, as firstname lastname"},
							{name: "staffID",description: "The staff member's database number in the Anilist database"},
							{name: "count",description: "The total number of media this staff member has credits for, for the current user"},
							{name: "score",description: "The current user's mean score for the staff member out of 100"},
							{name: "chaptersRead",description: "How many chapters of this staff member's credited media the current user has read"},
							{name: "volumesRead",description: "How many volumes of this staff member's credited media the current user has read"}
						],
						data: staffList.map(staff => {
							return {
								name: (staff.name.first + " " + (staff.name.last || "")).trim(),
								staffID: staff.id,
								count: staff.count,
								score: (staff.scoreSum/staff.scoreCount).roundPlaces(2),
								chaptersRead: staff.chaptersRead,
								volumesRead: staff.volumesRead
							}
						})
					},"Manga staff stats for " + user + ".json")
				}
				nameHeading.onclick = function(){
					staffList.sort(ALPHABETICAL(a => a.name.first + " " + (a.name.last || "")));
					drawStaffList()
				};
				countHeading.onclick = function(){
					staffList.sort(
						(b,a) => a.count - b.count
							|| a.chaptersRead - b.chaptersRead
							|| a.volumesRead - b.volumesRead
							|| a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount
					);
					drawStaffList()
				};
				scoreHeading.onclick = function(){
					staffList.sort(
						(b,a) => a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount
							|| a.count - b.count
							|| a.chaptersRead - b.chaptersRead
							|| a.volumesRead - b.volumesRead
					);
					drawStaffList()
				};
				timeHeading.onclick = function(){
					staffList.sort(
						(b,a) => a.chaptersRead - b.chaptersRead
							|| a.volumesRead - b.volumesRead
							|| a.count - b.count
							|| a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount
					);
					drawStaffList()
				};
				volumeHeading.onclick = function(){
					staffList.sort(
						(b,a) => a.volumesRead - b.volumesRead
							|| a.chaptersRead - b.chaptersRead
							|| a.count - b.count
							|| a.scoreSum/a.scoreCount - b.scoreSum/b.scoreCount
					);
					drawStaffList()
				}
			};
			let clickOnce = function(){
				drawStaffList();
				let place = document.querySelector(`[href$="/stats/manga/staff"]`);
				if(place){
					place.removeEventListener("click",clickOnce)
				}
			}
			let waiter = function(){
				if(location.pathname.includes("/stats/manga/staff")){
					clickOnce();
					return
				}
				let place = document.querySelector(`[href$="/stats/manga/staff"]`);
				if(place){
					place.addEventListener("click",clickOnce)
				}
				else{
					setTimeout(waiter,200)
				}
			};waiter();
			return
		};
		if(user === whoAmI && reliablePersistentStorage){
			cache.getList("MANGA",data => {
				personalStatsMangaCallback(data)
			})
		}
		else{
			const mangaData = await anilistAPI(queryMediaListManga, {
				variables: {name: user, listType: "MANGA"}
			})
			if(mangaData.errors){
				return
			}
			personalStatsMangaCallback(mangaData)
		}
		return
	};
	let tabWaiter = function(){
		let tabMenu = filterGroup.querySelectorAll(".filter-group > a");
		tabMenu.forEach(tab => {
			tab.onclick = function(){
				Array.from(document.querySelector(".stats-wrap").children).forEach(child => {
					child.style.display = "initial";
				});
				Array.from(document.getElementsByClassName("hohActive")).forEach(child => {
					child.classList.remove("hohActive");
				});
				document.getElementById("hohStats").style.display = "none";
				document.getElementById("hohGenres").style.display = "none";
				document.querySelector(".page-content .user").classList.remove("hohSpecialPage")
			}
		});
		if(!tabMenu.length){
			setTimeout(tabWaiter,200)
		}
	};tabWaiter();
	let statsWrap = document.querySelector(".stats-wrap");
	if(statsWrap){
		hohStats = create("div","#hohStats",false,statsWrap,"display:none;");
		hohGenres = create("div","#hohGenres",false,statsWrap,"display:none;");
		regularFilterHeading = create("div","#regularFilterHeading",false,hohGenres);
		regularGenresTable = create("div","#regularGenresTable",translate("$loading"),hohGenres);
		if(script_type !== "Boneless"){
			regularTagsTable = create("div","#regularTagsTable",translate("$loading"),hohGenres);
			regularAnimeTable = create("div","#regularAnimeTable",translate("$loading"),statsWrap);
			regularMangaTable = create("div","#regularMangaTable",translate("$loading"),statsWrap);
			animeStaff = create("div","#animeStaff",translate("$loading"),statsWrap);
			mangaStaff = create("div","#mangaStaff",translate("$loading"),statsWrap);
			animeStudios = create("div","#animeStudios",translate("$loading"),statsWrap);
		}
		hohStats.calculated = false;
		generateStatPage()
	}
	hohStatsTrigger.onclick = function(){
		hohStatsTrigger.classList.add("hohActive");
		hohGenresTrigger.classList.remove("hohActive");
		document.querySelector(".page-content .user").classList.add("hohSpecialPage");
		let otherActive = filterGroup.querySelector(".router-link-active");
		if(otherActive){
			otherActive.classList.remove("router-link-active");
			otherActive.classList.remove("router-link-exact-active");
		}
		document.querySelectorAll(".stats-wrap > div").forEach(
			module => module.style.display = "none"
		);
		hohStats.style.display = "initial";
		hohGenres.style.display = "none"
	};
	hohGenresTrigger.onclick = function(){
		hohStatsTrigger.classList.remove("hohActive");
		hohGenresTrigger.classList.add("hohActive");
		document.querySelector(".page-content .user").classList.add("hohSpecialPage");
		let otherActive = filterGroup.querySelector(".router-link-active");
		if(otherActive){
			otherActive.classList.remove("router-link-active");
			otherActive.classList.remove("router-link-exact-active")
		}
		document.querySelectorAll(".stats-wrap > div").forEach(
			module => module.style.display = "none"
		);
		hohStats.style.display = "none";
		hohGenres.style.display = "initial"
	}
}
//end modules/addMoreStats.js
//begin modules/addMyThreadsLink.js
function addMyThreadsLink(){
	if(!document.URL.match(/^https:\/\/anilist\.co\/forum\/?(overview|search\?.*|recent|new|subscribed)?$/)){
		return
	}
	if(document.querySelector(".hohMyThreads")){
		return
	}
	let target = document.querySelector(".filters");
	if(!target){
		setTimeout(addMyThreadsLink,100)
	}
	else{
		create("a",["hohMyThreads","link"],translate("$myThreads_link"),target)
			.href = "https://anilist.co/user/" + whoAmI + "/social#my-threads"
	}
}
//end modules/addMyThreadsLink.js
//begin modules/addProgressBar.js
function addProgressBar(){
	if(location.pathname !== "/home"){
		return
	}
	let mediaCards = document.querySelectorAll(".media-preview-card .content .info:not(.hasMeter) > div");
	if(!mediaCards.length){
		setTimeout(function(){
			addProgressBar()
		},200);//may take some time to load
		return
	}
	mediaCards.forEach(card => {
		const progressInformation = card.innerText.match(/Progress: (\d+)\/(\d+)/);
		if(progressInformation){
			let pBar = create("meter");
			pBar.value = progressInformation[1];
			pBar.min = 0;
			pBar.max = progressInformation[2];
			card.parentNode.insertBefore(pBar,card);
			card.parentNode.parentNode.parentNode.querySelector(".plus-progress").onclick = function(){
				pBar.value++;
				setTimeout(function(){
					pBar.value = card.innerText.match(/Progress: (\d+)\/(\d+)/)[1]
				},1000)
			}
		}
	});
	if(document.querySelector(".size-toggle")){
		document.querySelector(".size-toggle").onclick = function(){
			setTimeout(function(){
				addProgressBar()
			},200);
		}
	}
}
//end modules/addProgressBar.js
//begin modules/addRelationStatusDot.js
function addRelationStatusDot(id){
	if(!location.pathname.match(/^\/(anime|manga)/)){
		return;
	}
	let relations = document.querySelector(".relations");
	if(relations){
		if(relations.classList.contains("hohRelationStatusDots")){
			return
		}
		relations.classList.add("hohRelationStatusDots");
	}
	authAPIcall(
`query($id: Int){
	Media(id:$id){
		relations{
			nodes{
				id
				type
				mediaListEntry{status}
			}
		}
		recommendations(sort:RATING_DESC){
			nodes{
				mediaRecommendation{
					id
					type
					mediaListEntry{status}
				}
			}
		}
	}
}`,
		{id: id},
		function(data){
			if(!data){
				return
			}
			let adder = function(){
				let mangaAnimeMatch = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
				if(!mangaAnimeMatch){
					return
				}
				if(mangaAnimeMatch[2] !== id){
					return
				}
				let rels = data.data.Media.relations.nodes.filter(media => media.mediaListEntry);
				if(rels){
					relations = document.querySelector(".relations");
					if(relations){
						relations.classList.add("hohRelationStatusDots");
						relations.querySelectorAll(".hohStatusDot").forEach(dot => dot.remove());
						rels.forEach(media => {
							let target = relations.querySelector("[href^=\"/" + media.type.toLowerCase() + "/" + media.id + "/\"]");
							if(target){
								let statusDot = create("div","hohStatusDot",false,target);
								statusDot.style.background = distributionColours[media.mediaListEntry.status];
								statusDot.title = media.mediaListEntry.status.toLowerCase();
							}
						})
					}
					else{
						setTimeout(adder,300);
					}
				}
			};adder();
			let init_completed = false;
			let recsAdder = function(){
				let mangaAnimeMatch = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
				if(!mangaAnimeMatch){
					return
				}
				if(mangaAnimeMatch[2] !== id){
					return
				}
				let recs = data.data.Media.recommendations.nodes.map(
					item => item.mediaRecommendation
				).filter(
					item => item.mediaListEntry
				);
				if(recs.length){
					let findCard = document.querySelector(".recommendation-card");
					if(findCard){
						findCard = findCard.parentNode;
						let adder = function(recs){
							recs.forEach(media => {
								let target = findCard.querySelector("[href^=\"/" + media.type.toLowerCase() + "/" + media.id + "/\"]");
								if(target){
									let statusDot = create("div","hohStatusDot",false,target);
									statusDot.style.background = distributionColours[media.mediaListEntry.status];
									statusDot.title = media.mediaListEntry.status.toLowerCase();
								}
							});
						};adder(recs);
						let toggle = document.querySelector(".recommendations .view-all .toggle");
						if(toggle){
							toggle.addEventListener("click",function(){
								setTimeout(function(){adder(recs)},1000)
							})
						}
						if(!init_completed){
							init_completed = true;
							if(toggle && parseInt(toggle.innerText.match(/\d+/)) > 25){
								let recs2 = [];
								toggle.addEventListener("mouseover",function(){
									authAPIcall(
`query($id: Int){
	Media(id:$id){
		recommendations(sort:RATING_DESC,page:2){
			nodes{
				mediaRecommendation{
					id
					type
					mediaListEntry{status}
				}
			}
		}
	}
}`,
									{id: id},
									function(data){
										recs2 = data.data.Media.recommendations.nodes.map(
											item => item.mediaRecommendation
										).filter(
											item => item.mediaListEntry
										);
									}
									)
								})
								toggle.addEventListener("click",function(){
									setTimeout(function(){adder(recs2)},1000);//eh, good enough
									setTimeout(function(){adder(recs2)},5000);
									setTimeout(function(){adder(recs2)},10000);
									setTimeout(function(){adder(recs2)},15000)
								})
							}
						}
					}
					else{
						setTimeout(recsAdder,300)
					}
				}
			};recsAdder();
		},
		"hohRelationStatusDot" + id,2*60*1000,
		false,false,
		function(data){
			let adder = function(){
				let mangaAnimeMatch = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/(\d+)\/?([^/]*)?\/?(.*)?/);
				if(!mangaAnimeMatch){
					return
				}
				if(mangaAnimeMatch[2] !== id){
					return
				}
				let rels = data.data.Media.relations.nodes.filter(media => media.mediaListEntry);
				if(rels){
					relations = document.querySelector(".relations");
					if(relations && !relations.classList.contains("hohRelationStatusDots")){
						relations.classList.add("hohRelationStatusDots");
						rels.forEach(media => {
							let target = relations.querySelector("[href^=\"/" + media.type.toLowerCase() + "/" + media.id + "/\"]");
							if(target){
								let statusDot = create("div","hohStatusDot",false,target);
								statusDot.style.background = distributionColours[media.mediaListEntry.status];
								statusDot.title = media.mediaListEntry.status.toLowerCase();
							}
						})
					}
					else{
						setTimeout(adder,300)
					}
				}
			};adder();
		}
	)
}
//end modules/addRelationStatusDot.js
//begin modules/addReviewConfidence.js
exportModule({
	id: "reviewConfidence",
	description: "Add confidence scores to reviews",
	isDefault: true,
	categories: ["Browse"],
	visible: true,
	urlMatch: function(url){
		return /^https:\/\/anilist\.co\/reviews/.test(url)
	},
	code: function(){
		let pageCount = 0;
		const adultContent = userObject ? userObject.options.displayAdultContent : false;

		const addReviewConfidence = async function(){
			pageCount++
			const {data, errors} = await anilistAPI("query($page:Int){Page(page:$page,perPage:30){reviews(sort:ID_DESC){id rating ratingAmount}}}", {
				variables: {page: pageCount},
				cacheKey: "hohRecentReviewsPage" + pageCount,
				duration: 30*1000,
				auth: adultContent // api doesn't return reviews for adult content unless authed + have the option enabled
			})
			if(errors){
				return;
			}
			const locationForIt = document.querySelector(".recent-reviews");
			if(!locationForIt){
				return;
			}
			const reviewWrap = locationForIt.querySelector(".review-wrap") || await watchElem(".review-wrap", locationForIt);
			data.Page.reviews.forEach(async (review) => {
				const wilsonLowerBound = wilson(review.rating,review.ratingAmount).left
				const extraScore = create("span","wilson","~" + Math.round(100*wilsonLowerBound));
				extraScore.style.color = "hsl(" + wilsonLowerBound*120 + ",100%,50%)";
				extraScore.style.marginRight = "3px";
				const votes = `[href="/review/${review.id}"] .votes`;
				const parent = reviewWrap.querySelector(votes) || await watchElem(votes, reviewWrap);
				if(parent.querySelector(".wilson")){
					return;
				}
				parent.insertBefore(extraScore,parent.firstChild);
				if(wilsonLowerBound < 0.05){
					parent.parentNode.parentNode.style.opacity = "0.5" // dim review-card
				}
				return;
			})
			return;
		}

		const checkMore = async function(){
			const container = document.querySelector(".recent-reviews");
			if(!container){
				return;
			}
			const loadMore = container.querySelector(".load-more") || await watchElem(".load-more", container);
			addReviewConfidence()
			loadMore.addEventListener("click", () => {
				addReviewConfidence()
				checkMore() // a different load more button is created, so the listener needs to be reattached
			})
			return;
		};checkMore();
	},
	css: `
	.recent-reviews .review-wrap .review-card .summary {
		margin-bottom: 15px;
	}
	`
})
//end modules/addReviewConfidence.js
//begin modules/addSocialThemeSwitch.js
function addSocialThemeSwitch(){
	let URLstuff = location.pathname.match(/^\/user\/(.*)\/social/)
	if(!URLstuff){
		return
	}
	if(document.querySelector(".filters .hohThemeSwitch")){
		return
	}
	let target = document.querySelector(".filters");
	if(!target){
		setTimeout(addSocialThemeSwitch,100);
		return;
	}
	let themeSwitch = create("div",["theme-switch","hohThemeSwitch"],false,target,"width:70px;");
	let listView = create("span",false,false,themeSwitch);
	let cardView = create("span","active",false,themeSwitch);
	listView.appendChild(svgAssets2.listView.cloneNode(true));
	cardView.appendChild(svgAssets2.cardView.cloneNode(true));
	listView.onclick = function(){
		document.querySelector(".hohThemeSwitch .active").classList.remove("active");
		listView.classList.add("active");
		document.querySelector(".user-social").classList.add("listView");
	}
	cardView.onclick = function(){
		document.querySelector(".hohThemeSwitch .active").classList.remove("active");
		cardView.classList.add("active");
		document.querySelector(".user-social.listView").classList.remove("listView");
	}
}
//end modules/addSocialThemeSwitch.js
//begin modules/addStudioBrowseSwitch.js
function addStudioBrowseSwitch(){
	let URLstuff = location.pathname.match(/^\/studio\//)
	if(!URLstuff){
		return
	}
	if(document.querySelector(".studio-page-unscoped .hohThemeSwitch")){
		return
	}
	let target = document.querySelector(".studio-page-unscoped");
	if(!target){
		setTimeout(addStudioBrowseSwitch,100);
		return;
	}
	let themeSwitch = create("div",["theme-switch","hohThemeSwitch"],false,target);
	target.classList.add("cardView");
	let listView = create("span",false,false,themeSwitch);
	listView.title = "List View";
	let cardView = create("span","active",false,themeSwitch);
	cardView.title = "Card View";
	listView.appendChild(svgAssets2.bigListView.cloneNode(true));
	cardView.appendChild(svgAssets2.compactView.cloneNode(true));
	cardView.onclick = function(){
		document.querySelector(".hohThemeSwitch .active").classList.remove("active");
		cardView.classList.add("active");
		target.classList.add("cardView");
		target.classList.remove("listView");
	}
	listView.onclick = function(){
		document.querySelector(".hohThemeSwitch .active").classList.remove("active");
		listView.classList.add("active");
		target.classList.remove("cardView");
		target.classList.add("listView");
	}
}
//end modules/addStudioBrowseSwitch.js
//begin modules/addSubTitleInfo.js
function addSubTitleInfo(){
	let URLstuff = document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/.*/);
	if(!URLstuff){
		return
	}
	else if(document.querySelector(".hohExtraBox")){
		document.querySelector(".hohExtraBox").remove()
	}
	let sidebar = document.querySelector(".sidebar");
	if(!sidebar){
		setTimeout(addSubTitleInfo,200);
		return
	}
	let cover_inner = document.querySelector(".cover-wrap-inner");
	if(cover_inner){
		let diff = sidebar.getBoundingClientRect().top - cover_inner.getBoundingClientRect().bottom;
		if(diff < 20){
			if(sidebar.style.marginTop){
				sidebar.style.marginTop = Math.round(20 - diff + parseInt(sidebar.style.marginTop.match(/\d+/)[0])) + "px"
			}
			else{
				sidebar.style.marginTop = Math.round(20 - diff) + "px"
			}
		}
	}
	let infoNeeded = {};
	Array.from(sidebar.querySelectorAll(".data-set .type")).forEach(pair => {
		if(pair.innerText === "Native"){
			infoNeeded.native = pair.nextElementSibling.innerText
		}
		if(pair.innerText === "Romaji"){
			infoNeeded.romaji = pair.nextElementSibling.innerText
		}
		if(pair.innerText === "English"){
			infoNeeded.english = pair.nextElementSibling.innerText
		}
		else if(pair.innerText === "Format"){
			infoNeeded.format = pair.nextElementSibling.innerText;
			if(infoNeeded.format === "Manga (Chinese)"){
				infoNeeded.format = "Manhua"
			}
			else if(infoNeeded.format === "Manga (Korean)"){
				infoNeeded.format = "Manhwa"
			}
		}
		else if(pair.innerText === "Release Date" || pair.innerText === "Start Date"){
			infoNeeded.year = pair.nextElementSibling.innerText.match(/\d{4}/)[0]
		}
		else if(pair.innerText === "Studios"){
			infoNeeded.studios = pair.nextElementSibling.innerText.split("\n");
			infoNeeded.studiosLinks = Array.from(
				pair.nextElementSibling.querySelectorAll("a")
			).map(a => a.href);
		}
	});
	if(!infoNeeded.romaji){//guaranteed to exist, so a good check for if the sidebar has loaded
		setTimeout(addSubTitleInfo,200);
		return
	}
	let title = document.querySelector(".content > h1");
	let extraBox = create("div","hohExtraBox");
	title.parentNode.insertBefore(extraBox,title.nextElementSibling);
	let subTitle = create("p","value","",extraBox,"margin:2px;font-style:italic;");
	if(useScripts.titleLanguage === "NATIVE"){
		if(infoNeeded.romaji && infoNeeded.romaji !== infoNeeded.native){
			subTitle.innerText = infoNeeded.romaji
		}
		else if(infoNeeded.english && infoNeeded.english !== infoNeeded.native){
			subTitle.innerText = infoNeeded.english
		}
	}
	else if(useScripts.titleLanguage === "ENGLISH"){
		if(infoNeeded.native && infoNeeded.native !== infoNeeded.english){
			subTitle.innerText = infoNeeded.native
		}
		else if(infoNeeded.romaji && infoNeeded.romaji !== infoNeeded.english){
			subTitle.innerText = infoNeeded.romaji
		}
	}
	else{
		if(
			infoNeeded.native
			&& infoNeeded.native.replace(//convert fullwidth to regular before comparing
				/[\uff01-\uff5e]/g,
				ch => String.fromCharCode(ch.charCodeAt(0) - 0xfee0)
			) !== infoNeeded.romaji
		){
			subTitle.innerText = infoNeeded.native
		}
	}
	if(infoNeeded.year){
		create("a","value",infoNeeded.year,extraBox,"margin-right:10px;")
			.href = "/search/" + URLstuff[1] + "?year=" + infoNeeded.year + "%25"
	}
	if(infoNeeded.format && infoNeeded.format !== "Manga"){
		create("span","value",infoNeeded.format,extraBox,"margin-right:10px;")
	}
	if(infoNeeded.studios){
		let studioBox = create("span","value",false,extraBox);
		infoNeeded.studios.forEach((studio,i) => {
			let studiolink = create("a",false,studio,studioBox);
			studiolink.href = infoNeeded.studiosLinks[i];
			if(i < infoNeeded.studios.length - 1){
				create("span",false,", ",studioBox)
			}
		})
	}
}
//end modules/addSubTitleInfo.js
//begin modules/ALbuttonReload.js
if(useScripts.ALbuttonReload){
	let logo = document.querySelector("#nav .logo");
	if(logo){
		logo.onclick = function(){
			if(/\/home\/?$/.test(location.pathname)){//we only want this behaviour here
				window.location.reload(false);//reload page, but use cache if possible
			}
		}
	}
}

exportModule({
	id: "ALbuttonReload",
	description: "$ALbuttonReload_description",
	isDefault: true,
	categories: ["Navigation"],
	visible: true
})
//end modules/ALbuttonReload.js
//begin modules/anisongs.js
//fork of anisongs by morimasa
//https://greasyfork.org/en/scripts/374785-anisongs
const anisongs_temp = {
	last: null,
	target: null
}

exportModule({
	id: "anisongs",
	description: "Add OP/ED data to media pages [by Morimasa]",
	isDefault: false,
	categories: ["Media"],
	visible: true,
	urlMatch: function(url,oldUrl){
    return /^https:\/\/anilist\.co\/(anime|manga)\/[0-9]+\/.*/.test(url)
	},
	code: function(){
const options = {
  cacheTTL: 604800000, // 1 week in ms
  class: 'anisongs', // container class
}

const songCache = localforage.createInstance({name: script_type.toLowerCase(), storeName: "anisongs"});

const API = {
  async getSongs(mal_id) {
    const res = await fetch(`https://api.jikan.moe/v4/anime/${mal_id}/themes`)
    return res.json()
  },
  async getVideos(anilist_id) {
    const res = await fetch(`https://staging.animethemes.moe/api/anime?filter[has]=resources&filter[site]=AniList&filter[external_id]=${anilist_id}&include=animethemes.animethemeentries.videos`)
    return res.json()
  }
}

class VideoElement {
  constructor(parent, url) {
    this.url = url
    this.parent = parent
    this.make()
  }

  toggle() {
    if (this.el.parentNode) {
      this.el.remove()
    }
    else {
      this.parent.append(this.el)
      this.el.children[0].autoplay = true // autoplay
    }
  }

  make() {
    const box = document.createElement('div'),
          vid = document.createElement('video')
    vid.src = this.url
    vid.controls = true
    vid.preload = "none"
    vid.volume = 0.4
    box.append(vid)
    this.el = box
  }
}

class Videos {
  constructor(id) {
    this.id = id
  }

  async get() {
    const {anime} = await API.getVideos(this.id);
    if(anime.length === 0){
      return {"OP":[], "ED":[]}
    }
    return Videos.groupTypes(anime[0].animethemes)
  }

  static groupTypes(songs) {
    const groupBy = (xs, key) => {
      return xs.reduce(function(rv, x) {
        (rv[x[key]] = rv[x[key]] || []).push(x);
        return rv;
      }, {});
    };
    return groupBy(songs, "type")
  }

  static merge(entries, videos) {
    const cleanTitle = song => {
      return song.replace(/^\d{1,2}:/, "")
    }
    const findUrl = n => {
      let url;
      if(videos[n]) {
        if(videos[n].animethemeentries[0] && videos[n].animethemeentries[0].videos[0]){
          url = videos[n].animethemeentries[0].videos[0].link
        }
        if(url) url = url.replace(/staging\./, "")
      }
      return url
    }
    if(videos) {
      return entries.map((e, i) => {
        return {
          title: cleanTitle(e),
          url: findUrl(i)
        }
      })
    }
    return entries.map((e, i) => {
      return {
        title: cleanTitle(e)
      }
    })
  }
}

function insert(songs, parent) {
  if (!songs || !songs.length) {
    create("div",false,translate("$anisongs_noSongs") + " (つ﹏<)･ﾟ｡",parent,"text-align:center");
  }
  else {
    songs.forEach( (song, i) => {
      const txt = `${i+1}. ${song.title || song}`;
      const node = create("div","anisong-entry",txt,parent);
      if (song.url) {
        const vid = new VideoElement(node, song.url)
        node.addEventListener("click", () => vid.toggle())
        node.classList.add("has-video")
      }
    })
  }
}

function createTargetDiv(text, target, pos) {
  let el = document.createElement('div');
  el.appendChild(document.createElement('h2'));
  el.children[0].innerText = text;
  el.classList = options.class;
  target.insertBefore(el, target.children[pos]);
  return el;
}

function cleaner(target) {
  if (!target) return;
  let el = target.querySelectorAll(`.${options.class}`);
  el.forEach(e => target.removeChild(e))
}

function placeData(data) {
  cleaner(anisongs_temp.target);
  let op = createTargetDiv(translate("$anisongs_openings"), anisongs_temp.target, 0);
  if(data.opening_themes.length === 1){
    op.children[0].innerText = translate("$anisongs_opening")
  }
  let ed = createTargetDiv(translate("$anisongs_endings"), anisongs_temp.target, 1);
  if(data.ending_themes.length === 1){
    ed.children[0].innerText = translate("$anisongs_ending")
  }
  insert(data.opening_themes, op);
  insert(data.ending_themes, ed);
}

async function launch(currentid) {
  // get from cache and check TTL
  const cache = await songCache.getItem(currentid) || {time: 0};
  if(
    (cache.time + options.cacheTTL)
    < +new Date()
  ) {
    const {data, errors} = await anilistAPI("query($id:Int){Media(id:$id){idMal status}}", {
      variables: {id: currentid}
    });
    if(errors){
      return "AniList API failure"
    }
    const {idMal: mal_id, status} = data.Media;
    if (mal_id) {
      const {data} = await API.getSongs(mal_id);
      let {openings: opening_themes, endings: ending_themes} = data;
      // add songs to cache if they're not empty and query videos
      if (opening_themes.length || ending_themes.length) {
        if (["FINISHED", "RELEASING"].includes(status)) {
          try {
            const _videos = await new Videos(currentid).get()
            opening_themes = Videos.merge(opening_themes, _videos.OP)
            ending_themes = Videos.merge(ending_themes, _videos.ED)
          }
          catch(e){console.log("Anisongs", e)} // 🐟
        }
        await songCache.setItem(currentid, {opening_themes, ending_themes, time: +new Date()});
      }
      // place the data onto site
      placeData({opening_themes, ending_themes});
      return "Downloaded songs"
    }
    else {
      return "No malid"
    }
  }
  else {
    // place the data onto site
    placeData(cache);
    return "Used cache"
  }
}

let currentpath = location.pathname.match(/(anime|manga)\/([0-9]+)\/[^/]*\/?(.*)/)
if(currentpath[1] === "anime") {
	let currentid = currentpath[2];
	let location = currentpath[3];
	if(location !== ""){
		anisongs_temp.last = 0
	}
	anisongs_temp.target = document.querySelectorAll(".grid-section-wrap")[2];
	if(anisongs_temp.last !== currentid && location === ""){
		if(anisongs_temp.target){
			anisongs_temp.last = currentid;
			launch(currentid)
		}
		else{
			setTimeout(()=>{this.code.call(this)},500)
		}
	}
}
else if(currentpath[1] === "manga"){
	cleaner(anisongs_temp.target);
	anisongs_temp.last = 0
}
else{
	anisongs_temp.last = 0
}
	}
})
//end modules/anisongs.js
//begin modules/autoLogin.js
exportModule({
	boneless_disable: true,
	id: "autoLogin",
	description: "Attempt automatic login when visiting anilist.co [read description]",
	extendedDescription: `
Normally, ${script_type} will stay signed in even if you close your browser.

However, if you have all persistant storage turned off, that's not possible.
To use features that requires an Anilist login, you will normally have to click the "sign in" link on the settings page each time.

In those cases, this module tries to automatically sign in when first visiting the page, potentially saving you a few clicks.

IMPORTANT DETAILS FOR THIS MODULE TO WORK!

This module is off by default. In some cases of non-persistance storage, ${script_type} will always load at default settings, thus checking this checkbox will do absolutely nothing.
To change the defaults:

Option a) When building from source edit "src/modules/autoLogin.js" so "isDefault" is set to true

Option b) Manually add your access token in the file "src/settings.js". It's a field in the "useScripts" object.

Option c) If you just have the compiled JS file "${script_type.toLowerCase()}.js", search for "I EAT PANCAKES" in the code, and change "isDefault" line below to true
`,
	isDefault: false,
	categories: ["Script"],
	visible: true
})
//end modules/autoLogin.js
//begin modules/betterListPreview.js
function betterListPreview(){
	if(window.screen.availWidth && window.screen.availWidth <= 1040){
		return
	}
	let errorHandler = function(e){
		console.error(e);
		console.warn("Alternative list preview failed. Trying to bring back the native one");
		let hohListPreviewToRemove = document.getElementById("hohListPreview");
		if(hohListPreviewToRemove){
			hohListPreviewToRemove.remove()
		}
		document.querySelectorAll(".list-preview-wrap").forEach(wrap => {
			wrap.style.display = "block"
		})
	}
	try{//it's complex, and could go wrong. Furthermore, we want a specific behavour when it fails, namely bringing back the native preview
	let hohListPreview = document.getElementById("hohListPreview");
	if(hohListPreview){
		return
	}
	let buildPreview = function(data,overWrite){try{
		if(!data){
			return
		}
		if(!hohListPreview){
			overWrite = true;
			let listPreviews = document.querySelectorAll(".list-previews h2");
			if(!listPreviews.length){
				setTimeout(function(){buildPreview(data)},200);
				return
			}
			hohListPreview = create("div","#hohListPreview");
			listPreviews[0].parentNode.parentNode.parentNode.parentNode.insertBefore(hohListPreview,listPreviews[0].parentNode.parentNode.parentNode);
			listPreviews.forEach(heading => {
				if(!heading.innerText.includes("Manga") && !heading.innerText.includes(translate("$preview_mangaSection_title"))){
					heading.parentNode.parentNode.style.display = "none"
				}
				else if(useScripts.additionalTranslation){
					heading.childNodes[0].textContent = translate("$preview_mangaSection_title")
				}
			})
		}
		if(overWrite){
			let mediaLists = data.data.Page.mediaList.map((mediaList,index) => {
				mediaList.index = index;
				if(aliases.has(mediaList.media.id)){
					mediaList.media.title.userPreferred = aliases.get(mediaList.media.id)
				}
				return mediaList
			});
			let notAiring = mediaLists.filter(
				mediaList => !mediaList.media.nextAiringEpisode
			)
			let airing = mediaLists.filter(
				mediaList => mediaList.media.nextAiringEpisode
			).map(
				mediaList => {
					mediaList.points = 100/(mediaList.index + 1) + mediaList.priority/10 + (mediaList.scoreRaw || 60)/10;
					if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
						mediaList.points -= 100/(mediaList.index + 1);
					}
					if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*24){
						mediaList.points += 1;
						if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
							mediaList.points += 1;
						}
					}
					if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*12){
						mediaList.points += 1;
						if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
							mediaList.points += 2;
						}
					}
					if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*3){
						mediaList.points += 1;
						if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
							mediaList.points += 2;
						}
					}
					if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*1){
						mediaList.points += 1;
						if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
							mediaList.points += 3;
						}
					}
					if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*10){
						mediaList.points += 1;
						if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1){
							mediaList.points += 5;
						}
						else if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 2){
							mediaList.points += 2;
						}
					}
					if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 2){
						mediaList.points += 7;
						if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*24*7){
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*6){
								mediaList.points += 3;
							}
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*7 - 60*60*3){
								mediaList.points += 3;
							}
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*7 - 60*60*1){
								mediaList.points += 3;
							}
						}
					}
					else if(mediaList.progress === mediaList.media.nextAiringEpisode.episode - 3){
						mediaList.points += 2;
						if(mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*24*7){
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*6){
								mediaList.points += 1;
							}
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*7 - 60*60*3){
								mediaList.points += 1;
							}
							if(mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*7 - 60*60*1){
								mediaList.points += 1;
							}
						}
					}
					return mediaList;
				}
			).sort(
				(b,a) => a.points - b.points
			);
			let airingImportant = mediaLists.filter(
				(mediaList,index) => mediaList.media.nextAiringEpisode && (
					index < 20
					|| mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*4
					|| (
						mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*12
						&& mediaList.progress === mediaList.media.nextAiringEpisode.episode - 1
					)
					|| (
						mediaList.media.nextAiringEpisode.timeUntilAiring > 60*60*24*6
						&& mediaList.media.nextAiringEpisode.timeUntilAiring < 60*60*24*7
						&& mediaList.progress === mediaList.media.nextAiringEpisode.episode - 2
					)
				)
			).length;
			if(airingImportant > 3){
				airingImportant = Math.min(5*Math.ceil((airingImportant - 1)/5),airing.length)
			}
			removeChildren(hohListPreview)
			let drawSection = function(list,name,moveExpander){
				let airingSection = create("div","list-preview-wrap",false,hohListPreview,"margin-bottom: 20px;");
				let airingSectionHeader = create("div","section-header",false,airingSection);
				if(name === "Airing"){
					create("a","asHeading",name,airingSectionHeader,"font-size: 1.4rem;font-weight: 500;")
						.href = "https://anilist.co/airing"
				}
				else{
					create("h2",false,name,airingSectionHeader,"font-size: 1.4rem;font-weight: 500;")
				}
				if(moveExpander && document.querySelector(".size-toggle")){
					airingSectionHeader.appendChild(document.querySelector(".size-toggle"))
				}
				let airingListPreview = create("div","list-preview",false,airingSection,"display:grid;grid-template-columns: repeat(5,85px);grid-template-rows: repeat(auto-fill,115px);grid-gap: 20px;padding: 20px;background: rgb(var(--color-foreground));");
				list.forEach((air,index) => {
					let card = create("div",["media-preview-card","small","hohFallback"],false,airingListPreview,"width: 85px;height: 115px;background: rgb(var(--color-foreground));border-radius: 3px;display: inline-grid;");
					if(air.media.coverImage.color && !useScripts.SFWmode){
						card.style.backgroundColor = air.media.coverImage.color
					}
					if((index % 5 > 1) ^ useScripts.rightToLeft){
						card.classList.add("info-left")
					}
					let cover = create("a","cover",false,card,"background-position: 50%;background-repeat: no-repeat;background-size: cover;text-align: center;border-radius: 3px;");
					cover.style.backgroundImage = "url(\"" + air.media.coverImage.large + "\")";
					cover.href = "/anime/" + air.media.id + "/" + safeURL(air.media.title.userPreferred);
					if(air.media.nextAiringEpisode){
						let imageText = create("div","image-text",false,cover,"background: rgba(var(--color-overlay),.7);border-radius: 0 0 3px 3px;bottom: 0;color: rgba(var(--color-text-bright),.91);display: inline-block;font-weight: 400;left: 0;letter-spacing: .2px;margin-bottom: 0;position: absolute;transition: .3s;width: 100%;font-size: 1.1rem;line-height: 1.2;padding: 8px;");
						let imageTextWrapper = create("div","countdown",false,imageText);
						let createCountDown = function(){
							removeChildren(imageTextWrapper)
							create("span",false,"Ep " + air.media.nextAiringEpisode.episode,imageTextWrapper);
							create("br",false,false,imageTextWrapper);
							if(air.media.nextAiringEpisode.timeUntilAiring <= 0){
								create("span",false,"Recently aired",imageTextWrapper);
								return;
							}
							let days = Math.floor(air.media.nextAiringEpisode.timeUntilAiring/(60*60*24));
							let hours = Math.floor((air.media.nextAiringEpisode.timeUntilAiring - days*(60*60*24))/3600);
							let minutes = Math.round((air.media.nextAiringEpisode.timeUntilAiring - days*(60*60*24) - hours*3600)/60);
							if(minutes === 60){
								hours++;
								minutes = 0;
								if(hours === 24){
									days++;
									hours = 0;
								}
							}
							if(days){
								create("span",false,days + translate("$time_short_day",null,"d") + " ",imageTextWrapper)
							}
							if(hours){
								create("span",false,hours + translate("$time_short_hour",null,"h") + " ",imageTextWrapper)
							}
							if(minutes){
								create("span",false,minutes + translate("$time_short_minute",null,"m"),imageTextWrapper)
							}
							setTimeout(function(){
								air.media.nextAiringEpisode.timeUntilAiring -= 60;
								createCountDown();
							},60*1000);
						};createCountDown();
						const behind = air.media.nextAiringEpisode.episode - 1 - air.progress;
						if(behind > 0){
							create("div","behind-accent",false,imageText,"background: rgb(var(--color-red));border-radius: 0 0 2px 2px;bottom: 0;height: 5px;left: 0;position: absolute;transition: .2s;width: 100%;")
						}
					}
					let imageOverlay = create("div","image-overlay",false,cover);
					let plusProgress = create("div","plus-progress",air.progress + " +",imageOverlay);
					let content = create("div","content",false,card);
					if(air.media.nextAiringEpisode){
						const behind = air.media.nextAiringEpisode.episode - 1 - air.progress;
						if(behind > 0){
							let infoHeader = create("div","info-header",false,content,"color: rgb(var(--color-blue));font-size: 1.2rem;font-weight: 500;margin-bottom: 8px;");
							if(behind > 1){
								create("div",false,translate("$preview_Mbehind",behind),infoHeader)
							}
							else{
								create("div",false,translate("$preview_1behind"),infoHeader)
							}
						}
					}
					let title = create("a","title",air.media.title.userPreferred,content,"font-size: 1.4rem;");
					let info = create("div",["info","hasMeter"],false,content,"bottom: 12px;color: rgb(var(--color-text-lighter));font-size: 1.2rem;left: 12px;position: absolute;");
					let pBar;
					if(air.media.episodes && useScripts.progressBar){
						pBar = create("meter",false,false,info);
						pBar.value = air.progress;
						pBar.min = 0;
						pBar.max = air.media.episodes;
						if(air.media.nextAiringEpisode){
							pBar.low = air.media.nextAiringEpisode.episode - 2;
							pBar.high = air.media.nextAiringEpisode.episode - 1;
							pBar.optimum = air.media.nextAiringEpisode.episode - 1;
						}
					}
					let progress = create("div",false,translate("$preview_progress") + " " + air.progress + (air.media.episodes ? "/" + air.media.episodes : ""),info);
					let isBlocked = false;
					plusProgress.onclick = function(e){
						if(isBlocked){
							return
						}
						if(air.media.episodes){
							if(air.progress < air.media.episodes){
								if(useScripts.progressBar){
									pBar.value++;
								}
								air.progress++;
								progress.innerText = "Progress: " + air.progress + (air.media.episodes ? "/" + air.media.episodes : "");
								isBlocked = true;
								setTimeout(function(){
									plusProgress.innerText = air.progress + " +";
									isBlocked = false;
								},300);
								if(air.progress === air.media.episodes){
									progress.innerText += " Completed";
									if(air.status === "REWATCHING"){//don't overwrite the existing end date
										authAPIcall(
											`mutation($progress: Int,$id: Int){
												SaveMediaListEntry(progress: $progress,id:$id,status:COMPLETED){id}
											}`,
											{id: air.id,progress: air.progress},
											data => {}
										);
									}
									else{
										authAPIcall(
											`mutation($progress: Int,$id: Int,$date:FuzzyDateInput){
												SaveMediaListEntry(progress: $progress,id:$id,status:COMPLETED,completedAt:$date){id}
											}`,
											{
												id: air.id,
												progress: air.progress,
												date: {
													year: (new Date()).getUTCFullYear(),
													month: (new Date()).getUTCMonth() + 1,
													day: (new Date()).getUTCDate(),
												}
											},
											data => {}
										);
									}
								}
								else{
									authAPIcall(
										`mutation($progress: Int,$id: Int){
											SaveMediaListEntry(progress: $progress,id:$id){id}
										}`,
										{id: air.id,progress: air.progress},
										data => {}
									);
								}
								localStorage.setItem("hohListPreview",JSON.stringify(data));
							}
						}
						else{
							air.progress++;
							plusProgress.innerText = air.progress + " +";
							progress.innerText = "Progress: " + air.progress;
							isBlocked = true;
							setTimeout(function(){
								plusProgress.innerText = air.progress + " +";
								progress.innerText = "Progress: " + air.progress;
								isBlocked = false;
							},300);
							authAPIcall(
								`mutation($progress: Int,$id: Int){
									SaveMediaListEntry(progress: $progress,id:$id){id}
								}`,
								{id: air.id,progress: air.progress},
								data => {}
							);
							localStorage.setItem("hohListPreview",JSON.stringify(data));
						}
						if(air.media.nextAiringEpisode){
							if(air.progress === air.media.nextAiringEpisode.episode - 1){
								if(card.querySelector(".behind-accent")){
									card.querySelector(".behind-accent").remove()
								}
							}
						}
						e.stopPropagation();
						e.preventDefault();
						return false
					}
					let fallback = create("span","hohFallback",air.media.title.userPreferred,card,"background-color: rgb(var(--color-foreground),0.6);padding: 3px;border-radius: 3px;");
					if(useScripts.titleLanguage === "ROMAJI"){
						fallback.innerText = air.media.title.userPreferred
					}
					
				})
			};
			if(airingImportant > 3){
				drawSection(
					airing.slice(0,airingImportant),translate("$preview_airingSection_title"),true
				);
				drawSection(
					notAiring.slice(0,5*Math.ceil((20 - airingImportant)/5)),translate("$preview_animeSection_title")
				)
			}
			else{
				let remainderAiring = airing.slice(0,airingImportant).filter(air => air.index >= 20);
				drawSection(mediaLists.slice(0,20 - remainderAiring.length).concat(remainderAiring),translate("$preview_animeSection_title"),true)
			}
		}
	}catch(e){errorHandler(e)}}
	authAPIcall(
		`query($name: String){
			Page(page:1){
				mediaList(type:ANIME,status_in:[CURRENT,REPEATING],userName:$name,sort:UPDATED_TIME_DESC){
					id
					priority
					scoreRaw: score(format: POINT_100)
					progress
					status
					media{
						id
						episodes
						coverImage{large color}
						title{userPreferred}
						nextAiringEpisode{episode timeUntilAiring}
					}
				}
			}
		}`,{name: whoAmI},function(data){
			localStorage.setItem("hohListPreview",JSON.stringify(data));
			buildPreview(data,true)
		}
	);
	buildPreview(JSON.parse(localStorage.getItem("hohListPreview")),false);
	}
	catch(e){
		errorHandler(e)
	}
}
//end modules/betterListPreview.js
//begin modules/betterReviewRatings.js
function betterReviewRatings(){
	if(!location.pathname.match(/\/home/)){
		return
	}
	let reviews = document.querySelectorAll(".review-card .el-tooltip.votes");
	if(!reviews.length){
		setTimeout(betterReviewRatings,500);
		return;
	}
	// Basic idea: read the rating info from the tooltips to avoid an API call.
	document.body.classList.add("TMPreviewScore");//add a temporary class, which makes all tooltips
	reviews.forEach(likeElement => {//trigger creation of the tooltips (they don't exist before hover)
		likeElement.dispatchEvent(new Event("mouseenter"));
		likeElement.dispatchEvent(new Event("mouseleave"));
		//bonus: add some alias and localisation
		let showId;
		if(likeElement.parentNode.previousElementSibling && likeElement.parentNode.previousElementSibling.classList.contains("banner")){//unreliable: they load separately. But better than nothing
			let possibleRefId = likeElement.parentNode.previousElementSibling.style.backgroundImage.match(/banner\/n?(\d+)-/);
			if(possibleRefId){
				showId = parseInt(possibleRefId[1])
			}
		}
		if(useScripts.partialLocalisationLanguage !== "English" || aliases.has(showId)){
			let elements = likeElement.previousElementSibling.previousElementSibling.textContent.match(/Review of (.+) by (.+)$/);
			if(elements){
				likeElement.previousElementSibling.previousElementSibling.childNodes[0].textContent
					= translate(
						"$review_reviewTitle",[
							titlePicker({id: showId, title: {romaji: elements[1]}}),
							elements[2]
						]
					)
			}
		}
	});
	setTimeout(function(){//give anilist some time to generate them
		reviews.forEach(likeElement => {
			let likeExtra = document.getElementById(likeElement.attributes["aria-describedby"].value);
			if(likeExtra){
				let matches = likeExtra.innerText.match(/(\d+) out of (\d+)/);
				if(matches){
					likeElement.childNodes[1].textContent += "/" + matches[2];
					if(useScripts.additionalTranslation){
						likeExtra.childNodes[0].textContent = translate("$reviewLike_tooltip",[matches[1],matches[2]])
					}
				}
			}
			likeElement.style.bottom = "4px";
			likeElement.style.right = "7px";
		})
		document.body.classList.remove("TMPreviewScore");//make tooltips visible again
	},200);
}
//end modules/betterReviewRatings.js
//begin modules/browseSubmenu.js
if(useScripts.browseSubmenu && useScripts.CSSverticalNav && whoAmI && !useScripts.mobileFriendly){
	let addMouseover = function(){
		let navThingy = document.querySelector(`.nav .links .browse-wrap`);
		if(navThingy){
			navThingy.classList.add("subMenuContainer");
			let subMenu = create("div","hohSubMenu",false,navThingy);

			[
				{
					text: "$submenu_anime",
					href: "/search/anime",
					vue: { name: 'Search', params: {type:'anime'}}
				},
				{
					text: "$submenu_manga",
					href: "/search/manga",
					vue: { name: 'Search', params: {type:'manga'}}
				},
				{
					text: "$submenu_staff",
					href: "/search/staff",
					vue: { name: 'Search', params: {type:'staff'}}
				},
				{
					text: "$submenu_characters",
					href: "/search/characters",
					vue: { name: 'Search', params: {type:'characters'}}
				},
				{
					text: "$submenu_reviews",
					href: "/reviews",
					vue: { name: 'Reviews'}
				},
				{
					text: "$submenu_recommendations",
					href: "/recommendations",
					vue: { name: 'Recommendations'}
				}
			].forEach(link => {
				let element = create("a","hohSubMenuLink",translate(link.text),subMenu);
				element.href = link.href;
				if(link.vue){
					element.onclick = function(){
						try{
							document.getElementById('app').__vue__._router.push(link.vue);
							return false
						}
						catch(e){
							console.warn("vue routes are outdated!")
						}
					}
				}
			})
			navThingy.onmouseenter = function(){
				subMenu.style.display = "inline"
			}
			navThingy.onmouseleave = function(){
				subMenu.style.display = "none"
			}
		}
		else{
			setTimeout(addMouseover,500)
		}
	};addMouseover()
}
//end modules/browseSubmenu.js
//begin modules/cencorMediaPage.js
function cencorMediaPage(id){
	if(!location.pathname.match(/^\/(anime|manga)/)){
		return
	}
	let possibleLocation = document.querySelectorAll(".tags .tag .name");
	if(possibleLocation.length){
		if(possibleLocation.some(
			tag => badTags.some(
				bad => tag.innerText.toLowerCase().includes(bad)
			)
		)){
			let content = document.querySelector(".page-content");
			if(content){
				content.classList.add("hohCencor")
			}
		}
	}
	else{
		setTimeout(() => {cencorMediaPage(id)},200)
	}
}
//end modules/cencorMediaPage.js
//begin modules/characterBrowse.js
exportModule({
	id: "characterBrowseFavouriteCount",
	description: "Add favourite counts to character browse pages",
	isDefault: true,
	categories: ["Browse"],
	visible: false,
	urlMatch: function(url){
		return /^https:\/\/anilist\.co\/search\/characters\/?(favorites)?$/.test(url)
	},
	code: function(){
		let pageCount = 0;
		let perPage = 30;
		const query = `
query($page: Int!,$perPage: Int!){
	Page(page: $page,perPage: $perPage){
		characters(sort: [FAVOURITES_DESC]){
			id
			favourites
		}
	}
}`;
		const results = document.querySelector(".landing-section.characters > .results, .results.cover");
		let charCount = results.childElementCount;

		const insertFavs = function(data){
			const chars = data.Page.characters;
			chars.forEach((character,index) => create(
				"span",
				"hohFavCountBrowse",
				character.favourites,
				results.children[(pageCount - 1)*chars.length + index]
			).title = translate("$characterBrowseTooltip"));
		}

		const getFavs = async function(){
			pageCount++
			const {data, errors} = await anilistAPI(query, {
				variables: {page: pageCount, perPage}
			})
			if(errors){
				return;
			}
			return insertFavs(data);
		}

		if(!/\/search\/characters\/?$/.test(location.pathname)){ // full favorites page
			perPage = 20;
			new MutationObserver((_mutations) => {
				if(results.childElementCount !== charCount && results.childElementCount % 20 === 0){
					charCount = results.childElementCount;
					getFavs();
				}
			}).observe(results, { subtree: true, childList: true })
		}

		getFavs();
	},
	css: `
.hohFavCountBrowse{
	color: rgb(var(--color-text-lighter));
	position: absolute;
	right: 2px;
	font-size: 60%;
	opacity: 0.7;
	top: -10px;
}`
})
//end modules/characterBrowse.js
//begin modules/character.js
exportModule({
	id: "characterFavouriteCount",
	description: "Add an exact favourite count to character pages",
	isDefault: true,
	categories: ["Media"],
	visible: false,
	urlMatch: function(url){
		return /^https:\/\/anilist\.co\/character(\/.*)?/.test(url)
	},
	code: async function(){
		const charWrap = document.querySelector(".character");
		const favWrap = charWrap.querySelector(".favourite") || await watchElem(".favourite", charWrap);
		const favCount = favWrap.querySelector(".count") || await watchElem(".count", favWrap);
		if(!favCount){
			return;
		}
		if(!isNaN(favCount.textContent)){
			return; // abort early since the site already displays exact fav count if under 1000
		}
		const favCallback = function(data){
			favWrap.onclick = function(){
				if(favWrap.classList.contains("isFavourite")){
					favCount.textContent = parseInt(favCount.textContent) - 1;
				}
				else{
					favCount.textContent = parseInt(favCount.textContent) + 1;
				}
			};
			if(data.Character.favourites){
				favCount.textContent = data.Character.favourites;
			}
		};
		const query = `query($id: Int!){
			Character(id: $id){
				favourites
			}
		}`;
		const variables = {id: parseInt(location.pathname.match(/\/character\/(\d+)\/?/)[1])};
		const {data, errors} = await anilistAPI(query, {
			variables,
			cacheKey: "hohCharacterFavs" + variables.id,
			duration: 60*60*1000
		});
		if(errors){
			return;
		}
		return favCallback(data);
	}
})
//end modules/character.js
//begin modules/clickableActivityHistory.js
exportModule({
	id: "clickableActivityHistory",
	description: "Displays activities for an entry in the activity history",
	isDefault: true,
	categories: ["Navigation","Profiles"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url.match(/\/user\/[^/]+\/?$/);
	},
	code: function(){
		if(!useScripts.termsFeed){
			return
		}
		let waiter = function(){
			let activityHistory = document.querySelector(".activity-history");
			if(!activityHistory){
				setTimeout(waiter,1000);
				return
			}
			activityHistory.onclick = function(event){
				let target = event.target;
				if(target && target.classList.contains("history-day")){
					if(target.classList.contains("lv-0")){
						return
					}
					let offset = 1;
					while(target.nextSibling){
						offset++;
						target = target.nextSibling
					}
					let presentDayPresentTime = (new Date()).valueOf();
					presentDayPresentTime = new Date(presentDayPresentTime.valueOf() - offset * 24*60*60*1000);
					let year = presentDayPresentTime.getUTCFullYear();
					let month = presentDayPresentTime.getUTCMonth() + 1;
					let day = presentDayPresentTime.getUTCDate();
					let hour = presentDayPresentTime.getUTCHours();
					if(hour + 9 > 23){
						day++
					}
					window.location.href = "https://anilist.co/terms?user=" + encodeURIComponent(document.querySelector("h1.name").innerText) + "&date=" + year + "-" + month + "-" + day
				}
			}
		};waiter()
	}
})
//end modules/clickableActivityHistory.js
//begin modules/directEditorAccess.js
exportModule({
	id: "directListAccess",
	description: "Make the down arrow links in the feeds open the list editor directly",
	extendedDescription: "When hovering over the cover image of an entry in the activity feeds, an arrow will appear. Clicking the arrow will present you with various options, including opening the list editor. I never use any of the other options, so this module turns this into a one-click experience.",
	isDefault: false,
	importance: 0,
	categories: ["Feeds"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url === "https://anilist.co/home" || url.match(/^https:\/\/anilist\.co\/user\/(.*)\/$/)
	},
	code: function(){
		let adder = function(){
			if(document.querySelector(".activity-feed")){
				document.querySelector(".activity-feed").addEventListener("click",function(e){
					let tmp_target = e.target;
					if(!tmp_target.classList.contains("el-dropdown-menu__item--divided")){
						for(let i=0;i<4;i++){
							if(tmp_target.classList.contains("entry-dropdown")){
								let item = document.getElementById(tmp_target.children[0].getAttribute("aria-controls"));
								if(item){
									item.querySelector(".el-dropdown-menu__item--divided").click()
								}
								break
							}
							else{
								tmp_target = tmp_target.parentNode
							}
						}
					}
				})
			}
			else{
				setTimeout(adder,2000)
			}
		};
		adder()
	}
})
//end modules/directEditorAccess.js
//begin modules/documentTitleManager.js
let mutated = false;

let titleObserver = new MutationObserver(mutations => {
	if(mutated){
		mutated = false;
		return
	}
	let title = document.querySelector("head > title").textContent;
	let titleMatch = title.match(/(.*)\s\((\d+)\)\s\((.*)\s\(\2\)\)(.*)/);//ugly nested paranthesis like "Tetsuwan Atom (1980) (Astro Boy (1980)) · AniList"
	if(titleMatch){
		//change to the form "Tetsuwan Atom (Astro Boy 1980) · AniList"
		document.title = titleMatch[1] + " (" + titleMatch[3] + " " + titleMatch[2] + ")" + titleMatch[4];
		mutated = true
	}
	let badApostropheMatch = title.match(/^(\S+?s)'s\sprofile(.*)/);
	if(badApostropheMatch){
		document.title = badApostropheMatch[1] + "' profile" + badApostropheMatch[2];
		mutated = true
	}
	let name = title.match(/^(\S+?)'s\sprofile(.*)/);
	if(name && useScripts.partialLocalisationLanguage !== "English" && translate("$profile_title","") !== "'s profile"){
		document.title = translate("$profile_title",name[1]);
		mutated = true
	}
	if(useScripts.additionalTranslation){
		[
["Home · AniList","$documentTitle_home"],
["Notifications · AniList","$documentTitle_notifications"],
["Forum - Anime & Manga Discussion · AniList","$documentTitle_forum"],
["App Settings · AniList","$documentTitle_appSettings"]
		].forEach(pair => {
			if(title === pair[0]){
				let translation = translate(pair[1]);
				if(translation !== pair[0]){
					document.title = translation
				}
			}
		})
	}
	if(useScripts.SFWmode && title !== "Table of Contents"){//innocent looking
		document.title = "Table of Contents";
		mutated = true
	}
});
if(document.title){
	titleObserver.observe(document.querySelector("head > title"),{subtree: true, characterData: true, childList: true })
}
//end modules/documentTitleManager.js
//begin modules/dubMarker.js
function dubMarker(){
	if(!document.URL.match(/^https:\/\/anilist\.co\/anime\/.*/)){
		return
	}
	if(document.getElementById("dubNotice")){
		return
	}
	const variables = {
		id: document.URL.match(/\/anime\/(\d+)\//)[1],
		page: 1,
		language: useScripts.dubMarkerLanguage.toUpperCase()
	};
	const query = `
query($id: Int!, $type: MediaType, $page: Int = 1, $language: StaffLanguage){
	Media(id: $id, type: $type){
		characters(page: $page, sort: [ROLE], role: MAIN){
			edges {
				node{id}
				voiceActors(language: $language){language}
			}
		}
	}
}`;
	let dubCallback = function(data){
		if(!document.URL.match(/^https:\/\/anilist\.co\/anime\/.*/)){
			return
		}
		let dubNoticeLocation = document.querySelector(".sidebar");
		if(!dubNoticeLocation){
			setTimeout(function(){
				dubCallback(data)
			},200);
			return
		}
		if(data.data.Media.characters.edges.reduce(
			(actors,a) => actors + a.voiceActors.length,0
		)){//any voice actors for this language?
			if(document.getElementById("dubNotice")){
				return
			}
			let dubNotice = create("p","#dubNotice",
				translate("$dubMarker_notice",translate("$language_" + useScripts.dubMarkerLanguage))
			);
			dubNoticeLocation.insertBefore(dubNotice,dubNoticeLocation.firstChild)
		}
	};
	generalAPIcall(query,variables,dubCallback,"hohDubInfo" + variables.id + variables.language)
}
//end modules/dubMarker.js
//begin modules/embedHentai.js
function embedHentai(){
	if(!document.URL.match(/^https:\/\/anilist\.co\/(home|user|forum|activity)/)){
		return
	}
	if(useScripts.SFWmode){//saved you there
		return
	}
	setTimeout(embedHentai,1000);
	let mediaEmbeds = document.querySelectorAll(".media-embed");
	let bigQuery = [];//collects all on a page first so we only have to send 1 API query.
	mediaEmbeds.forEach(function(embed){
		if(embed.children.length === 0 && !embed.classList.contains("hohMediaEmbed")){//if( "not-rendered-natively" && "not-rendered-by-this sript" )
			embed.classList.add("hohMediaEmbed");
			let createEmbed = function(data){
				if(!data){
					return
				}
				embed.innerText = "";
				let eContainer = create("div",false,false,embed);
				let eEmbed = create("div","embed",false,eContainer);
				let eCover = create("div","cover",false,eEmbed);
				if(data.data.Media.coverImage.color){
					eCover.style.backgroundColor = data.data.Media.coverImage.color
				}
				eCover.style.backgroundImage = "url(" + data.data.Media.coverImage.large + ")";
				let eWrap = create("div","wrap",false,eEmbed);
				let mediaTitle = titlePicker(data.data.Media);
				let eTitle = create("div","title",mediaTitle,eWrap);
				let eInfo = create("div","info",false,eWrap);
				let eGenres = create("div","genres",false,eInfo);
				data.data.Media.genres.forEach((genre,index) => {
					let eGenre = create("span",false,genre,eGenres);
					let comma = create("span",false,", ",eGenre);
					if(index === data.data.Media.genres.length - 1){
						comma.style.display = "none"
					}
				});
				create("span",false,distributionFormats[data.data.Media.format],eInfo);
				create("span",false," · " + distributionStatus[data.data.Media.status],eInfo);
				if(data.data.Media.season){
					create("span",false,
						" · " + capitalize(data.data.Media.season.toLowerCase()) + " " + data.data.Media.startDate.year,
						eInfo
					)
				}
				else if(data.data.Media.startDate.year){
					create("span",false,
						" · " + data.data.Media.startDate.year,
						eInfo
					)
				}
				if(data.data.Media.averageScore){
					create("span",false," · " + data.data.Media.averageScore + "%",eInfo)
				}
				else if(data.data.Media.meanScore){//fallback if it's not popular enough, better than nothing
					create("span",false," · " + data.data.Media.meanScore + "%",eInfo)
				}
			}
			bigQuery.push({
				query: "query($mediaId:Int,$type:MediaType){Media(id:$mediaId,type:$type){id title{romaji native english} coverImage{large color} genres format status season meanScore averageScore startDate{year}}}",
				variables: {
					mediaId: +embed.dataset.mediaId,
					type: embed.dataset.mediaType.toUpperCase()
				},
				callback: createEmbed,
				cacheKey: "hohMedia" + embed.dataset.mediaId
			})
		}
	});
	queryPacker(bigQuery);
}
//end modules/embedHentai.js
//begin modules/enumerateSubmissionStaff.js
exportModule({
	id: "enumerateSubmissionStaff",
	description: "Enumerate the multiple credits for staff in the submission form to help avoid duplicates",
	isDefault: true,
	categories: [/*"Submissions",*/"Profiles"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/edit/)
	},
	code: function enumerateSubmissionStaff(){
		if(!location.pathname.match(/^\/edit/)){
			return
		}
		setTimeout(enumerateSubmissionStaff,500);
		let staffFound = [];
		let staffEntries = document.querySelectorAll(".staff-row .col > .image");
		Array.from(staffEntries).forEach(function(staff){
			let enumerate = staffFound.filter(a => a === staff.href).length;
			if(enumerate === 1){
				let firstStaff = document.querySelector(".staff-row .col > .image[href=\"" + staff.href.replace("https://anilist.co","") + "\"]");
				if(!firstStaff.previousSibling){
					firstStaff.parentNode.insertBefore(
						create("span","hohEnumerateStaff",1),
						firstStaff
					)
				}
			}
			if(enumerate > 0){
				if(staff.previousSibling){
					staff.previousSibling.innerText = enumerate + 1;
				}
				else{
					staff.parentNode.insertBefore(
						create("span","hohEnumerateStaff",(enumerate + 1)),
						staff
					)
				}
			}
			staffFound.push(staff.href);
		})
	}
})
//end modules/enumerateSubmissionStaff.js
//begin modules/expandDescriptions.js
exportModule({
	id: "expandDescriptions",
	description: "Automatically expand media descriptions",
	isDefault: true,
	categories: ["Media"],
	visible: true
})
//end modules/expandDescriptions.js
//begin modules/expandedListNotes.js
exportModule({
	id: "expandedListNotes",
	description: "Click list notes for an expanded view",
	extendedDescription: "For those who write entire essays in their list notes",
	isDefault: true,
	importance: 0,
	categories: ["Lists"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/.+\/(anime|manga)list\/?(.*)?$/)
	},
	code: function(){
		let clickHandler = function(){
			let URLstuff = document.URL.match(/^https:\/\/anilist\.co\/user\/(.+)\/(anime|manga)list\/?/);
			let name = decodeURIComponent(URLstuff[1]);
			Array.from(document.querySelectorAll(".list-entries .notes")).forEach(note => {
				note.onclick = function(){
					//getting the title is tricky since the layouts vary
					let title_element = note.parentNode.querySelector(".title a");
					let id = title_element.href.match(/(anime|manga)\/(\d+)\//)[2];
					let title = titlePicker({//hack: pretend we have all this fancy API info
						title: {
							native: title_element.innerText,
							romaji: title_element.innerText,
							english: title_element.innerText
						},
						id: id
					});
					let floatyWindowThingy = createDisplayBox("min-width:500px;min-height:300px;",title);
					floatyWindowThingy.style.maxWidth = "80ch";
					floatyWindowThingy.style.lineHeight = "1.4";
					floatyWindowThingy.style.marginRight = "12px";
					create("p",false,note.getAttribute("label"),floatyWindowThingy,"margin-bottom: 30px;margin-top: 10px;background: rgb(var(--color-background));padding: 10px;border-radius: 5px;");
					//fancy stuff: find activities with replies
					generalAPIcall(
						"query($name:String){User(name:$name){id}}",
						{name: name},
						function(nameData){generalAPIcall(`
							query{
								Page{
									activities(userId: ${nameData.data.User.id},mediaId: ${id}, sort: ID_DESC){
										... on ListActivity{
											status
											progress
											siteUrl
											createdAt
											replies{
												user{name}
												text(asHtml: true)
											}
										}
									}
								}
							}`,
							{},
							function(data){
								data.data.Page.activities.forEach(activity => {
									create("hr",false,false,floatyWindowThingy);
									let activityEntry = create("div","hohTimelineEntry",false,floatyWindowThingy);
									let activityContext = create("a","newTab",capitalize(activity.status),activityEntry);
									activityContext.href = activity.siteUrl;
									if(["watched episode","read chapter","rewatched episode","reread chapter"].includes(activity.status)){
										activityContext.innerText += " " + activity.progress
									}
									create("span",false,
										" " + (new Date(activity.createdAt*1000)).toDateString(),
										activityEntry,
										"position:absolute;right:7px;"
									).title = (new Date(activity.createdAt*1000)).toLocaleString()
									if(activity.replies.length){
										let activityReplies = create("div",["hohTimelineEntry","replies"],false,floatyWindowThingy,"margin-left: 30px;");
										activity.replies.forEach(reply => {
											let reply_container = create("div","reply",false,activityReplies,"padding: 10px;margin: 2px;border-radius: 5px;background: rgb(var(--color-background));");
											create("span","name",reply.user.name + ": ",reply_container);
											let text = create("span",false,false,reply_container);
											text.innerHTML = DOMPurify.sanitize(reply.text)//reason for inner HTML: preparsed sanitized HTML from the Anilist API
										})
									}
								})
							}
						)},
						"hohIDlookup" + name.toLowerCase()
					)
				}
			})
			setTimeout(function(){
				if(document.URL.match(/^https:\/\/anilist\.co\/.+\/(anime|manga)list\/?(.*)?$/)){
					clickHandler()
				}
			},2000)
		};
		clickHandler()
	},
	css: ".list-entries .entry-card .notes{cursor: pointer}"
})
//end modules/expandedListNotes.js
//begin modules/expandFeedFilters.js
exportModule({
	id: "CSSexpandFeedFilters",
	description: "Expand the feed filters",
	isDefault: true,
	categories: ["Feeds"],
	visible: true
})
//end modules/expandFeedFilters.js
//begin modules/expandRight.js
function expandRight(){
	if(!location.pathname.match(/^\/home\/?$/)){
		return
	}
	let possibleFullWidth = document.querySelector(".home.full-width");
	if(possibleFullWidth){
		let homeContainer = possibleFullWidth.parentNode;
		let sideBar = document.querySelector(".activity-feed-wrap")
		if(!sideBar){
			setTimeout(expandRight,100);
			return;
		}
		sideBar = sideBar.nextElementSibling;
		sideBar.insertBefore(possibleFullWidth,sideBar.firstChild);
		let setSemantics = function(){
			let toggle = document.querySelector(".size-toggle.fa-compress");
			if(toggle){
				toggle.onclick = function(){
					homeContainer.insertBefore(possibleFullWidth,homeContainer.firstChild)
				}
			}
			else{
				setTimeout(setSemantics,200)
			}
		};setSemantics();
	}
}
//end modules/expandRight.js
//begin modules/extraDefaultSorts.js
exportModule({
	id: "extraDefaultSorts",
	description: "Make all list sort options available as options for the default setting",
	extendedDescription: `
Default list order can be selected at https://anilist.co/settings/lists

This module will add extra options in that dropdown.
	`,
	isDefault: true,
	importance: 0,
	categories: ["Lists","Newly Added"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/\/user\/.*\/(anime|manga)list/) || url === "https://anilist.co/settings/lists"
	},
	code: function(){
		if(document.URL === "https://anilist.co/settings/lists"){
			let optionsAdder = function(){
				if(document.URL !== "https://anilist.co/settings/lists"){
					return
				}
				let selector = document.querySelector('input[placeholder="Default List Order"]');
				if(!selector){
					setTimeout(optionsAdder,500);
					return
				}
				if(useScripts.customDefaultListOrder){
					selector.value = useScripts.customDefaultListOrder
				}
				selector.onclick = function(){
					let findDropdown = function(){
						if(document.URL !== "https://anilist.co/settings/lists"){
							return
						}
						let dropdowns = document.querySelectorAll(".el-select-dropdown");
						let correctDropdownFound = true;
						Array.from(dropdowns).forEach(dropdown => {
							if(dropdown.textContent === "ScoreTitleLast UpdatedLast Added"){//will break when more defaults are added. That's intentional
								correctDropdownFound = true;
								let ul = dropdown.querySelector("ul");
								let nativeOrder = "";
								let nativeIndex = 0;
								Array.from(ul.children).forEach((child,index) => {
									child.style.display = "none";
									if(child.classList.contains("selected")){
										nativeOrder = child.textContent;
										nativeIndex = index
									}
								});
								[
{
	name: "Title",
	native: true,
	nativeIndex: 1
},
{
	name: "Score",
	native: true,
	nativeIndex: 0
},
{
	name: "Progress"
},
{
	name: "Last Updated",
	native: true,
	nativeIndex: 2
},
{
	name: "Last Added",
	native: true,
	nativeIndex: 3
},
{
	name: "Start Date"
},
{
	name: "Completed Date"
},
{
	name: "Release Date"
},
{
	name: "Average Score"
},
{
	name: "Popularity"
}
								].forEach(option => {
									let element = create("li","el-select-dropdown__item",false,ul);
									let elementSpan = create("span",false,option.name,element);
									if(
										option.name === useScripts.customDefaultListOrder
										|| (useScripts.customDefaultListOrder === "" && option.name === nativeOrder)
									){
										element.classList.add("selected")
										element.classList.add("hohSelected")
									}
									element.onclick = function(){
										if(option.native){
											nativeOrder = option.name;
											nativeIndex = option.nativeIndex;
											useScripts.customDefaultListOrder = "";
											selector.value = option.name;
											useScripts.save()
										}
										else{
											useScripts.customDefaultListOrder = option.name;
											selector.value = useScripts.customDefaultListOrder;
											useScripts.save()
										}
										let badSelected = ul.querySelector(".hohSelected");
										badSelected.classList.remove("selected");
										badSelected.classList.remove("hohSelected");
										element.classList.add("selected");
										element.classList.add("hohSelected");
										ul.children[nativeIndex].click()
									}
								})
							}
						})
						if(!correctDropdownFound){
							setTimeout(findDropdown,200)
						}
					};findDropdown()
				}
			};optionsAdder()
		}
		else{
			if(useScripts.customDefaultListOrder === ""){
				return
			}
			let optionsAdder = function(){
				const URLstuff = location.pathname.match(/^\/user\/(.+)\/(animelist|mangalist)/);
				if(!URLstuff){
					return
				}
				if(decodeURIComponent(URLstuff[1]) !== whoAmI){
					return
				}
				let selector = document.querySelector('input[placeholder="Sort"]');
				if(!selector){
					setTimeout(optionsAdder,200);
					return
				}
				if(selector.classList.contains("hohCustomSelected")){
					return
				}
				selector.click();
				selector.classList.add("hohCustomSelected");
				let findDropdown = function(){
					if(!location.pathname.match(/^\/user\/(.+)\/(animelist|mangalist)/)){
						return
					}
					let dropdowns = document.querySelectorAll(".el-select-dropdown");
					let correctDropdownFound = true;
					Array.from(dropdowns).forEach(dropdown => {
						if(dropdown.textContent === "TitleScoreProgressLast UpdatedLast AddedStart DateCompleted DateRelease DateAverage ScorePopularity"){
							correctDropdownFound = true;
							let ul = dropdown.querySelector("ul");
							Array.from(ul.children).forEach((child,index) => {
								if(child.textContent === useScripts.customDefaultListOrder){
									child.click()
								}
							})
						}
					})
					if(!correctDropdownFound){
						setTimeout(findDropdown,200)
					}
				};findDropdown()
			};optionsAdder()
		}
	}
})
//end modules/extraDefaultSorts.js
//begin modules/extraFavs.js
exportModule({
	id: "extraFavs",
	description: "Make scrollable favourite sections on profiles",
	extendedDescription: `
Work in progress. Only anime and manga so far.`,
	isDefault: true,
	importance: 0,
	categories: ["Profiles"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/user\/(.*?)\/?$/)
	},
	code: function(){
		let finder = function(){
			const URLstuff = document.URL.match(/^https:\/\/anilist\.co\/user\/(.*?)\/?$/);
			if(!URLstuff){
				return
			}
			const favSection = document.querySelector(".favourites-wrap.anime");
			if(!favSection){
				setTimeout(finder,1000);
				return
			}
			if(favSection.classList.contains("hohExtraFavs")){
				if(favSection.dataset.user === decodeURIComponent(URLstuff[1])){
					return
				}
				else{
					Array.from(favSection.querySelectorAll(".hohExtraFav")).forEach(fav => fav.remove())
				}
			}
			favSection.dataset.user = decodeURIComponent(URLstuff[1]);
			if(favSection.children.length === 0){
				setTimeout(finder,1000);
				return
			}
			if(
				favSection.children.length < 25 //user has all favs on profile
				|| favSection.children.length > 25 //if I have messed up somehow
			){
				return
			}
			favSection.classList.add("hohExtraFavs");
			generalAPIcall(//private users will not be able to use this on themselves, funnily enough.
`
query($user: String!){
	User(name: $user){
		favourites{
			anime1:anime(page:2){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
			anime2:anime(page:3){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
			anime3:anime(page:4){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
		}
	}
}
`,//top 100 is enough in most cases
				{
					user: decodeURIComponent(URLstuff[1]),
				},
				function(data){
					favSection.style.maxHeight = (favSection.clientHeight || 615) + "px";
					if(!data){
						return//could be a private profile
					}
					let findTooltip = function(){
						let possibleTooltip = document.querySelector(".tooltip.visible.animate-position");
						if(
							!possibleTooltip
							|| !possibleTooltip.querySelector(".content")
						){
							let candidates = Array.from(document.querySelectorAll(".tooltip.animate-position")).filter(
								tooltip => tooltip.querySelector(".content") && !tooltip.innerText.match(/Manga$/)
							)
							if(candidates.length){
								possibleTooltip = candidates[0]
							}
						}
						return possibleTooltip
					}
					let elderText = null;
					let elderRestorer = function(){
						let possibleTooltip = findTooltip();
						if(possibleTooltip){
							possibleTooltip.children[0].childNodes[0].textContent = elderText.title;
							possibleTooltip.children[1].childNodes[0].textContent = elderText.extra;
							possibleTooltip.style.transform = elderText.position;
							elderText = null;
							possibleTooltip.style.pointerEvents = "none"
						}
					}
					data.data.User.favourites.anime1.nodes.concat(
						data.data.User.favourites.anime2.nodes
					).concat(
						data.data.User.favourites.anime3.nodes
					).forEach(fav => {
						let element = create("a",["favourite","media","hohExtraFav"],false,favSection,'background-image: url("' + fav.coverImage.large + '")');
						element.href = "/anime/" + fav.id + "/" + safeURL(titlePicker(fav));
						cheapReload(element,{path: element.pathname})
						element.onmouseover = function(){
							let possibleTooltip = findTooltip();
							if(possibleTooltip){
								possibleTooltip.classList.add("visible");
								if(!elderText){
									elderText = {
										title: possibleTooltip.children[0].childNodes[0].textContent,
										extra: possibleTooltip.children[1].childNodes[0].textContent,
										position: possibleTooltip.style.transform
									}
									possibleTooltip.addEventListener("mouseenter",elderRestorer,{once: true});
									possibleTooltip.style.pointerEvents = "unset"
								}
								possibleTooltip.children[0].childNodes[0].textContent = titlePicker(fav);
								possibleTooltip.children[1].childNodes[0].textContent = [fav.startDate ? (fav.startDate.year || "") : "", distributionFormats[fav.format] || ""].join(" ")
								let pos = element.getBoundingClientRect();
								let pos2 = possibleTooltip.getBoundingClientRect();
								let x_offset = Math.round(pos.left + window.scrollX - pos2.width/2 + pos.width/2);
								let y_offset = Math.round(pos.top + window.scrollY - pos2.height - 10);
								possibleTooltip.style.transform = "translate(" + x_offset + "px, " + y_offset + "px)"
							}
							else{
								element.title = titlePicker(fav)
							}
						}
						element.onmouseout = function(){
							let possibleTooltip = findTooltip();
							if(possibleTooltip){
								possibleTooltip.classList.remove("visible");
							}
						}
					})
				},
				"hohExtraFavs" + URLstuff[1],
				60*60*1000//cache for an hour
			)
		};finder()
		let finder2 = function(){
			const URLstuff = document.URL.match(/^https:\/\/anilist\.co\/user\/(.*?)\/?$/);
			if(!URLstuff){
				return
			}
			const favSection = document.querySelector(".favourites-wrap.manga");
			if(!favSection){
				setTimeout(finder2,1000);
				return
			}
			if(favSection.classList.contains("hohExtraFavs")){
				return
			}
			if(favSection.children.length === 0){
				setTimeout(finder2,1000);
				return
			}
			if(
				favSection.children.length < 25 //user has all favs on profile
				|| favSection.children.length > 25 //if I have messed up somehow
			){
				return
			}
			favSection.classList.add("hohExtraFavs");
			generalAPIcall(
`
query($user: String!){
	User(name: $user){
		favourites{
			manga1:manga(page:2){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
			manga2:manga(page:3){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
			manga3:manga(page:4){
				nodes{
					id
					coverImage{large}
					startDate{year}
					format
					title{romaji native english}
				}
			}
		}
	}
}
`,//top 100 is enough in most cases
				{
					user: decodeURIComponent(URLstuff[1]),
				},
				function(data){
					favSection.style.maxHeight = (favSection.clientHeight || 615) + "px";
					if(!data){
						return//could be a private profile
					}
					let findTooltip = function(){
						let possibleTooltip = document.querySelector(".tooltip.visible.animate-position");
						if(possibleTooltip.innerText.match(/(TV|Movie)$/)){
							possibleTooltip = null
						}
						if(
							!possibleTooltip
							|| !possibleTooltip.querySelector(".content")
						){
							let candidates = Array.from(document.querySelectorAll(".tooltip.animate-position")).filter(
								tooltip => tooltip.querySelector(".content") && !tooltip.innerText.match(/(TV|Movie)$/)
							)
							if(candidates.length){
								possibleTooltip = candidates[0]
							}
						}
						return possibleTooltip
					}
					let elderText = null;
					let elderRestorer = function(){
						let possibleTooltip = findTooltip();
						if(possibleTooltip){
							possibleTooltip.children[0].childNodes[0].textContent = elderText.title;
							possibleTooltip.children[1].childNodes[0].textContent = elderText.extra;
							possibleTooltip.style.transform = elderText.position;
							elderText = null;
							possibleTooltip.style.pointerEvents = "none"
						}
					}
					data.data.User.favourites.manga1.nodes.concat(
						data.data.User.favourites.manga2.nodes
					).concat(
						data.data.User.favourites.manga3.nodes
					).forEach(fav => {
						let element = create("a",["favourite","media","hohExtraFav"],false,favSection,'background-image: url("' + fav.coverImage.large + '")');
						element.href = "/manga/" + fav.id + "/" + safeURL(titlePicker(fav));
						cheapReload(element,{path: element.pathname})
						element.onmouseover = function(){
							let possibleTooltip = findTooltip();
							if(possibleTooltip){
								possibleTooltip.classList.add("visible");
								if(!elderText){
									elderText = {
										title: possibleTooltip.children[0].childNodes[0].textContent,
										extra: possibleTooltip.children[1].childNodes[0].textContent,
										position: possibleTooltip.style.transform
									}
									possibleTooltip.addEventListener("mouseenter",elderRestorer,{once: true});
									possibleTooltip.style.pointerEvents = "unset"
								}
								possibleTooltip.children[0].childNodes[0].textContent = titlePicker(fav);
								possibleTooltip.children[1].childNodes[0].textContent = [fav.startDate ? (fav.startDate.year || "") : "", distributionFormats[fav.format] || ""].join(" ")
								let pos = element.getBoundingClientRect();
								let pos2 = possibleTooltip.getBoundingClientRect();
								let x_offset = Math.round(pos.left + window.scrollX - pos2.width/2 + pos.width/2);
								let y_offset = Math.round(pos.top + window.scrollY - pos2.height - 10);
								possibleTooltip.style.transform = "translate(" + x_offset + "px, " + y_offset + "px)"
							}
							else{
								element.title = titlePicker(fav)
							}
						}
						element.onmouseout = function(){
							let possibleTooltip = findTooltip();
							if(possibleTooltip){
								possibleTooltip.classList.remove("visible");
							}
						}
					})
				},
				"hohExtraFavsManga" + URLstuff[1],
				60*60*1000//cache for an hour
			)
		};finder2()
	},
	css: `
.hohExtraFav{
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	border-radius: 4px;
	cursor: pointer;
	display: inline-block;
	height: 115px;
	position: relative;
	width: 85px;
	margin-bottom: 20px;
	margin-right: 21px;
}
.hohExtraFavs:hover{
	overflow-y: auto;
	scrollbar-width: none;
	-ms-overflow-style: none;
}
.hohExtraFavs:hover::-webkit-scrollbar{
	width: 0;
	height: 0;
}
`
})
//end modules/extraFavs.js
//begin modules/feedListLikes.js
exportModule({
	id: "feedListLikes",
	description: "Add a full list of likes to feed posts",
	isDefault: true,
	categories: ["Feeds"],
	visible: false
})

let likeLoop = setInterval(function(){
	document.querySelectorAll(
		".activity-entry > .wrap > .actions .action.likes:not(.hohHandledLike)"
	).forEach(thingy => {
		thingy.classList.add("hohHandledLike");
		thingy.onmouseover = function(){
			if(!thingy.querySelector(".count")){
				return
			}
			let likeCount = parseInt(thingy.querySelector(".count").innerText) || 0;
			if(likeCount <= 5){
				return
			}
			if(thingy.classList.contains("hohLoadedLikes")){
				let dataSetCache = parseInt(thingy.dataset.cacheLikeCount);
				if(isNaN(dataSetCache)){//API query already in progress
					return
				}
				if(dataSetCache === likeCount){//nothing changed
					return
					//in theory, someone *could* have retracted a like, and someone else been added, but it doesn't really happen all that often.
					//at least, this is better than what was previously done, namely never refetching the data at all, even if the count changed
				}
			}
			thingy.classList.add("hohLoadedLikes");
			const id = parseInt(thingy.parentNode.parentNode.querySelector(`[href^="/activity/"`).href.match(/\d+/));
			generalAPIcall(`
query($id: Int){
	Activity(id: $id){
		... on TextActivity{
			likes{name}
		}
		... on MessageActivity{
			likes{name}
		}
		... on ListActivity{
			likes{name}
		}
	}
}`,
				{id: id},
				data => {
					thingy.title = data.data.Activity.likes.map(like => like.name).join("\n");
					thingy.dataset.cacheLikeCount = data.data.Activity.likes.length
				}
			)
		}
	});
},400);
//end modules/feedListLikes.js
//begin modules/filterStaffTabs.js
exportModule({
	id: "filterStaffTabs",
	description: "Add filtering to media staff tabs",
	isDefault: true,
	categories: ["Media"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/(anime|manga)\/\d+\/.*\/staff/)
	},
	code: function(){
		let waiter = function(tries){
			if(!document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\/\d+\/.*\/staff/)){
				return
			}
			if(tries > 10){
				return
			}
			let mediaStaff = document.querySelector(".media-staff");
			if(!mediaStaff){
				setTimeout(function(){waiter(0)},250);
				return
			}
			if(mediaStaff.children[0].children.length > 9){
				let filterBoxContainer = create("div","#hohStaffTabFilter",false,mediaStaff.parentNode);
				let filterRemover = create("span","#hohFilterRemover",svgAssets.cross,filterBoxContainer)
				let filterBox = create("input",false,false,filterBoxContainer);
				filterBox.placeholder = translate("$mediaStaff_filter");
				filterBox.setAttribute("list","staffRoles");
				let filterer = function(){
					let val = filterBox.value;
					Array.from(mediaStaff.children[0].children).forEach(card => {
						if(
							looseMatcher(card.querySelector(".name").innerText,val)
							|| looseMatcher(card.querySelector(".role").innerText,val)
						){
							card.style.display = "inline-grid"
						}
						else{
							card.style.display = "none"
						}
					});
					if(val === ""){
						filterRemover.style.display = "none"
					}
					else{
						filterRemover.style.display = "inline"
					}
				}
				filterRemover.onclick = function(){
					filterBox.value = "";
					filterer()
				}
				filterBox.oninput = filterer;
				let dataList = create("datalist","#staffRoles",false,filterBoxContainer);
				let buildStaffRoles = function(){
					let autocomplete = new Set();
					Array.from(mediaStaff.children[0].children).forEach(card => {
						autocomplete.add(card.querySelector(".name").innerText);
						autocomplete.add(card.querySelector(".role").innerText.replace(/\s*\(.*\)\.?\s*/,""));
						if(card.querySelector(".role").innerText.includes("OP")){
							autocomplete.add("OP")
						}
						if(card.querySelector(".role").innerText.includes("ED")){
							autocomplete.add("ED")
						}
					})
					removeChildren(dataList);
					autocomplete.forEach(
						value => create("option",false,false,dataList).value = value
					)
				};buildStaffRoles();
				let mutationConfig = {
					attributes: false,
					childList: true,
					subtree: false
				};
				let observer = new MutationObserver(function(){
					filterer();
					buildStaffRoles()
				});
				observer.observe(mediaStaff.children[0],mutationConfig)
			}
			else{
				setTimeout(function(){waiter(++tries)},250 + tries*100)
			}
		};waiter(0)
	}
})
//end modules/filterStaffTabs.js
//begin modules/forumLikes.js
exportModule({
	id: "forumLikes",
	description: "Add a full list of likes to forum threads",
	isDefault: true,
	categories: ["Forum"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return /^https:\/\/anilist\.co\/forum\/thread\/.*/.test(url)
	},
	code: function(){
		let URLstuff = location.pathname.match(/^\/forum\/thread\/(\d+)/);
		if(!URLstuff){
			return
		}
		let adder = function(data){
			if((!data) || (!location.pathname.includes("forum/thread/" + URLstuff[1]))){
				return
			}
			let button = document.querySelector(".footer .actions .like-wrap .button");
			if(!button){
				setTimeout(function(){adder(data)},200);
				return;
			}
			button.title = data.data.Thread.likes.map(like => like.name).join("\n");
		}
		generalAPIcall(`
			query($id: Int){
				Thread(id: $id){
					likes{name}
				}
			}`,
			{id: parseInt(URLstuff[1])},
			adder
		)
	}
})
//end modules/forumLikes.js
//begin modules/forumRecent.js
exportModule({
	id: "forumRecent",
	description: "Make the 'Forum' navbar item lead directly to /forum/recent",
	isDefault: false,
	categories: ["Forum","Navigation"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return false
	}
})

if(useScripts.forumRecent){
	let finder = function(){
		let navLinks = document.querySelector(`#nav .links .link[href="/forum/overview"]`);
		if(navLinks){
			navLinks.href = "/forum/recent";
			navLinks.onclick = function(){
				try{
					document.getElementById("app").__vue__._router.push({ name: "ForumFeed", params: {type: "recent"}});
					return false
				}
				catch(e){
					let forumRecentLink = navLinks.cloneNode(true);//copying and pasting the node should remove all event references to it
					navLinks.parentNode.replaceChild(forumRecentLink,navLinks);
				}
			}
		}
		else{
			setTimeout(finder,1000)
		}
	}
	finder()
}
//end modules/forumRecent.js
//begin modules/forumVisualLikes.js
exportModule({
	id: "forumVisualLikes",
	description: "Show more user avatars which liked a forum thread or comment",
	isDefault: true,
	categories: ["Forum"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return /^https:\/\/anilist\.co\/forum\/thread\/.*/.test(url)
	},
	code: function(){
		let likeLoop = setInterval(function(){
			// forum comments
			document.querySelectorAll(
				".forum-thread .comment .actions .like-wrap.thread_comment:not(.hohHandledLike)"
			).forEach(thingy => {
				thingy.classList.add("hohHandledLike");
				let updateLikes = function(){
					let idLink = thingy.parentNode.querySelector('.hidden[href^="/forum/thread/"]');
					if(!idLink){
						return
					}
					const id = parseInt(idLink.href.match(/\d+$/));
//wow, this API sucks!
					generalAPIcall(`
query($id: Int){
	ThreadComment(id:$id){
		id
		likes{
			name
			avatar{large}
		}
		childComments
	}
}`,
						{id: id},
						data => {
							if(!data){
								return
							}
							//TODO: be more efficient and update other comments too
							let seeker = function(comment){
								if(comment.id === id){
									let userList = thingy.querySelector(".users");
									let waitForAnilist = function(tries){
										tries--;
										if(!userList.children.length && tries){
											setTimeout(function(){waitForAnilist(tries)},200);
											return
										}
										for(let i=5;i<comment.likes.length;i++){
											let newEle = userList.children[0].cloneNode();//to be up to date with those random attributes
											newEle.href = "/user/" + comment.likes[i].name + "/";
											newEle.style.backgroundImage = 'url("' + comment.likes[i].avatar.large + '")';
											userList.appendChild(newEle)
										}
									};waitForAnilist(20);
									return true
								}
								else if(comment.childComments){
									for(let i=0;i<comment.childComments.length;i++){
										if(seeker(comment.childComments[i])){
											return true
										}
									}
								}
								return false
							}
							seeker(data.data.ThreadComment[0])
						}
					)
				}
				thingy.onmouseover = function(){
					if(!thingy.querySelector(".count")){
						return
					}
					let likeCount = parseInt(thingy.querySelector(".count").innerText);
					if(likeCount <= 5){
						return
					}
					if(thingy.classList.contains("hohLoadedLikes")){
						return
					}
					thingy.classList.add("hohLoadedLikes");
					updateLikes()
				}
				thingy.onclick = function(){
					//TODO handle this locally
					setTimeout(updateLikes,2000)
				}
			});

			// forum threads
			let thingy = document.querySelector(".forum-thread .body .actions .like-wrap.thread:not(.hohHandledLike)");
			if(thingy){
				thingy.classList.add("hohHandledLike");
				let shortlist = null;
				let updateLikes = function(){
					if(shortlist && shortlist.data.Page.likes.length >= 25 && !shortlist.data.Page.likes.map(like => like.name).includes(whoAmI)){
						return
					}
					let [,threadId] = location.pathname.match(/^\/forum\/thread\/(\d+)/);
					if(!threadId){
						return
					}
					const id = parseInt(threadId);
					generalAPIcall(`
query ($id: Int, $type: LikeableType) {
	Page(perPage: 20) {
		likes(likeableId: $id, type: $type) {
			name
			avatar {
				large
			}
		}
	}
}`,
						{id, type: "THREAD"},
						data => {
							if(!data){
								return
							}
							shortlist = data;
							let seeker = function(comment){
								let userList = thingy.querySelector(".users");
								let waitForAnilist = function(tries){
									tries--;
									if(!userList.children.length && tries){
										setTimeout(function(){waitForAnilist(tries)},200);
										return
									}
									for(let i=userList.children.length;i<comment.likes.length;i++){
										let newEle = userList.children[0].cloneNode();//to be up to date with those random attributes
										newEle.href = "/user/" + comment.likes[i].name + "/";
										newEle.style.backgroundImage = 'url("' + comment.likes[i].avatar.large + '")';
										userList.appendChild(newEle)
									}
									if(userList.children.length>comment.likes.length){
										for(let i=comment.likes.length;i<userList.children.length;i++){
											userList.children[i].remove();
										}
									}
								};waitForAnilist(20);
								return true
							}
							seeker(data.data.Page)
						}
					)
				}
				thingy.onmouseover = function(){
					if(!thingy.querySelector(".count")){
						return
					}
					let likeCount = parseInt(thingy.querySelector(".count").innerText);
					if(likeCount <= 5){
						return
					}
					if(thingy.classList.contains("hohLoadedLikes")){
						return
					}
					thingy.classList.add("hohLoadedLikes");
					updateLikes()
				}
				thingy.onclick = function(){
					//TODO handle this locally
					setTimeout(updateLikes,2000)
				}
			}
		},400);
	}
})
//end modules/forumVisualLikes.js
//begin modules/hideGlobalFeed.js
function hideGlobalFeed(){
	if(!location.pathname.match(/^\/home/)){
		return
	}
	let toggle = document.querySelector(".feed-type-toggle");
	if(!toggle){
		setTimeout(hideGlobalFeed,100);
		return
	}
	toggle.children[1].style.display = "none";
	if(toggle.children[1].classList.contains("active")){
		toggle.children[0].click()
	}
}
//end modules/hideGlobalFeed.js
//begin modules/hollowHearts.js
// SPDX-FileCopyrightText: 2021 Reina
// SPDX-License-Identifier: MIT
/*
Copyright (c) 2021 Reina

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//updated code here: https://github.com/Reinachan/AniList-High-Contrast-Dark-Theme
exportModule({
	id: "hollowHearts",
	description: "Make unliked hearts hollow [by Reina]",
	isDefault: false,
	importance: 0,
	categories: ["Feeds"],
	visible: true,
	css: `
/* Like heart */
.action.likes .button,
.like-wrap.thread_comment .button{
	color: rgb(var(--color-blue-dim));
}
.action.likes .button:hover,
.like-wrap.thread_comment .button:hover{
	color: rgb(var(--color-blue));
}
.action.likes .button .fa-heart,
.like-wrap.thread_comment .button .fa-heart{
	color: #0000;
	stroke: rgb(var(--color-blue-dim));
	stroke-width: 70;
	stroke-alignment: inner;
	font-size: 0.870em;
	padding-bottom: 0.08em;
	padding-top: 0.05em;
}
.action.likes .button .fa-heart:hover,
.like-wrap.thread_comment .button .fa-heart:hover{
	stroke: rgb(var(--color-blue));
}
.action.likes .button.liked,
.like-wrap.thread_comment .button.liked{
	color: rgb(var(--color-red));
}
.action.likes .button.liked:hover,
.like-wrap.thread_comment .button.liked:hover{
	color: rgb(var(--color-blue-dim));
}
.action.likes .button.liked:hover .fa-heart,
.like-wrap.thread_comment .button.liked:hover .fa-heart{
	color: rgb(var(--color-blue-dim));
}
.action.likes .button.liked .fa-heart,
.like-wrap.thread_comment .button.liked .fa-heart{
	color: var(--color-red);
	stroke: rgba(0, 0, 0, 0);
	stroke-width: 0;
	font-size: 0.875em;
	padding-bottom: 0;
	padding-top: 0;
}
.action.likes .button.liked .fa-heart:hover,
.like-wrap.thread_comment .button.liked .fa-heart:hover{
	color: rgb(var(--color-blue-dim));
}
/* forum thread, favourite like heart */
.like-wrap.thread .button .fa-heart,
.actions .favourite .fa-heart{
	color: #0000;
	stroke: rgb(var(--color-white));
	stroke-width: 70;
}
.like-wrap.thread .button.liked .fa-heart,
.actions .favourite.liked .fa-heart,
.like-wrap.thread .button.isFavourite .fa-heart,
.actions .favourite.isFavourite .fa-heart{
	color: rgb(var(--color-white)) !important;
	stroke: rgba(0, 0, 0, 0) !important;
}
`
})
//end modules/hollowHearts.js
//begin modules/imageFreeEditor.js
exportModule({
	id: "imageFreeEditor",
	description: "Don't display the cover and banner image in the list editor",
	isDefault: false,
	importance: -2,
	categories: ["Media","Lists"],
	visible: true,
	css: `
.list-editor-wrap .cover{
	display: none;
}
.list-editor-wrap .header{
	background-image: none!important;
	height: 0px;
}
.list-editor-wrap .header .content{
	padding-top: 2px;
	padding-left: 35px;
	padding-right: 120px;
	height: 60px;
}
	`
})
//end modules/imageFreeEditor.js
//begin modules/infoTable.js
exportModule({
	id: "infoTable",
	description: "$setting_infoTable",
	isDefault: false,
	importance: 1,
	categories: ["Media"],
	visible: true,
	css: `
.media-page-unscoped > .content.container{
	grid-template-columns: 215px auto;
}
.media-page-unscoped .sidebar > .data{
	padding: 15px;
}
.media-page-unscoped .data-set,
.media-page-unscoped .data-set #hohMALserialization{
	display: inline-block;
	width: 100%;
	padding-bottom: 9px!important;
	padding-top: 4px;
}
.media-page-unscoped .data-set ~ .data-set{
	border-top-style: solid;
	border-top-width: 1px;
	border-top-color: rgb(var(--color-background));
}
.media-page-unscoped .data-set .type{
	display: inline;
}
.media-page-unscoped .data-set .value{
	display: inline;
	float: right;
	margin-top: 2px;
}`
})
//end modules/infoTable.js
//begin modules/interestingRecs.js
exportModule({
	id: "interestingRecs",
	description: "Add a 'For You' filter to the recommendations page",
	isDefault: true,
	categories: ["Login"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/https:\/\/anilist\.co\/recommendations/) && useScripts.accessToken
	},
	code: function(){
		let buttonInserter = function(){
			if(!document.URL.match(/https:\/\/anilist\.co\/recommendations/)){
				return
			}
			let switchL = document.querySelector(".page-content .switch:not(.list-switch) .options");
			if(switchL && document.querySelector(".recommendations-wrap")){
				switchL.parentNode.classList.add("hohRecsSwitch");
				let optionWrapper = create("div","option",false,switchL);
				let option = create("span",false,translate("$recs_forYou"),optionWrapper);
				option.title = translate("$recs_description");
				let fakeContent = create("div",["recommendations-wrap","substitute"],false,false,"display:none;");
				let realNode = document.querySelector(".recommendations-wrap");
				realNode.parentNode.insertBefore(fakeContent,realNode);
				optionWrapper.onclick = function(){
					switchL.querySelector(".active").classList.remove("active");
					fakeContent.style.display = "grid";
					realNode.style.display = "none";
					optionWrapper.classList.add("active");
					if(fakeContent.childElementCount){
						return
					}
					authAPIcall(`
query($id: Int){
	Page{
		mediaList(status:COMPLETED,sort:SCORE_DESC,userId:$id){
			... stuff
		}
	}
	Page2:Page(page:2){
		mediaList(status:COMPLETED,sort:SCORE_DESC,userId:$id){
			... stuff
		}
	}
}

fragment stuff on MediaList{
	rawScore:score(format:POINT_100)
	media{
		id
		siteUrl
		coverImage{large color}
		title{romaji native english}
		recommendations(sort:RATING_DESC){
			nodes{
				rating
				userRating
				mediaRecommendation{
					id
					siteUrl
					averageScore
					coverImage{large color}
					title{romaji native english}
					mediaListEntry{
						status
					}
				}
			}
		}
	}
}
`,
						{id: whoAmIid},
						function(data){
							let possRecs = [];
							data.data.Page.mediaList.concat(data.data.Page2.mediaList).forEach(entry => {
								entry.media.recommendations.nodes.forEach(node => {
									possRecs.push({
										first: {
											id: entry.media.id,
											score: entry.rawScore,
											title: entry.media.title,
											siteUrl: entry.media.siteUrl,
											coverImage: entry.media.coverImage
										},
										second: {
											id: node.mediaRecommendation.id,
											mediaListEntry: node.mediaRecommendation.mediaListEntry,
											title: node.mediaRecommendation.title,
											siteUrl: node.mediaRecommendation.siteUrl,
											averageScore: node.mediaRecommendation.averageScore,
											coverImage: node.mediaRecommendation.coverImage
										},
										rating: node.rating,
										userRating: node.userRating
									})
								})
							});
							possRecs.filter(
								rec => ((!rec.second.mediaListEntry) || rec.second.mediaListEntry.status === "PLANNING")
									&& rec.rating > 0
									&& rec.userRating !== "RATE_DOWN"//don't count this recommendation if the user has actively stated it is bad
							).sort(
								(b,a) => (a.first.score + a.second.averageScore || 41) * (1 - 1/(a.rating + 1))
									- (b.first.score + b.second.averageScore || 41) * (1 - 1/(b.rating + 1))
							).forEach(rec => {
								let pairCard = create("div","recommendation-pair-card",false,fakeContent);
									let first = create("a","media",false,pairCard);
									first.href = rec.first.siteUrl;
										let firstCover = create("div","cover",false,first);
										firstCover.style.backgroundColor = rec.first.coverImage.color;
										firstCover.style.backgroundImage = "url(\"" + rec.first.coverImage.large + "\")";
										let firstTitle = create("div","title",false,first);
											let firstTitleSpan = create("span",false,titlePicker(rec.first),firstTitle);
									let second = create("a","media",false,pairCard);
									second.href = rec.second.siteUrl;
										let secondCover = create("div","cover",false,second);
										secondCover.style.backgroundColor = rec.second.coverImage.color;
										secondCover.style.backgroundImage = "url(\"" + rec.second.coverImage.large + "\")";
										let secondTitle = create("div","title",false,second);
											let secondTitleSpan = create("span",false,titlePicker(rec.second),secondTitle);
									let ratingWrap = create("div","rating-wrap",false,pairCard);
										let actions = create("div","actions",false,ratingWrap);
											let thumbsDownWrap = create("div",["icon","thumbs-down"],false,actions,"margin-right:10px;");
											thumbsDownWrap.appendChild(svgAssets2.thumbsDown.cloneNode(true));
											if(rec.userRating === "RATE_DOWN"){
												thumbsDownWrap.style.color = "rgb(var(--color-red))"
											}
											let thumbsUpWrap = create("div",["icon","thumbs-up"],false,actions);
											if(rec.userRating === "RATE_UP"){
												thumbsUpWrap.style.color = "rgb(var(--color-green))"
											}
											thumbsUpWrap.appendChild(svgAssets2.thumbsUp.cloneNode(true));
										let rating = create("div","rating",0,ratingWrap);
										if(rec.rating > 0){
											rating.innerText = "+" + rec.rating
										}
								thumbsDownWrap.onclick = function(){
									if(rec.userRating === "NO_RATING" || rec.userRating === "RATE_UP"){
										authAPIcall(
											`mutation{SaveRecommendation(mediaId:${rec.first.id},mediaRecommendationId:${rec.second.id},rating:RATE_DOWN){id}}`,
											{},
											data => {
												if(data.data){
													thumbsDownWrap.style.color = "rgb(var(--color-red))";
													if(rec.userRating === "RATE_UP"){
														thumbsUpWrap.style.color = "inherit";
														rec.rating--;
													}
													rec.userRating = "RATE_DOWN";
													rec.rating--;
													if(rec.rating > 0){
														rating.innerText = "+" + rec.rating
													}
													else{
														rating.innerText = 0
													}
												}
											}
										)
									}
									else{
										authAPIcall(
											`mutation{SaveRecommendation(mediaId:${rec.first.id},mediaRecommendationId:${rec.second.id},rating:NO_RATING){id}}`,
											{},
											data => {
												if(data.data){
													thumbsDownWrap.style.color = "inherit";
													rec.userRating = "NO_RATING";
													rec.rating++;
													rating.innerText = "+" + rec.rating
												}
											}
										)
									}
								}
								thumbsUpWrap.onclick = function(){
									if(rec.userRating === "NO_RATING" || rec.userRating === "RATE_DOWN"){
										authAPIcall(
											`mutation{SaveRecommendation(mediaId:${rec.first.id},mediaRecommendationId:${rec.second.id},rating:RATE_UP){id}}`,
											{},
											data => {
												if(data.data){
													thumbsUpWrap.style.color = "rgb(var(--color-green))";
													if(rec.userRating === "RATE_UP"){
														thumbsDownWrap.style.color = "inherit";
														rec.rating++;
													}
													rec.userRating = "RATE_UP";
													rec.rating++;
													rating.innerText = "+" + rec.rating
												}
											}
										)
									}
									else{
										authAPIcall(
											`mutation{SaveRecommendation(mediaId:${rec.first.id},mediaRecommendationId:${rec.second.id},rating:NO_RATING){id}}`,
											{},
											data => {
												if(data.data){
													thumbsUpWrap.style.color = "inherit";
													rec.userRating = "NO_RATING";
													rec.rating--;
													if(rec.rating > 0){
														rating.innerText = "+" + rec.rating
													}
													else{
														rating.innerText = 0
													}
												}
											}
										)
									}
								}
							})
						}
					)
				};
				let normal = function(event){
					optionWrapper.classList.remove("active");
					fakeContent.style.display = "none";
					realNode.style.display = "grid";
					if(event.target.classList.contains("option")){
						event.target.classList.add("active")
					}
					else{
						event.target.parentNode.classList.add("active")
					}
				}
				switchL.children[0].addEventListener("click",normal);
				switchL.children[1].addEventListener("click",normal);
				switchL.children[2].addEventListener("click",normal);
			}
			else{
				setTimeout(buttonInserter,200)
			}
		};buttonInserter()
	}
})
//end modules/interestingRecs.js
//begin modules/keepAlive.js
exportModule({
	boneless_disable: true,
	id: "keepAlive",
	description: "Keep connections alive to prevent 'Session expired' errors [EXPERIMENTAL]",
	extendedDescription: `Not perfectly working yet. Info: https://github.com/hohMiyazawa/Automail/issues/65`,
	isDefault: false,
	importance: 0,
	categories: ["Script"],
	visible: true
})

new MutationObserver(function(){
	let messages = Array.from(document.querySelectorAll(".el-message--error.is-closable"));
	if(messages.some(message => message.textContent === "Session expired, please refresh")){
		fetch("index.html").then(function(response){
			return response.text()
		}).then(function(html){
			let token = html.match(/window\.al_token = "([a-zA-Z0-9]+)";/);
			console.log("token",token);
			if(!token){
				return//idk, stuff changed, better do nothing
			}
			window.al_token = token;
			//alert the other tabs so they don't have to do the same
			aniCast.postMessage({type:"sessionToken",value:token});
			//fetch the alert list again, they may have piled up while fetching
			Array.from(document.querySelectorAll(".el-message--error.is-closable")).forEach(message => {
				if(message.textContent === "Session expired, please refresh"){
					message.querySelector(".el-message__closeBtn").click()
				}
			});
		}).catch(function(){})//fail silently, trust Anilist to do the right thing by default
	}
}).observe(
	document.body,
	{attributes: false, childList: true, subtree: false}
)
//end modules/keepAlive.js
//begin modules/mangaBrowse.js
exportModule({
	id: "mangaBrowse",
	description: "$mangaBrowse_description",
	isDefault: false,
	categories: ["Browse","Navigation"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return false
	}
})

if(useScripts.mangaBrowse){
	let finder = function(){
		let navLinks = document.querySelector(`#nav .links .link[href="/search/anime"]`);
		if(navLinks){
			navLinks.href = "/search/manga";
			navLinks.onclick = function(){
				try{
					document.getElementById('app').__vue__._router.push({ name: 'Search', params: {type:'manga'}});
					return false
				}
				catch(e){
					let mangaBrowseLink = navLinks.cloneNode(true);//copying and pasting the node should remove all event references to it
					navLinks.parentNode.replaceChild(mangaBrowseLink,navLinks);
				}
			}
		}
		else{
			setTimeout(finder,1000)
		}
	}
	finder()
}
//end modules/mangaBrowse.js
//begin modules/mangaGuess.js
function mangaGuess(cleanAnime,id){
	let possibleMangaGuess = document.querySelector(".data-set .value[data-media-id]");
	if(possibleMangaGuess && (
		cleanAnime
		|| id !== parseInt(possibleMangaGuess.dataset.mediaId)
	)){
		removeChildren(possibleMangaGuess)
	}
	if(cleanAnime){
		return
	}
	let URLstuff = location.pathname.match(/^\/manga\/(\d+)\/?(.*)?/);
	if(!URLstuff){
		return
	}
	let possibleReleaseStatus = Array.from(
		document.querySelectorAll(".data-set .value")
	).find(
		element => element.innerText.match(/^Releasing/)
	);
	if(!possibleReleaseStatus){
		setTimeout(mangaGuess,200);
		return
	}
	if(
		possibleReleaseStatus.dataset.mediaId === URLstuff[1]
		&& possibleReleaseStatus.children.length !== 0
	){
		return
	}
	else{
		removeChildren(possibleReleaseStatus)
	}
	possibleReleaseStatus.dataset.mediaId = URLstuff[1];
	const variables = {id: parseInt(URLstuff[1]),userName: whoAmI};
	let query = `
query($id: Int,$userName: String){
	Page(page: 1){
		activities(
			mediaId: $id,
			sort: ID_DESC
		){
			... on ListActivity{
				progress
				userId
			}
		}
	}
	MediaList(
		userName: $userName,
		mediaId: $id
	){
		progress
	}
}`;
	let possibleMyStatus = document.querySelector(".actions .list .add");
	const simpleQuery = !possibleMyStatus || possibleMyStatus.innerText === "Add to List" || possibleMyStatus.innerText === "Planning";
	if(simpleQuery){
		query = `
query($id: Int){
	Page(page: 1){
		activities(
			mediaId: $id,
			sort: ID_DESC
		){
			... on ListActivity{
				progress
				userId
			}
		}
	}
}`;
	}
	let highestChapterFinder = function(data){
		if(possibleReleaseStatus.children.length !== 0){
			return
		}
		let guesses = [];
		let userIdCache = new Set();
		data.data.Page.activities.forEach(activity => {
			if(activity.progress){
				let chapterMatch = parseInt(activity.progress.match(/\d+$/)[0]);
				if(!userIdCache.has(activity.userId)){
					guesses.push(chapterMatch);
					userIdCache.add(activity.userId)
				}
			}
		});
		guesses.sort(VALUE_DESC);
		if(guesses.length){
			let bestGuess = guesses[0];
			if(guesses.length > 2){
				let diff = guesses[0] - guesses[1];
				let inverseDiff = 1 + Math.ceil(25/(diff+1));
				if(guesses.length >= inverseDiff){
					if(guesses[1] === guesses[inverseDiff] || guesses[0] - guesses[1] > 500){
						bestGuess = guesses[1]
					}
				}
			}
			if(hasOwn(commonUnfinishedManga, variables.id)){
				if(bestGuess < commonUnfinishedManga[variables.id].chapters){
					bestGuess = commonUnfinishedManga[variables.id].chapters
				}
			}
			if(simpleQuery && bestGuess){
				create("span","hohGuess"," (" + bestGuess + "?)",possibleReleaseStatus)
			}
			else{
				bestGuess = Math.max(bestGuess,data.data.MediaList.progress);
				if(bestGuess){
					if(bestGuess === data.data.MediaList.progress){
						create("span","hohGuess"," (" + bestGuess + "?)",possibleReleaseStatus,"color:rgb(var(--color-green));")
					}
					else{
						create("span","hohGuess"," (" + bestGuess + "?)",possibleReleaseStatus);
						create("span","hohGuess"," [+" + (bestGuess - data.data.MediaList.progress) + "]",possibleReleaseStatus,"color:rgb(var(--color-red));")
					}
				}
			}
		}
	};
	try{
		generalAPIcall(query,variables,highestChapterFinder,"hohMangaGuess" + variables.id,30*60*1000)
	}
	catch(e){
		sessionStorage.removeItem("hohMangaGuess" + variables.id)
	}
}

//end modules/mangaGuess.js
//begin modules/markdownHelp.js
exportModule({
	id: "markdownHelp",
	description: "$markdown_help_description",
	isDefault: false,
	categories: ["Navigation"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return true
	},
	code: function(){
		let markdownHelper = document.getElementById("hohMarkdownHelper");
		if(markdownHelper){
			return
		}
		markdownHelper = create("span","#hohMarkdownHelper","</>?",document.getElementById("app"));
		markdownHelper.title = translate("$markdown_help_title");
		markdownHelper.onclick = function(){
			let existing = document.querySelector(".hohDisplayBox");
			if(existing){
				existing.remove()
			}
			else{
				let disp = createDisplayBox("height: 600px;",translate("$markdown_help_title"));
				create("h3","hohGuideHeading",translate("$markdown_help_images_header"),disp);
				create("pre","hohCode","img(your link here)",disp);
				create("pre","hohCode","img(https://i.stack.imgur.com/Wlvkk.jpg)",disp);
				create("p",false,translate("$markdown_help_imageUpload"),disp);
				create("p",false,translate("$markdown_help_imageSize"),disp);
				create("pre","hohCode","img300(your link here)",disp);
				create("p",false,translate("$markdown_help_infixOr"),disp);
				create("pre","hohCode","img40%(your link here)",disp);
				create("h3","hohGuideHeading",translate("$markdown_help_links_header"),disp);
				create("pre","hohCode","[link text](URL)",disp);
				create("pre","hohCode","[cool show](https://en.wikipedia.org/wiki/Urusei_Yatsura)",disp);
				create("p",false,"To get a media preview card, just put the Anilist URL of the show:",disp);
				create("pre","hohCode","https://anilist.co/anime/1293/Urusei-Yatsura/",disp);
				create("p",false,"To make an image a link, put the image markdown inside the link markdown, with a space on both sides",disp);
				create("pre","hohCode","[ img(image URL) ](link URL)",disp);
				create("h3","hohGuideHeading",translate("$markdown_help_formatting_header"),disp);
				create("h1",false,"headline",disp);
				create("pre","hohCode","# headline",disp);
				create("i",false,"italics",disp);
				create("pre","hohCode","*italics* or _italics_",disp);
				create("b",false,"bold",disp);
				create("pre","hohCode","**bold** or __bold__",disp);
				create("del",false,"strikethrough",disp);
				create("pre","hohCode","~~strikethrough~~",disp);
				create("span",false,"Use a backslash \\ to undo special meaning of formatting symols like * ~ # _ \\",disp);
				create("pre","hohCode","Use a backslash \\\\ to undo special meaning of formatting symols like \\* \\~ \\# \\_ \\\\",disp);
				create("a",["link","hohGuideHeading"],"Full guide",disp).href = "https://anilist.co/forum/thread/6125";
				create("span",false," ◆ ",disp);
				create("a",["link","hohGuideHeading"],"Make emojis work",disp).href = "https://files.kiniro.uk/unicodifier.html";
			}
		}
	}
})
//end modules/markdownHelp.js
//begin modules/meanScoreBack.js
//rename?
function meanScoreBack(){
	const userRegex = /^\/user\/([^/]+)\/?$/;
	let URLstuff = location.pathname.match(userRegex);
	if(!URLstuff){
		return
	}
	const query = `
	query($userName: String) {
		User(name: $userName){
			statistics{
				anime{
					episodesWatched
					meanScore
				}
				manga{
					volumesRead
					meanScore
				}
			}
		}
	}`;
	let variables = {
		userName: decodeURIComponent(URLstuff[1])
	}
	generalAPIcall(query,variables,function(data){
		if(!data){
			return;
		}
		let adder = function(){
			if(
				!userRegex.test(location.pathname)
				|| location.pathname.match(userRegex)[1] !== URLstuff[1]
			){
				return
			}
			let possibleStatsWrap = document.querySelectorAll(".stats-wrap .stats-wrap");
			if(possibleStatsWrap.length){
				if(possibleStatsWrap.length === 2 && possibleStatsWrap[0].childElementCount === 3){
					if(data.data.User.statistics.anime.meanScore){
						let statAnime = create("div","stat",false,possibleStatsWrap[0]);
						create("div","value",data.data.User.statistics.anime.episodesWatched,statAnime);
						create("div","label",translate("$milestones_totalEpisodes"),statAnime);
						let totalDays = possibleStatsWrap[0].children[1].children[0].innerText;
						possibleStatsWrap[0].children[1].remove();
						possibleStatsWrap[0].parentNode.querySelector(".milestone:nth-child(2)").innerText = translate("$milestones_daysWatched",totalDays);
						possibleStatsWrap[0].parentNode.classList.add("hohMilestones")
					}
					if(data.data.User.statistics.manga.meanScore){
						let statManga = create("div","stat",false,possibleStatsWrap[1]);
						create("div","value",data.data.User.statistics.manga.volumesRead,statManga);
						create("div","label",translate("$milestones_totalVolumes"),statManga);
						let totalChapters = possibleStatsWrap[1].children[1].children[0].innerText;
						possibleStatsWrap[1].children[1].remove();
						possibleStatsWrap[1].parentNode.querySelector(".milestone:nth-child(2)").innerText = translate("$milestones_chaptersRead",totalChapters);
						possibleStatsWrap[1].parentNode.classList.add("hohMilestones")
					}
				}
				else if(possibleStatsWrap[0].innerText.includes("Total Manga")){
					if(data.data.User.statistics.manga.meanScore){
						let statManga = create("div","stat",false,possibleStatsWrap[0]);
						create("div","value",data.data.User.statistics.manga.volumesRead,statManga);
						create("div","label",translate("$milestones_totalVolumes"),statManga);
						let totalChapters = possibleStatsWrap[0].children[1].children[0].innerText;
						possibleStatsWrap[0].children[1].remove();
						possibleStatsWrap[0].parentNode.querySelector(".milestone:nth-child(2)").innerText = translate("$milestones_chaptersRead",totalChapters);
						possibleStatsWrap[0].parentNode.classList.add("hohMilestones")
					}
				}
			}
			else{
				setTimeout(adder,200)
			}
		};adder();
	},"hohMeanScoreBack" + variables.userName,60*1000)
}
//end modules/meanScoreBack.js
//begin modules/mediaList.js
exportModule({
	id: "mediaList",
	description: "wrapper module for various unrelelated medialist modules",
	isDefault: true,
	categories: ["Lists"],
	visible: false,//not relevant in settings, adjust the wrapped modules instead
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/.+\/(anime|manga)list\/?(.*)?$/);
	},
	code: function(){
		const URLstuff = location.pathname.match(/^\/user\/(.+)\/(animelist|mangalist)/);
		if(!URLstuff){
			return
		}
		if(document.querySelector(".hohExtraFilters")){
			return
		}
		let waiter = function(){
			let filters = document.querySelector(".filters-wrap");
			if(!filters){
				setTimeout(waiter,200);
				return
			}
			let extraFilters = create("div","hohExtraFilters");
			extraFilters.style.marginTop = "15px";
			if(useScripts.draw3x3){
				let buttonDraw3x3 = create("span","#hohDraw3x3",translate("$make3x3"),extraFilters);
				buttonDraw3x3.title = translate("$make3x3_title");
				buttonDraw3x3.onclick = function(){
					this.style.color = "rgb(var(--color-blue))";
					let counter = 0;
					let linkList = [];
					let keepUpdating = true;
					let updateCards = function(){
						let cardList = document.querySelectorAll(".entry-card.row,.entry.row");
						cardList.forEach(card => {
							card.onclick = function(){
								if(this.draw3x3selected){
									counter--;
									linkList[this.draw3x3selected - 1] = "";
									this.draw3x3selected = false;
									this.style.borderStyle = "none"
								}
								else{
									counter++;
									linkList.push(this.querySelector(".cover .image").style.backgroundImage.replace("url(","").replace(")","").replace('"',"").replace('"',""));
									this.draw3x3selected = +linkList.length;
									this.style.borderStyle = "solid";
									if(counter === 9){
										linkList = linkList.filter(e => e !== "");
										let displayBox = createDisplayBox(false,"3x3 maker");
										create("p",false,"Save the image below:",displayBox);
										displayBox.parentNode.querySelector(".hohDisplayBoxClose").onclick = function(){
											displayBox.parentNode.remove();
											keepUpdating = false;
											cardList.forEach(function(card){
												card.draw3x3selected = false;
												card.style.borderStyle = "none"
											});
											counter = 0;
											linkList = []
										};
										let finalCanvas = create("canvas",false,false,displayBox);
										finalCanvas.width = 230*3;
										finalCanvas.height = 345*3;
										let ctx = finalCanvas.getContext("2d");
										let drawStuff = function(image,x,y,width,height){
											let img = new Image();
											img.onload = function(){
												ctx.drawImage(img,x,y,width,height)
											}
											img.src = image
										};
										for(var i=0;i<3;i++){
											for(var j=0;j<3;j++){
												drawStuff(linkList[i*3+j],j*230,i*345,230,345)
											}
										}
									}
								}
							}
						})
					};
					let waiter = function(){
						updateCards();
						if(keepUpdating){
							setTimeout(waiter,500)
						}
					};waiter();
				}
			}
			if(useScripts.newChapters && URLstuff[2] === "mangalist"){
				newChaptersInsertion(extraFilters)
			}
			if(URLstuff[2] === "mangalist"){
				let alMangaButton = create("button",["button","hohButton"],"Export JSON",extraFilters);
				alMangaButton.onclick = function(){
					generalAPIcall(
						`
query($name: String!){
	MediaListCollection(userName: $name, type: MANGA){
		lists{
			name
			isCustomList
			isSplitCompletedList
			entries{
				... mediaListEntry
			}
		}
	}
	User(name: $name){
		name
		id
		mediaListOptions{
			scoreFormat
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	progressVolumes
	repeat
	notes
	priority
	hiddenFromStatusLists
	customLists
	advancedScores
	startedAt{
		year
		month
		day
	}
	completedAt{
		year
		month
		day
	}
	updatedAt
	createdAt
	media{
		idMal
		title{romaji native english}
	}
	score
}
				`,
						{name: decodeURIComponent(URLstuff[1])},
						function(data){
							if(!data){
								alert("Export failed");
								return
							}
							data.data.version = "1.01";
							data.data.scriptInfo = scriptInfo;
							data.data.type = "MANGA";
							data.data.url = document.URL;
							data.data.timeStamp = NOW();
							saveAs(data.data,"AnilistMangaList_" + decodeURIComponent(URLstuff[1]) + ".json");
						}
					)
				}
			}
			if(URLstuff[2] === "animelist"){
				let alAnimeButton = create("button",["button","hohButton"],"Export JSON",extraFilters);
				alAnimeButton.onclick = function(){
					generalAPIcall(
						`
query($name: String!){
	MediaListCollection(userName: $name, type: ANIME){
		lists{
			name
			isCustomList
			isSplitCompletedList
			entries{
				... mediaListEntry
			}
		}
	}
	User(name: $name){
		name
		id
		mediaListOptions{
			scoreFormat
		}
	}
}

fragment mediaListEntry on MediaList{
	mediaId
	status
	progress
	repeat
	notes
	priority
	hiddenFromStatusLists
	customLists
	advancedScores
	startedAt{
		year
		month
		day
	}
	completedAt{
		year
		month
		day
	}
	updatedAt
	createdAt
	media{
		idMal
		title{romaji native english}
	}
	score
}
				`,
						{name: decodeURIComponent(URLstuff[1])},
						function(data){
							if(!data){
								alert("Export failed");
								return
							}
							data.data.version = "1.01";
							data.data.scriptInfo = scriptInfo;
							data.data.type = "ANIME";
							data.data.url = document.URL;
							data.data.timeStamp = NOW();
							saveAs(data.data,"AnilistAnimeList_" + decodeURIComponent(URLstuff[1]) + ".json");
						}
					)
				}
			}
			if(useScripts.tagIndex && (!useScripts.mobileFriendly)){
				let tagIndex = create("div","tagIndex",false,extraFilters);
				let collectNotes = function(data){
					let customTags = new Map();	
					let listData = returnList(data,true);
					let blurbs = [];
					listData.forEach(function(entry){
						if(entry.notes){
							(
								entry.notes.match(/(#(\\\s|\S)+)/g) || []
							).filter(
								tagMatch => !tagMatch.match(/^#039/)
							).map(
								tagMatch => evalBackslash(tagMatch)
							).forEach(tagMatch => {
								if(!customTags.has(tagMatch)){
									customTags.set(tagMatch,{name: tagMatch,count: 0})
								}
								customTags.get(tagMatch).count++
							})
							let noteContent = parseListJSON(entry.notes);
							if(noteContent && noteContent.lists){
								blurbs.push(noteContent.lists)
							}
						}
					});
					let applier = function(){
						const URLstuff2 = location.pathname.match(/^\/user\/(.+)\/(animelist|mangalist)/);
						if(!URLstuff2 || URLstuff[0] !== URLstuff2[0]){
							return
						}
						Array.from(document.querySelectorAll(".hohDescriptions")).forEach(matching => matching.remove());
						blurbs.forEach(blurb => {
							blurb.forEach(list => {
								if(list.name && list.info){
									let titles = document.querySelectorAll("h3.section-name");
									for(var i=0;i<titles.length;i++){
										if(titles[i].innerText === list.name){
											let descriptionNode = create("p","hohDescriptions",list.info);
											titles[i].parentNode.insertBefore(descriptionNode,titles[i].nextSibling);
											break
										}
									}
								}
							})
						});
						setTimeout(applier,1000)
					};
					applier();
					if(customTags.has("##STRICT")){
						customTags.delete("##STRICT")
					}
					customTags = [...customTags].map(pair => pair[1]);
					customTags.sort((b,a) => a.count - b.count || b.name.localeCompare(a.name));
					let drawTags = function(){
						removeChildren(tagIndex);
						if(customTags.length > 1){
							let sortName = create("span",false,"▲",tagIndex,"cursor:pointer");
							sortName.title = "sort by name";
							let sortNumber = create("span",false,"▼",tagIndex,"cursor:pointer;float:right");
							sortNumber.title = "sort by count";
							sortName.onclick = function(){
								customTags.sort((b,a) => b.name.localeCompare(a.name));
								drawTags()
							}
							sortNumber.onclick = function(){
								customTags.sort((b,a) => a.count - b.count || b.name.localeCompare(a.name));
								drawTags()
							}
						}
						customTags.forEach(tag => {
							if(tag.name.match(/,(malSync|last)::/)){
								return
							}
							let tagElement = create("p",false,tag.name,tagIndex);
							create("span","count",tag.count,tagElement);
							tagElement.onclick = function(){
								let filterBox = document.querySelector(".entry-filter input");
								filterBox.value = tag.name;
								filterBox.dispatchEvent(new Event("input"));
								if(filterBox.scrollIntoView){
									filterBox.scrollIntoView({"behavior": "smooth","block": "start"})
								}
								else{
									document.body.scrollTop = document.documentElement.scrollTop = 0
								}
							}
						})
					};
					if(customTags.some(tag => !tag.name.match(/,(malSync|last)::/))){
						drawTags()
					}
				};
				let variables = {
					name: decodeURIComponent(URLstuff[1]),
					listType: "ANIME"
				};
				if(URLstuff[2] === "mangalist"){
					variables.listType = "MANGA"
				}
				if(variables.name === whoAmI && reliablePersistentStorage){
					cache.getList(variables.listType,function(data){
						collectNotes(data)
					})
				}
				else{
					generalAPIcall(
`query($name: String!, $listType: MediaType){
	MediaListCollection(userName: $name, type: $listType){
		lists{
			entries{
				mediaId
				notes
			}
		}
	}
}`,
						variables,
						collectNotes,
						"hohCustomTagIndex" + variables.listType + variables.name,
						60*1000
					)
				}
			}
			filters.appendChild(extraFilters);
			let filterBox = document.querySelector(".entry-filter input");
			let searchParams = new URLSearchParams(location.search);
			let paramSearch = searchParams.get("search");
			if(paramSearch){
				filterBox.value = decodeURIComponent(paramSearch);
				let event = new Event("input");
				filterBox.dispatchEvent(event)
			}
			let filterChange = function(){
				let newURL = location.protocol + "//" + location.host + location.pathname 
				if(filterBox.value === ""){
					searchParams.delete("search")
				}
				else{
					searchParams.set("search",encodeURIComponent(filterBox.value));
					newURL += "?" + searchParams.toString()
				}
				current = newURL;
				history.replaceState({},"",newURL);
				if(document.querySelector(".el-icon-circle-close")){
					document.querySelector(".el-icon-circle-close").onclick = filterChange
				}
			}
			filterBox.oninput = filterChange;
			filterChange();
			let mutationConfig = {
				attributes: false,
				childList: true,
				subtree: true
			};
			if(
				decodeURIComponent(URLstuff[1]) === whoAmI
				&& useScripts.accessToken
				&& useScripts.plussMinus
				&& (
					document.querySelector(".medialist").classList.contains("POINT_100")
					|| document.querySelector(".medialist").classList.contains("POINT_10")
					|| document.querySelector(".medialist").classList.contains("POINT_10_DECIMAL")
					|| document.querySelector(".medialist").classList.contains("POINT_5")
				)
			){
				let minScore = 1;
				let maxScore = 100;
				let stepSize = 1;
				if(document.querySelector(".medialist").classList.contains("POINT_10") || document.querySelector(".medialist").classList.contains("POINT_10_DECIMAL")){
					maxScore = 10
				}
				if(document.querySelector(".medialist").classList.contains("POINT_10_DECIMAL")){
					minScore = 0.1;
					stepSize = 0.1
				}
				if(document.querySelector(".medialist").classList.contains("POINT_5")){
					maxScore = 5;
				}
				let scoreChanger = function(){
					observer.disconnect();
					lists.querySelectorAll(".list-entries .row .score").forEach(function(entry){
						if(!entry.childElementCount){
							let updateScore = function(isUp){
								let score = parseFloat(entry.attributes.score.value);
								if(isUp){
									score += stepSize
								}
								else{
									score -= stepSize
								}
								if(score >= minScore && score <= maxScore){
									let id = parseInt(entry.previousElementSibling.children[0].href.match(/(anime|manga)\/(\d+)/)[2]);
									lists.querySelectorAll("[href=\"" + entry.previousElementSibling.children[0].attributes.href.value + "\"]").forEach(function(rItem){
										rItem.parentNode.nextElementSibling.attributes.score.value = score.roundPlaces(1);
										rItem.parentNode.nextElementSibling.childNodes[1].textContent = " " + score.roundPlaces(1) + " "
									});
									authAPIcall(
										`mutation($id:Int,$score:Float){
											SaveMediaListEntry(mediaId:$id,score:$score){
												score
											}
										}`,
										{id:id,score:score},function(data){
											if(!data){
												if(isUp){
													score -= stepSize
												}
												else{
													score += stepSize
												}
												lists.querySelectorAll("[href=\"" + entry.previousElementSibling.children[0].attributes.href.value + "\"]").forEach(function(rItem){
													rItem.parentNode.nextElementSibling.attributes.score.value = score.roundPlaces(1);
													rItem.parentNode.nextElementSibling.childNodes[1].textContent = " " + score.roundPlaces(1) + " "
												})
											}
										}
									);
								}
							};
							let changeMinus = create("span","hohChangeScore","-");
							entry.insertBefore(changeMinus,entry.firstChild);
							let changePluss = create("span","hohChangeScore","+",entry);
							if(useScripts.CSSdecimalPoint){
								entry.classList.add("hohNeedsPositioning");
								changePluss.style.position = "absolute";
								changePluss.style.right = "calc(50% - 2em)";
							}
							changeMinus.onclick = function(){updateScore(false)};
							changePluss.onclick = function(){updateScore(true)}
						}
					});
					observer.observe(lists,mutationConfig)
				}
				let lists = document.querySelector(".lists");
				let observer = new MutationObserver(scoreChanger);
				observer.observe(lists,mutationConfig);
				scoreChanger()
			}
		};waiter()
	}
})
//end modules/mediaList.js
//begin modules/middleClickLinkFixer.js
function linkFixer(){
	if(location.pathname !== "/home"){
		return
	}
	let recentReviews = document.querySelector(".recent-reviews h2.section-header");
	let recentThreads = document.querySelector(".recent-threads h2.section-header");
	if(recentReviews && recentThreads){
		recentReviews.innerText = "";
		create("a",false,translate("$home_reviewLink"),recentReviews)
			.href = "/reviews";
		recentThreads.innerText = "";
		create("a",false,translate("$home_forumLink"),recentThreads)
			.href = "/forum/overview";
		let sectionHeaders = document.querySelectorAll(".section-header");
		Array.from(sectionHeaders).forEach(header => {
			if(header.innerText.match("Trending")){
				header.innerText = "";
				create("a",false,translate("$home_trendingAnime"),header)
					.href = "https://anilist.co/search/anime/trending";
				create("a","hover-manga",translate("$home_trendingManga"),header)
					.href = "https://anilist.co/search/manga/trending"
			}
			else if(header.innerText.match("Newly Added Anime")){
				header.innerText = "";
				create("a",false,translate("$home_newAnime"),header)
					.href = "https://anilist.co/search/anime/new"
			}
			else if(header.innerText.match("Newly Added Manga")){
				header.innerText = "";
				create("a","hover-manga",translate("$home_newManga"),header)
					.href = "https://anilist.co/search/manga/new"
			}
		})
	}
	else{
		if(useScripts.additionalTranslation){
			setTimeout(linkFixer,1000)
		}
		else{
			setTimeout(linkFixer,2000)//invisible change, does not take priority
		}
	}
}
//end modules/middleClickLinkFixer.js
//begin modules/mobileAdjustments.js
exportModule({
	id: "mobileFriendly",
	description: "$mobileFriendly_description",
	isDefault: false,
	importance: 7,
	categories: ["Navigation","Script"],
	visible: true
})

if(useScripts.mobileFriendly){
	let addReviewLink = function(){
		let footerPlace = document.querySelector(".footer .links section:last-child");
		if(footerPlace){
			let revLink = create("a",false,"Reviews",footerPlace,"display:block;padding:6px;");
			revLink.href = "/reviews/";
		}
		else{
			setTimeout(addReviewLink,500)
		}
	};addReviewLink();
}
//end modules/mobileAdjustments.js
//begin modules/mobileTags.js
exportModule({
	id: "CSSmobileTags",
	description: "$setting_CSSmobileTags",
	isDefault: true,
	importance: 0,
	categories: ["Media"],
	visible: true,
	css: `
@media(max-width: 760px){
	.media .sidebar .tags{
		display: inline;
	}
	.media .sidebar .tags .tag{
		display: inline-block;
		margin-right: 2px;
	}
	.media .sidebar .tags .tag .rank{
		display: inline;
	}
	.media .overview .tags .tag .vote-dropdown .el-dropdown-link{
		opacity: 1;
		display: inline!important;
	}
	.media .overview .tags .add-icon{
		opacity: 1;
		display: inline!important;
	}
	.media-page-unscoped .review.button{
		display: inline-block;
		width: 48%;
	}
	.media-page-unscoped .sidebar + .overview{
		margin-top: 20px;
	}
}`
})
//end modules/mobileTags.js
//begin modules/moreImports.js
function moreImports(){
	if(document.URL !== "https://anilist.co/settings/import"){
		return
	}
	let target = document.querySelector(".content .import");
	if(!target){
		setTimeout(moreImports,200);
		return;
	}
	create("hr","hohSeparator",false,target,"margin-bottom:40px;");
	let apAnime = create("div",["section","hohImport"],false,target);
	create("h2",false,"Anime-Planet: Import Anime List",apAnime);
	const mapFormatAnime = new Map([["All", ""], ["TV Show", "TV"], ["Movie", "MOVIE"], ["TV Short", "TV_SHORT"],
									["Special", "SPECIAL"], ["OVA", "OVA"], ["ONA", "ONA"], ["MUSIC", "MUSIC"]])
	let selectFormatAnime = create("select", "meter", false, apAnime)
	mapFormatAnime.forEach((_, key) => {
		let option = create("option", false, key, selectFormatAnime)
		option.value = key
	})

	let apAnimeCheckboxContainer = create("label","el-checkbox",false,apAnime);
	let apAnimeOverwrite = createCheckbox(apAnimeCheckboxContainer);
	create("span","el-checkbox__label","Overwrite anime already on my list",apAnimeCheckboxContainer);
	let apAnimeDropzone = create("div","dropbox",false,apAnime);
	let apAnimeInput = create("input","input-file",false,apAnimeDropzone);
	let apAnimeDropText = create("p",false,"Drop list JSON file here or click to upload",apAnimeDropzone);
	apAnimeInput.type = "file";
	apAnimeInput.name = "json";
	apAnimeInput.accept = "application/json";
	let apManga = create("div",["section","hohImport"],false,target);
	create("h2",false,"Anime-Planet: Import Manga List",apManga);

	const mapFormatManga = new Map([["All", ""], ["Manga", "MANGA"], ["Light Novel", "NOVEL"], ["One Shot", "ONE_SHOT"]])
	let selectFormatManga = create("select", "meter", false, apManga)
	mapFormatManga.forEach((_, key) => {
		let option = create("option", false, key, selectFormatManga)
		option.value = key
	})

	let apMangaCheckboxContainer = create("label","el-checkbox",false,apManga);
	let apMangaOverwrite = createCheckbox(apMangaCheckboxContainer);
	create("span","el-checkbox__label","Overwrite manga already on my list",apMangaCheckboxContainer);
	let apMangaDropzone = create("div","dropbox",false,apManga);
	let apMangaInput = create("input","input-file",false,apMangaDropzone);
	let apMangaDropText = create("p",false,"Drop list JSON file here or click to upload",apMangaDropzone);
	apMangaInput.type = "file";
	apMangaInput.name = "json";
	apMangaInput.accept = "application/json";
	let resultsArea = create("div","importResults",false,target);
	let resultsErrors = create("div",false,false,resultsArea,"color:red;padding:5px;");
	let resultsWarnings = create("div",false,false,resultsArea,"color:orange;padding:5px;");
	let resultsStatus = create("div",false,false,resultsArea,"padding:5px;");
	let missingList = create("div",false,false,resultsArea,"padding:5px;");
	let exportErrors = create("button",["hohButton","button", "danger"],"Export all errors and unchecked",resultsArea,"display: none; margin: 5px 10px")
	let uncheckedTitles = [];
	exportErrors.onclick = function() {
		var link = create("a")
		let dataTitles = ""
		uncheckedTitles.forEach(title => {
			dataTitles += `Unchecked title : ${title}\n`			
		})
		link.href = "data:text/plain;charset=utf-8," + encodeURIComponent(dataTitles + "\n" + missingList.innerText.replace(/[\n\r]+/g, "\n"))
		link.download =  "errors_ap_import.txt"
		link.click()
	}
	let pushResults = create("button",["hohButton","button"],"Import all selected",resultsArea,"display: none; margin: 5px 10px")
	let resultsTable = create("div",false,false,resultsArea);

	let selectedValues = {}

	let apImport = function(type,file){
		let reader = new FileReader();
		reader.readAsText(file,"UTF-8");
		reader.onload = function(evt){
			let data;
			try{
				data = JSON.parse(evt.target.result)
			}
			catch(e){
				resultsErrors.innerText = "error parsing JSON";
			}
			if(data.export.type !== type){
				resultsErrors.innerText = "error wrong list";
				return;
			}
			if(data.user.name.toLowerCase() !== whoAmI.toLowerCase()){
				resultsWarnings.innerText = "List for \"" + data.user.name + "\" loaded, but currently signed in as \"" + whoAmI + "\". Are you sure this is right?"
			}
			if((new Date()) - (new Date(data.export.date)) > 1000*86400*30){
				resultsWarnings.innerText += "\nThis list is " + Math.round(((new Date()) - (new Date(data.export.date)))/(1000*86400)) + " days old. Did you upload the right one?"
			}
			resultsStatus.innerText = "Trying to find matching media...";
			let shows = [];
			let drawShows = function(){
				removeChildren(resultsTable);
				shows = shows.filter(a => {
					if(a.titles.length){
						return true
					}
					else{
						create("p", false, "No matches found for " + a.apData.name, missingList, "color: rgba(var(--color-peach), .8)")
						exportErrors.style.display = "inline"
						return false
					}
				});
				shows.sort(
					(b,a) => a.titles[0].levDistance - b.titles[0].levDistance
				);
				shows.forEach(show => {
					let row = create("div","hohImportRow",false,resultsTable);
					if(show.isAnthology){
						create("div","hohImportEntry",show.apData.map(a => a.name).join(", "),row)
					}
					else{
						create("div","hohImportEntry",show.apData.name,row)
					}
					create("span","hohImportArrow","→",row);
					let aniEntry = create("div", "hohImportSelect", false, row);

					let selectEntry = create("select", "#typeSelect", false, aniEntry, "width: 100%; white-space: nowrap; text-overflow: ellipsis")

					let images = {}
					show.titles.forEach(title => {
						let optionEntry = create("option", false, title.title + " (" + title.format + ")", selectEntry)
						optionEntry.value = title.id
						images[title.id] = title.cover
					})

					selectedValues[show.apData.name] = parseInt(selectEntry.value)
					let aniLink = create("a", ["hohButton","button","link","newTab"], "View", row, "margin: 0 10px")
					aniLink.href = "/" + type + "/" + parseInt(selectEntry.value)

					const image = create("img", false, false, row, "margin-right: 10px")
					image.src = images[selectEntry.value]

					selectEntry.onchange = () => { 
						selectedValues[show.apData.name] = parseInt(selectEntry.value)
						aniLink.href = "/" + type + "/" + parseInt(selectEntry.value)
						image.src = images[selectEntry.value]
					}

					let button = createCheckbox(row);
					row.style.backgroundColor = "hsl(" + (120 - Math.min(show.titles[0].levDistance,12)*10) + ",30%,50%)";
					if(show.titles[0].levDistance > 8){
						button.checked = false;
						show.toImport = false;
						uncheckedTitles = uncheckedTitles.filter(e => e !== show.apData.name)
						uncheckedTitles.push(show.apData.name)
					}
					else{
						button.checked = true;
						show.toImport = true;
					}
					button.oninput = function(){
						show.toImport = button.checked
						if(!show.toImport) uncheckedTitles.push(show.apData.name)
						else uncheckedTitles = uncheckedTitles.filter(e => e !== show.apData.name)
					}
				})
			};
			const apAnthologies = {
	"The Dragon Dentist": 20947,
	"Hill Climb Girl": 20947,
	"20min Walk From Nishi-Ogikubo Station": 20947,
	"Collection of Key Animation Films": 20947,
	"(Making of) Evangelion: Another Impact": 20947,
	"Sex and Violence with Mach Speed": 20947,
	"Memoirs of Amorous Gentlemen": 20947,
	"Denkou Choujin Gridman: boys invent great hero": 20947,
	"Evangelion: Another Impact": 20947,
	"Bureau of Proto Society": 20947,
	"Cassette Girl": 20947,
	"Bubu & Bubulina": 20947,
	"I can Friday by day!": 20947,
	"Three Fallen Witnesses": 20947,
	"Robot on the Road": 20947,
	"Comedy Skit 1989": 20947,
	"Power Plant No.33": 20947,
	"Me! Me! Me! Chronic": 20947,
	"Endless Night": 20947,
	"Neon Genesis IMPACTS": 20947,
	"Obake-chan": 20947,
	"Hammerhead": 20947,
	"Girl": 20947,
	"Yamadeloid": 20947,
	"Me! Me! Me!": 20947,
	"Ibuseki Yoruni": 20947,
	"Rapid Rouge": 20947,
	"Tomorrow from there": 20947,
	"The Diary of Ochibi": 20947,
	"until You come to me.": 20947,
	"Tsukikage no Tokio": 20947,
	"Carnage": 20947,
	"Iconic Field": 20947,
	"The Ultraman (2015)": 20947,
	"Kanoun": 20947,
	"Ragnarok": 20947,
	"Death Note Rewrite 1: Visions of a God": 2994,
	"Death Note Rewrite 2: L's Successors": 2994
}
;
			const apMappings_anime = {
	"Rebuild of Evangelion: Final": 3786,
	"KonoSuba – God’s blessing on this wonderful world!! Movie: Legend of Crimson": 102976,
	"Puella Magi Madoka Magica: Magica Quartet x Nisioisin": 20891,
	"Kanye West: Good Morning": 8626,
	"Patlabor 2: The Movie": 1096,
	"She and Her Cat": 1004,
	"Star Blazers: Space Battleship Yamato 2199": 12029,
	"Digimon Season 3: Tamers": 874,
	"The Anthem of the Heart": 20968,
	"Digimon Movie 1: Digimon Adventure": 2961,
	"Love, Chunibyo & Other Delusions!: Sparkling... Slapstick Noel": 16934,
	"The Labyrinth of Grisaia Special": 21312,
	"Candy Boy EX01": 5116,
	"Candy Boy EX02": 6479,
	"Attack on Titan 3rd Season": 99147,
	"Attack on Titan 2nd Season": 20958,
	"Nichijou - My Ordinary Life: Episode 0": 8857,
	"March Comes in like a Lion 2nd Season": 98478,
	"KonoSuba – God’s blessing on this wonderful world!! 2 OVA": 97996,
	"KonoSuba – God’s blessing on this wonderful world!! OVA": 21574,
	"Laid-Back Camp Specials": 101206,
	"Spice and Wolf II OVA": 6007,
	"Mob Psycho 100 Specials": 102449
}
;
			const apMappings_manga = {
	"GATE: Where the JSDF Fought": 71733,
	"Emanon: Memories of Emamon": 47465
}
;
			let bigQuery = [];
			let myFastMappings = [];
			data.entries.forEach(function(entry,index){
				if(entry.status === "won't watch"){
					return
				}
				if(apAnthologies[entry.name]){
					let already = myFastMappings.findIndex(function(mapping){
						return mapping.id === apAnthologies[entry.name]
					});
					if(already !== -1){
						myFastMappings[already].entries.push(entry)
					}
					else{
						myFastMappings.push({
							entries: [entry],
							isAnthology: true,
							id: apAnthologies[entry.name]
						})
					}
					return;
				}
				if(type === "manga"){
					if(apMappings_manga[entry.name]){
						myFastMappings.push({
							entries: [entry],
							id: apMappings_manga[entry.name]
						})
						return;
					}
				}
				else{
					if(apMappings_anime[entry.name]){
						myFastMappings.push({
							entries: [entry],
							id: apMappings_anime[entry.name]
						})
						return;
					}
				}

				const chosenFormat = type === "manga" ? mapFormatManga.get(selectFormatManga.value) : mapFormatAnime.get(selectFormatAnime.value)
				const formatInQuery = chosenFormat === "" ? "" : `format:${chosenFormat}`
				bigQuery.push({
					query: `query($search:String){Page(perPage:5){media(type:${type.toUpperCase()},search:$search,${formatInQuery}){title{romaji english native} id synonyms format coverImage{medium}}}}`,
					variables: {search: entry.name},
					callback: function(dat){
						let show = {
							apData: entry,
							aniData: dat.data.Page.media,
							titles: []
						}
						show.aniData.forEach(function(hit){
							show.titles.push({
								title: hit.title.romaji,
								id: hit.id,
								levDistance: Math.min(
									levDist(show.apData.name,hit.title.romaji),
									levDist(show.apData.name,hit.title.romaji.toUpperCase()),
									levDist(show.apData.name,hit.title.romaji.toLowerCase())
								),
								format: hit.format,
								cover: hit.coverImage.medium
							});
							if(hit.title.english){
								show.titles.push({
									title: hit.title.english,
									id: hit.id,
									levDistance: Math.min(
										levDist(show.apData.name,hit.title.english),
										levDist(show.apData.name,hit.title.english.toUpperCase()),
										levDist(show.apData.name,hit.title.english.toLowerCase())
									),
									format: hit.format,
									cover: hit.coverImage.medium
								});
							}
							if(hit.title.native){
								show.titles.push({
									title: hit.title.native,
									id: hit.id,
									levDistance: levDist(show.apData.name,hit.title.native),
									format: hit.format,
									cover: hit.coverImage.medium
								})
							}
							hit.synonyms.forEach(
								synonym => show.titles.push({
									title: synonym,
									id: hit.id,
									levDistance: levDist(show.apData.name,synonym),
									format: hit.format,
									cover: hit.coverImage.medium
								})
							)
						});

						const groupBy = (arr) => arr.reduce((prev, cur) => ((prev[cur.cover] = prev[cur.cover] || []).push(cur), prev), {})
						const min = (arr) => Math.min(...arr.map(res => res.levDistance))
						const findTitle = (cover, levDistance) => show.titles.find(element => element.cover === cover && element.levDistance === levDistance)

						show.titles = Object.entries(groupBy(show.titles)).map(([key, val]) => {
							const levDistance = min(val)
							return { id: findTitle(key, levDistance).id, levDistance: levDistance, title: findTitle(key, levDistance).title, format: findTitle(key, levDistance).format, cover: key }
						})
						
						const getMapIndex = (map, format) => {
							let indexMap;
							[...map].some(([_, val], index) => {
								if(val === format) { 
									indexMap = index
									return true
								}
								return false
							})
							return indexMap
						}

						show.titles.sort(
							(a,b) => {
								const distance = a.levDistance - b.levDistance
								if(distance === 0) {
									const mapFormat = type === "manga" ? mapFormatManga : mapFormatAnime
									let indexA = getMapIndex(mapFormat, a.format)
									let indexB = getMapIndex(mapFormat, b.format)
									return indexA - indexB
								}
								return distance
							});
					
						shows.push(show);
						drawShows();
					}
				});
				if(index % 40 === 0){
					queryPacker(bigQuery);
					bigQuery = [];
				}
			});
			let apStatusMap = {
				"want to read": "PLANNING",
				"stalled": "PAUSED",
				"read": "COMPLETED",
				"reading": "CURRENT",
				"watched": "COMPLETED",
				"want to watch": "PLANNING",
				"dropped": "DROPPED",
				"watching": "CURRENT"
			}
			queryPacker(bigQuery,function(){
				setTimeout(function(){
					resultsStatus.innerText = "Please review the media matches. The worst matches are on top.";
					pushResults.style.display = "inline";
					pushResults.onclick = function(){
						pushResults.style.display = "none";
						if(!useScripts.accessToken){
							alert("Not signed in with the script. Can't do any changes to your list\n Go to settings > apps to sign in");
							return;
						}
						authAPIcall(
						`query($name: String,$listType: MediaType){
							Viewer{name mediaListOptions{scoreFormat}}
							MediaListCollection(userName: $name, type: $listType){
								lists{
									entries{
										mediaId
									}
								}
							}
						}`,
						{
							listType: type.toUpperCase(),
							name: whoAmI
						},
						function(data){
							if(data.data.Viewer.name !== whoAmI){
								alert("Signed in as\"" + whoAmI + "\" to Anilist, but as \"" + data.data.Viewer.name + "\" to the script.\n Go to settings > apps, revoke " + script_type + "'s permissions, and sign in with the scirpt again to fix this.");
								return;
							}
							let list = returnList(data,true).map(a => a.mediaId);
							shows = shows.filter(show => {
								if(!show.toImport){
									return false;
								}
								if(type === "anime"){
									if(!apAnimeOverwrite.checked && list.includes(selectedValues[show.apData.name])){
										return false;
									}
								}
								else{
									if(!apMangaOverwrite.checked && list.includes(selectedValues[show.apData.name])){
										return false;
									}
								}
								return true;
							});
							if(!shows.length){
								resultsStatus.innerText = "No entries imported. All the entries already exist in your AniList account."
								return;
							}
							let importSuccess = 0
							let mutater = function(show,index){
								if(index + 1 < shows.length){
									setTimeout(function(){
										mutater(shows[index + 1],index + 1);
									},1000);
								}
								let status = false;
								if(show.isAnthology){
									status = "CURRENT";
								}
								else{
									status = apStatusMap[show.apData.status];
								}
								if(!status){
									console.log("Unknown status \"" + show.apData.status + "\" for " + show.apData.name)
									let unknownStatus = create("p",false, "Unknown status \"" + show.apData.status + "\" for " + show.apData.name, false, "color: rgba(var(--color-orange), .8)")
									missingList.insertBefore(unknownStatus, missingList.firstChild)
									exportErrors.style.display = "inline"
									resultsStatus.innerText = index + 1 === shows.length ? `Import completed !\n${importSuccess} of ${shows.length} entries successfully imported.`
										: `Importing : ${index + 1} of ${shows.length} entries. Closing this tab will stop the import.\n${importSuccess} of ${shows.length} entries successfully imported.`
									return;
								}
								let score = 0;
								if(!show.isAnthology){
									score = show.apData.rating*2;
									if(data.data.Viewer.mediaListOptions.scoreFormat === "POINT_100"){
										score = show.apData.rating*20;
									}
									else if(data.data.Viewer.mediaListOptions.scoreFormat === "POINT_5"){
										score = Math.floor(show.apData.rating);
										if(show.apData.rating === 0.5){
											score = 1
										}
									}
									else if(data.data.Viewer.mediaListOptions.scoreFormat === "POINT_3"){
										if(show.apData.rating === 0){
											score = 0
										}
										else if(show.apData.rating < 2.5){
											score = 1
										}
										else if(show.apData.rating < 4){
											score = 2
										}
										else{
											score = 3
										}
									}
								}
								let progress = 0;
								let progressVolumes = 0;
								let repeat = 0;
								if(show.isAnthology){
									progress = show.apData.length
								}
								else{
									repeat = Math.max(0,show.apData.times - 1) || 0;
									if(status === "DROPPED" || status === "PAUSED" || status === "CURRENT"){
										if(type === "anime"){
											progress = show.apData.eps
										}
										else{
											progress = show.apData.ch
										}
									}
								}
								if(type === "manga"){
									progressVolumes = show.apData.vol
								}
								if(progress || progressVolumes){
									authAPIcall(
										`mutation(
											$mediaId: Int,
											$status: MediaListStatus,
											$score: Float,
											$progress: Int,
											$progressVolumes: Int,
											$repeat: Int
										){
											SaveMediaListEntry(
												mediaId: $mediaId,
												status: $status,
												score: $score,
												progress: $progress,
												progressVolumes: $progressVolumes,
												repeat: $repeat
											){
												id
											}
										}`,
										{
											mediaId: selectedValues[show.apData.name],
											status: status,
											score: score,
											progress: progress,
											progressVolumes: progressVolumes,
											repeat: repeat
										},
										data => {
											if(data.errors){
												const title = show.titles.find(element => element.id === selectedValues[show.apData.name]).title
												resultsErrors.innerText += JSON.stringify(data.errors.map(e => e.validation)) + " " + title + "\n"
											}
										}
									)
								}
								else{
									authAPIcall(
										`mutation(
											$mediaId: Int,
											$status: MediaListStatus,
											$score: Float,
											$repeat: Int
										){
											SaveMediaListEntry(
												mediaId: $mediaId,
												status: $status,
												score: $score,
												repeat: $repeat
											){
												id
											}
										}`,
										{
											mediaId: selectedValues[show.apData.name],
											status: status,
											score: score,
											repeat: repeat
										},
										data => {
											if(data.errors){
												const title = show.titles.find(element => element.id === selectedValues[show.apData.name]).title
												resultsErrors.innerText += JSON.stringify(data.errors.map(e => e.validation)) + " " + title +  "\n"
											}
										}
									)
								}
								importSuccess += 1
								resultsStatus.innerText = index + 1 === shows.length ? `Import completed !\n${importSuccess} of ${shows.length} entries successfully imported.`
									: `Importing : ${index + 1} of ${shows.length} entries. Closing this tab will stop the import.\n${importSuccess} of ${shows.length} entries successfully imported.`
							};
							mutater(shows[0],0);
						})
					};
				},2000);
			});
			bigQuery = [];
			myFastMappings.forEach(function(entry){
				bigQuery.push({
					query: `query($id:Int){Media(type:${type.toUpperCase()},id:$id){title{romaji english native} id format coverImage{medium}}}`,
					variables: {id: entry.id},
					callback: function(dat){
						const media =  dat.data.Media
						const titles = [{title: media.title.romaji,id: entry.id,levDistance: 0,format: media.format,cover: media.coverImage.medium}]
						if(entry.isAnthology){
							let show = {
								apData: entry.entries,
								directMapping: true,
								isAnthology: true,
								aniData: media,
								titles: titles
							}
							shows.push(show);
							drawShows();
						}
						else{
							let show = {
								apData: entry.entries[0],
								directMapping: true,
								aniData: media,
								titles: titles
							}
							shows.push(show);
							drawShows();
						}
					}
				})
			});
			queryPacker(bigQuery);
		}
		reader.onerror = function(evt){
			resultsErrors.innerText = "error reading file"
		}
	}
	apAnimeInput.onchange = function(){
		apImport("anime",apAnimeInput.files[0])
	}
	apMangaInput.onchange = function(){
		apImport("manga",apMangaInput.files[0])
	}
	create("hr","hohSeparator",false,target,"margin-bottom: 40px;");
	let userNameContainer = create("div",false,false,target,"margin-bottom: 20px;");
	let userNameLabel = create("span",false,"User: ",userNameContainer);
	let userName = create("input","hohNativeInput",false,userNameContainer);
	userName.value = whoAmI;
	
	let alAnimeExp = create("div",["section","hohImport"],false,target);
	create("h2",false,"AniList: Export Anime List",alAnimeExp);
	let alAnimeButton = create("button",["button","hohButton"],"Export Anime",alAnimeExp);
	alAnimeButton.onclick = function(){
		generalAPIcall(
			`
	query($name: String!){
		MediaListCollection(userName: $name, type: ANIME){
			lists{
				name
				isCustomList
				isSplitCompletedList
				entries{
					... mediaListEntry
				}
			}
		}
		User(name: $name){
			name
			id
			mediaListOptions{
				scoreFormat
			}
		}
	}

	fragment mediaListEntry on MediaList{
		mediaId
		status
		progress
		repeat
		notes
		priority
		hiddenFromStatusLists
		customLists
		advancedScores
		startedAt{
			year
			month
			day
		}
		completedAt{
			year
			month
			day
		}
		updatedAt
		createdAt
		media{
			idMal
			title{romaji native english}
		}
		score
	}
	`,
			{name: userName.value},
			function(data){
				if(!data){
					alert("Export failed");
					return
				}
				data.data.version = "1.01";
				data.data.scriptInfo = scriptInfo;
				data.data.type = "ANIME";
				data.data.url = document.URL;
				data.data.timeStamp = NOW();
				saveAs(data.data,"AnilistAnimeList.json");
			}
		);
	}
	create("h2",false,"AniList: Export Manga List",alAnimeExp,"margin-top:20px;");
	let alMangaButton = create("button",["button","hohButton"],"Export Manga",alAnimeExp);
	alMangaButton.onclick = function(){
		generalAPIcall(
			`
	query($name: String!){
		MediaListCollection(userName: $name, type: MANGA){
			lists{
				name
				isCustomList
				isSplitCompletedList
				entries{
					... mediaListEntry
				}
			}
		}
		User(name: $name){
			name
			id
			mediaListOptions{
				scoreFormat
			}
		}
	}

	fragment mediaListEntry on MediaList{
		mediaId
		status
		progress
		progressVolumes
		repeat
		notes
		priority
		hiddenFromStatusLists
		customLists
		advancedScores
		startedAt{
			year
			month
			day
		}
		completedAt{
			year
			month
			day
		}
		updatedAt
		createdAt
		media{
			idMal
			title{romaji native english}
		}
		score
	}
	`,
			{name: userName.value},
			function(data){
				if(!data){
					alert("Export failed");
					return
				}
				data.data.version = "1.01";
				data.data.scriptInfo = scriptInfo;
				data.data.type = "MANGA";
				data.data.url = document.URL;
				data.data.timeStamp = NOW();
				saveAs(data.data,"AnilistMangaList.json");
			}
		);
	};
	let malExport = function(data,type){//maybe some time? But there's always malscraper, which does it better
		let xmlContent = "";
		saveAs(xmlContent,type.toLowerCase() + "list_0_-_0.xml",true);
	}
	let alAnime = create("div",["section","hohImport"],false,target);
	create("h2",false,"Anilist JSON: Import Anime List",alAnime);
	let alAnimeCheckboxContainer = create("label","el-checkbox",false,alAnime,"display:none;");
	let alAnimeOverwrite = createCheckbox(alAnimeCheckboxContainer);
	create("span","el-checkbox__label","Overwrite anime already on my list",alAnimeCheckboxContainer);
	let alAnimeDropzone = create("div","dropbox",false,alAnime);
	let alAnimeInput = create("input","input-file",false,alAnimeDropzone);
	let alAnimeDropText = create("p",false,"Drop list JSON file here or click to upload",alAnimeDropzone);
	alAnimeInput.type = "file";
	alAnimeInput.name = "json";
	alAnimeInput.accept = "application/json";
	let alManga = create("div",["section","hohImport"],false,target);
	create("h2",false,"Anilist JSON: Import Manga List",alManga);
	let alMangaCheckboxContainer = create("label","el-checkbox",false,alManga,"display:none;");
	let alMangaOverwrite = createCheckbox(alMangaCheckboxContainer);
	create("span","el-checkbox__label","Overwrite manga already on my list",alMangaCheckboxContainer);
	let alMangaDropzone = create("div","dropbox",false,alManga);
	let alMangaInput = create("input","input-file",false,alMangaDropzone);
	let alMangaDropText = create("p",false,"Drop list JSON file here or click to upload",alMangaDropzone);
	alMangaInput.type = "file";
	alMangaInput.name = "json";
	alMangaInput.accept = "application/json";
	let resultsAreaAL = create("div","importResults",false,target);
	let resultsErrorsAL = create("div",false,false,resultsAreaAL,"color:red;padding:5px;");
	let resultsWarningsAL = create("div",false,false,resultsAreaAL,"color:orange;padding:5px;");
	let resultsStatusAL = create("div",false,false,resultsAreaAL,"padding:5px;");
	let pushResultsAL = create("button",["hohButton","button"],"Import all",resultsAreaAL,"display:none;");
	let resultsTableAL = create("div",false,false,resultsAreaAL);
	let alImport = function(type,file){
		let reader = new FileReader();
		reader.readAsText(file,"UTF-8");
		reader.onload = function(evt){
			let data;
			try{
				data = JSON.parse(evt.target.result)
			}
			catch(e){
				resultsErrorsAL.innerText = "error parsing JSON";
			}
			if(hasOwn(data, "user")){
				resultsErrorsAL.innerText = "This is the Anilist JSON importer, but you uploaded a GDPR JSON file. You either uploaded the wrong file, or ment to use the importer further down the page.";
				return;
			}
			if(parseFloat(data.version) > 1){//was not part of 1.00
				if(data.type !== type.toUpperCase()){
					resultsErrorsAL.innerText = "error wrong list type";
					return;
				}
			}
//
			if(data.User.name.toLowerCase() !== whoAmI.toLowerCase()){
				resultsWarningsAL.innerText = "List for \"" + data.User.name + "\" loaded, but currently signed in as \"" + whoAmI + "\". Are you sure this is right?"
			}
			if((new Date()) - (new Date(data.timeStamp)) > 1000*86400*30){
				resultsWarningsAL.innerText += "\nThis list is " + Math.round(((new Date()) - (new Date(data.timeStamp)))/(1000*86400)) + " days old. Did you upload the right one?"
			}
			if(!useScripts.accessToken){
				resultsWarningsAL.innerText += "\nNot signed in to the script! Can't do any changes to your list then. Go to the bottom of the settings > apps page to sign in"
			}
			resultsStatusAL.innerText = "Calculating list differences...";
			if((type === "anime" && alAnimeOverwrite.checked) || (type === "manga" && alMangaOverwrite.checked)){
				alert("Haven't gotten around to support overwriting yet, sorry!")
			}
			else{
				authAPIcall(
					`query($name:String!,$listType:MediaType){
						Viewer{name mediaListOptions{scoreFormat}}
						MediaListCollection(userName:$name,type:$listType){
							lists{
								entries{mediaId}
							}
						}
					}`,
					{
						name: whoAmI,
						listType: type.toUpperCase()
					},
					data2 => {
						if(!data2){
							resultsErrorsAL.innerText = "Could not access the list of " + whoAmI + " do you have persmission to modify this list? (try signing in at settings > apps, scroll down to the bottom)";
							return
						}
						if(data2.data.Viewer.name !== whoAmI){
							alert("Signed in as\"" + whoAmI + "\" to Anilist, but as \"" + data2.data.Viewer.name + "\" to the script.\n Go to settings > apps, revoke " + script_type + "'s permissions, and sign in with the script again to fix this.");
							return
						}
						let existing = new Set(data2.data.MediaListCollection.lists.map(list => list.entries).flat().map(entry => entry.mediaId));
						let dataList = returnList({data: data},true);
						let already = dataList.filter(entry => existing.has(entry.mediaId)).length;
						let notAlready = dataList.filter(entry => !existing.has(entry.mediaId));
						resultsStatusAL.innerText += "\n" + already + " of " + dataList.length + " entries already on list. Not modifying";
						if(notAlready.length > 0){
							resultsStatusAL.innerText += "\nThe " + notAlready.length + " entries below will be added:";
							pushResultsAL.style.display = "inline";
							notAlready.forEach(show => {
								let row = create("p",false,false,resultsTableAL);
								create("a",false,show.media.title.romaji,row)
									.href = "https://anilist.co/" + type + "/" + show.mediaId
							});
							pushResultsAL.onclick = function(){
								pushResultsAL.style.display = "none";



							let mutater = function(show,index){
								if(index + 1 < notAlready.length){
									setTimeout(function(){
										mutater(notAlready[index + 1],index + 1);
									},1000);
								}
								try{
									authAPIcall(
										`mutation($startedAt: FuzzyDateInput,$completedAt: FuzzyDateInput,$notes: String){
											SaveMediaListEntry(
												mediaId: ${show.mediaId},
												status: ${show.status},
												score: ${show.score},
												progress: ${show.progress},
												progressVolumes: ${show.progressVolumes || 0},
												repeat: ${show.repeat},
												priority: ${show.priority},
												notes: $notes,
												startedAt: $startedAt,
												completedAt: $completedAt
											){id}
										}`,
										{
											startedAt: show.startedAt,
											completedAt: show.completedAt,
											notes: show.notes
										},
										data => {}
									)
								}
								catch(e){
									resultsWarningsAL.innerText += "\nAn error occured for mediaID " + show.mediaID;
								}
								resultsStatusAL.innerText = (index + 1) + " of " + notAlready.length + " entries imported. Closing this tab will stop the import.";
							};
							mutater(notAlready[0],0);



							}
						}
					}
				)
			}
		}
		reader.onerror = function(evt){
			resultsErrors.innerText = "error reading file"
		}
	}
	alAnimeInput.onchange = function(){
		pushResultsAL.style.display = "none";
		removeChildren(resultsTableAL);
		alImport("anime",alAnimeInput.files[0])
	}
	alMangaInput.onchange = function(){
		pushResultsAL.style.display = "none";
		removeChildren(resultsTableAL);
		alImport("manga",alMangaInput.files[0])
	}

	create("hr","hohSeparator",false,target,"margin-bottom:40px;");
	let gdpr_import = create("div",["section","hohImport"],false,target);
	create("h2",false,"GDPR data: Import lists",gdpr_import);
	let gdpr_importCheckboxContainer = create("label","el-checkbox",false,gdpr_import);
	let gdpr_importOverwrite = createCheckbox(gdpr_importCheckboxContainer);
	create("span","el-checkbox__label","Overwrite entries already on my list (only overwrite mode implemented so far)",gdpr_importCheckboxContainer);
	let gdpr_importDropzone = create("div","dropbox",false,gdpr_import);
	let gdpr_importInput = create("input","input-file",false,gdpr_importDropzone);
	let gdpr_importDropText = create("p",false,"Drop GDPR JSON file here or click to upload",gdpr_importDropzone);
	gdpr_importInput.type = "file";
	gdpr_importInput.name = "json";
	gdpr_importInput.accept = "application/json";

	let resultsAreaGDPR = create("div","importResults",false,target);
	let resultsErrorsGDPR = create("div",false,false,resultsAreaGDPR,"color:red;padding:5px;");
	let resultsWarningsGDPR = create("div",false,false,resultsAreaGDPR,"color:orange;padding:5px;");
	let resultsStatusGDPR = create("div",false,false,resultsAreaGDPR,"padding:5px;");
	let pushResultsGDPR = create("button",["hohButton","button"],"Import all",resultsAreaGDPR,"display:none;");
	let resultsTableGDPR = create("div",false,false,resultsAreaGDPR);

	gdpr_importInput.onchange = function(){
		let file = gdpr_importInput.files[0];
		let reader = new FileReader();
		reader.readAsText(file,"UTF-8");
		resultsStatusGDPR.innerText = "Loading GDPR JSON file...";
		reader.onload = function(evt){
			resultsStatusGDPR.innerText = "";
			let data;
			try{
				data = JSON.parse(evt.target.result)
			}
			catch(e){

				resultsErrorsGDPR.innerText = "error parsing JSON";
				return
			}
			if(hasOwn(data, "User")){
				resultsErrorsAL.innerText = "This is the GDPR JSON importer, but you uploaded a Anilist JSON file. You either uploaded the wrong file, or ment to use the importer further up the page.";
				return
			}
			if(data.user.display_name.toLowerCase() !== whoAmI.toLowerCase()){
				resultsWarningsGDPR.innerText = "List for \"" + data.user.display_name + "\" loaded, but currently signed in as \"" + whoAmI + "\". Are you sure this is right?"
			}
			if(!useScripts.accessToken){
				resultsWarningsGDPR.innerText += "\nNot signed in to the script! Can't do any changes to your lists then. Go to the bottom of the settings > apps page to sign in"
			}

			if(!gdpr_importOverwrite.checked){
				gdpr_importOverwrite.onclick = function(){
					alert("Non-overwrite mode already selected! Reload this page to start the import in another mode\n(Starting the import now WILL NOT overwrite existing list entries)")
				}
				resultsStatusGDPR.innerText = "Loading anime list...";
				authAPIcall(
					`query($name: String,$listType: MediaType){
						Viewer{name mediaListOptions{scoreFormat}}
						MediaListCollection(userName: $name, type: $listType){
							lists{
								entries{
									mediaId
								}
							}
						}
					}`,
					{
						listType: "ANIME",
						name: whoAmI
					},
					function(dataAnime){
						resultsStatusGDPR.innerText = "";
						if(!dataAnime){
							resultsErrorsGDPR.innerText = "An error occured while loading your anime list";
							return;
						}
						if(dataAnime.data.Viewer.name !== whoAmI){
							alert("Signed in as\"" + whoAmI + "\" to Anilist, but as \"" + data.data.Viewer.name + "\" to the script.\n Go to settings > apps, revoke " + script_type + "'s permissions, and sign in with the scirpt again to fix this.");
							return;
						}
						let listAnime = new Set(returnList(dataAnime,true).map(a => a.mediaId));
						resultsStatusGDPR.innerText = "Loading manga list...";
						authAPIcall(
							`query($name: String,$listType: MediaType){
								Viewer{name mediaListOptions{scoreFormat}}
								MediaListCollection(userName: $name, type: $listType){
									lists{
										entries{
											mediaId
										}
									}
								}
							}`,
							{
								listType: "MANGA",
								name: whoAmI
							},
							function(dataManga){
								resultsStatusGDPR.innerText = "";
								if(!dataManga){
									resultsErrorsGDPR.innerText = "An error occured while loading your manga list";
									return;
								}
								let listManga = new Set(returnList(dataManga,true).map(a => a.mediaId));

								pushResultsGDPR.style.display = "inline";
								let filtered_list = data.lists.filter(a => !(listAnime.has(a.series_id) || listManga.has(a.series_id)));
								resultsTableGDPR.innerText = filtered_list.length + " list items will be imported (" + (data.lists.length - filtered_list.length) + " items already on list will not be imported).\nEstimated time to import: " + Math.ceil(filtered_list.length/60) + " minutes.\nBrowsing Anilist while the import is running is not recommended.\nClosing this tab will immediately stop the import.";
								resultsTableGDPR.style.marginTop = "10px";

								let mutater = function(index){
									if(index + 1 < filtered_list.length){
										setTimeout(function(){
											mutater(index + 1);
										},1000);
									}
									try{
										let show = filtered_list[index];
										authAPIcall(
											`mutation($startedAt: FuzzyDateInput,$completedAt: FuzzyDateInput,$notes: String){
												SaveMediaListEntry(
													mediaId: ${show.series_id},
													status: ${["CURRENT","PLANNING","COMPLETED","DROPPED","PAUSED","REPEATING"][show.status]},
													score: ${show.score},
													progress: ${show.progress},
													progressVolumes: ${show.progress_volume || 0},
													repeat: ${show.repeat},
													priority: ${show.priority},
													notes: $notes,
													startedAt: $startedAt,
													completedAt: $completedAt
												){id}
											}`,
											{
												startedAt: {
													year: parseInt((show.started_on + "").slice(0,4)),
													month: parseInt((show.started_on + "").slice(4,6)),
													day: parseInt((show.started_on + "").slice(6,8)) 
												},
												completedAt: {
													year: parseInt((show.finished_on + "").slice(0,4)),
													month: parseInt((show.finished_on + "").slice(4,6)),
													day: parseInt((show.finished_on + "").slice(6,8)) 
												},
												notes: show.notes
											},
											data => {
												if(!data){
													throw "expected API to return ID"
												}
											}
										)
									}
									catch(e){
										resultsWarningsGDPR.innerText += "\nAn error occured for mediaID " + filtered_list[index].series_id + ": " + e
									}
									resultsStatusGDPR.innerText = (index + 1) + " of " + filtered_list.length + " entries imported"
								};
								pushResultsGDPR.onclick = function(){
									mutater(0)
								}
							}
						)
					}
				)
			}
			else{
				gdpr_importOverwrite.onclick = function(){
					alert("Overwrite mode already selected! Reload this page to start the import in another mode\n(Starting the import now WILL overwrite existing list entries!!!)")
				}
				pushResultsGDPR.style.display = "inline";
				resultsTableGDPR.innerText = data.lists.length + " list items will be imported.\nEstimated time to import: " + Math.ceil(data.lists.length/60) + " minutes.\nBrowsing Anilist while the import is running is not recommended.\nClosing this tab will immediately stop the import.";
				resultsTableGDPR.style.marginTop = "10px";

				let mutater = function(index){
					if(index + 1 < data.lists.length){
						setTimeout(function(){
							mutater(index + 1);
						},1000);
					}
					try{
						let show = data.lists[index];
						authAPIcall(
							`mutation($startedAt: FuzzyDateInput,$completedAt: FuzzyDateInput,$notes: String){
								SaveMediaListEntry(
									mediaId: ${show.series_id},
									status: ${["CURRENT","PLANNING","COMPLETED","DROPPED","PAUSED","REPEATING"][show.status]},
									score: ${show.score},
									progress: ${show.progress},
									progressVolumes: ${show.progress_volume || 0},
									repeat: ${show.repeat},
									priority: ${show.priority},
									notes: $notes,
									startedAt: $startedAt,
									completedAt: $completedAt
								){id}
							}`,
							{
								startedAt: {
									year: parseInt((show.started_on + "").slice(0,4)),
									month: parseInt((show.started_on + "").slice(4,6)),
									day: parseInt((show.started_on + "").slice(6,8)) 
								},
								completedAt: {
									year: parseInt((show.finished_on + "").slice(0,4)),
									month: parseInt((show.finished_on + "").slice(4,6)),
									day: parseInt((show.finished_on + "").slice(6,8)) 
								},
								notes: show.notes
							},
							data => {
								if(!data){
									throw "expected API to return ID"
								}
							}
						)
					}
					catch(e){
						resultsWarningsGDPR.innerText += "\nAn error occured for mediaID " + data.lists[index].series_id + ": " + e
					}
					resultsStatusGDPR.innerText = (index + 1) + " of " + data.lists.length + " entries imported"
				};
				pushResultsGDPR.onclick = function(){
					mutater(0)
				}
			}
		}
	}
}
//end modules/moreImports.js
//begin modules/navbarDroptext.js
if(useScripts.navbarDroptext){
	let addDrop = function(){
		let navThingy = document.querySelector(".nav");
		if(navThingy){
			navThingy.ondragover = function(event){
				event.preventDefault()
			}
			navThingy.ondrop = function(event){
				event.preventDefault();
				let data = event.dataTransfer.getData("text");
				if(data.length && data.length < 1000){//avoid performance issues if someone accidentally drops the lord of the rings script into the navbar or something
					document.querySelector(".nav .wrap .search").click();
					let observer = new MutationObserver(function(){
						let inputElement = document.querySelector(".nav .quick-search .input input");
						inputElement.value = data;
						inputElement.dispatchEvent(new Event("input"));
						observer.disconnect()
					});
					observer.observe(document.querySelector(".nav .quick-search"),{
						attributes: true,
						childList: false,
						subtree: false
					})
				}
			}
		}
		else{
			setTimeout(addDrop,500)
		}
	};addDrop()
}
//end modules/navbarDroptext.js
//begin modules/newChapters.js
let newChaptersInsertion = function(extraFilters){
//called from modules/drawListStuff.js
let buttonFindChapters = create("button",["hohButton","button"],translate("$button_newChapters"),extraFilters,"display:block;");
buttonFindChapters.title = "Check if there are new chapters available for things you are reading";
buttonFindChapters.onclick = function(){
	const URLstuff = location.pathname.match(/^\/user\/(.+)\/(animelist|mangalist)/);
	if(!URLstuff){
		return
	}
	let scrollableContent = createDisplayBox("min-width:400px;height:500px;");
	let loader = create("p",false,translate("$scanning"),scrollableContent,"cursor:wait;");
	let bannedEntries = new Set();
	if(useScripts.bannedUpdates){
		useScripts.bannedUpdates.forEach(item => {
			bannedEntries.add(item.id)
		})
	}
	let banMode = false;
	generalAPIcall(`
	query($name: String!){
		MediaListCollection(userName: $name, type: MANGA){
			lists{
				entries{
					mediaId
					status
					media{
						status(version: 2)
					}
				}
			}
		}
	}`,
	{name: decodeURIComponent(URLstuff[1])},
	function(data){
		if(!data){
			loader.innerText = translate("$error_connection");
			return
		}
		let list = returnList(data,true).filter(a => a.status === "CURRENT" && a.media.status === "RELEASING");
		let returnedItems = 0;
		let goodItems = [];
		let banContainer = create("div",false,false,scrollableContent.parentNode,"position:absolute;bottom:10px;left:10px");
		let banButton = create("button","hohButton","Ban items",banContainer);
		let banManager = create("button","hohButton","Manage bans",banContainer);
		banButton.onclick = function(){
			banMode = !banMode;
			if(banMode){
				banButton.innerText = "Click items to ban them";
				scrollableContent.classList.add("banMode")
			}
			else{
				banButton.innerText = "Ban items";
				scrollableContent.classList.remove("banMode")
			}
		}
		banManager.onclick = function(){
			let manager = createDisplayBox("min-width:400px;height:500px;top:100px;left:220px");
			create("h3",false,"Banned entries:",manager);
			if(!useScripts.bannedUpdates || useScripts.bannedUpdates.length == "0"){
				create("p",false,"no banned items",manager);
				return
			}
			useScripts.bannedUpdates.forEach(function(item){
				let listing = create("p","hohNewChapter",false,manager);
				create("a",["link","newTab"],item.title,listing)
					.href = "/manga/" + item.id + "/" + safeURL(item.title) + "/";
				let chapterClose = create("span","hohDisplayBoxClose",svgAssets.cross,listing);
				chapterClose.onclick = function(){
					listing.remove();
					bannedEntries.delete(item.id);
					useScripts.bannedUpdates.splice(useScripts.bannedUpdates.findIndex(a => a.id === item.id));
					useScripts.save()
				}
			})
		}
		let checkListing = function(data){
			returnedItems++;
			if(returnedItems === list.length){
				loader.innerText = "";
				if(!goodItems.length){
					loader.innerText = translate("$updates_noNewManga")
				}
			}
			if(!data){
				return
			}
			let guesses = [];
			let userIdCache = new Set();
			data.data.Page.activities.forEach(function(activity){
				if(activity.progress){
					let chapterMatch = parseInt(activity.progress.match(/\d+$/)[0]);
					if(!userIdCache.has(activity.userId)){
						guesses.push(chapterMatch);
						userIdCache.add(activity.userId)
					}
				}
			});
			guesses.sort(VALUE_DESC);
			if(guesses.length){
				let bestGuess = guesses[0];
				if(guesses.length > 2){
					let diff = guesses[0] - guesses[1];
					let inverseDiff = 1 + Math.ceil(20/(diff+1));
					if(guesses.length >= inverseDiff){
						if(guesses[1] === guesses[inverseDiff]){
							bestGuess = guesses[1]
						}
					}
				}
				if(hasOwn(commonUnfinishedManga, data.data.MediaList.media.id)){
					if(bestGuess < commonUnfinishedManga[data.data.MediaList.media.id].chapters){
						bestGuess = commonUnfinishedManga[data.data.MediaList.media.id].chapters
					}
				}
				let bestDiff = bestGuess - data.data.MediaList.progress;
				if(bestDiff > 0 && (bestDiff < 30 || list.length <= 30)){
					goodItems.push({data:data,bestGuess:bestGuess});
					removeChildren(scrollableContent)
					goodItems.sort((b,a) => a.data.data.MediaList.score - b.data.data.MediaList.score);
					goodItems.forEach(function(item){
						let media = item.data.data.MediaList.media;
						if(bannedEntries.has(media.id)){
							return
						}
						let listing = create("p","hohNewChapter",false,scrollableContent);
						let title = titlePicker(media);
						let countPlace = create("span","count",false,listing,"width:110px;display:inline-block;");
						let progress = create("span",false,item.data.data.MediaList.progress + " ",countPlace);
						let guess = create("span",false,"+" + (item.bestGuess - item.data.data.MediaList.progress),countPlace,"color:rgb(var(--color-green));");
						progress.style.cursor = "pointer";
						progress.title = "Open list editor";
						progress.onclick = function(){
							if(banMode){
								return
							}
							document.getElementById("app").__vue__.$store.dispatch("medialistEditor/open",media.id)
						}
						if(useScripts.accessToken){
							guess.style.cursor = "pointer";
							guess.title = "Increment progress by 1";
							guess.onclick = function(){
								if(banMode){
									return
								}
								item.data.data.MediaList.progress++;
								authAPIcall(
									`mutation($id: Int,$progress: Int){
										SaveMediaListEntry(mediaId: $id,progress: $progress){id}
									}`,
									{
										id: media.id,
										progress: item.data.data.MediaList.progress
									},
									function(fib){
										if(!fib){
											item.data.data.MediaList.progress--;
											progress.innerText = item.data.data.MediaList.progress + " ";
											guess.innerText = "+" + (item.bestGuess - item.data.data.MediaList.progress)
										}
									}
								);
								progress.innerText = item.data.data.MediaList.progress + " ";
								if(item.bestGuess - item.data.data.MediaList.progress > 0){
									guess.innerText = "+" + (item.bestGuess - item.data.data.MediaList.progress)
								}
								else{
									guess.innerText = ""
								}
							}
						}
						create("a",["link","newTab"],title,listing)
							.href = "/manga/" + media.id + "/" + safeURL(title) + "/";
						let chapterClose = create("span","hohDisplayBoxClose",svgAssets.cross,listing);
						chapterClose.onclick = function(){
							if(banMode){
								return
							}
							listing.remove();
							bannedEntries.add(media.id)
						};
						listing.onclick = function(){
							if(banMode){
								if(bannedEntries.has(media.id)){
									bannedEntries.delete(media.id);
									listing.style.background = "inherit";
									useScripts.bannedUpdates.splice(useScripts.bannedUpdates.findIndex(item => item.id === media.id),1)
								}
								else {
									bannedEntries.add(media.id);
									listing.style.background = "rgb(var(--color-peach))";
									if(!useScripts.bannedUpdates){
										useScripts.bannedUpdates = []
									}
									useScripts.bannedUpdates.push({
										id: media.id,
										title: title
									})
								}
								useScripts.save()
							}
						}
					})
					create("p","hohNewChapter",false,scrollableContent)//spacer
				}
			}
		};
		let bigQuery = [];
		let queryList = [];
		list.forEach(function(entry,index){
			if(!bannedEntries.has(entry.mediaId)){
				bigQuery.push({
					query: `
query($id: Int,$userName: String){
	Page(page: 1){
		activities(
			mediaId: $id,
			sort: ID_DESC
		){
			... on ListActivity{
				progress
				userId
			}
		}
	}
	MediaList(
		userName: $userName,
		mediaId: $id
	){
		progress
		score
		media{
			id
			title{romaji native english}
		}
	}
}`,
					variables: {
						id: entry.mediaId,
						userName: decodeURIComponent(URLstuff[1])
					},
					callback: checkListing
				})
			}
			if((index % 2) === 0){
				queryList.push(bigQuery);
				bigQuery = []
			}
		});
		queryPacker(bigQuery);
		queryList.forEach((littleBig,index) => {
			setTimeout(function(){queryPacker(littleBig)},index * 100)
		})
	})
}
}
//end modules/newChapters.js
//begin modules/noAutoplay.js
exportModule({
	id: "noAutoplay",
	description: "Do not autoplay videos",
	extendedDescription: `
Your browser may also provide ways to control this:

Firefox: about:config > media.autoplay has a wide range of options

Chrome: chrome://flags/#autoplay-policy
`,
	isDefault: false,
	categories: ["Feeds"],
	visible: true
})

if(useScripts.noAutoplay){
	setInterval(function(){
		document.querySelectorAll("video").forEach(video => {
			if(video.hasAttribute("autoplay")){
				if(!(video.querySelector("source") && video.querySelector("source").src.match(/#image$/))){
					video.removeAttribute("autoplay");
					video.load()
				}
				else{
					video.removeAttribute("controls")
				}
			}
		})
	},500)
}
//end modules/noAutoplay.js
//begin modules/nonJapaneseVoiceDefaults.js
exportModule({
	id: "nonJapaneseVoiceDefaults",
	description: "defaults to Chinese and Korean voice actors for non-Japanese shows",
	isDefault: true,
	categories: ["Media"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url.match(/\/anime\/.*\/characters\/?$/)
	},
	code: function(){
		let checker = function(){
			if(!document.URL.match(/\/anime\/.*\/characters\/?$/)){
				return
			}
			let sidebarInfo = document.querySelector(".sidebar .data-set .value");
			if(!sidebarInfo){
				setTimeout(checker,500);
				return
			}
			let country = sidebarInfo.innerText.match(/Chinese|South Korean|Taiwanese/);
			if(!country){
				return
			}
			let selector = document.querySelector('.language-select input[placeholder="Language"]');
			if(!selector){
				setTimeout(checker,500);
				return
			}
			//opens the dropdown, spawning the alternate options
			selector.click();
			let selection = function(){
				if(!document.URL.match(/\/anime\/.*\/characters\/?$/)){
					return
				}
				let dropdown = document.querySelector(".el-select-dropdown");
				if(!dropdown){
					setTimeout(selection,100);
					return
				}
				let options = Array.from(dropdown.querySelectorAll(".el-select-dropdown__item span"));
				if(options.length === 0){
					selector.click()
				}
				options.forEach(option => {
					if(
						(option.innerText === "Chinese" && (country[0] === "Chinese" || country[0] === "Taiwanese"))
						|| (option.innerText === "Korean" && country[0] === "South Korean")
					){
						option.click()
					}
				})
			};selection()
		};checker()
	}
})
//end modules/nonJapaneseVoiceDefaults.js
//begin modules/nonJumpScroll.js
// SPDX-FileCopyrightText: 2021 Reina
// SPDX-License-Identifier: MIT
/*
Copyright (c) 2021 Reina

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//updated code here: https://github.com/Reinachan/AniList-High-Contrast-Dark-Theme
exportModule({
	id: "nonJumpScroll",
	description: "$nonJumpScroll_description",
	isDefault: true,
	importance: 1,
	categories: ["Feeds"],
	visible: true,
	css: `
/* Scrollbar */
* {
	scrollbar-color: rgb(var(--color-blue)) rgba(0, 0, 0, 0);
	scrollbar-width: thin;
}
::-webkit-scrollbar {
	width: 4px;
	height: 8px;
}

::-webkit-scrollbar-button {
	display: none;
}

::-webkit-scrollbar-track {
	background-color: #1110;
	width: 0px;
}

::-webkit-scrollbar-track-piece {
	display: none;
}

::-webkit-scrollbar-thumb {
	background-color: rgb(var(--color-blue));
}

.markdown::-webkit-scrollbar-thumb,
.about .content-wrap::-webkit-scrollbar-thumb {
	background-color: rgba(0, 0, 0, 0);
}

.markdown:hover::-webkit-scrollbar-thumb,
.about .content-wrap:hover::-webkit-scrollbar-thumb {
	background-color: rgb(var(--color-blue));
}

::-webkit-scrollbar-corner {
	display: none;
}

.markdown {
	overflow-y: scroll!important;
	scrollbar-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0);
}
.markdown:hover {
	scrollbar-color: rgb(var(--color-blue)) rgba(0, 0, 0, 0);
}

.about .content-wrap .markdown {
	overflow: hidden!important;
}

.about .content-wrap {
	overflow-y: scroll!important;
	scrollbar-color: rgba(0, 0, 0, 0) rgba(0, 0, 0, 0);
}

.about .content-wrap:hover {
	overflow-y: scroll!important;
	scrollbar-color: rgb(var(--color-blue)) rgba(0, 0, 0, 0);
}
`
})
//end modules/nonJumpScroll.js
//begin modules/noScrollPosts.js
exportModule({
	id: "noScrollPosts",
	description: "$noScrollPosts_description",
	isDefault: false,
	importance: -2,
	categories: ["Feeds"],
	visible: true,
	css: ".activity-text .text .markdown{max-height: unset}"
})
//end modules/noScrollPosts.js
//begin modules/noSequel.js
const sequelList = new Set([20606,13663,110229,100878,16934,12477,103275,21416,87486,18753,126659,21460,14829,21281,98580,116005,15037,1840,9617,107068,21520,21258,114446,112625,20880,20494,10080,100815,6033,20958,21856,99147,100166,110277,1735,104578,104276,20594,2759,16870,21745,97767,116752,125367,111790,131942,20652,225,3784,20996,100643,20849,21400,114043,19163,21399,8525,11577,114194,21262,99749,20791,20671,18397,18247,15417,21110,98292,20021,112323,116741,104580,98384,97889,98762,15039,108623,3712,20801,11319,5,101432,6707,99425,117448,13659,21180,97996,111734,21390,20614,100049,16049,5341,19111,100185,106509,21377,10790,125368,16706,8516,20853,130592,108307,9181,552,20595,104459,98572,21887,116338,10521,124410,19489,20694,4280,21339,21733,14397,20751,528,20448,97672,16904,10067,4901,20995,21574,10863,21364,21394,21718,109190,20519,14967,9969,8937,11981,97886,3785,7593,17074,20626,103223,21861,100773,114308,111762,16894,18115,109963,20876,7791,10719,20745,98034,108553,21385,112124,19703,114862,135136,12365,142984,20572,120209,9515,3783,13271,21005,4282,131518,12729,97730,100178,100876,113538,108511,4181,97938,99255,119661,129874,98437,813,21679,104157,100723,101167,102351,32,98436,97668,20992,112151,101338,112641,20850,21698,117193,108725,21699,2904,21170,21128,108632,20474,99539,100240,106625,113936,131681,21450,100182,21518,102883,20698,20799,19603,114236,11741,142329,99540,101302,98635,100722,1519,131586,6675,21719,20879,16762,21676,9656,1889,97880,108631,3786,97888,21006,99634,4214,20963,20913,131773,117533,21560,21769,10030,20514,110733,13667,104462,9062,124858,104463,3782,16001,14837,101166,110178,21584,21799,104217,6213,111321,107717,20725,7311,103047,20513,245,100298,98478,124194,21127,102976,101474,20792,11597,108759,108928,108489,109261,20993,127720,15451,21403,21175,18671,116742,136430,31,11737,131520,21104,100784,21268,20819,430,2787,21184,13469,2472,5205,113359,5204,9982,21558,187,21565,119941,97983,874,21379,20889,18,6372,109819,1565,2889,109403,8247,138565,21710,108522,127366,130588,1119,138424,21088,8407,98702,111322,133844,106918,2924,4752,11553,15335,10589,442,20778,102977,21000,12403,11979,21650,97637,146984,125124,103276,101410,93,13939,20752,90,124395,112153,124195,104382,102997,900,101924,10049,10418,1117,20766,936,114745,99734,20638,19291,116674,21335,140439,4896,6007,3901,127371,105143,801,97918,108891,73,105893,104243,20680,10681,98884,108266,112296,21852,1239,21780,962,895,464,112803,372,105749,6793,101812,111048,97891,11123,134710,18295,15201,21871,18661,10073,99470,10378,1121,107203,16444,130183,4026,139,986,1002,16866,98524,20625,15437,10033,6178,6127,15793,5962,20714,1313,21103,97645,9135,21483,2581,6954,13331,20884,110355,114195,8408,21138,2144,100523,129188,21610,18195,11235,21384,104175,104458,101813,4106,459,100451,3927,135865,20762,846,395,15879,15199,21451,98885,110857,14175,905,14807,105200,376,141534,21691,21757,104461,468,21064,97875,21126,136804,20526,145545,129196,21348,17741,145139,11743,20566,118399,19363,4835,3297,108945,5781,20869,132193,101102,100684,9074,901,21322,21748,97643,15117,21586,108581,114087,19951,8246,17641,10020,101925,5300,122349,100675,100749,12859,21855,10271,99714,6811,6862,11665,20741,10379,4437,21815,21778,12893,4789,120150,139498,100353,102436,21356,97881,740,104174,10119,21749,103631,3228,122808,898,97757,18441,21629,14027,21424,131149,1120,9471,4472,116867,18001,1430,6421,21077,10209,317,532,101344,18617,131680,145064,1526,19613,10794,21862,11266,3972,20769,21660,21746,100855,97917,21874,21791,113693,20719,7338,116605,21191,20767,20467,6773,139648,12049,13357,20629,12115,139630,5258,4565,4155,21261,3652,20635,482,20547,21425,1564,15699,186,102882,20670,6325,12113,20666,19647,20728,113950,98502,127688,21186,21247,21046,101213,15059,20907,9366,6637,903,112125,16005,14527,119113,906,4182,21573,97634,21085,102167,543,21008,15565,2847,904,15197,108040,138,3572,9107,899,1132,101426,101343,10805,12231,1122,902,20723,20802,21579,896,9790,20609,102498,101992,1594,13055,137,897,97665,98497,6377,113917,98779,99394,20692,111852,4814,21241,20986,894,126357,104990,264,20654,1686,101215,18857,5277,98656,98349,20768,20711,1118,5667,21034,9734,20845,2994,101206,109492,101965,11783,20736,21376,20497,7858,107622,104307,996,10298,265,4477,21010,20826,13261,20659,21640,2685,20761,20633,156,6951,11209,2107,1095,109562,98060,6945,20775,98554,558,20554,859,452,761,461,21068,21765,21596,4872,65,8740,119947,450,82,10464,20856,98874,5262,21777,94,21489,1142,136192,21244,130389,121176,100465,13403,104198,132806,9047,21178,104460,126819,12783,7695,371,2131,17259,15811,7902,19211,100181,17873,100532,3226,1015,7748,18097,86,110738,136484,4866,20551,133898,14653,4726,21294,101313,12671,13709,4918,136381,127619,97619,98663,98565,18619,18523,133845,20481,449,100978,133175,3225,20454,2921,100268,465,139092,21678,15323,16868,6884,19109,15487,106494,21389,12187,97985,1074,123330,110445,101161,14511,11739,19023,100133,1894,21091,21407,2899,128643,100965,834,21831,21265,16385,20900,21235,21673,98240,12685,10638,136436,101595,6408,21772,650,131880,130550,969,21672,10083,104170,4535,20697,14893,21695,7017,135866,20895,16273,87489,987,463,20478,8577,99938,21415,451,13587,9063,5391,11359,6624,114473,99148,107069,10076,107294,126356,113811,3848,98575,1842,9917,142876,908,100659,21053,5028,107138,9130,9488,21255,15195,139449,102969,143080,139518,101016,21891,8023,98379,126661,141182,21331,97734,8440,104368,121467,103049,9712,21312,551,95,113290,20644,146065,779,100294,5955,87,780,781,1669,100305,1915,20660,101123,19123,136880,98496,2563,7082,100744,19191,531,12503,474,209,21266,891,9065,106495,106169,113050,101501,100518,20669,20945,3466,5152,97642,10507,12471,20835,121034,127368,133007,10447,21313,762,12979,85,20737,1566,21588,20560,20777,114622,10647,14189,460,98873,594,141249,20571,113924,4970,5034,101634,20485,6023,196,142853,20960,487,21094,20862,5337,21490,7367,108942,1090,10370,18121,9117,17115,120257,190,401,98402,1365,6288,21007,19391,21599,2508,21585,20824,8410,21813,21458,124223,98495,97769,127363,77,1363,15927,873,1956,102949,3759,1364,10075,102449,892,12069,8514,7655,2398,6864,2006,9203,822,139095,9201,4015,15609,19669,126830,3016,21879,10622,116147,20449,100561,7870,1023,20686,107208,20739,5279,4163,12673,98662,21487,18045,9724,9355,117496,298,13093,4196,21057,21540,16051,103110,21753,12753,1505,20515,97951,143085,6791,1719,8197,15359,1253,17875,131264,12929,100306,20938,880,101918,20882,4447,17437,20833,138425,20658,4938,8038,20978,98866,9963,20567,6634,6165,9999,4037,19697,535,10740,106154,7044,12255,1527,3231,102090,4134,20866,16239,20444,19193,107202,18055,1953,2248,9252,99302,110413,84,21325,8311,2471,20524,98876,7720,6633,21485,98703,104199,12669,20733,3328,20760,21649,132545,105401,12117,100269,10713,135102,10336,7337,107506,21473,2171,107263,10659,2962,130590,102822,18745,98438,102832,13263,16123,104979,21043,139093,20662,98629,9465,3352,1813,5460,146066,21786,21209,1257,137819,100813,1367,10017,133891,21658,21738,143866,12419,100780,17341,21208,21638,127550,99569,11889,7062,664,9958,101830,107351,139825,97936,136263,13767,2273,20546,21230,21501,4039,21744,5526,6489,997,10643,18713,13859,1836,101036,104278,20844,12053,101100,10582,98860,1397,21651,20962,656,21414,102508,10714,10330,5228,102353,113692,106223,2201,9136,6336,16694,4192,21328,117074,127400,21853,21327,21279,3091,21120,10686,21098,10491,128740,20487,20453,98878,103277,105662,140596,20796,20687,98033,21462,9925,98856,100644,2175,113108,96,21729,5162,21155,100957,16680,143337,20531,101844,21798,10232,10604,99476,20780,107704,21404,462,1709,20854,116756,21836,15377,146722,18851,16099,101574,21500,6381,21214,17389,3713,6572,126529,141208,81,21305,111729,16700,21248,2397,19511,14093,19319,107346,98574,5764,117002,12487,17535,12711,112686,19671,97988,98778,8479,142838,11113,21300,20906,130713,101633,3604,20472,10092,1614,104745,100283,1091,6467,104530,20926,16982,99363,8985,110088,6064,17879,20871,10739,19195,1366,118743,4793,1506,9618,15729,1092,101083,517,10536,10249,9510,14941,1172,16468,1372,11239,12665,21114,104200,7580,17643,21136,20423,14645,191,98338,14735,21252,10172,107764,3515,18849,10715,111145,6115,98473,108260,11813,20738,1668,127595,20451,8624,21476,140999,17409,2386,7334,136145,15881,17725,15489,10717,1425,101632,120700,8465,87526,6676,20601,10624,105595,2385,103588,15591,21470,20820,6291,104434,10716,1110,11859,2363,100227,21646,108939,7739,394,112324,21358,13267,9735,17637,100811,101471,20035,87498,5521,139359,615,352,10737,15611,1914,98814,7375,107905,109603,9362,20452,11001,2035,2969,15959,98344,2595,1078,5306,2488,104749,112177,155,2355,20695,9202,10469,21740,448,133124,8918,1356,10302,3033,564,4130,120851,2020,8190,20734,618,113470,7897,101098,20456,1471,109085,1238,110090,117085,20750,4811,104326,110640,6479,21681,123901,97859,125351,9745,100469,11237,10444,4792,1237,4053,102346,21113,4028,11879,20685,1847,108714,6984,101816,21338,21730,100729,596,139435,21864,9581,17205,10808,114744,113024,103209,15617,137804,101909,142343,821,98238,136344,21014,109731,20990,1240,142411,97667,21260,99730,111305,5947,102836,3323,963,21304,2356,6112,97860,21426,17080,3965,3931,21011,1747,351,13409,4483,3665,277,112302,107352,4760,3446,304,6927,2424,104437,7651,21492,9888,136226,11339,124115,2752,97910,138056,108941,1888,101085,883,98566,644,97765,291,99624,107913,2680,21505,98536,98520,396,114564,98704,97890,20683,97853,2490,89,134413,98222,18429,114981,181,6896,21513,995,1531,3165,15651,120046,124612,299,8348,1921,108267,20863,98847,6380,18099,101743,1563,141852,98239,107313,102839,2623,11341,1657,101499,98642,2683,102349,6187,1007,136064,117086,106896,14575,107342,21687,102499,87505,882,21880,4772,5772,4195,115800,12017,20928,886,100852,127976,14835,136829,12281,132467,46,120892,20650,192,20573,21122,4596,8302,976,9032,4705,122292,98833,104077,1094,140337,19799,110028,16241,11917,21357,21301,5163,135939,21079,104071,9347,3627,120343,9563,444,102348,102347,21253,21115,144932,98868,6050,100180,3593,15649,8422,4765,21774,20861,8532,128207,124756,98525,87480,1335,1487,21332,116676,21076,103237,10479,3031,108735,104286,10431,134623,20765,11161,100537,10380,101999,108548,98576,8728,9441,2520,21896,5713,98978,103712,101554,7222,1426,20731,21381,110318,5233,3918,20221,104378,11441,130,13145,21129,15963,1929,102350,21467,5244,2448,108062,11385,17391,20852,21534,20578,3269,1472,102946,117913,8456,21892,397,21886,7135,1350,19251,113653,540,12001,21413,8687,120180,15989,131866,3032,127721,137735,13561,17345,14267,5029,21570,6024,137337,21775,15411,15951,109418,20846,443,20764,87488,10834,92,124132,138700,103713,6768,5978,20598,103119,106287,10928,98186,101337,91,103555,141351,141902,3791,102631,807,136080,1066,100653,21666,1525,13377,14827,12449,111500,3956,21893,143271,15633,10153,15731,21293,21289,106206,112033,102093,12505,2213,620,97670,17739,5458,6795,125261,20823,117556,16395,123769,146953,12879,146206,19159,137309,15807,8995,6714,104371,21387,17947,20916,9544,119258,20921,118125,8609,9754,99614,20706,8668,1732,1008,17273,2108,1916,11615,2512,541,145813,104324,1432,10477,869,866,2905,13119,2298,2928,21245,106499,20564,3354,117197,1011,115217,21633,8230,281,21276,6443,1241,10845,98504,141400,20651,3485,112031,21508,792,107692,1262,2499,146637,101046,2126,102608,1419,122575,1825,124032,119812,21107,107984,3674,122041,123381,6882,1255,1289,219,101596,140350,651,87475,1861,1368,7304,102716,100979,143082,2498,1260,20181,100652,21324,4197,99196,11793,102503,5717,20450,3221,20805,1764,14117,121962,6712,17843,142684,108944,4080,21003,21812,21257,9988,113476,2123,106572,122671,107298,102978,7468,760,98622,3349,815,5529,102033,20848,4232,3887,21030,7568,98433,21154,1609,6964,3692,2117,87506,2842,2229,129759,694,20732,11255,1707,3090,140642,1215,1729,21477,4886,20689,6151,21231,3750,12067,8599,128306,124394,1290,1401,112640,12823,97820,13231,20883,146921,100719,98470,21287,21790,2048,1006,471,100186,1144,117408,119964,110228,6783,14875,98106,12447,1835,1376,6330,143846,7782,107252,102609,14049,20642,981,103254,101169,104213,99547,20915,116944,1917,2768,97919,4795,2198,98289,8057,9611,10933,115567,10350,146743,20904,98582,98452,98471,99732,99995,3449,21409,17717,10920,122497,114052,7322,9023,19255,2597,121681,6385,6591,919,106568,16678,98142,130558,10917,136303,2237,98516,2873,9288,1969,101339,98897,18413,6198,21194,12455,115927,104411,1348,132526,125308,98209,15785,101696,1418,10122,141352,110686,609,2497,146646,630,83,101115,1920,21592,6704,380,1357,20870,2515,21806,99742,6399,105391,20941,2589,2971,21139,454,131,21554,102293,6877,20878,116968,113023,20851,14627,2392,10219,5196,115566,524,113906,124136,102000,98206,21817,10999,126425,110786,97933,10934,9396,1369,4715,21636,1143,1435,1278,1473,108758,19029,143086,6287,20039,10497,143327,1258,2937,3861,97818,868,126678,13201,1146,17267,2513,525,8756,9591,1967,21135,114249,867,98220,100768,104102,107348,2761,21468,21564,21465,21814,9744,98420,102309,4052,21820,146954,124641,10924,3076,21839,6609,20989,418,98225,398,100716,4794,4874,110382,1211,222,87507,1619,1003,645,1817,14173,1256,8098,107350,138103,7875,2125,14817,20834,6438,2514,1398,112472,99646,115651,704,101216,8619,1830,1521,5333,641,1018,141212,101104,20498,1416,114233,10916,20847,20640,3174,122631,1654,100519,1968,5751,13727,10703,110275,6234,2606,492,100280,6344,5462,117764,1985,21442,99731,864,99197,97915,2265,102098,101097,381,133904,1302,20747,13931,6231,103717,7041,21405,1670,2450,5097,5348,2214,103543,3266,21388,2132,13839,5493,101267,100966,21822,20794,1796,21285,10923,20784,5725,9865,1504,8507,5256,101875,7740,17855,21430,104712,98599,120534,111082,21317,1382,101928,1631,3288,12725,2670,110173,98056,142914,124,8217,1433,106895,21590,17351,108355,4205,104291,19845,124896,98621,712,20998,428,1187,8331,3727,16638,139451,5419,1225,21345,110265,1761,97989,139466,1342,5096,105387,6581,1101,2454,21438,20896,9124,1400,138260,1399,105655,110359,9435,12863,1439,21789,3392,504,1349,13757,6275,87476,21374,7654,119696,117532,10628,146472,102573,122238,915,10810,1249,97905,21280,21664,102600,1930,21784,8317,111730,20579,13245,10573,3057,112166,1437,107447,1749,1910,18053,112900,19099,3745,20187,99557,5347,1438,7248,4664,1231,7463,4662,121043,814,98556,18881,8438,13799,7016,10804,102599,3447,4320,1152,1135,117765,2580,7474,2673,5291,128563,10534,6590,1415,13731,8231,20570,10870,4502,99912,125640,3626,3419,1190,108,20803,135108,131182,20902,113348,102933,10098,13855,13837,4910,15431,2109,114926,10531,102001,8358,21299,21286,1147,938,1286,12065,103870,261,429,17419,4650,2393,7270,121664,2269,2098,678,135171,117756,8362,631,97955,135255,114842,118126,2013,4200,2014,1931,20816,109002,99733,98107,21307,21770,16059,1750,98697,21251,7305,97856,769,97621,1413,3401,105244,7066,4082,1417,146638,1994,8245,132420,110253,114417,8359,1191,2174,100184,116610,2615,20924,1343,14077,11663,8133,2017,104396,1922,20948,3000,1429,5332,21821,124196,108853,106690,21383,113187,12221,6154,1168,20859,5753,99059,6379,106506,11777,1988,98548,5845,1924,102401,119042,20828,7045,1923,1421,102431,21796,98546,9002,15925,5199,673,254,2157,129608,2655,653,3429,3027,102572,21591,21314,685,131923,9979,2458,1475,10581,8490,1424,3051,8894,6705,100769,102464,21401,1803,1434,6460,6209,2661,2203,1252,1474,5032,1925,122585,101817,109153,1414,21620,21437,2675,1436,18525,9785,1420,21759,21750,99817,1422,98069,15307,20522,844,1226,7113,1423,1410,128947,102036,14957,8022,97631,21429,2523,555,3219,129610,17585,4469,4312,2725,20836,101908,21737,20914,99883,104257,2110,1800,6794,112732,20909,8097,5270,711,20636,142481,9342,6930,20267,10731,9220,4549,493,13619,6958,1651,3468,652,21870,21697,19889,113971,5305,1046,139754,2294,9241,2695,370,114030,1841,5844,1489,7774,107110,105962,10821,1081,1918,18531,20810,115107,11019,835,19945,1149,99083,16442,11053,5658,112455,20535,128,6152,99084,797,139752,17573,3469,109003,11009,2920,6582,2947,1718,2391,99839,87538,7471,921,636,20985,706,109260,6169,98332,99888,2743,176,5967,1919,1476,137726,109005,7745,3019,21119,5072,98542,115914,137734,115006,4703,115846,1427,9708,113308,15177,8705,4124,139274,6527,107943,109670,16614,20999,17357,115,109911,101917,9706,5351,2676,112658,20988,3954,98759,15219,3493,10390,8369,2664,21867,137612,97854,102859,21794,7060,2954,121035,10949,119350,9311,109191,559,138717,118,2011,10947,10483,104188,10945,4166,115916,20936,14693,10948,1856,12579,9040,313,101996,109004,102571,655,20549,1296,2665,15839,6736,14889,1880,98971,21797,120755,107199,1652,115918,119806,9547,2671,21121,262,19101,10359,8709,4508,2948,116786,9353,9035,110734,142794,104160,1042,5045,99741,10886,4851,16574,12961,1020,2734,104959,98746,1104,6988,21598,5712,5968,102974,100980,21323,9487,1645,11715,142219,21752,21157,20868,484,6555,119960,123803,16644,6130,21004,17699,2407,1720,104211,19645,12651,1578,8909,920,112019,911,11635,7744,98760,114561,7550,20141,1746,106606,13137,1996,21642,12239,11069,14583,9170,112258,2677,1428,1128,2760,255,21525,18231,20776,2470,2459,2302,101370,21137,128827,12121,98761,98547,21207,10351,1864,102096,21504,115671,5369,111306,21474,21767,140002,114304,6041,138511,20391,3602,1991,143203,6567,146473,15291,3024,107875,21125,19431,102860,446,135645,4646,3462,100667,10766,6217,2656,12499,4421,4078,12709,20893,9393,1336,7549,2922,2267,102601,11853,4450,9849,608,16928,7759,3618,12131,134286,1166,10549,1481,21559,17727,123074,2322,3744,1794,132209,100981,100484,100262,98581,141907,104214,102603,99391,108973,10832,3898,3964,1798,2217,2067,1501,1112,103022,17655,5019,99568,2648,112685,6299,101372,111144,98997,2669,123464,100225,2118,1298,17113,4804,4540,1676,1297,8062,10297,3256,1495,115656,128890,4712,2684,98744,97937,21478,20929,16508,3963,102602,119080,103311,8491,6959,2654,6153,15783,2713,689,8367,6885,10116,101101,16936,2408,2667,11773,8026,107141,10180,9005,1111,99478,2870,21890,143150,3991,1277,808,102979,2666,98891,98229,111909,2176,116962,3406,2168,1957,12727,12347,6901,2264,2090,113669,13937,101369,1540,100071,5996,3072,110788,8648,125909,21169,3071,314,102483,98843,999,129348,4114,993,113990,20890,1389,9167,140005,135864,21436,8365,1024,10825,5549,3738,2929,123490,8364,574,2119,2121,100176,9786,17497,2868,129350,97610,7540,378,2620,99085,6149,1123,106493,103923,19297,113864,102463,10280,121065,127163,1150,21491,4162,295,2706,1377,10301,8360,927,102450,1795,925,2111,3686,4486,16646,2304,136137,2062,1756,21337,10361,4353,1636,140187,116015,21229,7264,5415,1514,104187,21427,928,12921,2558,116923,101435,142016,123476,8635,6418,10050,8837,2784,100291,130846,100328,8361,2120,1539,858,106541,21232,4173,129946,4027,1964,8366,10679,87438,129351,13679,684,117758,10420,2998,17659,100570,102305,332,7857,2061,1874,127863,98517,3501,3222,8287,1755,1493,8250,1388,5890,5585,98846,8423,102005,12223,5723,20897,12963,6496,4209,102077,10862,7144,144990,116979,21859,3205,21446,114448,9309,4361,2303,16738,1648,2010,99841,9716,116964,13073,111955,13223,6883,121026,18149,139386,3381,1769,2668,112308,107993,20798,12343,4667,132634,5290,3067,137740,3112,16319,129349,10796,103809,20959,2583,1754,17917,2420,142826,11699,16532,7781,1344,103847,21528,8368,140175,114442,3223,131047,121528,2305,1234,7712,5031,3069,9346,104922,6749,139806,117395,1757,103023,99718,2672,108810,3008,2333,145478,1659,101546,9673,5859,129347,20925,2659,2658,557,18419,5691,145740,100527,6713,2511,2657,131770,10592,5832,2662,2586,98577,19207,10775,8908,13559,2733,14935,2429,139409,556,87483,21354,20500,10936,3234,2325,126649,7083,4443,1752,16726,362,87482,13067,5710,4416,771,10905,2359,6657,2674,87533,20822,7453,112010,2584,143202,21523,136512,113254,734,6999,114424,20917,2306,139273,8950,1882,104748,142985,8754,98096,2122,1635,1235,18781,14685,108625,1886,8800,6607,108767,2696,15979,8363,104557,111931,21652,7882,3111,21808,112612,106456,134168,12991,5165,5397,5288,3410,2474,8289,1736,102429,21849,115955,2678,21863,18449,7430,6492,2308,6891,104739,2717,11569,1014,100289,18639,10048,8134,3868,98094,113221,110641,2521,15547,146321,144336,101555,14047,2172,115105,2063,1460,105245,10276,2911,2765,3483,105663,7179,8373,100072,146140,100290,99945,21550,11911,2292,1632,8839,1999,132317,116415,130777,5164,7108,3157,10824,6312,1671,110219,9630,7861,312,2999,108041,1831,1939,122013,7363,144803,10693,4827,127042,2518,102525,2206,115519,115879,2009,1789,114334,9348,1381,97589,1843,10689,7329,140085,12225,3037,101385,2405,107755,5056,132055,1035,138675,562,21739,10666,3292,2212,1071,105616,104854,105964,104339,9494,5250,124230,103948,110578,122639,21134,130253,2008,4071,126275,106674,99663,5715,1392,423,139348,6199,2307,660,5372,106320,7579,5644,1753,887,3138,131048,6792,5539,2272,14913,2709,129123,104436,4476,12745,115082,126354,12715,4406,2777,1758,98970,9287,8518,131475,5584,2859,2276,2728,20894,4213,3511,1768,1273,6245,4056,3281,126783,123078,18549,7308,4926,107881,101876,21551,20477,14949,9100,127045,103690,654,125440,21433,13127,2181,126169,10732,707,108936,21203,2745,102628,4816,2064,5520,5324,2087,130190,20465,5037,14007,4075,110465,134081,20942,126186,104383,3729,139813,98092,124600,13143,21552,102462,10710,9127,1395,20937,5653,143766,9121,5147,130188,123885,686,2209,112450,10513,924,129595,108972,108331,2065,102165,13969,7666,107256,8208,5938,2492,109097,98521,123612,115654,102658,5213,112152,137761,110787,17787,1393,126294,2100,422,1394,5308,125783,110332,20528,7953,107188,110732,10471,4031,3854,140376,97916,100720,6374,102389,18391,101913,126316,113472,98791,1411,216,7691,3248,7436,112480,10286,5661,146543,132324,2046,128344,114721,7254,109484,102617,7004,5854,13917,4640,5501,11299,6437,8079,2802,19447,1266,9548,217,104006,3245,109280,99716,3004,2299,11685,7366,9087,6511,1771,6227,5296,2910,21589,6068,2399,109413,142298,138864,107862,10036,796,3182,4383,3671,3153,12603,4070,102743,2378,102677,15095,15015,5395,132014,8042,683,2344,146503,103392,101550,705,11511,122008,10324,13993,1268,215,130305,109482,8538,1113,126662,98972,2301,21562,7364,2801,98964,10526,4371,117572,98851,5484,4014,137799,2535,101697,8546,2256,123405,10527,2682,98378,10528,8228,4855,3185,2082,12481,2139,2114,132000,103707,6328,4154,146488,592,15769,8108,1834,839,2045,21368,4208,114814,6992,3203,140788,110131,19619,8109,2343,2289,10201,848,1584,7330,8964,1265,960,106159,100148,11017,7761,98421,15819,2493,97952,107255,12591,2778,108339,19825,6899,5043,2360,13927,5266,4444,399,101094,3864,1898,3227,116330,20795,968,113722,4061,99661,126664,131045,104105,101976,8972,102166,19977,19397,2613,19877,16347,765,125268,9098,141802,134761,21834,21036,16119,9549,3818,98090,144451,7536,109931,6994,2565,15159,1274,103924,21603,17707,2416,107340,102821,3259,1503,137729,1159,4418,142136,98785,5466,15093,115011,111954,108729,142173,116138,1267,146975,21635,4566,4242,116137,102718,119665,101877,12965,121567,111129,17379,106158,115143,13681,119938,5036,103050,126347,7290,14059,119548,15505,129591,102155,101789,10520,6038,367,9568,1937,1774,6375,2901,983,121177,9091,4202,2837,17147,9290,6331,111312,10735,137746,107175,104868,2027,9243,4068,146501,128737,127331,9078,8949,4298,101985,101425,10306,10104,7491,6028,118034,121508,111121,108986,3432,130362,2345,1741,100658,98093,13983,3752,1673,21024,8966,116793,108971,116053,5828,5246,117014,108730,108549,3849,104082,98208,21628,115238,112008,104104,4244,1905,120272,5865,988,102576,2380,110954,2840,100339,4946,2851,114919,214,113139,7667,4856,99715,2644,2442,113463,113273,7793,105873,101878,2342,1552,5203,3232,2707,126360,6939,3273,112452,12483,10524,10342,113419,14947,122672,107189,8409,129839,107623,4561,2601,120211,104385,20624,103333,9200,5237,3945,2916,132016,3529,120300,130033,10346,5640,4695,133146,131096,116320,9486,8547,1001,8550,7333,6230,3264,8815,5449,5006,137310,117034,3569,2187,2086,122652,114943,102168,21022,9244,7157,3587,135177,3547,2376,4489,108983,122205,18729,126888,115003,9163,8548,7664,7158,115931,115839,21023,7816,5629,15993,104957,8965,115907,139986,124472,122372,11268,3190,98383,16702,139212,121750,2085,12663,10743,9967,2080,1513,125153,9325,2375,1907,114679,109485,5411,7571,18669,8553,145210,12881,9773,3370,104292,10319,9340,5303,130787,114562,109415,9264,7294,5136,21344,4534,3726,8011,110346,102428,101879,21021,11919,8963,8145,4803,136110,8146,7775,4842,3762,2700,129202,1903,137742,102388,4586,8919,17963,2906,132903,132615,4129,98553,2537,137308,118630,99704,2689,129896,2501,134283,7427,6095,10443,9053,1745,141329,130445,113242,102619,18109,122689,2334,117325,17223,6277,2599,1872,124341,104027,16912,10751,3669,115794,99582,20563,12689,12485,110330,21267,4126,4967,3496,132893,114196,5344,4807,121663,118640,116789,116246,21847,18637,8156,8152,138351,126832,18061,134107,122670,6577,5956,122654,108332,119403,112453,6693,114557,102934,101498,17961,2480,1790,135381,112468,9344,7807,5289,142963,101880,12279,3768,117396,101881,104386,20821,9385,12439,11505,10028,6889,126350,122206,98751,20788,9013,4841,98297,145709,12351,3290,14367,11835,4509,2956,4729,110286,5396,3863,137296,98224,19959,12441,4400,3936,2208,142541,7488,2485,7446,5398,17989,11841,7164,8157,139588,117398,18375,112534,9972,2073,6107,104943,8431,4614,123056,117403,12569,2258,131239,9858,3884,2339,104328,5475,8443,3690,19271,11101,3274,2600,104468,18003,142216,108811,18063,3764,8678,135178,104388,10313,137728,133892,124960,6062,3280,126833,15865,9796,19879,6481,4190,12061,9857,9165,2643,126909,9365,8842,4848,2240,2192,130249,20235,15905,15875,6684,2464,137757,105049,18795,16131,9795,6434,10820,10373,9390,17165,8154,8153,19843,16393,119837,104067,9164,8252,4616,137738,15607,10199,7967,5472,101411,8314,5492,1851,136146,98586,9166,123778,117411,102664,102101,19755,143391,115908,110643,108309,8848,122675,118040,116150,13233,8227,7697,1850,133514,1892,21210,122207,18533,8155,2741,18425,9389,8707,136138,130584,112471,21227,20207,13433,7175,120055,104148,101431,143201,15937,8442,7626,130323,126908,8899,139179,125931,122208,138522,5190,131730,116805,112470,16371,10802,10525,9862,9376,9282,8493,8139,3028,13967,4388,3276,2710,136638,110331,16728,10202,8891,146310,104124,101523,139213,112156,20857,10625,8900,120321,108743,142549,122678,112449,16486,10114,9759,132321,103323,137097,115178,113180,9445,6518,138065,104469,98638,20855,14621,9403,10908,9528,143393,102941,17167,13431,5515,114111,102102,136517,13965,6297,113138,4682,3275,104932,104435,6482,5773,5240,107872,107859,102942,140645,109800,15815,7698,7601,3277,138716,137106,17237,11791,8357,3278,3279,2738,19687,136461,122062,117019,110245,109801,137739,20976,8956,118168,19337,14519,12971,9880,121433,2028,125822,21572,19781,19479,16510,134045,121514,16373,10409,5587,5564,3659,121998,106160,100655,18567,8356,7461,136666,130354,8524,126885,5571,126835,104553,21408,17159,109940,20175,13449,106162,9274,125514,113907,113689,21065,18241,17002,129540,15067,13207,109343,12563,8196,4905,6072,146664,114760,102562,2173,143485,5783,18815,15913,109340,104510,107627,17441,6133,119774,17445,14213,144687,130447,114560,106161,3769,9522,122690,121679,16377,9973,126757,17447,9416,130527,112006,17359,11959,9387,136641,116965,18199,13465,102057,145994,124435,109276,14067,10335,118637,115758,17443,8304,119939,140113,141878,120519,18937,141763,136139,112126,7980,126886,115836,102055,8897,6074,131329,18377,17163,10815,8180,7124,6156,124434,118200,7981,133469,125642,124027,19897,123379,122630,119345,104392,8417,119346,18573,17315,16988,10138,145985,122688,122687,117286,115345,109871,102777,102295,17479,16163,10285,8522,132477,125271,122758,117285,115824,105195,102552,21883,21418,10136,9451,9417,103360,17161,100654,6579,12497,11589,6583,5478,141877,116908,116790,105194,17825,109955,18941,18489,6517,20095,17263,16590,16460,10997,103423,102294,15897,117407,108988,18491,99534,87477,21346,8685,6524,141868,10061,9518,117284,102679,101179,17749,17066,10509,9533,10943,9885,114989,109193,102374,17753,17219,10000,134090,18939,17469,117409,107857,103424,10563,120378,116791,21768,16562,10059,4316,135443,129159,13365,10987,118245,109939,13781,10060,144779,120756,114244,107858,17086,16568,16490,14381,10040,6822,135535,103744,103359,102776,19751,18521,9797,9007,122241,7449,6630,141893,104131,102032,19587,18943,4314,129868,116801,116324,103361,21048,17605,17321,17215,11733,10244,10137,133730,116033,115895,102372,21810,20864,10684,10203,110272,103362,102778,102233,16748,14631,13827,10855,132444,125601,118119,102371,102296,18327,17317,17213,10685,7419,5776,133661,130247,125395,115759,115177,131741,128372,108745,103162,97954,19683,18583,11609,10057,141953,18357,16566,19433,16570,10139,10058,16480,13821,10056,9446,6760,5089,3500,139037,129045,122331,121714,98465,103970,18817,10247,126865,121300,119959,115825,18341,17104,6063,114559,102370,19839,17004,132530,126646,13499,10200,145406,125574,21367,18591,102373,8832,130619,3517,143264,136582,98764,98763,13505,145069,16908,16041,140787,132305,117287,107299,102780,21725,18355,10039,141866,138961,20081,13825,13819,8521,6762,127510,126643,119771,102432,10856,103465,16399,14069,145968,135580,119836,119794,16482,9388,131078,102366,10706,9464,138985,137758,132325,120831,119772,98765,13831,9818,6761,146631,126438,116784,126647,122044,110451,110273,109149,102912,102297,146632,137885,137745,119921,18577,17006,119784,116861,108728,102779,13511,9819,130211,124473,119541,116039,103987,141132,121299,103969,9447,145852,119919,102290,13509,138450,128019,103988,19325,13507,137743,121832,120324,103973,103971,18329,9749,8346,8192,139067,139062,123375,121835,131971,127180,126882,121297,121296,119922,119134,116966,104594,103960,145799,143553,137602,135536,131414,135572,126758,126605,120131,117246,116045,107301,103966,103964,12895,142806,19457,15069,137725,132938,121717,118202,103972,11731,142018,132655,121833,120126,103967,103963,103962,132697,104593,103351,131641,145958,129866,121823,121479,115864,109930,103992,103965,145857,121837,117163,107300,103756,131925,127996,126656,126318,121826,119925,116032,129649,126880,121825,11501,121082,102696,145841,131642,119347,128977,126606,122695,121084,129222,123119,121237,115763,111127,104466,103472,142730,116224,111028,103991,103990,103959,103723,103704,102383,121828,103989,103968,103961,145494,102396,145503,138804,129223,126881,121840,121838,121830,121822,121083,117000,146552,141880,132300,132698,121829,146171,143288,131957,130439,146865,140371,139351,135460,131567,128738,116160,120074,146397,143303,139020,132696,9820,146885,145557,135836,135278,133728,129634,129220,116222,133413,132694,139811,129221,126258,122691,121720,117001,116225,137747,137736,132268,129867,128979,126321,116046,114558,131732,130781,131927,130912,121074,121071,116050,116048,140377,132695,131926,121690,121075,140340,132343,130762,123113,122173,121085,119923,143294,131459,128739,121384,121293,121178,121072,145611,140955,140307,135585,132804,131884,131854,129230,129175,129157,121881,120231,131566,131564,129635,131563,131458,129652,13829,146541,141167,131574,130761,116998,139297,136546,131860,123115,121933,123120,121179,116999,104559,145829,131783,130675,130674,129844,121931,121388,121927,121860,145830,144852,141876,132312,131853,131589,129178,121861,121077,143307,141884,140370,131953,131859,131857,131855,131852,131592,131569,121935,121200,140022,138956,131892,131890,124397,123116,121199,145800,141858,141057,142480,140879,140036,139397,131886,131883,131728,131722,131594,131593,120510,131731,131729,131727,131726,131675,131597,131595,131591,129261,129212,121295,121201,109152,145563,145408,137741,136397,131955,131725,131604,131599,130561,129177,139678,131766,131649,115904,115903,102291,131753,131668,124439,119401,116996,134856,132512,131954,131754,131721,131590,130759,129600,119400,115905,145707,146347,145555,145479,139726,139622,131650,131015,130873,129584,129491,129216,124204,123028,119458,139669,136450,132515,129490,129489,129167,123139,119459,143548,139479,139353,132513,131781,131779,131778,131777,131776,131765,131570,129598,129478,129475,129382,129215,121221,146914,145823,145759,145751,145475,145353,139563,132348,131791,131648,131011,129597,129596,129594,129592,129587,129479,129300,116995,145553,145481,145477,139434,137339,136657,132517,131221,131014,129657,129593,129586,129568,129565,129554,129551,129548,129476,129302,129001,121224,121202,121198,145767,145766,145762,145705,145480,136635,129658,129599,129547,129365,129292,121233,145782,145781,145777,145776,145771,145765,145764,145761,145760,145746,145704,141309,131222,129659,129561,129556,129362,129359,129358,129301,129297,129293,129273,129217,147133,146583,146553,145778,145775,145774,145773,145772,145770,145769,145768,145763,141312,141311,139729,139728,129546,129495,129363,129360,129296,129168,145784,145783,145780,145779,129473,129274,121223, 9260,131573,114129,21875,21220,4107,393,1089,1096,44,15689,114317,21158,4059,985,893,502,984,3371,1170,1379,441,20159,16916,13411,20811,21624,6351,21386,21326,11701,20779,13851,5252,101695,7472]
)
const sequelList_manga = new Set([85199,103255,85522,137620,55515,87178,52651,97842,99549,114768,112673,103884,35157,30743,127231,86508,107267,91203,115166,48200,85617,87217,33008,31630,33006,30872,85216,52519,30081,85666,53751,86640,108817,102490,30092,30070,33403,30029,85151,47915,34941,30932,66903,118730,85611,31706,33009,104203,45242,103192,51151,111406,101863,103586,102423,98777,31260,112518,96626,33573,43277,98232,137278,69565,81857,118991,119767,31709,87296,81855,64053,85814,33574,71865,120796,86276,86569,30648,77363,39547,103252,49423,30027,103029,51499,99886,53900,54875,87232,87259,133104,114328,44115,138072,37760,116180,86637,124283,46081,74111,101864,114329,126445,95821,117802,61853,33526,103180,85604,85457,31258,86056,51498,86691,100774,46144,44531,30770,53661,129117,104896,109455,66131,126408,74227,30704,86652,31262,114528,98030,135129,143701,143726]
)

exportModule({
	id: "noSequel",
	description: "Add a 'hide sequels' filter option on the browse page",
	extendedDescription: `
Attemps to remove sequels and spinoffs from the results when active. This is a fuzzy problem, so the script will not always get it right, producing both false positives and false negatives.
	`,
	isDefault: true,
	importance: 1,
	categories: ["Browse","Newly Added"],
	visible: true,
	urlMatch: function(){
		return /^\/search\/anime/.test(location.pathname) || /^\/search\/manga/.test(location.pathname)
	},
	code: function(){
		let optionInserter = function(){
			if(!(/^\/search\/anime/.test(location.pathname) || /^\/search\/manga/.test(location.pathname))){
				return
			}
			let place = document.querySelector(".primary-filters .filters");
			if(!place){
				setTimeout(optionInserter,500);
				return
			};
			place.style.position = "relative";
			if(document.querySelector(".hohNoSequelSetting")){
				return
			}
			let setting = create("span","hohNoSequelSetting",false,place);
			let input = createCheckbox(setting);
			input.classList.add("hohNoSequelSetting_input");
			input.checked = useScripts.noSequel_value;
			input.onchange = function(){
				useScripts.noSequel_value = this.checked;
				useScripts.save();
			}
			create("span",false,translate("$hideSequels"),setting);
			let remover = setInterval(function(){
				if(!(/^\/search\/anime/.test(location.pathname) || /^\/search\/manga/.test(location.pathname))){
					clearInterval(remover);
					return
				}
				let input = document.querySelector(".hohNoSequelSetting_input");
				if(!input){
					clearInterval(remover);
					return
				}
				Array.from(document.querySelectorAll(".media-card")).forEach(hit => {
					let link = hit.querySelector(".cover");
					if(link){
						let id = (link.href || "").match(/(anime|manga)\/(\d+)\//);
						if(id && id[2]){
							id = parseInt(id[2]);
							if((sequelList.has(id) || sequelList_manga.has(id)) && input.checked){
								hit.classList.add("hohHiddenSequel")
							}
							else{
								hit.classList.remove("hohHiddenSequel")
							}
						}
					}
				})
			},500)
		};
		optionInserter()
	},
	css: ".hohHiddenSequel{display: none!important}"
})
//end modules/noSequel.js
//begin modules/notificationCake.js
function notificationCake(){
	let notificationDot = document.querySelector(".notification-dot");
	if(notificationDot && (!notificationDot.childElementCount)){
		authAPIcall(
			queryAuthNotifications,
			{page:1,name:whoAmI},
			function(data){
				if(!data){
					return
				}
				let Page = data.data.Page;
				let User = data.data.User;
				let types = [];
				let names = [];
				Page.notifications.slice(0,User.unreadNotificationCount).forEach(notification => {
					if(!notification.type){//probably obsolete, remove later
						notification.type = "THREAD_SUBSCRIBED"
					}
					if(notification.user && !useScripts.notificationColours[notification.type].supress){
						if(!notification.user || useScripts.softBlock.indexOf(notification.user.name) === -1){
							names.push((notification.user || {name:""}).name)
						}
					}
					if(!useScripts.notificationColours[notification.type] || !useScripts.notificationColours[notification.type].supress){
						if(!notification.user || useScripts.softBlock.indexOf(notification.user.name) === -1){
							types.push(notification.type)
						}
					}
				})
				if(types.length){
					let notificationCake = create("canvas","hohNotificationCake");
					notificationCake.width = 120;
					notificationCake.height = 120;
					notificationCake.style.width = "30px";
					notificationCake.style.height = "30px";
					notificationDot.innerText = "";
					notificationDot.style.background = "none";
					notificationDot.style.width = "30px";
					notificationDot.style.height = "30px";
					notificationDot.style.borderRadius = "0";
					notificationDot.style.left = "5px";
					notificationDot.style.marginRight = "-3px";
					notificationDot.appendChild(notificationCake);
					let cakeCtx = notificationCake.getContext("2d");
					cakeCtx.fillStyle = "red";
					cakeCtx.textAlign = "center";
					cakeCtx.fontWeight = "500";
					cakeCtx.font = 50 + "px sans-serif";
					types.forEach(function(type,i){
						cakeCtx.fillStyle = (useScripts.notificationColours[type] || {"colour":"rgb(247,191,99)","supress":false}).colour;
						cakeCtx.beginPath();
						cakeCtx.arc(
							60,60,
							40,
							Math.PI * (2*i/types.length - 0.5),
							Math.PI * (2*(i+1)/types.length - 0.5)
						);
						cakeCtx.lineTo(60,60);
						cakeCtx.closePath();
						cakeCtx.fill()
					});
					cakeCtx.fillStyle = "#fff2f2";
					cakeCtx.fillText(User.unreadNotificationCount,60,76);
					notificationCake.innerText = types.length;
					notificationCake.title = names.join("\n");
					let poller = function(){
						if(!document.querySelector(".hohNotificationCake")){
							try{
								notificationCake();
							}catch(err){ /*do nothing*/ }
						}
						else{
							setTimeout(poller,4000);
						}
					};poller();
					if(!document.querySelector(".hohDismiss") && useScripts.dismissDot){
						let dismisser = create("span","hohDismiss",".",notificationDot.parentNode);
						dismisser.title = "Dismiss notifications";
						dismisser.onclick = function(){
							authAPIcall("query{Notification(resetNotificationCount:true){... on ActivityLikeNotification{id}}}",{},function(data){
								dismisser.previousSibling.style.display = "none";
								dismisser.style.display = "none"
							})
						}
					}
				}
				else{
					notificationDot.style.display = "none";
					if(User.unreadNotificationCount){
						authAPIcall("query{Notification(resetNotificationCount:true){... on ActivityLikeNotification{id}}}",{},function(data){})
					}
				}
			}
		)
	}
}

if(useScripts.accessToken && !useScripts.mobileFriendly){
	setInterval(notificationCake,4*1000)
}
//end modules/notificationCake.js
//begin modules/notifications.js
exportModule({
	id: "notifications",
	description: "$setting_notifications",
	extendedDescription: `
Performs several changes to notifications:

- Similar consecutive notifications are grouped.
- Notifications get tagged with the cover image of the media they apply to. (or profile picture, if it's a status post)
- Notifications may have a preview of the comments on the activity.

If you for any reason need the default look, you can click the "Show default notifications" to the left on the page.
	`,
	isDefault: true,
	importance: 10,
	categories: ["Notifications","Login"],
	visible: true
})

let prevLength = 0;
let displayMode = "hoh";

let reasons = new Map();

function enhanceNotifications(forceFlag){
	//method: the real notifications are parsed, then hidden and a new list of notifications are created using a mix of parsed data and API calls.
	//alternative method: auth (not implemented)
	setTimeout(function(){
		if((location.pathname === "/notifications" || location.pathname === "/notifications#") && !(useScripts.accessToken && false)){
			enhanceNotifications()
		}
		else{
			prevLength = 0;
			displayMode = "hoh"
		}
	},300);
	if(displayMode === "native"){
		return
	}
	if(document.getElementById("hohNotifications") && !forceFlag){
		return
	}
	let possibleButton = document.querySelector(".reset-btn");
	if(possibleButton){
		if(!possibleButton.flag){
			possibleButton.flag = true;
			if(useScripts.additionalTranslation){
				possibleButton.childNodes[0].textContent = translate("$notifications_button_reset")
			}
			possibleButton.onclick = function(){
				Array.from(
					document.getElementById("hohNotifications").children
				).forEach(child => {
					child.classList.remove("hohUnread")
				})
			};
			let regularNotifications = create("span",false,svgAssets.envelope + " " + translate("$notifications_showDefault"),possibleButton.parentNode,"cursor: pointer;font-size: small");
			let setting = create("p",false,false,possibleButton.parentNode,"cursor: pointer;font-size: small");
			let checkbox = createCheckbox(setting);
			checkbox.checked = useScripts["hideLikes"];
			checkbox.targetSetting = "hideLikes";
			checkbox.onchange = function(){
				useScripts[this.targetSetting] = this.checked;
				useScripts.save();
				forceRebuildFlag = true;
				enhanceNotifications(true)
			};
			let description = create("span",false,translate("$notifications_hideLike"),setting);
			setting.style.fontSize = "small";
			let softBlockSpan = create("span",false,translate("$notifications_softBlock"),possibleButton.parentNode,"cursor: pointer;font-size: small;display: block;margin: 10px 0px;");
			softBlockSpan.onclick = function(){
				let manager = createDisplayBox("width:600px;height:500px;top:100px;left:220px","Soft block");
				create("p",false,translate("$notifications_softBlock_description1"),manager);
				create("p",false,translate("$notifications_softBlock_description1"),manager);
				create("p",false,translate("$notifications_softBlock_description1"),manager);
				let form = create("div",false,false,manager);
				create("span",false,"Username: ",form);
				let userInput = create("input","hohNativeInput",false,form);
				let userAdd = create("button","hohButton",translate("$button_add"),form,"margin-left: 10px");
				let userList = create("div",false,false,manager);
				let renderSoftBlock = function(){
					removeChildren(userList);
					useScripts.softBlock.forEach((user,index) => {
						let item = create("p",false,false,userList,"position: relative");
						create("span",false,user,item);
						let removeButton = create("span","hohDisplayBoxClose",svgAssets.cross,item,"top: 0px");
						removeButton.onclick = function(){
							useScripts.softBlock.splice(index,1);
							useScripts.save();
							renderSoftBlock();
							forceRebuildFlag = true;
							enhanceNotifications(true)
						}
					})
				}
				renderSoftBlock();
				userAdd.onclick = function(){
					if(userInput.value){
						useScripts.softBlock.push(userInput.value);
						renderSoftBlock();
						useScripts.save();
						userInput.value = "";
						forceRebuildFlag = true;
						enhanceNotifications(true)
					}
				}
			}
			if(useScripts.settingsTip){
				create("p",false,
`You can turn parts of the script on and off:
settings > apps.

You can also turn off this notice there.`,setting)
			}
			regularNotifications.onclick = function(){
				if(displayMode === "hoh"){
					displayMode = "native";
					let hohNotsToToggle = document.getElementById("hohNotifications");
					if(hohNotsToToggle){
						hohNotsToToggle.style.display = "none"
					}
					Array.from(
						document.getElementsByClassName("notification")
					).forEach(elem => {
						elem.style.display = "grid"
					})
					regularNotifications.innerText = svgAssets.envelope + " " + translate("$notifications_showHoh");
					setting.style.display = "none"
				}
				else{
					displayMode = "hoh";
					let hohNotsToToggle = document.getElementById("hohNotifications");
					if(hohNotsToToggle){
						hohNotsToToggle.style.display = "block"
					}
					Array.from(
						document.getElementsByClassName("notification")
					).forEach(elem => {
						elem.style.display = "none"
					})
					regularNotifications.innerText = svgAssets.envelope + " " + translate("$notifications_showDefault");
					setting.style.display = ""
				}
			};
			try{
				document.querySelector(".group-header + .link").onclick = function(){
					enhanceNotifications()
				}
			}
			catch(e){
				console.warn("Unexpected Anilist UI. Is " + script_type + " up to date?")
			}
		}
	}
	let commentCallback = function(data){
		let listOfComments = Array.from(document.getElementsByClassName("b" + data.data.Activity.id));
		listOfComments.forEach(function(comment){
			removeChildren(comment.children[1])
			comment.children[0].style.display = "block";
			data.data.Activity.replies.slice(
				(data.data.Activity.replies.length <= 50 ? 0 : data.data.Activity.replies.length - 30),
				data.data.Activity.replies.length
			).forEach(function(reply){
				let quickCom = create("div","hohQuickCom",false,comment.children[1]);
				let quickComName = create("span","hohQuickComName",reply.user.name,quickCom);
				if(reply.user.name === whoAmI){
					quickComName.classList.add("hohThisIsMe")
				}
				let quickComContent = create("span","hohQuickComContent",false,quickCom);
				quickComContent.innerHTML = DOMPurify.sanitize(reply.text) //reason for innerHTML: preparsed sanitized HTML from the Anilist API
				let quickComLikes = create("span","hohQuickComLikes","♥",quickCom);
				if(reply.likes.length > 0){
					quickComLikes.innerText = reply.likes.length + "♥";
					quickComLikes.title = reply.likes.map(a => a.name).join("\n")
				}
				reply.likes.forEach(like => {
					if(like.name === whoAmI){
						quickComLikes.classList.add("hohILikeThis")
					}
				});
				if(useScripts.accessToken){
					quickComLikes.style.cursor = "pointer";
					quickComLikes.onclick = function(){
						authAPIcall(
							"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
							{id: reply.id},
							function(data){
								if(!data){
									authAPIcall(//try again once if it fails
										"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
										{id: reply.id},
										data => {}
									)
								}
							}
						);
						if(reply.likes.some(like => like.name === whoAmI)){
							reply.likes.splice(reply.likes.findIndex(user => user.name === whoAmI),1);
							quickComLikes.classList.remove("hohILikeThis");
							if(reply.likes.length > 0){
								quickComLikes.innerText = reply.likes.length + "♥"
							}
							else{
								quickComLikes.innerText = "♥"
							}
						}
						else{
							reply.likes.push({name: whoAmI});
							quickComLikes.classList.add("hohILikeThis");
							quickComLikes.innerText = reply.likes.length + "♥"
						}
						quickComLikes.title = reply.likes.map(a => a.name).join("\n")
					}
				}
			});
			let loading = create("div",false,false,comment.children[1]);
			let statusInput = create("div",false,false,comment.children[1]);
			let inputArea = create("textarea",false,false,statusInput,"width: 99%;border-width: 1px;padding: 4px;border-radius: 2px;color: rgb(159, 173, 189);");
			let cancelButton = create("button",["hohButton","button"],"Cancel",statusInput,"background:rgb(31,35,45);display:none;color: rgb(159, 173, 189);");
			let publishButton = create("button",["hohButton","button"],"Publish",statusInput,"display:none;");
			inputArea.placeholder = translate("$placeholder_reply");
			inputArea.onfocus = function(){
				cancelButton.style.display = "inline";
				publishButton.style.display = "inline"
			};
			cancelButton.onclick = function(){
				inputArea.value = "";
				cancelButton.style.display = "none";
				publishButton.style.display = "none";
				document.activeElement.blur()
			};
			publishButton.onclick = function(){
				loading.innerText = translate("$publishingReply");
				authAPIcall(
					`mutation($text: String,$activityId: Int){
						SaveActivityReply(text: $text,activityId: $activityId){
							id
							user{name}
							likes{name}
							text(asHtml: true)
							createdAt
						}
					}`,
					{text: inputArea.value,activityId: data.data.Activity.id},
					function(retur){
						loading.innerText = "";
						data.data.Activity.replies.push({
							text: retur.data.SaveActivityReply.text,
							user: retur.data.SaveActivityReply.user,
							likes: retur.data.SaveActivityReply.likes,
							id: retur.data.SaveActivityReply.id
						});
						let saltedHam = JSON.stringify({
							data: data,
							time: NOW(),
							duration: 24*60*60*1000
						});
						localStorage.setItem("hohListActivityCall" + data.data.Activity.id,saltedHam);
						commentCallback(data);
					}
				);
				inputArea.value = "";
				cancelButton.style.display = "none";
				publishButton.style.display = "none";
				document.activeElement.blur()
			}
		})
	};
	let findAct = function(act){
		let modi = document.querySelector("#hohNotifications [href='" + act.href + "'");
		let ide = act.href.match(/(anime|manga)\/(\d+)\//);
		if(modi){
			modi.parentNode.querySelector(".hohDataChange").innerHTML = DOMPurify.sanitize(act.text);
			if(!modi.parentNode.querySelector(".reason-markdown")){
				if(ide && reasons.has(parseInt(ide[2]))){
					let text = reasons.get(parseInt(ide[2]));
					let anchor = modi.parentNode.querySelector(".hohDataChange").children[0];
					let cont = create("div","reason-markdown",false,anchor);
					let contCont = create("div","markdown",false,cont);
					create("p",false,text,contCont)
				}
			}
			else if(ide){
				reasons.set(parseInt(ide[2]),modi.parentNode.querySelector(".reason-markdown p").innerText)
			}
		}
	}
	let notificationDrawer = function(activities){
		let newContainer = document.getElementById("hohNotifications")
		if(newContainer){
			newContainer.remove()
		}
		newContainer = create("div","#hohNotifications");
		let notificationsContainer = document.querySelector(".notifications");
		if(!notificationsContainer){
			return
		}
		notificationsContainer.insertBefore(newContainer,notificationsContainer.firstChild);
		activities = activities.filter(
			activity => !(
				activity.textName
				&& useScripts.softBlock.includes(activity.textName)
			)
		);
		for(let i=0;i<activities.length;i++){
			if(useScripts.hideLikes && (activities[i].type === "likeReply" || activities[i].type === "like")){
				continue
			}
			let newNotification = create("div");
			newNotification.onclick = function(){
				this.classList.remove("hohUnread");
				let notiCount = document.getElementsByClassName("notification-dot");
				if(notiCount.length){
					const actualCount = parseInt(notiCount[0].textContent);
					if(actualCount < 2){
						if(possibleButton){
							possibleButton.click()
						}
					}
					else{
						notiCount[0].innerText = (actualCount - 1)
					}
				}
			};
			if(activities[i].unread){
				newNotification.classList.add("hohUnread")
			}
			newNotification.classList.add("hohNotification");
			let notImage = create("a","hohUserImage"); //container for profile images
			notImage.href = activities[i].href;
			notImage.style.backgroundImage = activities[i].image;
			let notNotImageContainer = create("span","hohMediaImageContainer"); //container for series images
			let text = create("a","hohMessageText");
			let textName = create("span");
			let textSpan = create("span");
			textName.style.color = "rgb(var(--color-blue))";
			let counter = 1;
			if(activities[i].type === "like"){
				for(
					counter = 0;
					i + counter < activities.length
					&& activities[i + counter].type === "like"
					&& activities[i + counter].href === activities[i].href;
					counter++
				){//one person likes several of your media activities
					let notNotImage = create("a",false,false,notNotImageContainer);
					create("img",["hohMediaImage",activities[i + counter].link],false,notNotImage);
					notNotImage.href = activities[i + counter].directLink;
					let possibleDirect = activities[i + counter].directLink.match(/activity\/(\d+)/);
					if(possibleDirect){
						cheapReload(notNotImage,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
					}
				}
				text.href = activities[i].directLink;
				let possibleDirect = activities[i].directLink.match(/activity\/(\d+)/);
				if(possibleDirect){
					cheapReload(text,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
				}
				textSpan.innerText = translate("$notification_likeActivity_1person_1activity");
				if(counter > 1){
					textSpan.innerText = translate("$notification_likeActivity_1person_Mactivity")
				}
				if(counter === 1){
					while(
						i + counter < activities.length
						&& activities[i + counter].type === "like"
						&& activities[i + counter].link === activities[i].link
					){//several people likes one of your activities
						let miniImageWidth = 40;
						let miniImage = create("a","hohUserImageSmall",false,newNotification);
						miniImage.href = activities[i + counter].href;
						miniImage.title = activities[i + counter].textName;
						miniImage.style.backgroundImage = activities[i + counter].image;
						miniImage.style.height = miniImageWidth + "px";
						miniImage.style.width = miniImageWidth + "px";
						miniImage.style.left = (72 + (counter - 1)*miniImageWidth) + "px";
						if(counter >= 8){
							miniImage.style.height = miniImageWidth/2 + "px";
							miniImage.style.width = miniImageWidth/2 + "px";
							miniImage.style.left = (72 + 7*miniImageWidth + Math.ceil((counter - 9)/2)/2 * miniImageWidth) + "px";
							if(counter % 2 === 1){
								miniImage.style.top = miniImageWidth/2 + "px"
							}
						}
						counter++;
					}
					if(counter === 2){
						text.style.marginTop = "45px";
						activities[i].textName += " & " + activities[i+1].textName;
						textSpan.innerText = translate("$notification_likeActivity_2person_1activity")
					}
					else if(counter > 2){
						text.style.marginTop = "45px";
						activities[i].textName += " +" + (counter - 1);
						textSpan.innerText = translate("$notification_likeActivity_Mperson_1activity")
					}
				}
				else{
					newNotification.classList.add("hohCombined")
				}
				textName.innerText = activities[i].textName;
				text.appendChild(textName);
				text.appendChild(textSpan);
				i += counter -1
			}
			else if(activities[i].type === "reply" ){
				let notNotImage = create("a",false,false,notNotImageContainer);
				create("img",["hohMediaImage",activities[i].link],false,notNotImage);
				notNotImage.href = activities[i].directLink;
				let samePerson = true;
				while(
					i + counter < activities.length
					&& activities[i + counter].type === "reply"
					&& activities[i + counter].link === activities[i].link
				){
					let miniImageWidth = 40;
					let miniImage = create("a","hohUserImageSmall",false,newNotification);
					miniImage.href = activities[i + counter].href;
					miniImage.style.backgroundImage = activities[i + counter].image;
					miniImage.style.height = miniImageWidth + "px";
					miniImage.style.width = miniImageWidth + "px";
					miniImage.style.left = (72 + (counter - 1)*miniImageWidth) + "px";
					if(counter >= 8){
						miniImage.style.height = miniImageWidth/2 + "px";
						miniImage.style.width = miniImageWidth/2 + "px";
						miniImage.style.left = (72 + 7*miniImageWidth + Math.ceil((counter - 9)/2)/2 * miniImageWidth) + "px";
						if(counter % 2 === 1){
							miniImage.style.top = miniImageWidth/2 + "px"
						}
					}
					if(activities[i].textName !== activities[i + counter].textName){
						samePerson = false
					}
					counter++
				}
				textSpan.innerText = translate("$notification_reply_1person_1reply");
				if(samePerson){
					if(counter > 1){
						text.style.marginTop = "45px";
						activities[i].textName += " x" + counter;
						textSpan.innerText = translate("$notification_reply_1person_1reply")
					}
				}
				else{
					if(counter === 2){
						text.style.marginTop = "45px";
						activities[i].textName += " & " + activities[i+1].textName;
						textSpan.innerText = translate("$notification_reply_2person_1reply")
					}
					else if(counter > 2){
						text.style.marginTop = "45px";
						activities[i].textName += " +" + (counter-1);
						textSpan.innerText = translate("$notification_reply_Mperson_1reply")
					}
				}
				text.href = activities[i].directLink;
				let possibleDirect = activities[i].directLink.match(/activity\/(\d+)/);
				if(possibleDirect){
					cheapReload(text,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
					cheapReload(notNotImage,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
				}
				textName.innerText = activities[i].textName;
				text.appendChild(textName);
				text.appendChild(textSpan);
				i += counter -1
			}
			else if(activities[i].type === "replyReply" ){
				let notNotImage = create("a",false,false,notNotImageContainer);
				create("img",["hohMediaImage",activities[i].link],false,notNotImage);
				notNotImage.href = activities[i].directLink;
				let samePerson = true;
				while(
					i + counter < activities.length
					&& activities[i + counter].type === "replyReply"
					&& activities[i + counter].link === activities[i].link
				){
					let miniImageWidth = 40;
					let miniImage = create("a","hohUserImageSmall",false,newNotification);
					miniImage.href = activities[i + counter].href;
					miniImage.title = activities[i + counter].textName;
					miniImage.style.backgroundImage = activities[i + counter].image;
					miniImage.style.height = miniImageWidth + "px";
					miniImage.style.width = miniImageWidth + "px";
					miniImage.style.left = (72 + (counter-1)*miniImageWidth) + "px";
					if(counter >= 8){
						miniImage.style.height = miniImageWidth/2 + "px";
						miniImage.style.width = miniImageWidth/2 + "px";
						miniImage.style.left = (72 + 7*miniImageWidth + Math.ceil((counter - 9)/2)/2 * miniImageWidth) + "px";
						if(counter % 2 === 1){
							miniImage.style.top = miniImageWidth/2 + "px"
						}
					}
					if(activities[i].textName !== activities[i + counter].textName){
						samePerson = false
					}
					counter++
				}
				textSpan.innerText = translate("$notification_replyReply_1person_1reply");
				if(samePerson){
					if(counter > 1){
						text.style.marginTop = "45px";
						activities[i].textName += " x" + counter
					}
				}
				else{
					if(counter === 2){
						text.style.marginTop = "45px";
						activities[i].textName += " & " + activities[i+1].textName
					}
					else if(counter > 2){
						text.style.marginTop = "45px";
						activities[i].textName += " +" + (counter-1)
					}
				}
				text.href = activities[i].directLink;
				let possibleDirect = activities[i].directLink.match(/activity\/(\d+)/);
				if(possibleDirect){
					cheapReload(text,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
					cheapReload(notNotImage,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
				}
				textName.innerText = activities[i].textName;
				text.appendChild(textName);
				text.appendChild(textSpan);
				i += counter -1
			}
			else if(
				activities[i].type === "likeReply"
			){
				let notNotImage = create("a",false,false,notNotImageContainer);
				create("img",["hohMediaImage",activities[i].link],false,notNotImage);
				notNotImage.href = activities[i].directLink;
				let samePerson = true;
				while(
					i + counter < activities.length
					&& activities[i + counter].type === "likeReply"
					&& activities[i + counter].link === activities[i].link
				){//several people likes one of your activity replies
					let miniImageWidth = 40;
					let miniImage = create("a","hohUserImageSmall",false,newNotification);
					miniImage.href = activities[i + counter].href;
					miniImage.title = activities[i + counter].textName;
					miniImage.style.backgroundImage = activities[i + counter].image;
					miniImage.style.height = miniImageWidth + "px";
					miniImage.style.width = miniImageWidth + "px";
					miniImage.style.left = (72 + (counter - 1)*miniImageWidth) + "px";
					if(counter >= 8){
						miniImage.style.height = miniImageWidth/2 + "px";
						miniImage.style.width = miniImageWidth/2 + "px";
						miniImage.style.left = (72 + 7*miniImageWidth + Math.ceil((counter - 9)/2)/2 * miniImageWidth) + "px";
						if(counter % 2 === 1){
							miniImage.style.top = miniImageWidth/2 + "px"
						}
					}
					if(activities[i].textName !== activities[i + counter].textName){
						samePerson = false
					}
					counter++
				}
				textSpan.innerText = translate("$notification_likeReply_1person_1reply");
				if(samePerson){
					if(counter > 1){
						text.style.marginTop = "45px";
						activities[i].textName += " x" + counter;
						textSpan.innerText = translate("$notification_likeReply_1person_Mreply")
					}
				}
				else{
					if(counter === 2){
						text.style.marginTop = "45px";
						activities[i].textName += " & " + activities[i+1].textName;
						textSpan.innerText = translate("$notification_likeReply_2person_1reply")
					}
					else if(counter > 2){
						text.style.marginTop = "45px";
						activities[i].textName += " +" + (counter-1);
						textSpan.innerText = translate("$notification_likeReply_Mperson_1reply")
					}
				}
				text.href = activities[i].directLink;
				let possibleDirect = activities[i].directLink.match(/activity\/(\d+)/);
				if(possibleDirect){
					cheapReload(text,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
					cheapReload(notNotImage,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
				}
				textName.innerText = activities[i].textName;
				text.appendChild(textName);
				text.appendChild(textSpan);
				i += counter -1
			}
			else if(
				activities[i].type === "message"
				|| activities[i].type === "mention"
			){
				let notNotImage = create("a",false,false,notNotImageContainer);
				create("img",["hohMediaImage",activities[i].link],false,notNotImage);
				notNotImage.href = activities[i].directLink;
				text.href = activities[i].directLink;
				let possibleDirect = activities[i].directLink.match(/activity\/(\d+)/);
				if(possibleDirect){
					cheapReload(text,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
					cheapReload(notNotImage,{name: "Activity", params: {id: parseInt(possibleDirect[1])}});
				}
				textName.innerText = activities[i].textName;
				if(activities[i].type === "message"){
					textSpan.innerText = translate("$notification_message")
				}
				else{
					textSpan.innerText = translate("$notification_mention")
				}
				text.appendChild(textName);
				text.appendChild(textSpan)
			}
			else if(activities[i].type === "airing"){
				textSpan.innerHTML = DOMPurify.sanitize(activities[i].text);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
				text.appendChild(textSpan);
				if(useScripts.partialLocalisationLanguage !== "English"){
					let episodeNumber = parseInt(textSpan.childNodes[1].textContent.trim());
					let episodeLink = textSpan.childNodes[4].outerHTML;
					if(episodeNumber){
						textSpan.innerHTML = DOMPurify.sanitize(translate("$notification_airing",[episodeNumber,episodeLink]));//reason for innerHTML: preparsed sanitized HTML from the Anilist API
					}
				}
			}
			else if(activities[i].type === "follow"){
				text.href = activities[i].directLink;
				textName.innerText = activities[i].textName;
				textSpan.innerText = activities[i].textSpan;
				text.appendChild(textName);
				text.appendChild(textSpan)
			}
			else if(
				activities[i].type === "forumCommentLike"
				|| activities[i].type === "forumSubscribedComment"
				|| activities[i].type === "forumCommentReply"
				|| activities[i].type === "forumLike"
				|| activities[i].type === "forumMention"
			){
				text.href = activities[i].directLink;
				textName.innerText = activities[i].textName;
				textSpan.innerText = activities[i].textSpan;
				text.appendChild(textName);
				text.appendChild(textSpan);
				let textSpan2 = create("span",false,activities[i].text,text,"color:rgb(var(--color-blue));");
				if(activities[i].text === ""){
					if(activities[i].type === "forumSubscribedComment"){
						textSpan.innerText = " commented in your subscribed forum thread "
					}
					else if(activities[i].type === "forumCommentLike"){
						textSpan.innerText = " liked your comment, in a "
					}
					else if(activities[i].type === "forumCommentReply"){
						textSpan.innerText = " replied to your comment, in a "
					}
					else if(activities[i].type === "forumLike"){
						textSpan.innerText = " liked your "
					}
					else if(activities[i].type === "forumMention"){
						textSpan.innerText = " mentioned you, in a "
					}
					textSpan2.innerText = "[deleted thread]";
					text.href = "#"
				}
				if(activities[i].type === "forumCommentLike"){
					textSpan.innerText = translate("$notification_forumCommentLike")
				}
				else if(activities[i].type === "forumMention"){
					textSpan.innerText = translate("$notification_forumMention")
				}
				text.style.maxWidth = "none";
				text.style.marginTop = "17px"
			}
			else if(activities[i].type === "newMedia"){
				textSpan.classList.add("hohNewMedia");
				textSpan.innerHTML = DOMPurify.sanitize(activities[i].text);
				textSpan.querySelector(".context").innerText = translate("$notification_newMedia");
				text.appendChild(textSpan);
				notImage.style.width = "51px";
				text.href = activities[i].href
			}
			else if(activities[i].type === "dataChange"){
				textSpan.classList.add("hohDataChange");
				text.href = activities[i].href;
				notImage.classList.remove("hohUserImage");
				notImage.classList.add("hohBackgroundCover");
				textSpan.innerHTML = DOMPurify.sanitize(activities[i].text);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
				text.style.marginTop = "10px";
				text.style.marginLeft = "10px";
				text.appendChild(textSpan)
			}
			else{//display as-is
				textSpan.classList.add("hohUnhandledSpecial");
				textSpan.innerHTML = DOMPurify.sanitize(activities[i].text);//reason for innerHTML: preparsed sanitized HTML from the Anilist API
				text.appendChild(textSpan)
			}
			newNotification.appendChild(notImage);
			newNotification.appendChild(text);
			newNotification.appendChild(notNotImageContainer);
			let time = create("div","hohTime");
			if(activities[i - counter + 1].time){
				time.appendChild(nativeTimeElement(activities[i - counter + 1].time))
			}
			newNotification.appendChild(time);
			let commentsContainer = create("div",["hohCommentsContainer","b" + activities[i].link]);
			let comments = create("a",["hohComments","link"],translate("$notifications_comments"),commentsContainer);
			create("span","hohMonospace","+",comments);
			comments.onclick = function(){
				if(this.children[0].innerText === "+"){
					this.children[0].innerText = "-";
					this.parentNode.children[1].style.display = "inline-block";
					let variables = {
						id: +this.parentNode.classList[1].substring(1)
					};
					generalAPIcall(queryActivity,variables,commentCallback,"hohListActivityCall" + variables.id,24*60*60*1000,true,true)
				}
				else{
					this.children[0].innerText = "+";
					this.parentNode.children[1].style.display = "none"
				}
			};
			let commentsArea = create("div","hohCommentsArea",false,commentsContainer);
			newNotification.appendChild(commentsContainer)
			newContainer.appendChild(newNotification)
		}
	};
	let activities = [];
	let notifications = document.getElementsByClassName("notification");//collect the "real" notifications
	if(notifications.length === prevLength && forceRebuildFlag === false){
		return
	}
	else{
		prevLength = notifications.length;
		forceRebuildFlag = false
	}
	const activityTypes = {
		" liked your activity." :                           "like",
		" replied to your activity." :                      "reply",
		" sent you a message." :                            "message",
		" liked your activity reply." :                     "likeReply",
		" mentioned you in their activity." :               "mention",
		" replied to activity you're subscribed to." :      "replyReply",
		" liked your comment, in the forum thread " :       "forumCommentLike",
		" commented in your subscribed forum thread " :     "forumSubscribedComment",
		" replied to your comment, in the forum thread " :  "forumCommentReply",
		" liked your forum thread, " :                      "forumLike",
		" mentioned you, in the forum thread " :            "forumMention"
	};
	let mutationConfig = {
		attributes: false,
		childList: true,
		subtree: false
	};
	let observer = new MutationObserver(function(){
		enhanceNotifications(true)
	});
	observer.observe(document.querySelector(".page-content .notifications"),mutationConfig);
	if(useScripts.accessToken && reasons.size === 0){
		authAPIcall(`query{
    Page{
    notifications(type_in:[MEDIA_DATA_CHANGE,MEDIA_MERGE,MEDIA_DELETION]){
      ... on MediaMergeNotification{
        reason mediaId
      }
      ... on MediaDeletionNotification{
        reason
      }
      ... on MediaDataChangeNotification{
        reason mediaId
      }
    }
  }
}`,{},function(data){
			data.data.Page.notifications.forEach(noti => {
				if(noti.mediaId){
					reasons.set(noti.mediaId,noti.reason)
				}
			});
		})
	}
	Array.from(notifications).forEach(function(notification){//parse real notifications
		notification.already = true;
		notification.style.display = "none";
		let active = {
			type: "special",
			unread: false,
			link: "aaa",//fixme. Edit 2019: I have no idea
			image: notification.children[0].style.backgroundImage,
			href: notification.children[0].href
		};
		if(
			notification.classList.length > 1
			&& notification.classList[1] !== "hasMedia"
		){//"notification unread" classlist
			active.unread = true
		}
		if(//check if we can query that
			notification.children.length >= 2
			&& notification.children[1].children.length
			&& notification.children[1].children[0].children.length
			&& notification.children[1].children[0].children[0].children.length
		){
			//TODO replace this with document.querySelector?
			const info = notification.children[1].children[0].children[0];
			if(info.href){
				active.directLink = info.href
				let linkMatch =     info.href.match(/activity\/(\d+)/);
				if(linkMatch){
					active.link = linkMatch[1]
				}
			}
			active.text =       info.innerHTML;//does not depend on user input
			active.textName =   (info.childNodes[0] || {textContent: ""}).textContent.trim();
			active.textSpan =   (info.childNodes[1] || {textContent: ""}).textContent;
			let testType = info.children[0].textContent;
			active.type = activityTypes[testType];
			if(!active.type){
				active.type = "special"
				//by default every activity is some weird thing we are displaying as-is
				//makes the transition more smooth every time Anilist introduces a new type of notification
			}
			else if(
				active.type === "forumCommentLike"
				|| active.type === "forumSubscribedComment"
				|| active.type === "forumCommentReply"
				|| active.type === "forumLike"
				|| active.type === "forumMention"
			){
				active.text = (info.children[1] || {textContent: ""}).textContent
			}
		}
		else{
			if(notification.innerText.includes("was recently added to the site")){
				active.type = "newMedia";
				active.text = notification.children[1].innerHTML
			}
			else if(notification.innerText.includes("received site data changes")){
				active.type = "dataChange";
				notification.querySelector(".expand-reason").click();
				setTimeout(function(){
					active.text = notification.children[1].innerHTML;
					findAct(active);
				},100);
			}
		}
		if(active.type === "special"){
			active.text = notification.children[1].innerHTML;//does not depend on user input
			if(notification.children[1].children.length){
				const info = notification.children[1].children[0];
				if(
					info.children.length >= 2
					&& (info.children[1] || {textContent: ""}).textContent === " started following you."
				){
					active.type = "follow";
					active.directLink = info.children[0].href;
					active.text =       info.children[0].innerHTML;//does not depend on user input
					active.textName =   (info.children[0] || {textContent: ""}).textContent.trim();
					active.textSpan =   translate("$notification_follow")
				}
				else if(
					info.children.length >= 4
					&& (info.children[3] || {textContent: ""}).textContent === " aired."
				){
					active.type = "airing";
					active.directLink = info.children[0].href;
					active.text = info.innerHTML;//does not depend on user input
				}
			}
		}
		if(
			notification.querySelector("time")
		){
			active.time = (new Date(notification.querySelector("time").dateTime).valueOf())/1000
		}
		else{
			active.time = null
		}
		activities.push(active)
	});
	notificationDrawer(activities);
	let alreadyRenderedComments = new Set();
	for(let i=0;APIcallsUsed < (APIlimit - 5);i++){//heavy
		if(!activities.length || i >= activities.length){//loading is difficult to predict. There may be nothing there when this runs
			break
		}
		let imageCallBack = function(data){
			if(!data){
				return
			}
			pending[data.data.Activity.id + ""] = false;
			let type = data.data.Activity.type;
			if(type === "ANIME_LIST" || type === "MANGA_LIST"){
				Array.from(document.getElementsByClassName(data.data.Activity.id)).forEach(stuff => {
					stuff.style.backgroundColor = data.data.Activity.media.coverImage.color || "rgb(var(--color-foreground))";
					stuff.src = data.data.Activity.media.coverImage.large;
					stuff.classList.add("hohBackgroundCover");
					if(data.data.Activity.media.title){
						stuff.parentNode.title = data.data.Activity.media.title.romaji
					}
				})
			}
			else if(type === "TEXT"){
				Array.from(document.getElementsByClassName(data.data.Activity.id)).forEach(stuff => {
					stuff.src = data.data.Activity.user.avatar.large;
					stuff.classList.add("hohBackgroundUserCover");
					stuff.parentNode.style.background = "none"
				})
			}
			if(data.data.Activity.replies.length){
				if(!alreadyRenderedComments.has(data.data.Activity.id)){
					alreadyRenderedComments.add(data.data.Activity.id);
					commentCallback(data)
				}
			}
		};
		let vars = {
			find: i
		};
		if(activities[i].link[0] !== "a"){//activities with post link
			let variables = {
				id: +activities[i].link
			};
			if(!pending[activities[i].link]){
				pending[activities[i].link] = true;
				generalAPIcall(queryActivity,variables,imageCallBack,"hohListActivityCall" + variables.id,24*60*60*1000,true)
			}
		}
	}
}

//end modules/notifications.js
//begin modules/oldDarkTheme.js
exportModule({
	id: "CSSoldDarkTheme",
	description: "Use the old dark theme colours",
	isDefault: false,
	categories: [],
	visible: true,
	css: `
.site-theme-dark{
	--color-background:39,44,56;
	--color-foreground:31,35,45;
	--color-foreground-grey:25,29,38;
	--color-foreground-grey-dark:16,20,25;
	--color-foreground-blue:25,29,38;
	--color-foreground-blue-dark:19,23,29;
	--color-background-blue-dark:31,35,45;
	--color-overlay:34,28,22;
	--color-shadow:49,54,68;
	--color-shadow-dark:6,13,34;
	--color-shadow-blue:103,132,187;
	--color-text:159,173,189;
	--color-text-light:129,140,153;
	--color-text-lighter:133,150,165;
	--color-text-bright:237,241,245;
}
.site-theme-dark .nav-unscoped.transparent{
	background: rgba(31, 38, 49, .5);
	color: rgb(var(--color-text));
}

.site-theme-dark .nav-unscoped,
.site-theme-dark .nav-unscoped.transparent:hover{
	background: rgb(var(--color-foreground));
}`
})
//end modules/oldDarkTheme.js
//begin modules/possibleBlocked.js
function possibleBlocked(oldURL){
	let URLstuff = oldURL.match(/\/user\/(.*?)\/?$/);
	if(URLstuff){
		let name = decodeURIComponent(URLstuff[1]);
		const query = `
		query($userName: String) {
			User(name: $userName){
				id
			}
		}`;
		let variables = {
			userName: name
		}
		if(name !== whoAmI){
			generalAPIcall(query,variables,data => {
				let notFound = document.querySelector(".not-found");
				name = name.split("/")[0];
				if(notFound){
					if(name.includes("submissions")){
						notFound.innerText = "This submission was probably denied"
					}
					else if(data){
						notFound.innerText = translate("$404_blocked",name)
					}
					else if(name === "ModChan"){
						notFound.innerText = "Nope."
					}
					else{
						notFound.innerText = translate("$404_private_or_noUser",name);
						generalAPIcall(
`
query($name: String){
	MediaList(userName: $name,mediaId: 1){
		id
	}
}
`,
							{name: name},
							function(data,variables,errors){
								if(errors){
									if(errors.errors[0].message === "Private User"){
										notFound.innerText = translate("$404_private",name)
									}
									else{
										notFound.innerText = translate("$404_noUser",name)
									}
								}
							}
						)
					}
					notFound.style.paddingTop = "200px";
					notFound.style.fontSize = "2rem"
				}
			})
		}
		return
	}
	URLstuff = oldURL.match(/\/(anime|manga)\/(\d+)/);
	if(URLstuff){
		let type = URLstuff[1];
		let id = parseInt(URLstuff[2]);
		const query = `
		query($id: Int,$type: MediaType) {
			Media(id: $id,type: $type){
				genres
			}
		}`;
		let variables = {
			type: type.toUpperCase(),
			id: id
		}
		generalAPIcall(query,variables,data => {
			if(data.data.Media.genres.some(genre => genre === "Hentai")){
				let notFound = document.querySelector(".not-found");
				if(notFound){
					if(id === 320){
						notFound.innerText = `Kite isn't *really* hentai, but it kinda is too, and it's a bit complicated.

(You can enable 18+ content in settings > Anime & Manga)`
					}
					else{
						notFound.innerText = `That's one of them hentais.

(You can enable 18+ content in settings > Anime & Manga)`
					}
					notFound.style.paddingTop = "200px";
					notFound.style.fontSize = "2rem"
				}
			}
		})
	}
}
//end modules/possibleBlocked.js
//begin modules/profileBackground.js
function profileBackground(){
	if(useScripts.SFWmode){//clearly not safe, users can upload anything
		return
	}
	const userRegex = /^\/user\/([^/]+)(\/.*)?$/;
	let URLstuff = location.pathname.match(userRegex);
	const query = `
	query($userName: String) {
		User(name: $userName){
			about
		}
	}`;
	let variables = {
		userName: decodeURIComponent(URLstuff[1])
	}
	generalAPIcall(query,variables,data => {
		if(!data){
			return;
		}
		let jsonMatch = (data.data.User.about || "").match(/^\[\]\(json([A-Za-z0-9+/=]+)\)/);
		if(!jsonMatch){
			let target = document.querySelector(".user-page-unscoped");
			if(target){
				target.style.background = "unset"
			}
			return;
		}
		try{
			let jsonData;
			try{
				jsonData = JSON.parse(atob(jsonMatch[1]))
			}
			catch(e){
				jsonData = JSON.parse(LZString.decompressFromBase64(jsonMatch[1]))
			}
			let adder = function(){
				if(!userRegex.test(location.pathname)){
					return
				}
				let target = document.querySelector(".user-page-unscoped");
				if(target){
					target.style.background = jsonData.background || "none";
				}
				else{
					setTimeout(adder,200);
				}
			};adder();
		}
		catch(e){
			console.warn("Invalid profile JSON for " + variables.userName + ". Aborting.");
			console.log(atob(jsonMatch[1]));
		}
	},"hohProfileBackground" + variables.userName,30*1000);
}
//end modules/profileBackground.js
//begin modules/randomButtons.js
exportModule({
	id: "randomButtons",
	description: "Make the headings on the site stats page lead to random entries",
	isDefault: true,
	categories: ["Script"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url === "https://anilist.co/site-stats";
	},
	code: function(){
		let list = [
			{data:"users",single:"user"},
			{data:"media(type: ANIME)",single:"anime"},
			{data:"media(type: MANGA)",single:"manga"},
			{data:"characters",single:"character"},
			{data:"staff",single:"staff"},
			{data:"reviews",single:"review"}
		];
		list.forEach(function(item,index){
			let adder = function(data){
				let place = document.querySelectorAll("section > .heading > h3");
				if(place.length <= index){
					setTimeout(function(){adder(data)},200);
					return;
				}
				let currentText = place[index].innerText;
				place[index].innerText = "";
				let link = create("a","link",currentText,place[index],"cursor:pointer;");
				link.title = "Click to pick one at random";
				let maximum = data.data.Page.pageInfo.total;
				let list = place[index].parentNode.parentNode.querySelectorAll(".point-label");
				let val = parseInt(list[list.length - 1].textContent.trim());
				if(val && val > 5000){
					maximum = val
				}
				let selected = Math.floor(Math.random()*maximum);
				link.onclick = function(){
					generalAPIcall(
						`query($page:Int){
							Page(page:$page){
								${item.data}{id}
							}
						}`,
						{page: Math.ceil(selected / 50)},
						function(data){
							window.location.href = "https://anilist.co/" + item.single + "/" + data.data.Page[item.data.replace(/\(.*\)/,"")][selected % 50].id + "/";
						}
					);
				}
			};
			generalAPIcall(
				`query($page:Int){
					Page(page:$page){
						pageInfo{total}
						${item.data}{id}
					}
				}`,
				{page: 1},
				adder
			)
		});
		let speedAdder = function(data){
			if(!data){
				return
			}
			let place = document.querySelector(".page-content .container section");
			if(!place){
				setTimeout(function(){speedAdder(data)},200);
				return;
			}
			let activityContainer = create("div",false,false,place.parentNode);
			create("h3","heading","Current Activity",activityContainer);
			create("p",false,Math.round((3600*199/(data.data.act1.activities[0].createdAt - data.data.act2.activities[data.data.act2.activities.length - 1].createdAt))) + " activities/hour",activityContainer);
			let activities = data.data.text.activities;
			create("p",false,(3600*(activities.length - 1)/(activities[0].createdAt - activities[activities.length - 1].createdAt)).roundPlaces(1) + " status posts/hour",activityContainer);
			activities = data.data.message.activities;
			create("p",false,(3600*(activities.length - 1)/(activities[0].createdAt - activities[activities.length - 1].createdAt)).roundPlaces(1) + " messages/hour",activityContainer);
			
		};
		generalAPIcall(
			`query{
				act1:Page(page: 1,perPage:10){
					activities(sort:ID_DESC){
						... on TextActivity{createdAt}
						... on MessageActivity{createdAt}
						... on ListActivity{createdAt}
					}
				}
				act2:Page(page: 20,perPage:10){
					activities(sort:ID_DESC){
						... on TextActivity{createdAt}
						... on MessageActivity{createdAt}
						... on ListActivity{createdAt}
					}
				}
				text:Page{
					activities(sort:ID_DESC,type:TEXT){
						... on TextActivity{createdAt}
					}
				}
				message:Page{
					activities(sort:ID_DESC,type:MESSAGE){
						... on MessageActivity{createdAt}
					}
				}
			}`,
			{},
			speedAdder
		)
	}
})
//end modules/randomButtons.js
//begin modules/rangeSetter.js
exportModule({
	id: "rangeSetter",
	description: "Add a progress range setter to the list editor",
	extendedDescription: `
When changing the number in the "progress" field, a button will appear.
When clicked, it sets the lower number on an activity ("user read chapter 65 - 69 of manga")
You then change the field to the higher number and click save as usual.
	`,
	isDefault: true,
	importance: 0,
	categories: ["Media","Newly Added","Lists","Login"],
	visible: true,
	css: `
.input-wrap .form.progress{
	position: relative;
}
.hohRangeSetter{
	width: 15px;
	height: 15px;
	position: absolute;
	right: -20px;
	top: 37.5px;
	background: rgb(var(--color-blue));
	border-radius: 2px;
	cursor: pointer;
}
`
})

if(useScripts.rangeSetter && useScripts.accessToken){
	setInterval(function(){
		let inputPlace = document.querySelector(".input-wrap .form.progress");
		if(inputPlace){
			if(inputPlace.querySelector(".hohRangeSetter")){
				return
			}
			let rangeSetter = create("div","hohRangeSetter",false,inputPlace);
			rangeSetter.title = "Click to set lower part of activity range";
			rangeSetter.style.display = "none";
			let realInput = inputPlace.querySelector("input");
			if(!realInput){
				return
			}
			let seriesID = null;//we need to gather this quickly!
			let possibleDirectMatch = document.URL.match(/\/(anime|manga)\/(\d+)/);
			if(possibleDirectMatch){
				seriesID = parseInt(possibleDirectMatch[2])
			}
			else{
				let secondPosition = inputPlace.parentNode.parentNode.parentNode.querySelector(".cover img");
				if(secondPosition && secondPosition.src.match(/cover\/.*\/[a-z]?[a-z]?(\d+)-/)){
					seriesID = parseInt(secondPosition.src.match(/cover\/.*\/[a-z]?[a-z]?(\d+)-/)[1]);
				}
				else{//oh no! pray the query is fast enough
					let title = inputPlace.parentNode.parentNode.parentNode.querySelector(".title").innerText;
					generalAPIcall(
`query{Media(search:"${title}"){id}}`,{},function(data){
							if(!data){
								return
							}
							seriesID = data.data.Media.id
						}
					)
				}
			}
			let changer = function(){
				if(!seriesID){
					return//too late!
				}
				if(!realInput.value){
					return
				}
				realInput.onclick = null;
				inputPlace.querySelector(".el-input-number__decrease").onclick = null;
				inputPlace.querySelector(".el-input-number__increase").onclick = null;
				rangeSetter.style.display = "block";
			}
			realInput.oninput = function(){
				changer()
			};
			inputPlace.querySelector(".el-input-number__decrease").onclick = function(){
				changer()
			}
			inputPlace.querySelector(".el-input-number__increase").onclick = function(){
				changer()
			}
			rangeSetter.onclick = function(){
				rangeSetter.onclick = null;
				authAPIcall(
					`mutation{
						SaveMediaListEntry(
							mediaId: ${seriesID},
							progress: ${parseInt(realInput.value)}
						){id}
					}`,
					{},
					data => {
						if(!data){
							rangeSetter.innerText = svgAssets.cross;
							rangeSetter.classList.add("spinnerError");
							rangeSetter.title = "Setting activity range failed"
						}
						else{
							rangeSetter.innerText = svgAssets.check;
							rangeSetter.classList.add("spinnerDone")
						}
					}
				);
				rangeSetter.innerText = "…";
				rangeSetter.style.background = "none";
				rangeSetter.style.cursor = "unset"
			}
		}
	},1000)
}
//end modules/rangeSetter.js
//begin modules/reinaDark.js
// SPDX-FileCopyrightText: 2021 Reina
// SPDX-License-Identifier: MIT
/*
Copyright (c) 2021 Reina

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
//updated code here: https://github.com/Reinachan/AniList-High-Contrast-Dark-Theme
exportModule({
	id: "reinaDark",
	description: "$setting_reinaDark",
	extendedDescription: `
More info and standalone versions: https://anilist.co/activity/136403139

Github: https://github.com/Reinachan/AniList-High-Contrast-Dark-Theme
`,
	isDefault: true,
	importance: 1,
	categories: ["Script"],
	visible: true,
	css: `
.theme-preview.dark-contrast{
	border-radius: 3px;
	border: 2px solid #46546b;
	cursor: pointer;
	display: inline-block;
	font-weight: 500;
	height: 25px;
	margin-right: 10px;
	padding-left: 2px;
	padding-top: 5px;
	width: 25px;

	background: rgb(14, 18, 22);
	color: rgb(240, 240, 240);
}
`//not the actual theme itself, just the styling of the theme switch
})

//outside the actual module export, as we want to run this at page load
if(useScripts.reinaDark){
	let darkContrastStyle = create("style");
	darkContrastStyle.id = "high-contrast-dark";
	darkContrastStyle.type = "text/css";
	documentHead.appendChild(darkContrastStyle);
	const style = `
:root {
	--color-background: 14, 18, 22;
	--color-blue: 120, 180, 255;
	--color-shadow-blue: 0, 0, 0;
	--color-foreground: 20, 25, 31;
	--color-foreground-alt: 18, 23, 29;
	--color-foreground-blue: 26, 33, 45;
	--color-foreground-grey: 15, 22, 28;
	--color-foreground-grey-dark: 6, 12, 13;
	--color-background-300: 30, 42, 56;
	--color-background-100: 19, 24, 32;
	--color-background-200: 14, 18, 22;
	--color-text: 240, 240, 240;
	--color-text-light: 220, 230, 240;
	--color-text-lighter: 230, 230, 240;
	--color-text-bright: 255, 255, 255;
	--color-blue-100: 247, 250, 252;
	--color-blue-200: 236, 246, 254;
	--color-blue-300: 201, 232, 255;
	--color-blue-400: 143, 215, 255;
	--color-blue-500: 111, 200, 255;
	--color-blue-600: 61, 180, 242;
	--color-blue-700: 8, 143, 214;
	--color-blue-800: 12, 101, 166;
	--color-blue-900: 11, 70, 113;
	--color-blue-1000: 16, 61, 85;
	--color-gray-1200: 251, 251, 251;
	--color-gray-1100: 240, 243, 246;
	--color-gray-1000: 221, 230, 238;
	--color-gray-900: 201, 215, 227;
	--color-gray-800: 173, 192, 210;
	--color-gray-700: 139, 160, 178;
	--color-gray-600: 116, 136, 153;
	--color-gray-500: 100, 115, 128;
	--color-gray-400: 81, 97, 112;
	--color-gray-300: 30, 42, 56;
	--color-gray-100: 21, 31, 46;
	--color-gray-200: 11, 22, 34;
}
#nav {
	background: rgb(20, 25, 31);
	color: #eaeeff!important;
}
.media .nav .link.router-link-exact-active.router-link-active,
.user .nav .link.router-link-exact-active.router-link-active{
	background: rgba(var(--color-foreground-grey-dark));
}
.site-theme-dark {
	--color-blue: 120, 180, 255;
	--color-shadow-blue: 8, 10, 16, 0.5;
	--color-foreground: 20, 25, 31;
	--color-foreground-alt: 18, 23, 29;
	--color-background: 14, 18, 22;
	--color-foreground-blue: 26, 33, 45;
	--color-foreground-grey: 15, 22, 28;
	--color-foreground-grey-dark: 6, 12, 13;
	--color-nav-hoh: rgb(20, 25, 31);
}
.site-theme-dark {
	/* Notification Dropdown */
	--color-background-300: 30, 42, 56;
	--color-background-100: 19, 24, 32;
	--color-background-200: 14, 18, 22;
	/* Text */
	--color-text: 240, 240, 240;
	--color-text-light: 220, 230, 240;
	--color-text-lighter: 230, 230, 240;
	--color-text-bright: 255, 255, 255;
	/* Blue Colours */
	--color-blue-100: 247, 250, 252;
	--color-blue-200: 236, 246, 254;
	--color-blue-300: 201, 232, 255;
	--color-blue-400: 143, 215, 255;
	--color-blue-500: 111, 200, 255;
	--color-blue-600: 61, 180, 242;
	--color-blue-700: 8, 143, 214;
	--color-blue-800: 12, 101, 166;
	--color-blue-900: 11, 70, 113;
	--color-blue-1000: 16, 61, 85;
}
/* Small screens adjustment */
.page-content > .container {
	@media screen and (max-width: 600px) {
		padding-left: 2px;
		padding-right: 2px;
	}
}
/* Coloured Text */
.name[data-v-5e514b1e] {
	color: rgb(var(--color-blue));
}
.site-theme-dark .user-page-unscoped.pink {
	--color-blue: 252, 157, 214;
}
/* Dropdown menu */
.el-dropdown-menu.el-popper.el-dropdown-menu--medium {
	width: 150px;
	text-align: center;
	background-color: rgb(var(--color-foreground-grey-dark))!important;
	box-shadow: 0 1px 10px 0 rgba(var(--color-shadow-blue));
}
.el-dropdown-menu.el-popper.el-dropdown-menu--medium .el-dropdown-menu__item:hover {
	background-color: rgb(var(--color-foreground-alt))!important;
}
.el-dropdown-menu.el-popper.el-dropdown-menu--medium .el-dropdown-menu__item--divided {
	border-top: 3px solid rgb(var(--color-foreground-alt));
	width: 90%;
	margin: auto;
}
.el-dropdown-menu.el-popper.el-dropdown-menu--medium .el-dropdown-menu__item--divided:before {
	background-color: rgb(var(--color-foreground-grey-dark))!important;
}
.el-dropdown-menu.el-popper.el-dropdown-menu--medium.activity-extras-dropdown {
	text-align: left;
}
/* Announcement */
.announcement {
	background-color: rgb(var(--color-blue-800))!important;
}
/* Reduce transparancy of card view notes to make them less easier to miss (accessibility)*/
.medialist.cards .entry-card .notes,
.medialist.cards .entry-card .repeat{
	color: rgba(var(--color-white),1);
	filter: drop-shadow(0 0 3px rgba(0,0,0,.9));
}
.review .banner .date{
	color: rgba(var(--color-white),.6);
}
/* Date Picker */
.el-picker-panel {
	border: 1px solid rgb(var(--color-foreground));
	background-color: rgb(var(--color-foreground-grey-dark));
	color: rgb(var(--color-text-bright));
	.el-date-picker__header-label {
		color: rgb(var(--color-text));
	}
	.el-picker-panel__icon-btn,
	.el-date-table th {
		color: rgb(var(--color-text-light));
	}
	.el-date-table {
		td.current:not(.disabled) span {
			background-color: rgb(var(--color-blue-700));
		}
		th {
			border-bottom: 1px solid #60656c;
			padding: 1px;
		}
		td.next-month,
		td.prev-month {
			color: #76777a;
		}
		tbody tr:nth-of-type(2) td {
			padding-top: 10px;
		}
	}
	.popper__arrow::after {
		border-bottom-color: rgb(var(--color-foreground-grey-dark)) !important;
		border-top-color: rgb(var(--color-foreground-grey-dark)) !important;
	}
}
`
	if(useScripts.reinaDarkEnable){
		darkContrastStyle.textContent = style
	}
	let adder = function(){//listen for the Site Theme changer to appear. A poller should be all that's needed
		let siteThemeSwitch = document.querySelector(".footer .theme-selector");
		if(!siteThemeSwitch){
			setTimeout(adder,500);//pretty relaxed timer, since the footer isn't even on screen when the page loads. 
		}
		else{
			siteThemeSwitch.appendChild(document.createTextNode(" "));
			Array.from(document.querySelectorAll(".el-tooltip.theme-preview")).forEach(theme => {
				theme.onclick = function(){
					if(useScripts.reinaDarkEnable){
						useScripts.reinaDarkEnable = false;
						useScripts.save();
						darkContrastStyle.textContent = ""
					}
				}
			})
			let darkContrastSwitch = create("div",["el-tooltip","theme-preview","dark-contrast"],"A",siteThemeSwitch);
			darkContrastSwitch.title = translate("$theme_highContrastDark");//not quite the same as the native tooltip, but that's a minor issue that can be fixed later
			darkContrastSwitch.onclick = function(){
				if(!useScripts.reinaDarkEnable){
					document.querySelector(".el-tooltip.theme-preview.dark").click();//fallback theme
					useScripts.reinaDarkEnable = true;
					useScripts.save();
					darkContrastStyle.textContent = style
				}
			}
		}
	};
	adder()
}
//end modules/reinaDark.js
//begin modules/relations.js
exportModule({
	id: "relations",
	description: "$relations_description",
	isDefault: true,
	categories: ["Profiles"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return /^https:\/\/anilist\.co\/user\/(.*)\/social/.test(url)
	},
	code: function(){
		let their_followers = null;
		let their_following = null;
		let my_followers = null;
		let my_following = null;
		let userID = null;
		let user = decodeURIComponent(document.URL.match(/^https:\/\/anilist\.co\/user\/(.*)\/social/)[1]);
		generalAPIcall(
			"query($name:String){User(name:$name){id}}",
			{name: user},
			function(data){
				userID = data.data.User.id
			},
			"hohIDlookup" + user.toLowerCase()
		);
		
		let adder = function(){
			let matching = location.pathname.match(/^\/user\/(.*)\/social/);
			if(!matching){
				return;
			}
			let target = document.querySelector(".filters .filter-group");
			if(!target){
				setTimeout(adder,500);
				return
			}
			let hohDisplay = create("div",["hohSocialContent","user-follow"],false,target.parentNode.parentNode);
			Array.from(target.children).forEach(child => {
				child.onclick = function(){
					let possibleActive = target.querySelector(".active");
					if(possibleActive){
						possibleActive.classList.remove("active");
					}
					possibleActive = target.querySelector(".active");
					if(possibleActive){
						possibleActive.classList.remove("active");
					}
					child.classList.add("active");
					target.parentNode.parentNode.children[1].style.display = "block";
					hohDisplay.style.display = "none";
				}
			})
			let followingOnly = create("span",false,translate("$relations_following_only"),target);
			let followingOnly_count = create("span","hohCount",false,followingOnly);
			let followersOnly = create("span",false,translate("$relations_followers_only"),target);
			let followersOnly_count = create("span","hohCount",false,followersOnly);
			let mutuals = create("span",false,translate("$relations_mutuals"),target);
			let mutuals_count = create("span","hohCount",false,mutuals);
			let sharedFollowing = create("span",false,translate("$relations_shared_following"),target);
			let sharedFollowing_count = create("span","hohCount",false,sharedFollowing);
			let sharedFollowers = create("span",false,translate("$relations_shared_followers"),target);
			let sharedFollowers_count = create("span","hohCount",false,sharedFollowers);
			if(user === whoAmI){
				sharedFollowing.style.display = "none";
				sharedFollowers.style.display = "none";
			}
			let commonUI = function(){
				let possibleActive = target.querySelector(".active");
				if(possibleActive){
					possibleActive.classList.remove("active");
				}
				possibleActive = target.querySelector(".active");
				if(possibleActive){
					possibleActive.classList.remove("active");
				}
				target.parentNode.parentNode.children[1].style.display = "none";
				hohDisplay.style.display = ""
			}

			let activeModule = "";

			let followingOnlyDisplay = function(){
				hohDisplay.innerText = "";
				let count = 0;
				their_following.forEach((user,key) => {
					if(!their_followers.has(key)){
						count++;
						if(activeModule === "followingOnly"){
							let card = create("div","follow-card",false,hohDisplay);
							let avatar = create("div","avatar",false,card);
							avatar.style.backgroundImage = 'url("' + user.avatar.large + '")';
							let name = create("a","name",user.name,avatar);
							name.href = "/user/" + user.name;
						}
					}
				})
				followingOnly_count.innerText = count
			}

			let followersOnlyDisplay = function(){
				hohDisplay.innerText = "";
				let count = 0;
				their_followers.forEach((user,key) => {
					if(!their_following.has(key)){
						count++;
						if(activeModule === "followersOnly"){
							let card = create("div","follow-card",false,hohDisplay);
							let avatar = create("div","avatar",false,card);
							avatar.style.backgroundImage = 'url("' + user.avatar.large + '")';
							let name = create("a","name",user.name,avatar);
							name.href = "/user/" + user.name;
						}
					}
				})
				followersOnly_count.innerText = count
			}

			let mutualDisplay = function(){
				hohDisplay.innerText = "";
				let count = 0;
				their_followers.forEach((user,key) => {
					if(their_following.has(key)){
						count++;
						if(activeModule === "mutuals"){
							let card = create("div","follow-card",false,hohDisplay);
							let avatar = create("div","avatar",false,card);
							avatar.style.backgroundImage = 'url("' + user.avatar.large + '")';
							let name = create("a","name",user.name,avatar);
							name.href = "/user/" + user.name;
						}
					}
				})
				mutuals_count.innerText = count
			}

			let sharedFollowingDisplay = function(){
				hohDisplay.innerText = "";
				let count = 0;
				their_following.forEach((user,key) => {
					if(my_following.has(key)){
						count++;
						if(activeModule === "sharedFollowing"){
							let card = create("div","follow-card",false,hohDisplay);
							let avatar = create("div","avatar",false,card);
							avatar.style.backgroundImage = 'url("' + user.avatar.large + '")';
							let name = create("a","name",user.name,avatar);
							name.href = "/user/" + user.name;
						}
					}
				})
				sharedFollowing_count.innerText = count
			}

			let sharedFollowersDisplay = function(){
				hohDisplay.innerText = "";
				let count = 0;
				their_followers.forEach((user,key) => {
					if(my_followers.has(key)){
						count++;
						if(activeModule === "sharedFollowers"){
							let card = create("div","follow-card",false,hohDisplay);
							let avatar = create("div","avatar",false,card);
							avatar.style.backgroundImage = 'url("' + user.avatar.large + '")';
							let name = create("a","name",user.name,avatar);
							name.href = "/user/" + user.name;
						}
					}
				})
				sharedFollowers_count.innerText = count
			}

			let collect_theirFollowing = function(page1,page2,id,displayer){
				generalAPIcall(
`query{
	page1:Page(page:${page1}){
		following(userId:${id}){
			id name avatar{large}
		}
	}
	page2:Page(page:${page2}){
		following(userId:${id}){
			id name avatar{large}
		}
	}
}`,
					{},
					function(data){
						if(!data){
							return;
						}
						data.data.page1.following.concat(data.data.page2.following).forEach(user => {
							their_following.set(user.id,user)
						})
						displayer();
						if(data.data.page2.following.length){
							collect_theirFollowing(page1 + 2,page2 + 2,id,displayer)
						}
					}
				);
			}
			let collect_theirFollowers = function(page1,page2,id,displayer){
				generalAPIcall(
`query{
	page1:Page(page:${page1}){
		followers(userId:${id}){
			id name avatar{large}
		}
	}
	page2:Page(page:${page2}){
		followers(userId:${id}){
			id name avatar{large}
		}
	}
}`,
					{},
					function(data){
						if(!data){
							return;
						}
						data.data.page1.followers.concat(data.data.page2.followers).forEach(user => {
							their_followers.set(user.id,user)
						})
						displayer();
						if(data.data.page2.followers.length){
							collect_theirFollowers(page1 + 2,page2 + 2,id,displayer)
						}
					}
				);
			}

			let collect_myFollowing = function(page1,page2,id,displayer){
				generalAPIcall(
`query{
	page1:Page(page:${page1}){
		following(userId:${id}){
			id name avatar{large}
		}
	}
	page2:Page(page:${page2}){
		following(userId:${id}){
			id name avatar{large}
		}
	}
}`,
					{},
					function(data){
						if(!data){
							return;
						}
						data.data.page1.following.concat(data.data.page2.following).forEach(user => {
							my_following.set(user.id,user)
						})
						displayer();
						if(data.data.page2.following.length){
							collect_myFollowing(page1 + 2,page2 + 2,id,displayer)
						}
					}
				);
			}
			let collect_myFollowers = function(page1,page2,id,displayer){
				generalAPIcall(
`query{
	page1:Page(page:${page1}){
		followers(userId:${id}){
			id name avatar{large}
		}
	}
	page2:Page(page:${page2}){
		followers(userId:${id}){
			id name avatar{large}
		}
	}
}`,
					{},
					function(data){
						if(!data){
							return;
						}
						data.data.page1.followers.concat(data.data.page2.followers).forEach(user => {
							my_followers.set(user.id,user)
						})
						displayer();
						if(data.data.page2.followers.length){
							collect_myFollowers(page1 + 2,page2 + 2,id,displayer)
						}
					}
				);
			}

			followingOnly.onclick = function(){
				commonUI();
				activeModule = "followingOnly";
				followingOnly.classList.add("active");
				if(their_followers && their_following){
					followingOnlyDisplay()
				}
				else if(their_followers && !their_following){
					their_following = new Map();
					collect_theirFollowing(1,2,userID,followingOnlyDisplay);
				}
				else if(!their_followers && their_following){
					their_followers = new Map();
					collect_theirFollowers(1,2,userID,followingOnlyDisplay);
				}
				else{
					their_following = new Map();
					their_followers = new Map();
					collect_theirFollowing(1,2,userID,followingOnlyDisplay);
					collect_theirFollowers(1,2,userID,followingOnlyDisplay);
				}
			}
			followersOnly.onclick = function(){
				commonUI();
				activeModule = "followersOnly";
				followersOnly.classList.add("active");
				if(their_followers && their_following){
					followersOnlyDisplay()
				}
				else if(their_followers && !their_following){
					their_following = new Map();
					collect_theirFollowing(1,2,userID,followersOnlyDisplay);
				}
				else if(!their_followers && their_following){
					their_followers = new Map();
					collect_theirFollowers(1,2,userID,followersOnlyDisplay);
				}
				else{
					their_following = new Map();
					their_followers = new Map();
					collect_theirFollowing(1,2,userID,followersOnlyDisplay);
					collect_theirFollowers(1,2,userID,followersOnlyDisplay);
				}
			}
			mutuals.onclick = function(){
				commonUI();
				activeModule = "mutuals";
				mutuals.classList.add("active");
				if(their_followers && their_following){
					mutualDisplay()
				}
				else if(their_followers && !their_following){
					their_following = new Map();
					collect_theirFollowing(1,2,userID,mutualDisplay);
				}
				else if(!their_followers && their_following){
					their_followers = new Map();
					collect_theirFollowers(1,2,userID,mutualDisplay);
				}
				else{
					their_following = new Map();
					their_followers = new Map();
					collect_theirFollowing(1,2,userID,mutualDisplay);
					collect_theirFollowers(1,2,userID,mutualDisplay);
				}
			}
			sharedFollowing.onclick = function(){
				commonUI();
				activeModule = "sharedFollowing";
				sharedFollowing.classList.add("active");
				if(their_following && my_following){
					sharedFollowingDisplay()
				}
				else if(their_following && !my_following){
					my_following = new Map();
					collect_myFollowing(1,2,userObject.id,sharedFollowingDisplay);
				}
				else if(!their_following && my_following){
					their_following = new Map();
					collect_theirFollowing(1,2,userID,sharedFollowingDisplay);
				}
				else{
					my_following = new Map();
					their_following = new Map();
					collect_myFollowing(1,2,userObject.id,sharedFollowingDisplay);
					collect_theirFollowing(1,2,userID,sharedFollowingDisplay);
				}
			}
			sharedFollowers.onclick = function(){
				commonUI();
				activeModule = "sharedFollowers";
				sharedFollowers.classList.add("active");
				if(their_followers && my_followers){
					sharedFollowersDisplay()
				}
				else if(their_followers && !my_followers){
					my_followers = new Map();
					collect_myFollowers(1,2,userObject.id,sharedFollowersDisplay);
				}
				else if(!their_followers && my_followers){
					their_followers = new Map();
					collect_theirFollowers(1,2,userID,sharedFollowersDisplay);
				}
				else{
					my_followers = new Map();
					their_followers = new Map();
					collect_myFollowers(1,2,userObject.id,sharedFollowersDisplay);
					collect_theirFollowers(1,2,userID,sharedFollowersDisplay);
				}
			}
		};adder()
	},
	css: `
.user-social .filter-group span{
	cursor: pointer;
	border-radius: 3px;
	color: rgb(var(--color-text-lighter));
	display: block;
	font-size: 1.4rem;
	margin-bottom: 8px;
	padding: 5px 10px;
}
.user-social .filter-group span.active{
	background: rgba(var(--color-foreground),.8);
	color: rgb(var(--color-text));
	font-weight: 500;
}
.hohSocialContent .follow-card{
	width: 80px;
	position: relative;
}
.hohSocialContent .avatar{
	width: 80px;
	height: 80px;
	background-size: cover;
	background-repeat: no-repeat;
	background-position: 50%;
	overflow: hidden;
	border-radius: 4px;
}
.hohSocialContent .avatar .name{
	font-family: Overpass,-apple-system,BlinkMacSystemFont,Segoe UI,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;
	align-items: flex-end;
	background: rgba(var(--color-shadow),.6);
	color: rgb(var(--color-white));
	display: flex;
	font-size: 1.3rem;
	font-weight: 700;
	height: 100%;
	justify-content: center;
	opacity: 0;
	padding: 10px 4px;
	text-align: center;
	transition: opacity .3s ease-in-out;
	width: 100%;
	word-break: break-all;
}
.hohSocialContent .avatar .name:hover{
	opacity: 1;
	color: rgb(var(--color-white));
}
.hohSocialContent{
	display: grid;
	grid-gap: 20px;
	grid-template-columns: repeat(auto-fill,80px);
	grid-template-rows: repeat(auto-fill,80px);
}
`
})
//end modules/relations.js
//begin modules/replaceStaffRoles.js
exportModule({
	id: "replaceStaffRoles",
	description: "Hoh's version of sortable staff pages",
	isDefault: !!useScripts.accessToken,
	categories: ["Media","Login"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/staff\/.*/)
	},
	code: function(){
let selfcaller = function(){
let URLstuff = location.pathname.match(/^\/staff\/(\d+)\/?.*/);
if(!URLstuff){
	return
}
let possibleGarbage = document.getElementById("hoh-media-roles");
if(possibleGarbage){
	if(possibleGarbage.dataset.staffId === URLstuff[1]){
		return
	}
	else{
		possibleGarbage.remove();
		let possibleFilterBar = document.querySelector(".hohFilterBar");
		if(possibleFilterBar){
			possibleFilterBar.remove()
		}
	}
}
let insertParent = document.querySelector(".media-roles");
let insertParentCharacters = document.querySelector(".character-roles");
if(!insertParent && !insertParentCharacters){
	setTimeout(selfcaller	,200);
	return;
}
insertParentCharacters.classList.add("hohSubstitute");
let substitution = false;
if(!insertParent){
	insertParent = create("div",["media-roles","container","substitution"],false,insertParentCharacters.parentNode);
	substitution = true
}
else{
	insertParent.classList.add("substitution")
}
insertParent.parentNode.classList.add("substitution");
let hohCharacterRolesBox = create("div","#hoh-character-roles");
let hohCharacterRolesHeader = create("h4",false,translate("$staff_voiceRoles"),hohCharacterRolesBox);
hohCharacterRolesHeader.style.display = "none";
let hohCharacterRoles = create("div","grid-wrap",false,hohCharacterRolesBox);
hohCharacterRoles.style.margin = "10px";

let hohMediaRoles = create("div","#hoh-media-roles");
hohMediaRoles.dataset.staffId = URLstuff[1];
let hohMediaRolesAnimeHeader = create("h4",false,translate("$staff_animeRoles"),hohMediaRoles);
hohMediaRolesAnimeHeader.style.display = "none";
let hohMediaRolesAnime = create("div","grid-wrap",false,hohMediaRoles);
hohMediaRolesAnime.style.margin = "10px";

let hohMediaRolesMangaHeader = create("h4",false,translate("$staff_mangaRoles"),hohMediaRoles);
hohMediaRolesMangaHeader.style.display = "none";
let hohMediaRolesManga = create("div","grid-wrap",false,hohMediaRoles);
hohMediaRolesManga.style.margin = "10px";
//sort
let hohMediaSort = create("div",["container","hohFilterBar"]);
let sortText = create("span",false,translate("$staff_sort"),hohMediaSort);
let sortSelect = create("select",false,false,hohMediaSort);
sortSelect.style.marginLeft = "5px";
let filterSelect = create("input",false,false,hohMediaSort);
filterSelect.setAttribute("list","staffRoles");
filterSelect.placeholder = translate("$staff_filter_placeholder");
let filterExplanation = create("abbr",false,"?",hohMediaSort,"margin-left:5px;cursor:pointer;");
filterExplanation.title = translate("$staff_filterHelp");
filterExplanation.onclick = function(){
	let scrollableContent = createDisplayBox("min-width:400px;width:700px;");
	scrollableContent.innerText = `
Text in the field will be matched against all titles, roles, genres tags, your status, the media format and the start year. If it matches one of them, the media is displayed.

Regular expressions are permitted for titles.

If you want to limit it to just one filter type, you can do it like "genre:mecha" or "status:watching"
(status filtering only works if you have granted ${script_type} permission to view your list data)

The start year can also be a range like "2000-2005"`
};
let dataList = create("datalist","#staffRoles",false,hohMediaSort);
let digestStats = create("span",false,false,hohMediaSort,"margin-left:100px;position:relative;");
let sortOptionAlpha = create("option",false,translate("$sort_alphabetical"),sortSelect);
sortOptionAlpha.value = "alphabetical";
let sortOptionChrono2 = create("option",false,translate("$sort_newest"),sortSelect);
sortOptionChrono2.value = "chronological2";
let sortOptionChrono = create("option",false,translate("$sort_oldest"),sortSelect);
sortOptionChrono.value = "chronological";
let sortOptionPopularity = create("option",false,translate("$sort_popularity"),sortSelect);
sortOptionPopularity.value = "popularity";
let sortOptionLength = create("option",false,translate("$sort_length"),sortSelect);
sortOptionLength.value = "length";
let sortOptionScore = create("option",false,translate("$sort_score"),sortSelect);
sortOptionScore.value = "score";
if(useScripts.accessToken){
	create("option",false,translate("$sort_myScore"),sortSelect)
		.value = "myScore"
	create("option",false,translate("$sort_myProgress"),sortSelect)
		.value = "myProgress"
}
let autocomplete = new Set();
sortSelect.value = useScripts.staffRoleOrder;
hohMediaSort.style.marginBottom = "10px";
hohMediaSort.style.marginTop = "3px";
//end sort
let initPerformed = false;
let UIinit = function(){
	initPerformed = true;
	insertParent.parentNode.insertBefore(hohMediaSort,insertParentCharacters);
	insertParent.insertBefore(hohMediaRoles,insertParent.children[0]);
	insertParentCharacters.insertBefore(hohCharacterRolesBox,insertParentCharacters.children[0]);
	if(document.querySelector(".filters.container")){
		document.querySelector(".filters.container").remove()
	}
};
let animeRolesList = [];
let mangaRolesList = [];
let voiceRolesList = [];
const animeValueFunction = function(anime){
	if(!anime.myStatus){
		return -1
	}
	let entryDuration = (anime.duration || 1)*(anime.myStatus.progress || 0);//current round
	if(useScripts.noRewatches && anime.myStatus.repeat){
		entryDuration = Math.max(
			1,
			anime.episodes || 0,
			anime.myStatus.progress || 0
		) * (anime.duration || 1);//first round
	}
	else{
		entryDuration += (anime.myStatus.repeat || 0) * Math.max(
			1,
			anime.episodes || 0,
			anime.myStatus.progress || 0
		) * (anime.duration || 1);//repeats
	}
	if(anime.listJSON && anime.listJSON.adjustValue){
		entryDuration = Math.max(0,entryDuration + anime.listJSON.adjustValue*(anime.duration || 1))
	}
	return entryDuration
}
const mangaValueFunction = function(manga){
	if(!manga.myStatus){
		return {
			chapters: 0,
			volumes: 0
		}
	}
	let chaptersRead = 0;
	let volumesRead = 0;
	if(manga.myStatus.status === "COMPLETED"){//if it's completed, we can make some safe assumptions
		chaptersRead = Math.max(//chapter progress on the current read
			manga.chapters,//in most cases, it has a chapter count
			manga.volumes,//if not, there's at least 1 chapter per volume
			manga.myStatus.progress,//if it doesn't have a volume count either, the current progress is probably not out of date
			manga.myStatus.progressVolumes,//if it doesn't have a chapter progress, count at least 1 chapter per volume
			1//finally, an entry has at least 1 chapter
		);
		volumesRead += Math.max(
			manga.myStatus.progressVolumes,
			manga.volumes
		)
	}
	else{//we may only assume what's on the user's list.
		chaptersRead += Math.max(
			manga.myStatus.progress,
			manga.myStatus.progressVolumes
		);
		volumesRead += manga.myStatus.progressVolumes;
	}
	if(useScripts.noRewatches && (manga.myStatus.repeat || 0)){//if they have a reread, they have at least completed it
		chaptersRead = Math.max(//first round
			manga.chapters,
			manga.volumes,
			manga.myStatus.progress,
			manga.myStatus.progressVolumes,
			1
		);
		volumesRead = Math.max(
			manga.volumes,
			manga.myStatus.progressVolumes
		)
	}
	else{
		chaptersRead += (manga.myStatus.repeat || 0) * Math.max(//chapters from rereads
			manga.chapters,
			manga.volumes,
			manga.myStatus.progress,
			manga.myStatus.progressVolumes,
			1
		);
		volumesRead += (manga.myStatus.repeat || 0) * Math.max(
			manga.volumes,
			manga.myStatus.progressVolumes
		)
	}
	if(manga.listJSON && manga.listJSON.adjustValue){
		chaptersRead = Math.max(0,chaptersRead + manga.listJSON.adjustValue)
	}
	return {
		chapters: chaptersRead,
		volumes: volumesRead
	}
}
let listRenderer = function(){
	if(!initPerformed){
		UIinit()
	}
	useScripts.staffRoleOrder = sortSelect.value;
	useScripts.save();
	if(sortSelect.value === "alphabetical"){
		animeRolesList.sort(ALPHABETICAL(a => a.title));
		mangaRolesList.sort(ALPHABETICAL(a => a.title));
		voiceRolesList.sort(ALPHABETICAL(a => a.title))
	}
	else if(sortSelect.value === "chronological"){
		const yearSorter = (a,b) => {
			let aTime = a.startDate;
			let bTime = b.startDate;
			if(!aTime.year){
				aTime = a.endDate
			}
			if(!bTime.year){
				bTime = b.endDate
			}
			if(!aTime.year){
				if(!bTime.year){
					if(b.status === "NOT_YET_RELEASED" && a.status === "NOT_YET_RELEASED"){
						return 0
					}
					else if(a.status === "NOT_YET_RELEASED"){
						return -1
					}
				}
				return 1;
			}
			else if(!bTime.year){
				return -1
			}
			return aTime.year - bTime.year
				|| aTime.month - bTime.month
				|| aTime.day - bTime.day
				|| a.endDate.year - b.endDate.year
				|| a.endDate.month - b.endDate.month
				|| a.endDate.day - b.endDate.day
				|| 0
		};
		animeRolesList.sort(yearSorter);
		mangaRolesList.sort(yearSorter);
		voiceRolesList.sort(yearSorter)
	}
	else if(sortSelect.value === "chronological2"){
		const yearSorter = (a,b) => {
			let aTime = a.startDate;
			let bTime = b.startDate;
			if(!aTime.year){
				aTime = a.endDate
			}
			if(!bTime.year){
				bTime = b.endDate
			}
			if(!aTime.year){
				if(!bTime.year){
					if(b.status === "NOT_YET_RELEASED" && a.status === "NOT_YET_RELEASED"){
						return 0
					}
					else if(a.status === "NOT_YET_RELEASED"){
						return -1
					}
				}
				return 1;
			}
			else if(!bTime.year){
				return -1
			}
			return bTime.year - aTime.year
				|| bTime.month - aTime.month
				|| bTime.day - aTime.day
				|| b.endDate.year - a.endDate.year
				|| b.endDate.month - a.endDate.month
				|| b.endDate.day - a.endDate.day
				|| 0
		};
		animeRolesList.sort(yearSorter);
		mangaRolesList.sort(yearSorter);
		voiceRolesList.sort(yearSorter)
	}
	else if(sortSelect.value === "popularity"){
		const popSorter = (b,a) => a.popularity - b.popularity || a.score - b.score;
		animeRolesList.sort(popSorter);
		mangaRolesList.sort(popSorter);
		voiceRolesList.sort(popSorter)
	}
	else if(sortSelect.value === "score"){
		const scoreSorter = (b,a) => a.score - b.score || a.popularity - b.popularity;
		animeRolesList.sort(scoreSorter);
		mangaRolesList.sort(scoreSorter);
		voiceRolesList.sort(scoreSorter)
	}
	else if(sortSelect.value === "length"){
		animeRolesList.sort(
			(b,a) => a.episodes - b.episodes || a.duration - b.duration || b.title.localeCompare(a.title)
		);
		voiceRolesList.sort(
			(b,a) => a.episodes - b.episodes || a.duration - b.duration || b.title.localeCompare(a.title)
		);
		mangaRolesList.sort(
			(b,a) => a.chapters - b.chapters || a.volumes - b.volumes || b.title.localeCompare(a.title)
		)
	}
	else if(sortSelect.value === "myScore"){
		let scoreSorter = function(b,a){
			let scoreTier = (a.myStatus ? a.myStatus.scoreRaw : 0) - (b.myStatus ? b.myStatus.scoreRaw : 0);
			if(scoreTier !== 0){
				return scoreTier
			}
			let progressTier = (a.myStatus ? a.myStatus.progress : -1) - (b.myStatus ? b.myStatus.progress : -1);
			if(progressTier !== 0){
				return progressTier
			}
			return a.popularity - b.popularity
		}
		animeRolesList.sort(scoreSorter);
		mangaRolesList.sort(scoreSorter);
		voiceRolesList.sort(scoreSorter);
	}
	else if(sortSelect.value === "myProgress"){
		const animeSorter = (b,a) => animeValueFunction(a) - animeValueFunction(b) || b.title.localeCompare(a.title);
		const mangaSorter = (b,a) => {
			const aval = mangaValueFunction(a);
			const bval = mangaValueFunction(b);
			return aval.chapters - bval.chapters || aval.volumes - bval.volumes || b.title.localeCompare(a.title)
		}
		animeRolesList.sort(animeSorter);
		voiceRolesList.sort(animeSorter);
		mangaRolesList.sort(mangaSorter);
	}
	hohMediaRolesAnimeHeader.style.display = "none";
	hohMediaRolesMangaHeader.style.display = "none";
	hohCharacterRolesHeader.style.display = "none";
	if(animeRolesList.length){
		hohMediaRolesAnimeHeader.style.display = "inline-block";
		hohMediaRolesAnimeHeader.style.marginBottom = 0;
	}
	if(mangaRolesList.length){
		hohMediaRolesMangaHeader.style.display = "inline-block";
		hohMediaRolesMangaHeader.style.marginBottom = 0;
	}
	if(voiceRolesList.length){
		hohCharacterRolesHeader.style.display = "inline-block";
		hohCharacterRolesHeader.style.marginBottom = 0;
	}
	let createRoleCard = function(media,type){
		let roleCard = create("div",["role-card","view-media"]);
		roleCard.style.position = "relative";
		let mediaA = create("div","media",false,roleCard);
		let cover = create("a","cover",false,mediaA);
		cover.href = "/" + type + "/" + media.id + "/" + safeURL(media.title);
		cheapReload(cover,{path: cover.pathname})
		cover.style.backgroundImage = "url(" + media.image + ")";
		let content = create("a","content",false,mediaA);
		content.href = "/" + type + "/" + media.id + "/" + safeURL(media.title);
		cheapReload(content,{path: content.pathname})
		let name = create("div","name",media.title,content);

		//default value of a credit not listed here is 0. Positive values are more important, negative less important
		let roleValues = {
			"Director": 2,
			"Creator": 1.91,
			"Original Creator": 1.9,//important that this is early
			"Script": 1.8,
			"Storyboard": 1.75,
			"Art Director": 1.7,//personal bias :)
			"Character Design": 1.65,
			"Animation Director": 1.6,
			"Sound Director": 1.5,
			"Assistant Director": 1,
			"Episode Director": 1,
			"Main Animator": 0.1,
			"Key Animation": 0,
			"Animation": -0.1,
			"2nd Key Animation": -0.5,
			"In-Between Animation": -1
		}
		media.role.sort((b,a) => {
			let amatch = roleValues[a.match(/^(.*?)(\s*\(.*\))?$/)[1]] || 0;
			let bmatch = roleValues[b.match(/^(.*?)(\s*\(.*\))?$/)[1]] || 0;
			return amatch - bmatch
		})

		let role = create("div","role",media.role.map(word => {
			let parts = word.trim().match(/^(.*?)(\s+\(.*\))?$/);
			let t_role = translate("$role_" + parts[1]);
			if(t_role.substring(0,6) === "$role_"){
				return word
			}
			return t_role + (parts[2] || "")
		}).join(", "),content);
		role.title = media.role.join("\n");
		if(sortSelect.value === "popularity"){
			create("span","hohStaffPageData",media.popularity,content).title = "Popularity"
		}
		else if(sortSelect.value === "score"){
			create("span","hohStaffPageData",media.score || "",content).title = "Score"
		}
		else if(sortSelect.value === "length"){
			create("span","hohStaffPageData",media.episodes || media.chapers || media.volumes || "",content).title = "Length"
		}
		else if(sortSelect.value === "myProgress"){
			let staffPageData = create("span","hohStaffPageData",false,content)
			staffPageData.title = "Progress";
			if(type === "manga"){
				staffPageData.innerText = mangaValueFunction(media).chapters || ""
			}
			else{
				let animeVal = animeValueFunction(media);
				if(animeVal > 0){
					staffPageData.innerText = (animeVal/60).roundPlaces(1) + "h";
				}
			}
		}
		else if(sortSelect.value === "myScore"){
			create("span","hohStaffPageData",(media.myStatus ? media.myStatus.scoreRaw : null) || "",content).title = "My Score"
		}
		if(media.myStatus){
			let statusDot = create("div",["hohStatusDot","hohStatusDotRight"],false,roleCard);
			statusDot.style.background = distributionColours[media.myStatus.status];
			statusDot.title = media.myStatus.status.toLowerCase();
			if(media.myStatus.status === "CURRENT"){
				statusDot.title += " (" + media.myStatus.progress + ")"
			}
		}
		return roleCard;
	};
	let sumDuration = 0;
	let sumChapters = 0;
	let sumVolumes = 0;
	let sumScoresAnime = 0;
	let sumScoresManga = 0;
	let amountAnime = 0;
	let amountManga = 0;
	let animeCurrentFlag = false;
	let mangaCurrentFlag = false;
	let distribution = {};
	let alreadyCounted = new Set();
	Object.keys(distributionColours).forEach(
		status => distribution[status] = 0
	);
	removeChildren(hohCharacterRoles)
	Array.from(insertParentCharacters.children).forEach(child => {
		if(child.id !== "hoh-character-roles"){
			child.style.display = "none";
		}
	})
	Array.from(insertParent.children).forEach(child => {
		if(child.id !== "hoh-media-roles"){
			child.style.display = "none"
		}
	})
	const mediaMatcher = {
		"title-romaji": (query,media) => media.titleRomaji && (
			media.titleRomaji.toLowerCase().match(query.toLowerCase())
			|| media.titleRomaji.toLowerCase().includes(query.toLowerCase())
		),
		"title-english": (query,media) => media.titleEnglish && (
			media.titleEnglish.toLowerCase().match(query.toLowerCase())
			|| media.titleEnglish.toLowerCase().includes(query.toLowerCase())
		),
		"title-native": (query,media) => media.titleNative && (
			media.titleNative.toLowerCase().match(query.toLowerCase())
			|| media.titleNative.toLowerCase().includes(query.toLowerCase())
		),
		"format": (query,media) => (media.format || "").replace("_","").toLowerCase().match(
			query.toLowerCase().replace(/\s|-|_/,"")
		),
		"status": (query,media) => media.myStatus && (
			media.myStatus.status.toLowerCase() === query.toLowerCase()
			|| media.myStatus.status === "CURRENT"  && ["reading","watching"].includes(query.toLowerCase())
			|| media.myStatus.status === "PLANNING" && ["plan to watch","plan to read","planning"].includes(query.toLowerCase())
		),
		"year": (query,media) => {
			const rangeMatch = query.trim().match(/^(\d\d\d\d)\s?-\s?(\d\d\d\d)$/);
			return parseInt(query) === (media.startDate.year || media.endDate.year)
				|| rangeMatch && parseInt(rangeMatch[1]) <= media.startDate.year && parseInt(rangeMatch[2]) >= media.startDate.year
				|| rangeMatch && parseInt(rangeMatch[2]) <= media.startDate.year && parseInt(rangeMatch[1]) >= media.startDate.year
		},
		"genre": (query,media) => media.genres.some(
			genre => genre === query.toLowerCase()
		),
		"tag": (query,media) => media.tags.some(
			tag => tag === query.toLowerCase()
		),
		"role": (query,media) => media.role.some(
			role => {
				let parts = role.trim().match(/^(.*?)(\s+\(.*\))?$/);
				let t_role = translate("$role_" + parts[1]);
				if(t_role.substring(0,6) !== "$role_" && t_role.toLowerCase().match(query.toLowerCase())){
					return true
				}
				return role.toLowerCase().match(query.toLowerCase())
			}
		),
		"title": (query,media) => mediaMatcher["title-romaji"](query,media)
			|| mediaMatcher["title-english"](query,media)
			|| mediaMatcher["title-native"](query,media)
	}
	let voiceYear = 0;
	if(sortSelect.value === "chronological2"){
		voiceYear = 3000//Y3k, here we goooo
	}
	voiceRolesList.forEach(anime => {
		let foundRole = filterSelect.value === "";
		if(!foundRole){
			let specificMatch = filterSelect.value.toLowerCase().match(/^\s*(.*?)\s*:\s*(.*)/);
			if(specificMatch && Object.keys(mediaMatcher).includes(specificMatch[1])){
				foundRole = mediaMatcher[specificMatch[1]](specificMatch[2],anime)
			}
			else{
				foundRole = Object.keys(mediaMatcher).some(
					key => mediaMatcher[key](filterSelect.value,anime)
				)
				|| looseMatcher(anime.character.name,filterSelect.value)
			}
		}
		if(foundRole){
			if(sortSelect.value === "chronological"){
				if((anime.startDate.year || anime.endDate.year) > voiceYear){
					voiceYear = anime.startDate.year || anime.endDate.year;
					create("h3","hohYearHeading",voiceYear,hohCharacterRoles)
				}
				else if(!(anime.startDate.year || anime.endDate.year) && voiceYear > 0){
					animeYear = 0;
					create("h3","hohYearHeading","No date",hohCharacterRoles)
				}
			}
			else if(sortSelect.value === "chronological2"){
				if((anime.startDate.year || anime.endDate.year) < voiceYear){
					voiceYear = anime.startDate.year || anime.endDate.year;
					create("h3","hohYearHeading",voiceYear,hohCharacterRoles)
				}
				else if(!(anime.startDate.year || anime.endDate.year) && voiceYear > 0){
					animeYear = 0;
					create("h3","hohYearHeading","No date",hohCharacterRoles)
				}
			}
			let roleCard = createRoleCard(anime,"anime");
			roleCard.classList.add("view-media-character");
			roleCard.classList.remove("view-media");
			let character = create("div","character",false,false,"grid-area: character;grid-template-columns: auto 60px;grid-template-areas: 'content image'");
			let cover = create("a","cover",false,character);
			cover.href = "/character/" + anime.character.id + "/" + safeURL(anime.character.name);
			cheapReload(cover,{path: cover.pathname})
			cover.style.backgroundImage = "url(" + anime.character.image + ")";
			let content = create("a","content",false,character,"text-align: right;");
			content.href = "/character/" + anime.character.id + "/" + safeURL(anime.character.name);
			cheapReload(content,{path: content.pathname})
			let name = create("a","name",anime.character.name,content);
			roleCard.insertBefore(character,roleCard.children[0]);
			hohCharacterRoles.appendChild(roleCard);
			if(anime.myStatus && !alreadyCounted.has(anime.id)){
				distribution[anime.myStatus.status]++;
				if(anime.myStatus.status === "CURRENT"){
					animeCurrentFlag = true
				}
				sumDuration += Math.max(animeValueFunction(anime),0);
				if(anime.myStatus.scoreRaw){
					sumScoresAnime += anime.myStatus.scoreRaw;
					amountAnime++;
				}
				alreadyCounted.add(anime.id)
			}
		}
	});
	removeChildren(hohMediaRolesAnime)
	let animeYear = 0;
	if(sortSelect.value === "chronological2"){
		animeYear = 3000
	}
	animeRolesList.forEach(anime => {
		let foundRole = filterSelect.value === "";
		if(!foundRole){
			let specificMatch = filterSelect.value.toLowerCase().match(/^\s*(.*?)\s*:\s*(.*)/);
			if(specificMatch && Object.keys(mediaMatcher).includes(specificMatch[1])){
				foundRole = mediaMatcher[specificMatch[1]](specificMatch[2],anime)
			}
			else{
				foundRole = Object.keys(mediaMatcher).some(
					key => mediaMatcher[key](filterSelect.value,anime)
				)
			}
		}
		if(foundRole){
			if(sortSelect.value === "chronological"){
				if((anime.startDate.year || anime.endDate.year) > animeYear){
					animeYear = anime.startDate.year || anime.endDate.year;
					create("h3","hohYearHeading",animeYear,hohMediaRolesAnime)
				}
				else if(!(anime.startDate.year || anime.endDate.year) && animeYear > 0){
					animeYear = 0;
					create("h3","hohYearHeading","No date",hohMediaRolesAnime)
				}
			}
			else if(sortSelect.value === "chronological2"){
				if((anime.startDate.year || anime.endDate.year) < animeYear){
					animeYear = anime.startDate.year || anime.endDate.year;
					create("h3","hohYearHeading",animeYear,hohMediaRolesAnime)
				}
				else if(!(anime.startDate.year || anime.endDate.year) && animeYear > 0){
					animeYear = 0;
					create("h3","hohYearHeading","No date",hohMediaRolesAnime)
				}
			}
			let roleCard = createRoleCard(anime,"anime");
			hohMediaRolesAnime.appendChild(roleCard);
			if(anime.myStatus && !alreadyCounted.has(anime.id)){
				distribution[anime.myStatus.status]++;
				if(anime.myStatus.status === "CURRENT"){
					animeCurrentFlag = true
				}
				sumDuration += Math.max(animeValueFunction(anime),0);
				if(anime.myStatus.scoreRaw){
					sumScoresAnime += anime.myStatus.scoreRaw;
					amountAnime++;
				}
				alreadyCounted.add(anime.id)
			}
		}
	});
	removeChildren(hohMediaRolesManga);
	let mangaYear = 0;
	if(sortSelect.value === "chronological2"){
		mangaYear = 3000
	}
	mangaRolesList.forEach(manga => {
		let foundRole = filterSelect.value === "";
		if(!foundRole){
			let specificMatch = filterSelect.value.toLowerCase().match(/^\s*(.*?)\s*:\s*(.*)/);
			if(specificMatch && Object.keys(mediaMatcher).includes(specificMatch[1])){
				foundRole = mediaMatcher[specificMatch[1]](specificMatch[2],manga)
			}
			else{
				foundRole = Object.keys(mediaMatcher).some(
					key => mediaMatcher[key](filterSelect.value,manga)
				)
			}
		}
		if(foundRole){
			if(sortSelect.value === "chronological"){
				if((manga.startDate.year || manga.endDate.year) > mangaYear){
					mangaYear = manga.startDate.year || manga.endDate.year;
					create("h3","hohYearHeading",mangaYear,hohMediaRolesManga)
				}
				else if(!(manga.startDate.year || manga.endDate.year) && mangaYear > 0){
					mangaYear = 0;
					create("h3","hohYearHeading","No date",hohMediaRolesManga)
				}
			}
			else if(sortSelect.value === "chronological2"){
				if((manga.startDate.year || manga.endDate.year) < mangaYear){
					mangaYear = manga.startDate.year || manga.endDate.year;
					create("h3","hohYearHeading",mangaYear,hohMediaRolesManga)
				}
				else if(!(manga.startDate.year || manga.endDate.year) && mangaYear > 0){
					mangaYear = 0;
					create("h3","hohYearHeading","No date",hohMediaRolesManga)
				}
			}
			let roleCard = createRoleCard(manga,"manga");
			hohMediaRolesManga.appendChild(roleCard);
			if(manga.myStatus){
				distribution[manga.myStatus.status]++;
				if(manga.myStatus.status === "CURRENT"){
					mangaCurrentFlag = true
				}
				const mangaValue = mangaValueFunction(manga);
				sumChapters += mangaValue.chapters;
				sumVolumes += mangaValue.volumes;
				if(manga.myStatus.scoreRaw){
					sumScoresManga += manga.myStatus.scoreRaw;
					amountManga++
				}
			}
		}
	});
	if(sumDuration || sumChapters || sumVolumes || (sumScoresAnime + sumScoresManga)){
		removeChildren(digestStats)
		if(sumDuration){
			create("span",false,translate("$staff_hoursWatched"),digestStats);
			create("span",false,(sumDuration/60).roundPlaces(1),digestStats,"color:rgb(var(--color-blue))")
		}
		if(sumChapters){
			create("span",false,translate("$staff_chaptersRead"),digestStats);
			create("span",false,sumChapters,digestStats,"color:rgb(var(--color-blue))")
		}
		if(sumVolumes){
			create("span",false,translate("$staff_volumesRead"),digestStats);
			create("span",false,sumVolumes,digestStats,"color:rgb(var(--color-blue))")
		}
		if(amountAnime + amountManga){
			create("span",false,translate("$staff_meanScore"),digestStats);
			let averageNode = create("span",false,((sumScoresAnime + sumScoresManga)/(amountAnime + amountManga)).roundPlaces(1),digestStats,"color:rgb(var(--color-blue))");
			if(((sumScoresAnime + sumScoresManga)/(amountAnime + amountManga)) === 10 && userObject.mediaListOptions.scoreFormat === "POINT_10"){//https://anilist.co/activity/49407649
				averageNode.innerText += "/100"
			}
			if(sumScoresAnime && sumScoresManga){
				averageNode.title = "Anime: " + (sumScoresAnime/amountAnime).roundPlaces(1) + "\nManga: " + (sumScoresManga/amountManga).roundPlaces(1);
			}
		}
		let statusList = create("span","#statusList",false,digestStats,"position: absolute;top: -2px;margin-left: 20px;width: 300px;");
		semmanticStatusOrder.forEach(status => {
			if(distribution[status]){
				let statusSumDot = create("div","hohSummableStatus",distribution[status],statusList);
				statusSumDot.style.background = distributionColours[status];
				let title = capitalize(translate("$mediaStatus_" + status.toLowerCase()));
				if(status === "CURRENT" && !animeCurrentFlag){
					title = capitalize(translate("$mediaStatus_reading"))
				}
				else if(status === "CURRENT" && !mangaCurrentFlag){
					title = capitalize(translate("$mediaStatus_watching"))
				}
				statusSumDot.title = distribution[status] + " " + title;
				if(distribution[status] > 99){
					statusSumDot.style.fontSize = "8px"
				}
				if(distribution[status] > 999){
					statusSumDot.style.fontSize = "6px"
				}
				statusSumDot.onclick = function(){
					if(filterSelect.value === "status:" + status.toLowerCase()){
						filterSelect.value = ""
					}
					else{
						filterSelect.value = "status:" + status.toLowerCase()
					}
					filterSelect.dispatchEvent(new Event("input",{bubbles: true}))
				}
			}
		})
	}
};
sortSelect.oninput = listRenderer;
filterSelect.oninput = listRenderer;
let refreshAutocomplete = function(){
	removeChildren(dataList)
	autocomplete.forEach(
		value => create("option",false,false,dataList).value = value
	)
};
let animeHandler = function(data){
	if(data.data.Staff.staffMedia.pageInfo.hasNextPage === true){
		authAPIcall(
			staffQuery,
			{
				page: data.data.Staff.staffMedia.pageInfo.currentPage + 1,
				type: "ANIME",
				id: URLstuff[1]
			},
			animeHandler
		)
	}
	data.data.Staff.staffMedia.edges.forEach(edge => {
		let anime = {
			role: [edge.staffRole],
			format: edge.node.format,
			title: titlePicker(edge.node),
			titleRomaji: edge.node.title.romaji,
			titleEnglish: edge.node.title.english,
			titleNative: edge.node.title.native,
			image: edge.node.coverImage.large,
			startDate: edge.node.startDate,
			endDate: edge.node.endDate,
			id: edge.node.id,
			episodes: edge.node.episodes,
			popularity: edge.node.popularity,
			duration: edge.node.duration || 1,
			status: edge.node.status,
			score: edge.node.averageScore,
			genres: edge.node.genres.map(genre => genre.toLowerCase()),
			tags: edge.node.tags.map(tag => tag.name.toLowerCase()),
			myStatus: edge.node.mediaListEntry,
			listJSON: edge.node.mediaListEntry ? parseListJSON(edge.node.mediaListEntry.notes) : null
		};
		if(anime.myStatus && anime.myStatus.status === "REPEATING" && anime.myStatus.repeat === 0){
			anime.myStatus.repeat = 1
		}
		autocomplete.add(anime.title);
		autocomplete.add(distributionFormats[anime.format]);
		autocomplete.add(edge.staffRole);
		let parts = edge.staffRole.trim().match(/^(.*?)(\s+\(.*\))?$/);
		let t_role = translate("$role_" + parts[1]);
		if(t_role.substring(0,6) !== "$role_"){
			autocomplete.add(t_role + (parts[2] || ""))
		}
		animeRolesList.push(anime)
	});
	animeRolesList = removeGroupedDuplicates(
		animeRolesList,
		e => e.id,
		(oldElement,newElement) => {
			newElement.role = newElement.role.concat(oldElement.role)
		}
	);
	refreshAutocomplete();
	listRenderer();
};
let mangaHandler = function(data){
	if(data.data.Staff.staffMedia.pageInfo.hasNextPage === true){
		authAPIcall(
			staffQuery,
			{
				page: data.data.Staff.staffMedia.pageInfo.currentPage + 1,
				type: "MANGA",
				id: URLstuff[1]
			},
			mangaHandler
		)
	}
	data.data.Staff.staffMedia.edges.forEach(edge => {
		let manga = {
			role: [edge.staffRole],
			format: edge.node.format,
			title: titlePicker(edge.node),
			titleRomaji: edge.node.title.romaji,
			titleEnglish: edge.node.title.english,
			titleNative: edge.node.title.native,
			image: edge.node.coverImage.large,
			startDate: edge.node.startDate,
			endDate: edge.node.endDate,
			id: edge.node.id,
			chapters: edge.node.chapters,
			volumes: edge.node.volumes,
			popularity: edge.node.popularity,
			status: edge.node.status,
			score: edge.node.averageScore,
			genres: edge.node.genres.map(genre => genre.toLowerCase()),
			tags: edge.node.tags.map(tag => tag.name.toLowerCase()),
			myStatus: edge.node.mediaListEntry,
			listJSON: edge.node.mediaListEntry ? parseListJSON(edge.node.mediaListEntry.notes) : null
		};
		if(manga.myStatus && manga.myStatus.status === "REPEATING" && manga.myStatus.repeat === 0){
			manga.myStatus.repeat = 1
		}
		autocomplete.add(manga.title);
		autocomplete.add(distributionFormats[manga.format]);
		autocomplete.add(edge.staffRole);
		let parts = edge.staffRole.trim().match(/^(.*?)(\s+\(.*\))?$/);
		let t_role = translate("$role_" + parts[1]);
		if(t_role.substring(0,6) !== "$role_"){
			autocomplete.add(t_role + (parts[2] || ""))
		}
		mangaRolesList.push(manga)
	});
	mangaRolesList = removeGroupedDuplicates(
		mangaRolesList,
		e => e.id,
		(oldElement,newElement) => {
			newElement.role = newElement.role.concat(oldElement.role)
		}
	);
	refreshAutocomplete();
	listRenderer()
};
let voiceHandler = function(data){
	if(data.data.Staff.characters.pageInfo.hasNextPage === true){
		authAPIcall(
			staffVoice,
			{
				page: data.data.Staff.characters.pageInfo.currentPage + 1,
				id: URLstuff[1]
			},
			voiceHandler
		)
	}
	data.data.Staff.characters.edges.forEach(edge => {
		edge.role = capitalize(edge.role.toLowerCase());
		let character = {
			image: edge.node.image.large,
			id: edge.node.id
		}
		if(useScripts.titleLanguage === "NATIVE" && edge.node.name.native){
			character.name = edge.node.name.native
		}
		else{
			character.name = (edge.node.name.first || "") + " " + (edge.node.name.last || "")
		}
		autocomplete.add(edge.role);
		let parts = edge.role.trim().match(/^(.*?)(\s+\(.*\))?$/);
		let t_role = translate("$role_" + parts[1]);
		if(t_role.substring(0,6) !== "$role_"){
			autocomplete.add(t_role + (parts[2] || ""))
		}
		edge.media.forEach(thingy => {
			let anime = {
				role: [edge.role],
				format: thingy.format,
				title: titlePicker(thingy),
				titleRomaji: thingy.title.romaji,
				titleEnglish: thingy.title.english,
				titleNative: thingy.title.native,
				image: thingy.coverImage.large,
				startDate: thingy.startDate,
				endDate: thingy.endDate,
				id: thingy.id,
				episodes: thingy.episodes,
				popularity: thingy.popularity,
				duration: thingy.duration || 1,
				status: thingy.status,
				score: thingy.averageScore,
				myStatus: thingy.mediaListEntry,
				character: character,
				genres: thingy.genres.map(genre => genre.toLowerCase()),
				tags: thingy.tags.map(tag => tag.name.toLowerCase()),
				listJSON: thingy.mediaListEntry ? parseListJSON(thingy.mediaListEntry.notes) : null
			};
			if(anime.myStatus && anime.myStatus.status === "REPEATING" && anime.myStatus.repeat === 0){
				anime.myStatus.repeat = 1;
			}
			autocomplete.add(anime.title);
			voiceRolesList.push(anime)
		})
	});
	refreshAutocomplete();
	listRenderer();
};
const staffQuery = `
query($id: Int,$page: Int,$type: MediaType){
	Staff(id: $id){
		staffMedia(
			sort: POPULARITY_DESC,
			type: $type,
			page: $page
		){
			edges{
				staffRole
				node{
					id
					format
					episodes
					chapters
					volumes
					popularity
					duration
					status
					averageScore
					coverImage{large}
					startDate{year month day}
					endDate{year month day}
					title{romaji native english}
					tags{name}
					genres
					mediaListEntry{
						status
						progress
						progressVolumes
						repeat
						notes
						scoreRaw: score(format: POINT_100)
					}
				}
			}
			pageInfo{
				currentPage
				lastPage
				hasNextPage
			}
		}
	}
}`;
const staffVoice = `
query($id: Int,$page: Int){
	Staff(id: $id){
		characters(
			sort: ID,
			page: $page
		){
			edges{
				node{
					id
					image{large}
					name{first last native}
				}
				role
				media{
					id
					format
					episodes
					chapters
					volumes
					popularity
					duration
					status
					averageScore
					coverImage{large}
					startDate{year month day}
					endDate{year month day}
					title{romaji native english}
					tags{name}
					genres
					mediaListEntry{
						status
						progress
						progressVolumes
						repeat
						notes
						scoreRaw: score(format: POINT_100)
					}
				}
			}
			pageInfo{
				currentPage
				lastPage
				hasNextPage
			}
		}
	}
}`;
const variables = {
	page: 1,
	id: URLstuff[1]
};
authAPIcall(staffQuery,Object.assign({type:"ANIME"},variables),animeHandler);
authAPIcall(staffQuery,Object.assign({type:"MANGA"},variables),mangaHandler);
authAPIcall(staffVoice,variables,voiceHandler)
};
selfcaller();
	}
})
//end modules/replaceStaffRoles.js
//begin modules/rightSideNavbar.js
exportModule({
	id: "rightSideNavbar",
	description: "Move the vertical navbar to the right side of the screen",
	isDefault: false,
	categories: ["Navigation"],
	visible: true
})
//end modules/rightSideNavbar.js
//begin modules/scoreOverviewFixer.js
function scoreOverviewFixer(){
	if(!document.URL.match(/^https:\/\/anilist\.co\/(anime|manga)\//)){
		return;
	}
	let overview = document.querySelector(".media .overview");
	if(!overview){
		setTimeout(scoreOverviewFixer,300);
		return;
	}
	let follows = overview.querySelectorAll(".follow");
	if(follows.length){
		follows.forEach(el => {
			scoreColors(el);
		});
	}
	else{
		setTimeout(scoreOverviewFixer,300);
	}
}
//end modules/scoreOverviewFixer.js
//begin modules/selectMyThreads.js
function selectMyThreads(){
	if(document.URL !== "https://anilist.co/user/" + whoAmI + "/social#my-threads"){
		return
	}
	let target = document.querySelector(".filter-group span:nth-child(4)");
	if(!target){
		setTimeout(selectMyThreads,100)
	}
	else{
		target.click()
	}
}
//end modules/selectMyThreads.js
//begin modules/selfInsert.js
exportModule({
	boneless_disable: true,
	id: "selfInsert",
	description: "add " + script_type + " to the apps page",
	isDefault: true,
	categories: ["Script"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url.match("https://anilist.co/apps")
	},
	code: function(){
		let waiter = function(){
			if(!document.URL.match("https://anilist.co/apps")){
				return
			}
			if(document.querySelector(".app.hohscript")){
				return
			}
			let location = document.querySelector("[href=\"https://www.animouto.moe/\"]");
			if(!location){
				setTimeout(waiter,500)
				return
			}
			if(
				location.parentNode.childNodes.length % 3 !== 0
				&& location.parentNode.childNodes.length % 2 !== 0
			){//two or three per row, so only fill the gap if we can make the symmetry pleasing
				let app = location.cloneNode(true);
				app.classList.add("hohscript");
				app.href = scriptInfo.link;
				app.children[0].src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABkCAMAAAAL3/3yAAAA1VBMVEUfJjKXHyngDxb6AwXAGCH/AADBAAByAAA4AAAWAAAFAABzAADCAAAeJTEVGiMEBQkAAAAEBgkYHigFBwsFBwwUGSITGCEPExsUGiMZH5kLD+ECA/oAAP8AAMAAYgAAgAACfQULcRYZTykTGMIAAHEAOgATYiEAADcAHQAAABUADAAAAAYABAACA/kCfQYAADgAHgAAAHMAOwAAAMIAYwAVGiQFCAwYHikTGSLDwwB0dAA6OgAXFwAGBgB1dQDExAD//wD5+QX5+Qbg4RaXlynAwSH6+gXAOZK3AAABlUlEQVR42u3ZA4IsMRRG4b8tpW0+m2Nz/0t6rB7mZszzLeFUxQIA4K7E4olEPCaEKZn6KykExVL/xYSQeBQrLoQkolgJISQ1J4QQi1jEIhaxiAViEYtYxCIWsUAsYhGLWMQiFohFLGIRi1jEQjqTzeXzuWyhKJhK5Yqbq5ZLglet7k5o1ASPpjujJZyr7c7RFs7RcpHQv4Wa86gJp5QazqNeEk7qOK+ycFLFeVX1DHV7/YHP0BlGY5/JdKYn6cXA8NIZXo0Nr/UEdQeWN87wdmyZ6enpDSzvnOH92DLV09MfWD44w8exZaKn59Ntxfqsi2MYPrsJ/oszfLUn+Ge3dfjmDN/NrcPz25T+cIaf5qb0Gapy3Lm4svNaEE4qLd7AFQ2Xf0vCRa+Vl4U7fLDgKQy1hjthcUnwKi1U3Vx1oSSYVlbX1jc21tc2t4SQ7TkhhFjEIhaxiEUsEItYxCIWsYgFYhGLWMQiFrFALGIRi1jEIhZ2ola7QsheFGtPCNmPYu0LQQf/Wh1ICNvfOzzc2xcAAHfkF2ouxpBwdu2dAAAAAElFTkSuQmCC";
				app.children[1].textContent = script_type;
				location.parentNode.appendChild(app)
			}
		};
		waiter()
	}
})
//end modules/selfInsert.js
//begin modules/settingsPage.js
//https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript
//The first argument is the character you want to test, and the second argument is the font you want to test it in.
//If the second argument is left out, it defaults to the font of the <body> element.
//The third argument isn't used under normal circumstances, it's just used internally to avoid infinite recursion.
function characterIsSupported(character, font = getComputedStyle(document.body).fontFamily, recursion = false){
    //Create the canvases
    let testCanvas = document.createElement("canvas");
    let referenceCanvas = document.createElement("canvas");
    testCanvas.width = referenceCanvas.width = testCanvas.height = referenceCanvas.height = 150;

    //Render the characters
    let testContext = testCanvas.getContext("2d");
    let referenceContext = referenceCanvas.getContext("2d");
    testContext.font = referenceContext.font = "100px " + font;
    testContext.fillStyle = referenceContext.fillStyle = "black";
    testContext.fillText(character, 0, 100);
    referenceContext.fillText('\uffff', 0, 100);
    
    //Firefox renders unsupported characters by placing their character code inside the rectangle making each unsupported character look different.
    //As a workaround, in Firefox, we hide the inside of the character by placing a black rectangle on top of it.
    //The rectangle we use to hide the inside has an offset of 10px so it can still see part of the character, reducing the risk of false positives.
    //We check for Firefox and browers that behave similarly by checking if U+FFFE is supported, since U+FFFE is, just like U+FFFF, guaranteed not to be supported.
    if(!recursion && characterIsSupported('\ufffe', font, true)){
        testContext.fillStyle = referenceContext.fillStyle = "black";
        testContext.fillRect(10, 10, 80, 80);
        referenceContext.fillRect(10, 10, 80, 80);
    }

    //Check if the canvases are identical
    return testCanvas.toDataURL() != referenceCanvas.toDataURL();
}

const infoChar = (characterIsSupported("🛈") ? "🛈" : "i");

exportModule({
	id: "settingsPage",
	description: "This settings page",
	isDefault: true,//must be true
	categories: ["Script"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url === "https://anilist.co/settings/apps"
	},
	code: function(){
		if(location.pathname !== "/settings/apps"){
			return
		}
		if(document.getElementById("hohSettings")){
			return
		}
		let targetLocation = document.querySelector(".settings.container .content");
		let hohSettings = create("div","#hohSettings",false,targetLocation);
		hohSettings.classList.add("all");
		let scriptStatsHead = create("h1",false,translate("$settings_title"),hohSettings);
		let scriptStats = create("div",false,false,hohSettings);
		let sVersion = create("p",false,false,scriptStats);
		create("span",false,translate("$settings_version"),sVersion);
		create("span","hohStatValue",scriptInfo.version,sVersion);
		let sHome = create("p",false,translate("$settings_homepage"),scriptStats);
		let sHomeLink = create("a","external",scriptInfo.link,sHome);
		sHomeLink.href = scriptInfo.link;
		let sHome2 = create("p",false,translate("$settings_repository"),scriptStats);
		let sHomeLink2 = create("a","external",scriptInfo.repo,sHome2);
		sHomeLink2.href = scriptInfo.repo;
		if(!useScripts.accessToken){
			if(script_type === "Boneless"){
				create("p",false,"Faded options only have limited functionallity without signing in to the script (scroll down to the bottom of the page for that) which also requires persistent cookies",scriptStats)
			}
			else{
				create("p",false,"Faded options only have limited functionallity without signing in to the script (scroll down to the bottom of the page for that) which also requires persistent cookies, see https://github.com/hohMiyazawa/Automail/issues/26#issuecomment-623677462",scriptStats)
			}
		}
		let categories = create("div",["container","hohCategories"],false,scriptStats);
		let catList = ["Notifications","Feeds","Forum","Lists","Profiles","Stats","Media","Navigation","Browse","Script","Login","Newly Added"];
		let activeCategory = "";
		catList.forEach(function(category){
			let catBox = create("div","hohCategory",translate("$settings_category_" + category),categories);
			catBox.onclick = function(){
				hohSettings.className = "";
				if(activeCategory === category){
					catBox.classList.remove("active");
					activeCategory = "";
					hohSettings.classList.add("all");
				}
				else{
					if(activeCategory !== ""){
						categories.querySelector(".hohCategory.active").classList.remove("active")
					}
					catBox.classList.add("active");
					hohSettings.classList.add(category.replace(" ",""));
					activeCategory = category
				}
			}
		});
		let scriptSettings = create("div",false,false,hohSettings);
		if(!useScripts.accessToken){
			scriptSettings.classList.add("noLogin")
		}
		useScriptsDefinitions.sort((b,a) => (a.importance || 0) - (b.importance || 0));
		useScriptsDefinitions.forEach(function(def){
			let setting = create("p","hohSetting",false,scriptSettings);
			if(def.visible === false || (script_type === "Boneless" && def.boneless_disable)){
				setting.style.display = "none"
			}
			if(hasOwn(def, "type")){//other kinds of input
				let input;
				if(def.type === "select"){
					input = create("select",false,false,setting);
					if(def.id === "partialLocalisationLanguage"){
						//English stafff credits aren't included in the files since the site is already in English, but we still want to estimate the amount
						const nativeEnglishRoleCount = Object.keys(languageFiles["Norsk"].keys).filter(e => e.substring(0,6) === "$role_").length;
						def.values.forEach(
							value => create("option",false,value + " (" + Math.max(
									Object.keys(languageFiles[value].keys).length
									+ (value === "English" ? nativeEnglishRoleCount : 0),
									(
										languageFiles[value].info.variation_of
										?
										Object.keys(languageFiles[languageFiles[value].info.variation_of].keys).length	
										+ (languageFiles[value].info.variation_of === "English" ? nativeEnglishRoleCount : 0)
										:
										0
									)
								) + " keys) [" + (languageFiles[value].info.translators ? languageFiles[value].info.translators.join(", ") : languageFiles[value].info.maintainer) + "]",input)
								.value = value
						)
					}
					else{
						if(def.displayValues){
							def.values.forEach(
								(value,index) => create("option",false,translate(def.displayValues[index]),input)
									.value = value
							)
						}
						else{
							def.values.forEach(
								value => create("option",false,value,input)
									.value = value
							)
						}
					}
				}
				else if(def.type === "text"){
					input = create("input",false,false,setting)
				}
				else if(def.type === "number"){
					input = create("input",false,false,setting);
					input.type = "number";
					if(def.min !== undefined){
						input.setAttribute("min",def.min)
					}
					if(def.max){
						input.setAttribute("max",def.max)
					}
				}
				if(def.type !== "heading"){
					input.targetSetting = def.id;
					input.value = useScripts[def.id];
					input.onchange = function(){
						useScripts[this.targetSetting] = this.value;
						useScripts.save()
					}
				}
			}
			else{//default: a checkbox
				let input = createCheckbox(setting);
				input.targetSetting = def.id;
				input.checked = useScripts[def.id];
				input.onchange = function(){
					useScripts[this.targetSetting] = this.checked;
					useScripts.save();
					initCSS();
					if(!this.checked && def.destructor){
						def.destructor()
					}
					if(this.checked && def.css){
						moreStyle.textContent += def.css
					}
				}
			}
			if(def.categories){
				def.categories.forEach(
					category => {
						if(catList.includes(category)){
							setting.classList.add(category.replace(/\s/g,""))
						}
						else{
							console.warn("Unknown category '" + category + "' for module '" + def.id + "'")
						}
					}
				)
			}
			create("span",false,translate(def.description),setting);
			if(def.extendedDescription){
				let infoButton = create("span","hohInfoButton",infoChar,setting);
				infoButton.title = translate("$settings_moreInfo_tooltip");
				infoButton.onclick = function(){
					createDisplayBox(false,"Module info").innerText = translate(def.extendedDescription)
				}
			}
		});
		let titleAliasSettings = create("div");
		let titleAliasInstructions = create("p");
		titleAliasInstructions.innerText = `
	Add title aliases. Use the format /type/id/alias , one per line. Examples:

	/anime/5114/Fullmetal Alchemist
	/manga/30651/Nausicaä

	Changes take effect on reload.`;
		let titleAliasInput = create("textarea","#titleAliasInput");
		(
			JSON.parse(localStorage.getItem("titleAliases")) || []
		).forEach(
			alias => titleAliasInput.value += alias[0] + alias[1] + "\n"
		);
		titleAliasInput.rows = "6";
		titleAliasInput.cols = "50";
		let titleAliasChange = create("button",["hohButton","button"],translate("$button_submit"));
		titleAliasChange.onclick = function(){
			let newAliases = [];
			let aliasContent = titleAliasInput.value.split("\n");
			let aliasRegex = /^(\/(anime|manga)\/\d+\/)(.*)/;
			let cssAlias = /^(css\/)(.*)/;
			aliasContent.forEach(content => {
				let matches = content.match(aliasRegex);
				if(!matches){
					let cssMatches = content.match(cssAlias);
					if(cssMatches){
						newAliases.push([cssMatches[1],cssMatches[2]])
					}
					return
				}
				newAliases.push([matches[1],matches[3]]);
			});
			localStorage.setItem("titleAliases",JSON.stringify(newAliases))
		};
		titleAliasSettings.appendChild(create("hr"));
		titleAliasSettings.appendChild(titleAliasInstructions);
		titleAliasSettings.appendChild(titleAliasInput);
		create("br",false,false,titleAliasSettings);
		titleAliasSettings.appendChild(titleAliasChange);
		titleAliasSettings.appendChild(create("hr"));
		hohSettings.appendChild(titleAliasSettings);
		//
		let notificationColour = create("div");
		if(useScripts.accessToken){
			const notificationTypes = Object.keys(notificationColourDefaults);
			const supportedColours = [
				{name:translate("$colour_transparent"),value:"rgb(0,0,0,0)"},
				{name:translate("$colour_blue"),value:"rgb(61,180,242)"},
				{name:translate("$colour_white"),value:"rgb(255,255,255)"},
				{name:translate("$colour_black"),value:"rgb(0,0,0)"},
				{name:translate("$colour_red"),value:"rgb(232,93,117)"},
				{name:translate("$colour_peach"),value:"rgb(250,122,122)"},
				{name:translate("$colour_orange"),value:"rgb(247,154,99)"},
				{name:translate("$colour_yellow"),value:"rgb(247,191,99)"},
				{name:translate("$colour_green"),value:"rgb(123,213,85)"}
			];
			create("p",false,translate("$settings_notificationDotColour"),notificationColour);
			let nColourType = create("select",false,false,notificationColour);
			let nColourValue = create("select",false,false,notificationColour);
			let supressOption = createCheckbox(notificationColour);
			let supressOptionText = create("span",false,"Don't show dot for this type",notificationColour);
			notificationTypes.forEach(
				type => create("option",false,type,nColourType)
					.value = type
			);
			supportedColours.forEach(
				colour => create("option",false,colour.name,nColourValue)
					.value = colour.value
			);
			create("br",false,false,notificationColour);
			let resetAll = create("button",["hohButton","button"],translate("$button_resetAll"),notificationColour);
			resetAll.onclick = function(){
				useScripts.notificationColours = notificationColourDefaults;
				useScripts.save();
			};
			nColourType.oninput = function(){
				nColourValue.value = useScripts.notificationColours[nColourType.value].colour;
				supressOption.checked = useScripts.notificationColours[nColourType.value].supress;
			};
			nColourValue.oninput = function(){
				useScripts.notificationColours[nColourType.value].colour = nColourValue.value;
				useScripts.save();
			};
			supressOption.oninput = function(){
				useScripts.notificationColours[nColourType.value].supress = supressOption.checked;
				useScripts.save()
			};
			nColourValue.value = useScripts.notificationColours[nColourType.value].colour;
			supressOption.checked = useScripts.notificationColours[nColourType.value].supress;
			hohSettings.appendChild(notificationColour);
		}
		hohSettings.appendChild(create("hr"));
		let blockList = localStorage.getItem("blockList");
		if(blockList){
			blockList = JSON.parse(blockList)
		}
		else{
			blockList = []
		}
		let blockSettings = create("div");
		let blockInstructions = create("p",false,false,blockSettings);
		blockInstructions.innerText = `
Block stuff in the home feed.

Example1: To block "planning" activities by a specific user, fill out those two fields and leave the media field blank.
Example2: To block a specific piece of media, fill out that field and leave the other two blank.

Changes take effect on reload.`;
		let blockInput = create("div","#blockInput",false,blockSettings);
		create("span",false,"User: ",blockInput);
		let blockUserInput = create("input",false,false,blockInput,"width:100px;margin-right:10px;");
		blockUserInput.value = "";
		create("span",false," Status: ",blockInput);
		let blockStatusInput = create("select",false,false,blockInput,"margin-right:10px;");
		const blockStatuses = ["","all","status","progress","anime","manga","planning","watching","reading","pausing","dropping","rewatching","rereading","rewatched","reread"];
		blockStatuses.forEach(
			status => create("option",false,capitalize(status),blockStatusInput)
				.value = status
		);
		blockStatusInput.value = "";
		create("span",false," Media ID: ",blockInput);
		let blockMediaInput = create("input",false,false,blockInput,"width:100px;margin-right:10px;");
		blockMediaInput.type = "number";
		blockMediaInput.value = "";
		blockMediaInput.min = 1;
		blockMediaInput.addEventListener("paste",function(e){
			let clipboardData = e.clipboardData || window.clipboardData;
			if(!clipboardData){//don't mess with paste
				return
			}
			let pastedData = clipboardData.getData("Text");
			if(!pastedData){
				return
			}
			e.stopPropagation();
			e.preventDefault();
			let possibleFullURL = pastedData.match(/(anime|manga)\/(\d+)\/?/);
			if(possibleFullURL){
				blockMediaInput.value = parseInt(possibleFullURL[2])
			}
			else{
				blockMediaInput.value = pastedData
			}
		});
		let blockAddInput = create("button",["button","hohButton"],"Add",blockInput);
		let blockVisual = create("div",false,false,blockSettings);
		let drawBlockList = function(){
			removeChildren(blockVisual)
			blockList.forEach(function(blockItem,index){
					let item = create("div","hohBlock",false,blockVisual);
					let cross = create("span","hohBlockCross",svgAssets.cross,item);
					cross.onclick = function(){
						blockList.splice(index,1);
						localStorage.setItem("blockList",JSON.stringify(blockList));
						drawBlockList();
					};
					if(blockItem.user){
						create("span","hohBlockSpec",blockItem.user,item)
					}
					if(blockItem.status){
						create("span","hohBlockSpec",capitalize(blockItem.status),item)
					}
					if(blockItem.media){
						create("span","hohBlockSpec","ID:" + blockItem.media,item)
					}
			})
		};drawBlockList();
		blockAddInput.onclick = function(){
			let newBlock = {
				user: false,
				status: false,
				media: false
			};
			if(blockUserInput.value){
				newBlock.user = blockUserInput.value
			}
			if(blockStatusInput.value){
				newBlock.status = blockStatusInput.value
			}
			if(blockMediaInput.value){
				newBlock.media = blockMediaInput.value
			}
			if(newBlock.user || newBlock.status || newBlock.media){
				blockList.push(newBlock);
				localStorage.setItem("blockList",JSON.stringify(blockList));
				drawBlockList();
			}
		};
		hohSettings.appendChild(blockSettings);
		//
		hohSettings.appendChild(create("hr"));
		if(useScripts.profileBackground && useScripts.accessToken){
			let backgroundSettings = create("div",false,false,hohSettings);
			create("p",false,translate("$profileBackground_help1"),backgroundSettings);
			create("pre","hohCode","red",backgroundSettings);
			create("pre","hohCode","#640064",backgroundSettings);
			create("pre","hohCode","url(https://www.example.com/myBackground.jpg)",backgroundSettings);
			create("p",false,translate("$profileBackground_help2"),backgroundSettings);
			create("pre","hohCode","rgb(100,0,100,0.4)",backgroundSettings);
			create("p",false,translate("$profileBackground_help3"),backgroundSettings);
			create("pre","hohCode","linear-gradient(rgb(var(--color-background),0.8),rgb(var(--color-background),0.8)), url(https://www.example.com/myBackground.jpg) center/100% fixed",backgroundSettings);
			let inputField = create("input",false,false,backgroundSettings);
			inputField.value = useScripts.profileBackgroundValue;
			create("br",false,false,backgroundSettings);
			let backgroundChange = create("button",["hohButton","button"],translate("$button_submit"),backgroundSettings);
			backgroundChange.onclick = function(){
				useScripts.profileBackgroundValue = inputField.value;
				useScripts.save();
				let jsonMatch = (userObject.about || "").match(/^\[\]\(json([A-Za-z0-9+/=]+)\)/);
				let profileJson = {};
				if(jsonMatch){
					try{
						profileJson = JSON.parse(atob(jsonMatch[1]))
					}
					catch(e){
						try{
							profileJson = JSON.parse(LZString.decompressFromBase64(jsonMatch[1]))
						}
						catch(e){
							console.warn(translate("$settings_errorInvalidJSON"))
						}
					}
				}
				profileJson.background = useScripts.profileBackgroundValue;
				if(!profileJson.background){
					delete profileJson["background"]
				}
				//let newDescription = "[](json" + btoa(JSON.stringify(profileJson)) + ")" + (userObject.about.replace(/^\[\]\(json([A-Za-z0-9+/=]+)\)/,""));
				let newDescription = "[](json" + LZString.compressToBase64(JSON.stringify(profileJson)) + ")" + ((userObject.about || "").replace(/^\[\]\(json([A-Za-z0-9+/=]+)\)/,""));
				authAPIcall(
					`mutation($about: String){
						UpdateUser(about: $about){
							about
						}
					}`,
					{about: newDescription},function(data){
						if(!data){
							return
						}
						deleteCacheItem("hohProfileBackground" + whoAmI)
					}
				)
			};
			hohSettings.appendChild(create("hr"));
		}
		if(useScripts.customCSS && useScripts.accessToken && script_type !== "Boneless"){
			let backgroundSettings = create("div",false,false,hohSettings);
			create("p",false,translate("$settings_CSSadd"),backgroundSettings);
			let inputField = create("textarea",false,false,backgroundSettings,"width: 100%;scrollbar-width: auto;");
			inputField.value = useScripts.customCSSValue;
			if(inputField.value){
				inputField.rows = 10
			}
			else{
				inputField.rows = 4
			}
			create("br",false,false,backgroundSettings);
			create("p",false,translate("$settings_CSSlinkTip"),backgroundSettings);
			let backgroundChange = create("button",["hohButton","button"],translate("$button_submit"),backgroundSettings);
			backgroundChange.onclick = function(){
				useScripts.customCSSValue = inputField.value;
				let jsonMatch = (userObject.about || "").match(/^\[\]\(json([A-Za-z0-9+/=]+)\)/);
				let profileJson = {};
				if(jsonMatch){
					try{
						profileJson = JSON.parse(atob(jsonMatch[1]))
					}
					catch(e){
						try{
							profileJson = JSON.parse(LZString.decompressFromBase64(jsonMatch[1]))
						}
						catch(e){
							console.warn(translate("$settings_errorInvalidJSON"))
						}
					}
				}
				profileJson.customCSS = useScripts.customCSSValue;
				if(!profileJson.customCSS){
					delete profileJson["customCSS"]
				}
				//let newDescription = "[](json" + btoa(JSON.stringify(profileJson)) + ")" + (userObject.about.replace(/^\[\]\(json([A-Za-z0-9+/=]+)\)/,""));
				let newDescription = "[](json" + LZString.compressToBase64(JSON.stringify(profileJson)) + ")" + ((userObject.about || "").replace(/^\[\]\(json([A-Za-z0-9+/=]+)\)/,""));
				if(newDescription.length > 1e6){
					alert(translate("$cssTooBig"))
				}
				else{
					useScripts.save();
					authAPIcall(
						`mutation($about: String){
							UpdateUser(about: $about){
								about
							}
						}`,
						{about: newDescription},
						function(data){
							if(!data){
								alert("failed to save custom CSS")
							}
							deleteCacheItem("hohProfileBackground" + whoAmI)
						}
					)
				}
			};
			hohSettings.appendChild(create("hr"))
		}
		if(useScripts.customCSS && useScripts.accessToken && script_type !== "Boneless"){
			let pinSettings = create("div",false,false,hohSettings);
			create("p",false,translate("$settings_pinnedActivity"),pinSettings);
			let inputField = create("input",false,false,pinSettings);
			inputField.value = useScripts.pinned;
			inputField.setAttribute("placeholder","activity link");
			create("br",false,false,pinSettings);
			let pinChange = create("button",["hohButton","button"],translate("$button_submit"),pinSettings);
			let hohSpinner = create("span","hohSpinner","",pinSettings);
			pinChange.onclick = function(){
				hohSpinner.innerText = svgAssets.loading;
				hohSpinner.classList.remove("spinnerError");
				hohSpinner.classList.remove("spinnerDone");
				hohSpinner.classList.add("spinnerLoading");
				let activityID = parseInt(inputField.value);
				if(inputField.value !== ""){
					if(!activityID){
						let matches = inputField.value.match(/^https:\/\/anilist\.co\/activity\/(\d+)\/?$/);
						if(matches){
							activityID = parseInt(matches[1])
						}
					}
					if(!activityID){
						alert(translate("$settings_errorInvalidActivity"));
						hohSpinner.innerText = svgAssets.cross;
						hohSpinner.classList.add("spinnerError");
						hohSpinner.classList.remove("spinnerLoading");
						return
					}
					generalAPIcall(
`
query{
	Activity(id: ${activityID}){
		... on ListActivity{
			id
		}
		... on MessageActivity{
			id
		}
		... on TextActivity{
			id
		}
	}
}
`,
						{},
						function(data){
							if(!data){
								hohSpinner.innerText = svgAssets.cross;
								hohSpinner.classList.add("spinnerError");
								hohSpinner.classList.remove("spinnerLoading");
								hohSpinner.classList.remove("spinnerDone");
								alert(translate("$settings_errorInvalidActivity"))
							}
						}
					)
				}
				else{
					activityID = ""
				}
				useScripts.pinned = activityID;
				let jsonMatch = (userObject.about || "").match(/^\[\]\(json([A-Za-z0-9+/=]+)\)/);
				let profileJson = {};
				if(jsonMatch){
					try{
						profileJson = JSON.parse(atob(jsonMatch[1]))
					}
					catch(e){
						try{
							profileJson = JSON.parse(LZString.decompressFromBase64(jsonMatch[1]))
						}
						catch(e){
							hohSpinner.innerText = svgAssets.cross;
							hohSpinner.classList.add("spinnerError");
							hohSpinner.classList.remove("spinnerLoading");
							console.warn(translate("$settings_errorInvalidJSON"));
							return
						}
					}
				}
				profileJson.pinned = useScripts.pinned;
				if(!profileJson.pinned){
					delete profileJson["pinned"]
				}
				let newDescription = "[](json" + LZString.compressToBase64(JSON.stringify(profileJson)) + ")" + ((userObject.about || "").replace(/^\[\]\(json([A-Za-z0-9+/=]+)\)/,""));
				if(newDescription.length > 1e6){
					hohSpinner.innerText = svgAssets.cross;
					hohSpinner.classList.add("spinnerError");
					hohSpinner.classList.remove("spinnerLoading");
					alert(translate("$jsonTooBig"))
				}
				else{
					useScripts.save();
					authAPIcall(
						`mutation($about: String){
							UpdateUser(about: $about){
								about
							}
						}`,
						{about: newDescription},
						function(data){
							if(!data){
								hohSpinner.innerText = svgAssets.cross;
								hohSpinner.classList.add("spinnerError");
								hohSpinner.classList.remove("spinnerLoading");
								alert("failed to save pinned activity")
							}
							else{
								hohSpinner.innerText = svgAssets.check;
								hohSpinner.classList.add("spinnerDone");
								hohSpinner.classList.remove("spinnerLoading");
							}
							deleteCacheItem("hohProfileBackground" + whoAmI)
						}
					)
				}
			};
			hohSettings.appendChild(create("hr"))
		}

		create("p",false,"Delete all custom settings. Re-installing the script will not do that by itself.",hohSettings);
		let cleanEverything= create("button",["hohButton","button","danger"],translate("$button_defaultSettings"),hohSettings);
		cleanEverything.onclick = function(){
			localStorage.removeItem("hohSettings");
			window.location.reload(false);
		}
		create("hr","hohSeparator",false,hohSettings);
		let loginURL = create("a",false,translate("$terms_signin_link"),hohSettings,"font-size: x-large;");
		loginURL.href = authUrl;
		loginURL.style.color = "rgb(var(--color-blue))";
		create("p",false,"Enables or improves every module in the \"Login\" tab, improves those greyed out.",hohSettings);
		if(script_type !== "Boneless"){
			create("h4",false,"Alternative signin method: Self-hosting the script",hohSettings);
			create("p",false,"1. Go to settings > developer > \"Create New Client\"",hohSettings);
			create("p",false,"2. Give it any name, and use \"https://anilist.co/home\" for the redirect URL",hohSettings);
			create("p",false,"3. Take a screenshot so you don't loose the info",hohSettings);
			let ele = create("p",false,"4. ",hohSettings);
			let lonk = create("span",false,"Click here and input the Client ID",ele,"color:rgb(var(--color-blue));cursor:pointer");
			lonk.onclick = function(){
				let id = parseInt(prompt("Client ID:"));
				if(id){
					useScripts.client_id = id;
					useScripts.save();
					window.location = "https://anilist.co/api/v2/oauth/authorize?client_id=" + id + "&response_type=token"
				}
				else{
					alert("Error: Client not found")
				}
			}
			if(useScripts.accessToken){
				create("hr","hohSeparator",false,hohSettings);
				create("p",false,"Current access token (do not share with others):",hohSettings);
				create("p","hohMonospace",useScripts.accessToken,hohSettings,"word-wrap: anywhere;font-size: small;line-break: anywhere;")
			}
		}

		hohSettings.appendChild(create("hr"));

		let debugInfo = create("button",["hohButton","button"],translate("$settings_button_export"),hohSettings);
		create("p",false,translate("$settings_export_description"),hohSettings);
		create("p",false,translate("$settings_import"),hohSettings);
		let debugImport = create("input","input-file",false,hohSettings);
		debugImport.setAttribute("type","file");
		debugImport.setAttribute("name","json");
		debugImport.setAttribute("accept","application/json");
		debugInfo.onclick = function(){
			let export_settings = JSON.parse(JSON.stringify(useScripts));//deepclone
			if(export_settings.accessToken){//idiot proofing: we don't want users leaking their access tokens
				export_settings.accessToken = "[REDACTED]"
			}
			if(whoAmI){
				saveAs(export_settings,script_type + "_settings_" + whoAmI + ".json")
			}
			else{
				saveAs(export_settings,script_type + "_settings.json")
			}
		}
		debugImport.oninput = function(){
			let reader = new FileReader();
			reader.readAsText(debugImport.files[0],"UTF-8");
			reader.onload = function(evt){
				let data;
				try{
					data = JSON.parse(evt.target.result)
				}
				catch(e){
					alert("error parsing JSON")
					return
				}
				if(!hasOwn(data, "socialTab")){//sanity check
					alert("not a settings file")
					return
				}
				Object.keys(data).forEach(//this is to keep the default settings if the version imported is outdated
					key => {
						if(key === "accessToken"){
							if(!useScripts.accessToken && data[key] === "[REDACTED]"){
								alert("Access tokens are not stored in settings files for security reasons. You have to click the 'Sign in with the script' button again")
							}
						}
						else{
							useScripts[key] = data[key]
						}
					}
				)
				useScripts.save();
				alert("settings imported!")
			}
			reader.onerror = function(evt){
				alert("error reading file")
			}
		}
		create("p",false,translate("$debug_tip"),hohSettings);
	}
})
//end modules/settingsPage.js
//begin modules/showMarkdown.js
function showMarkdown(id){
	if(!location.pathname.match(id)){
		return
	}
	if(document.querySelector(".hohGetMarkdown")){
		return
	}
	let timeContainer = document.querySelector(".activity-text .time,.activity-message .time");
	if(!timeContainer){
		setTimeout(function(){showMarkdown(id)},200);
		return
	}
	if(!useScripts.accessToken && document.querySelector(".private-badge")){
		return//can't fetch private messages without privileges
	}
	let codeLink = create("span",["action","hohGetMarkdown"],"</>",false,"font-weight:bolder;");
	timeContainer.insertBefore(codeLink,timeContainer.firstChild);
	codeLink.onclick = function(){
		let activityMarkdown = document.querySelector(".activity-markdown");
		if(activityMarkdown.style.display === "none"){
			document.querySelector(".hohMarkdownSource").style.display = "none";
			activityMarkdown.style.display = "initial"
		}
		else{
			activityMarkdown.style.display = "none";
			let markdownSource = document.querySelector(".hohMarkdownSource");
			if(markdownSource){
				markdownSource.style.display = "initial"
			}
			else{
				const caller = (document.querySelector(".private-badge") ? authAPIcall : generalAPIcall);
				caller("query($id:Int){Activity(id:$id){...on MessageActivity{text:message}...on TextActivity{text}}}",{id:id},function(data){
					if(!location.pathname.match(id) || !data){
						return
					}
					markdownSource = create("div",["activity-markdown","hohMarkdownSource"],data.data.Activity.text,activityMarkdown.parentNode);
				},"hohGetMarkdown" + id,20*1000)
			}
		}
	}
}
//end modules/showMarkdown.js
//begin modules/singleActivityReplyLikes.js
exportModule({
	id: "singleActivityReplyLikes",
	description: "Add like tooltips to all replies when viewing a single activity",
	isDefault: true,
	categories: ["Feeds"],
	visible: false,
	urlMatch: function(url,oldUrl){
		return url.match(/^https:\/\/anilist\.co\/activity\/(\d+)/)
	},
	code: function singleActivityReplyLikes(){
		let id = parseInt(document.URL.match(/^https:\/\/anilist\.co\/activity\/(\d+)/)[1])
		let adder = function(data){
			if(!data){
				return//private actitivites, mostly. Doesn't matter as there aren't many people there.
			}
			if(!document.URL.includes("activity/" + id || !data)){
				return
			}
			let post = document.querySelector(".activity-entry > .wrap > .actions .action.likes");
			if(!post){
				setTimeout(function(){adder(data)},200);
				return
			}
			post.classList.add("hohLoadedLikes");
			post.classList.add("hohHandledLike");
			if(post.querySelector(".count") && !(parseInt(post.querySelector(".count").innerText) <= 5)){
				post.title = data.data.Activity.likes.map(like => like.name).join("\n")
			}
			let smallAdder = function(){
				if(!document.URL.includes("activity/" + id)){
					return
				}
				let actionLikes = document.querySelectorAll(".activity-replies .action.likes");
				if(!actionLikes.length){
					setTimeout(smallAdder,200);
					return
				}
				actionLikes.forEach((node,index) => {
					if(node.querySelector(".count") && !(parseInt(node.querySelector(".count").innerText) <= 5)){
						node.title = data.data.Activity.replies[index].likes.map(like => like.name).join("\n")
					}
				});
			};
			if(data.data.Activity.replies.length){
				smallAdder()
			}
		}
		generalAPIcall(`
	query($id: Int){
		Activity(id: $id){
			... on TextActivity{
				likes{name}
				replies{likes{name}}
			}
			... on MessageActivity{
				likes{name}
				replies{likes{name}}
			}
			... on ListActivity{
				likes{name}
				replies{likes{name}}
			}
		}
	}`,
			{id: id},
			adder
		)
	}
})
//end modules/singleActivityReplyLikes.js
//begin modules/slimNav.js
exportModule({
	id: "slimNav",
	description: "Slim navbar",
	isDefault: false,
	importance: -2,
	categories: ["Navigation"],
	visible: true
})
//end modules/slimNav.js
//begin modules/socialTabFeed.js
function enhanceSocialTabFeed(){
	let URLstuff = location.pathname.match(/^\/(anime|manga)\/(\d+)(\/[\w-]*)?\/social/);
	if(!URLstuff){
		return
	}
	let feedLocation = document.querySelector(".activity-feed");
	if(!feedLocation){
		setTimeout(enhanceSocialTabFeed,100);
		return
	}
	let hohFeed = create("div","hohSocialFeed");
	feedLocation.insertBefore(hohFeed,feedLocation.children[0]);
	let optionsContainer = create("div",false,false,hohFeed,"position:absolute;top:0px;right:0px;");
	let hasReplies = createCheckbox(optionsContainer);
	create("span",false,translate("$filter_replies"),optionsContainer,"margin-right:7px;");
	let isFollowing = createCheckbox(optionsContainer);
	if(useScripts.accessToken){
		create("span",false,translate("$filter_following"),optionsContainer)
	}
	else{
		isFollowing.parentNode.style.display = "none"
	}
	let feedHeader = create("h2",false,"Recent Activity",hohFeed,"display:none;");
	let feedContent = create("div",false,false,hohFeed,"display:none;");
	let loadMore = create("div","load-more",translate("$load_more"),hohFeed);
	let query = "";
	let buildFeed = function(page){
		authAPIcall(//use also when accessToken is not available, since it will fall back to a regular API call
			query,
			{
				page: page,
				mediaId: parseInt(URLstuff[2])
			},
			function(data){
				if(!data){//restore regular feed
					feedLocation.classList.remove("hohReplaceFeed");
					feedContent.style.display = "none";
					feedHeader.style.display = "none";
					loadMore.style.display = "none";
					return
				}
				if(
					data.data.Page.pageInfo.lastPage > page
					&& (
						data.data.Page.activities.length === 25
						|| data.data.Page.activities.length === 24//since pageInfo is kill, it's better with some false positives than missing the button too often
					)
				){
					loadMore.style.display = "block";
					loadMore.onclick = function(){
						buildFeed(page + 1)
					}
				}
				else{
					loadMore.style.display = "none"
				}
				if(data.data.Page.activities.length === 0){
					create("div","activity-entry",translate("$socialTabFeed_noActivities"),feedContent)
				}
				data.data.Page.activities.forEach(act => {
					let activityEntry = create("div",["activity-entry","activity-" + URLstuff[1] + "_list"],false,feedContent);
					let wrap = create("div","wrap",false,activityEntry);
						let list = create("div","list",false,wrap);
							let cover = create("a",["cover","router-link-active"],false,list);
							cover.href = "/" + URLstuff[1] + "/" + URLstuff[2] + "/" + safeURL(act.media.title.userPreferred);
							cover.style.backgroundImage = `url("${act.media.coverImage.medium}")`;
							let details = create("div","details",false,list);
								let name = create("a","name",act.user.name,details);
								name.href = "/user/" + act.user.name;
								details.appendChild(document.createTextNode(" "));
								if(!act.status){//old "null" values from the API
									if(URLstuff[1] === "manga"){
										act.status = "read"
									}
									else{
										act.status = "watched"
									}
								}
								let status = create("div","status",act.status + (act.progress ? " " + act.progress + " of " : " "),details);
								if(URLstuff[1] === "manga"){
									if(act.status === "read chapter" && act.progress){
										status.innerText = translate("$listActivity_MreadChapter",act.progress)
									}
									else if(act.status === "reread"){
										status.innerText = translate("$listActivity_repeatedManga")
									}
									else if(act.status === "reread chapter" && act.progress){
										status.innerText = translate("$listActivity_MrepeatingManga",act.progress)
									}
									else if(act.status === "dropped" && act.progress){
										status.innerText = " " + translate("$listActivity_MdroppedManga",act.progress)
									}
									else if(act.status === "completed"){
										status.innerText = translate("$listActivity_completedManga")
									}
									else if(act.status === "plans to read"){
										status.innerText = translate("$listActivity_planningManga")
									}
									else if(act.status === "paused reading"){
										status.innerText = translate("$listActivity_pausedManga")
									}
									else{
										console.warn("Missing listActivity translation key for:",act.status)
									}
								}
								else{
									if(act.status === "watched episode" && act.progress){
										status.innerText = translate("$listActivity_MwatchedEpisode",act.progress)
									}
									else if(act.status === "rewatched"){
										status.innerText = translate("$listActivity_repeatedAnime")
									}
									else if(act.status === "rewatched episode" && act.progress){
										status.innerText = translate("$listActivity_MrepeatingAnime",act.progress)
									}
									else if(act.status === "dropped" && act.progress){
										status.innerText = " " + translate("$listActivity_MdroppedAnime",act.progress)
									}
									else if(act.status === "completed"){
										status.innerText = translate("$listActivity_completedAnime")
									}
									else if(act.status === "plans to watch"){
										status.innerText = translate("$listActivity_planningAnime")
									}
									else if(act.status === "paused watching"){
										status.innerText = translate("$listActivity_pausedAnime")
									}
									else{
										console.warn("Missing listActivity translation key for:",act.status)
									}
								}
								let link = create("a",["title","router-link-active"]," " + act.media.title.userPreferred,status);
									link.href = "/" + URLstuff[1] + "/" + URLstuff[2] + "/" + safeURL(act.media.title.userPreferred);
								let avatar = create("a","avatar",false,details);
								avatar.href = "/user/" + act.user.name;
								avatar.style.backgroundImage = `url("${act.user.avatar.medium}")`;
						let timeWrapper = create("div","time",false,wrap);
							let action = create("a","action",false,timeWrapper);
							action.appendChild(svgAssets2.link.cloneNode(true));
							action.href = "/activity/" + act.id;
							cheapReload(action,{name: "Activity", params: {id: act.id}});
							let time = nativeTimeElement(act.createdAt);timeWrapper.appendChild(time);
						let actions = create("div","actions",false,wrap);
							let actionReplies = create("div",["action","replies"],false,actions);
								if(act.replies.length){
									let replyCount = create("span","count",act.replies.length,actionReplies);
									actionReplies.appendChild(document.createTextNode(" "));
								}
								actionReplies.appendChild(svgAssets2.reply.cloneNode(true));
							actions.appendChild(document.createTextNode(" "));
							let actionLikes = create("div",["action","likes"],false,actions);
								let likeWrap = create("div","like-wrap",false,actionLikes);
									let likeButton = create("div","button",false,likeWrap);
										let likeCount = create("span","count",act.likes.length || "",likeButton);
										likeButton.appendChild(document.createTextNode(" "));
										likeButton.appendChild(svgAssets2.likeNative.cloneNode(true));
									likeButton.title = act.likes.map(a => a.name).join("\n");
									if(act.likes.some(like => like.name === whoAmI)){
										likeButton.classList.add("liked")
									}
									likeButton.onclick = function(){
										authAPIcall(
											"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY){id}}",
											{id: act.id},
											function(data2){
												if(!data2){
													authAPIcall(//try again once if it fails
														"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY){id}}",
														{id: act.id},
														function(data3){}
													)
												}
											}
										);
										if(act.likes.some(like => like.name === whoAmI)){
											act.likes.splice(act.likes.findIndex(user => user.name === whoAmI),1);
											likeButton.classList.remove("liked");
											if(act.likes.length > 0){
												likeButton.querySelector(".count").innerText = act.likes.length
											}
											else{
												likeButton.querySelector(".count").innerText = ""
											}
										}
										else{
											act.likes.push({name: whoAmI});
											likeButton.classList.add("liked");
											likeButton.querySelector(".count").innerText = act.likes.length;
										}
										likeButton.title = act.likes.map(a => a.name).join("\n")
									};
					let replyWrap = create("div","reply-wrap",false,activityEntry,"display:none;");
					actionReplies.onclick = function(){
						if(replyWrap.style.display === "none"){
							replyWrap.style.display = "block"
						}
						else{
							replyWrap.style.display = "none"
						}
					};
					let activityReplies = create("div","activity-replies",false,replyWrap);
					act.replies.forEach(rep => {
						let reply = create("div","reply",false,activityReplies);
							let header = create("div","header",false,reply);
								let repAvatar = create("a","avatar",false,header);
								repAvatar.href = "/user/" + rep.user.name;
								repAvatar.style.backgroundImage = `url("${rep.user.avatar.medium}")`;
								header.appendChild(document.createTextNode(" "));
								let repName = create("a","name",rep.user.name,header);
								repName.href = "/user/" + rep.user.name;
								let cornerWrapper = create("div","actions",false,header);
									let repActionLikes = create("div",["action","likes"],false,cornerWrapper,"display: inline-block");
										const randomDataHate = "data-v-977827fa";
										let repLikeWrap = create("div","like-wrap",false,repActionLikes);
											let repLikeButton = create("div","button",false,repLikeWrap);
												let repLikeCount = create("span","count",rep.likes.length || "",repLikeButton);
												repLikeButton.appendChild(document.createTextNode(" "));
												repLikeButton.appendChild(svgAssets2.likeNative.cloneNode(true));
											repLikeButton.title = rep.likes.map(a => a.name).join("\n");
											if(rep.likes.some(like => like.name === whoAmI)){
												repLikeButton.classList.add("liked")
											}
											repLikeButton.onclick = function(){
												authAPIcall(
													"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
													{id: rep.id},
													function(data2){
														if(!data2){
															authAPIcall(//try again once if it fails
																"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
																{id: rep.id},
																function(data3){}
															)
														}
													}
												);
												if(rep.likes.some(like => like.name === whoAmI)){
													rep.likes.splice(rep.likes.findIndex(user => user.name === whoAmI),1);
													repLikeButton.classList.remove("liked");
													repLikeButton.classList.remove("hohILikeThis");
													if(rep.likes.length > 0){
														repLikeButton.querySelector(".count").innerText = rep.likes.length
													}
													else{
														repLikeButton.querySelector(".count").innerText = ""
													}
												}
												else{
													rep.likes.push({name: whoAmI});
													repLikeButton.classList.add("liked");
													repLikeButton.classList.add("hohILikeThis");
													repLikeButton.querySelector(".count").innerText = rep.likes.length;
												}
												repLikeButton.title = rep.likes.map(a => a.name).join("\n")
											};
									let repActionTime = create("div",["action","time"],false,cornerWrapper,"display: inline-block");
										let repTime = nativeTimeElement(rep.createdAt);repActionTime.appendChild(repTime);
							let replyMarkdown = create("div","reply-markdown",false,reply);
								let markdown = create("div","markdown",false,replyMarkdown);
								markdown.innerHTML = rep.text;//reason for inner HTML: preparsed sanitized HTML from the Anilist API
					})
				})
			}
		)
	};
	hasReplies.oninput = isFollowing.oninput = function(){
		if(hasReplies.checked || isFollowing.checked){
			feedLocation.classList.add("hohReplaceFeed");
			feedContent.style.display = "block";
			feedHeader.style.display = "block";
			removeChildren(feedContent)
			if(hasReplies.checked && isFollowing.checked){
				query = `
query($mediaId: Int,$page: Int){
	Page(page: $page,perPage: 25){
		pageInfo{lastPage}
		activities(mediaId: $mediaId,hasReplies:true,isFollowing:true,sort:ID_DESC){
			... on ListActivity{
				id
				status
				progress
				createdAt
				user{
					name
					avatar{
						medium
					}
				}
				media{
					title{
						userPreferred
					}
					coverImage{medium}
				}
				replies{
					id
					text(asHtml: true)
					createdAt
					user{
						name
						avatar{
							medium
						}
					}
					likes{
						name
					}
				}
				likes{
					name
				}
			}
		}
	}
}`;
			}
			else if(hasReplies.checked){
				query = `
query($mediaId: Int,$page: Int){
	Page(page: $page,perPage: 25){
		pageInfo{lastPage}
		activities(mediaId: $mediaId,hasReplies:true,sort:ID_DESC){
			... on ListActivity{
				id
				status
				progress
				createdAt
				user{
					name
					avatar{
						medium
					}
				}
				media{
					title{
						userPreferred
					}
					coverImage{medium}
				}
				replies{
					id
					text(asHtml: true)
					createdAt
					user{
						name
						avatar{
							medium
						}
					}
					likes{
						name
					}
				}
				likes{
					name
				}
			}
		}
	}
}`;
			}
			else{
				query = `
query($mediaId: Int,$page: Int){
	Page(page: $page,perPage: 25){
		pageInfo{lastPage}
		activities(mediaId: $mediaId,isFollowing:true,sort:ID_DESC){
			... on ListActivity{
				id
				status
				progress
				createdAt
				user{
					name
					avatar{
						medium
					}
				}
				media{
					title{
						userPreferred
					}
					coverImage{medium}
				}
				replies{
					id
					text(asHtml: true)
					createdAt
					user{
						name
						avatar{
							medium
						}
					}
					likes{
						name
					}
				}
				likes{
					name
				}
			}
		}
	}
}`;
			}
			buildFeed(1)
		}
		else{
			feedLocation.classList.remove("hohReplaceFeed");
			feedContent.style.display = "none";
			feedHeader .style.display = "none";
			loadMore   .style.display = "none"
		}
	}
}
//end modules/socialTabFeed.js
//begin modules/socialTab.js
//Morimasa code https://greasyfork.org/en/scripts/375622-betterfollowinglist
const stats = {
	element: null,
	count: 0,
	scoreSum: 0,
	scoreCount: 0
}

const scoreColors = e => {
	let el = e.querySelector("span") || e.querySelector("svg");
	let light = document.body.classList.contains("site-theme-dark") ? 45 : 38;
	if(!el){
		return null
	}
	el.classList.add("score");
	if(el.nodeName === "svg"){
		// smiley
		if(el.dataset.icon === "meh"){
			el.childNodes[0].setAttribute("fill",`hsl(60, 100%, ${light}%)`)
		}
		return {
			scoreCount: 0.5,//weight those scores lower because of the precision
			scoreSum: ({"smile": 85,"meh": 60,"frown": 35}[el.dataset.icon])*0.5
		}
	}
	else if(el.nodeName === "SPAN"){
		let score = el.innerText.split("/").map(num => parseFloat(num));
		if(score.length === 1){// convert stars, 10 point and 10 point decimal to 100 point
			score = score[0]*20-10
		}
		else{
			if(score[1] === 10){
				score = score[0]*10
			}
			else{
				score = score[0]
			}
		}
		el.style.color = `hsl(${score*1.2}, 100%, ${light}%)`;
		return {
			scoreCount: 1,
			scoreSum: score,
		}
	}
}

const handler = (data,target,idMap) => {
	if(!target){
		return
	}
	data.forEach(e => {
		target[idMap[e.user.id]].style.gridTemplateColumns = "30px 1.3fr .7fr .6fr .2fr .2fr .5fr"; //css is my passion
		const progress = create("div","progress",e.progress);
		if(e.media.chapters || e.media.episodes){
			progress.innerText = `${e.progress}/${e.media.chapters || e.media.episodes}`;
			if(e.progress > (e.media.chapters || e.media.episodes)){
				progress.title = translate("$socialTab_tooManyChapters")
			}
			else if(
				e.progress === (e.media.chapters || e.media.episodes)
				&& e.status === "COMPLETED"
			){
				progress.style.color = "rgb(var(--color-green))"
			}
		}
		target[idMap[e.user.id]].insertBefore(progress,target[idMap[e.user.id]].children[2])
		let notesEL = create("span","notes") // notes
		if(
			e.notes //only if notes
			&& !e.notes.match(/^,malSync::[a-zA-Z0-9]+=?=?::$/) //no need to show malSync-only notes, nobody is interested in that
			&& !e.notes.match(/^\s+$/) //whitespace-only notes will not show up properly anyway
		){
			if(e.notes.trim().match(/^(#\S+\s+)*(#\S+)$/)){//use a separate symbol for tags-only notes. Also helps popularizing tags
				notesEL.appendChild(svgAssets2.notesTags.cloneNode(true))
			}
			else{
				notesEL.appendChild(svgAssets2.notes.cloneNode(true))
			}
			notesEL.title = entityUnescape(e.notes);
		}
		let dateString;
		if(
			e.startedAt.year && e.completedAt.year && e.startedAt.year == e.completedAt.year
			&& e.startedAt.month && e.completedAt.month && e.startedAt.month == e.completedAt.month
			&& e.startedAt.day && e.completedAt.day && e.startedAt.day == e.completedAt.day
		){
			dateString = [
				e.startedAt.year,
				e.startedAt.month,
				e.startedAt.day
			].filter(TRUTHY).map(a => ((a + "").length === 1 ? "0" + a : "" + a)).join("-")
		}
		else{
			dateString = [
				e.startedAt.year,
				e.startedAt.month,
				e.startedAt.day
			].filter(TRUTHY).map(a => ((a + "").length === 1 ? "0" + a : "" + a)).join("-") + " - " + [
				e.completedAt.year,
				e.completedAt.month,
				e.completedAt.day
			].filter(TRUTHY).map(a => ((a + "").length === 1 ? "0" + a : "" + a)).join("-");
		}
		if(
			(e.media.chapters || e.media.episodes) === 1
			&& !e.startedAt.year
			&& e.completedAt.year
		){
			dateString = [
				e.completedAt.year,
				e.completedAt.month,
				e.completedAt.day
			].filter(TRUTHY).map(a => ((a + "").length === 1 ? "0" + a : "" + a)).join("-")
		}
		if(
			!e.completedAt.year
			&& e.createdAt
			&& e.status === "PLANNING"
		){
			dateString = translate("$mediaStatus_planning_time",new Date(e.createdAt*1000).toISOString().split("T")[0])
		}
		if(dateString !== " - "){
			target[idMap[e.user.id]].children[3].title = dateString;
		}
		if(useScripts.partialLocalisationLanguage !== "English"){
			let text = target[idMap[e.user.id]].children[3].childNodes[0].textContent;
			target[idMap[e.user.id]].children[3].childNodes[0].textContent = capitalize(translate("$mediaStatus_" + text.toLowerCase(),null,text))
		}
		target[idMap[e.user.id]].insertBefore(
			notesEL,target[idMap[e.user.id]].children[4]
		)
		let rewatchEL = create("span","repeat");
		if(e.repeat){
			rewatchEL.appendChild(svgAssets2.repeat.cloneNode(true));
			rewatchEL.title = e.repeat;
		}
		target[idMap[e.user.id]].insertBefore(
			rewatchEL,target[idMap[e.user.id]].children[4]
		)
	})
}

const MakeStats = () => {
	if(stats.element){
		stats.element.remove()
	}
	let main = create("h2");
	const createStat = (text, number) => {
		let el = create("span",false,text);
		create("span",false,number,el);
		return el
	}
	let count = createStat(translate("$socialTab_users") + ": ",stats.count);
	main.append(count);
	let avg = createStat(translate("$socialTab_shortAverage") + ": ",0);
	avg.style.float = "right";
	main.append(avg);
	const parent = document.querySelector(".following");
	parent.prepend(main);
	stats.element = main
}

function enhanceSocialTab(){
	if(!location.pathname.match(/^\/(anime|manga)\/\d*(\/[\w-]*)?\/social/)){
		return
	}
	let listOfFollowers = Array.from(document.getElementsByClassName("follow"));
	listOfFollowers = listOfFollowers.filter((ele,index) => {
		if(index && listOfFollowers[index - 1].href === ele.href){
			ele.remove();
			return false
		}
		return true
	})
	if(!listOfFollowers.length){
		setTimeout(enhanceSocialTab,100);
		return
	}
	MakeStats();
	let idmap = {};//TODO, rewrite as actual map?
	listOfFollowers.forEach(function(e,i){
		if(!e.dataset.changed){
			const avatarURL = e.querySelector(".avatar").dataset.src;
			if(!avatarURL || avatarURL === "https://s4.anilist.co/file/anilistcdn/user/avatar/large/default.png"){
				return
			}
			const id = avatarURL.split("/").pop().match(/\d+/g)[0];
			idmap[id] = i;
			let change = scoreColors(e);
			if(change){
				stats.scoreCount += change.scoreCount;
				stats.scoreSum += change.scoreSum
			}
			++stats.count;
			e.dataset.changed = true
		}
	})
	if(Object.keys(idmap).length){
		const mediaID = window.location.pathname.split("/")[2];
		generalAPIcall(
			`query($users:[Int],$media:Int){
				Page{
					mediaList(userId_in: $users,mediaId: $media){
						progress notes repeat user{id}
						startedAt{year month day}
						completedAt{year month day}
						createdAt
						status
						media{chapters episodes}
					}
				}
			}`,
			{users: Object.keys(idmap), media: mediaID},
			function(res){
				let unique = new Map();
				res.data.Page.mediaList.forEach(media => {
					unique.set(media.user.id,media)
				})
				handler(
					Array.from(unique).map(e => e[1]),
					listOfFollowers,
					idmap
				)
			}
		)
		let statsElements = stats.element.querySelectorAll("span > span");
		statsElements[0].innerText = stats.count;
		const avgScore = Math.round(stats.scoreSum/stats.scoreCount || 0);
		if(avgScore){
			statsElements[1].style.color = `hsl(${avgScore*1.2}, 100%, 40%)`;
			statsElements[1].innerText = `${avgScore}%`;
			statsElements[1].title = (stats.scoreSum/stats.scoreCount).toPrecision(4)
		}
		else{
			statsElements[1].parentNode.remove() // no need if no scores
		}
		statsElements[1].onclick = function(){
			statsElements[1].classList.toggle("toggled");
			Array.from(root.querySelectorAll(".follow")).forEach(function(item){
				if(item.querySelector(".score") || !statsElements[1].classList.contains("toggled")){
					item.style.display = "grid"
				}
				else{
					item.style.display = "none"
				}
			})
		}
	}
/*add average score to social tab*/
	let root = listOfFollowers[0].parentNode;
	let distribution = {};
	Object.keys(distributionColours).forEach(
		status => distribution[status] = 0
	);
	listOfFollowers.forEach(function(follower){
		let statusType = follower.querySelector(".status").innerText.toUpperCase();
		if(statusType === "WATCHING" || statusType === "READING"){
			statusType = "CURRENT"
		}
		distribution[statusType]++
	});
	if(
		Object.keys(distributionColours).some(status => distribution[status] > 0)
	){
		let locationForIt = document.getElementById("averageScore");
		let dataList = document.getElementById("socialUsers");
		let statusList = document.getElementById("statusList");
		if(!locationForIt){
			let insertLocation = document.querySelector(".following");
			insertLocation.parentNode.style.marginTop = "5px";
			insertLocation.parentNode.style.position = "relative";
			locationForIt = create("span","#averageScore");
			insertLocation.insertBefore(
				locationForIt,
				insertLocation.children[0]
			);
			statusList = create("span","#statusList",false,false,"position:absolute;right:0px;top:5px;");
			insertLocation.insertBefore(
				statusList,
				insertLocation.children[0]
			);
			dataList = create("datalist","#socialUsers");
			insertLocation.insertBefore(
				dataList,
				insertLocation.children[0]
			);
			if(insertLocation.parentNode.children[0].nodeName === "H2"){
				insertLocation.parentNode.children[0].classList.remove("link");
				insertLocation.parentNode.children[0].classList.remove("router-link-exact-active");
				insertLocation.parentNode.children[0].classList.remove("router-link-active")
			}
		}
		locationForIt.nextSibling.style.marginTop = "5px";
		if(dataList.childElementCount < listOfFollowers.length){
			listOfFollowers.slice(dataList.childElementCount).forEach(
				follower => create("option",false,false,dataList)
					.value = follower.children[1].innerText
			)
		}
		removeChildren(statusList);
		let sortStatus = "";
		semmanticStatusOrder.forEach(status => {
			if(distribution[status]){
				let statusSumDot = create("div","hohSummableStatus",distribution[status],statusList);
				statusSumDot.style.background = distributionColours[status];
				statusSumDot.title = distribution[status] + " " + capitalize(translate("$mediaStatus_" + status.toLowerCase()));
				if(distribution[status] > 99){
					statusSumDot.style.fontSize = "8px"
				}
				if(distribution[status] > 999){
					statusSumDot.style.fontSize = "6px"
				}
				statusSumDot.onclick = function(){
					if(sortStatus === status){
						Array.from(root.querySelectorAll(".follow .status")).forEach(item => {
							item.parentNode.style.display = "grid"
						})
						sortStatus = ""
					}
					else{
						Array.from(root.querySelectorAll(".follow .status")).forEach(item => {
							if(item.innerText.toUpperCase() === status || (["WATCHING","READING"].includes(item.innerText.toUpperCase()) && status === "CURRENT")){
								item.parentNode.style.display = "grid"
							}
							else{
								item.parentNode.style.display = "none"
							}
						})
						sortStatus = status
					}
				}
			}
		});
	}
	let waiter = function(){
		setTimeout(function(){
			if(root.childElementCount !== listOfFollowers.length){
				enhanceSocialTab()
			}
			else{
				waiter()
			}
		},100);
	};waiter()
}
//end modules/socialTab.js
//begin modules/staffBrowse.js
function enhanceStaffBrowse(){
	if(!document.URL.match(/\/search\/staff\/?(favorites)?$/)){
		return
	}
	const query = `
query($page: Int!){
	Page(page: $page,perPage: 30){
		staff(sort: [FAVOURITES_DESC]){
			id
			favourites
			anime:staffMedia(type:ANIME){
				pageInfo{
					total
				}
			}
			manga:staffMedia(type:MANGA){
				pageInfo{
					total
				}
			}
			characters{
				pageInfo{
					total
				}
			}
		}
	}
}`;
	let favCallback = function(data,page){
		if(!document.URL.match(/\/search\/staff\/?(favorites)?$/)){
			return
		}
		let resultsToTag = document.querySelectorAll(".results.cover .staff-card,.landing-section.staff .staff-card");
		if(resultsToTag.length < page*data.data.Page.staff.length){
			setTimeout(function(){
				favCallback(data,page)
			},200);//may take some time to load
			return
		}
		data = data.data.Page.staff;
		data.forEach(function(staff,index){
			create("span","hohFavCountBrowse",staff.favourites,resultsToTag[(page - 1)*data.length + index]).title = "Favourites";
			if(staff.anime.pageInfo.total + staff.manga.pageInfo.total > staff.characters.pageInfo.total){
				let roleLine = create("div","hohRoleLine",false,resultsToTag[(page - 1)*data.length + index]);
				roleLine.style.backgroundImage =
				"linear-gradient(to right,hsla(" + Math.round(
					120*(1 + staff.anime.pageInfo.total/(staff.anime.pageInfo.total + staff.manga.pageInfo.total))
				) + ",100%,50%,0.8),rgba(var(--color-overlay),0.8))";
				let animePercentage = Math.round(100*staff.anime.pageInfo.total/(staff.anime.pageInfo.total + staff.manga.pageInfo.total));
				if(animePercentage === 100){
					roleLine.title = "100% anime"
				}
				else if(animePercentage === 0){
					roleLine.title = "100% manga"
				}
				else if(animePercentage >= 50){
					roleLine.title = animePercentage + "% anime, " + (100 - animePercentage) + "% manga"
				}
				else{
					roleLine.title = (100 - animePercentage) + "% manga, " + animePercentage + "% anime"
				}
			}
		});
		generalAPIcall(query,{page:page+1},data => favCallback(data,page+1))
	};
	generalAPIcall(query,{page:1},data => favCallback(data,1))
}
//end modules/staffBrowse.js
//begin modules/staff.js
function enhanceStaff(){
	if(!document.URL.match(/^https:\/\/anilist\.co\/staff\/.*/)){
		return
	}
	if(document.querySelector(".hohFavCount")){
		return
	}
	const variables = {id: document.URL.match(/\/staff\/(\d+)\/?/)[1]};
	const query = "query($id: Int!){Staff(id: $id){favourites}}";
	let favCallback = function(data){
		if(!document.URL.match(/^https:\/\/anilist\.co\/staff\/.*/)){
			return
		}
		let favCount = document.querySelector(".favourite .count");
		if(favCount){
			favCount.parentNode.onclick = function(){
				if(favCount.parentNode.classList.contains("isFavourite")){
					favCount.innerText = Math.max(parseInt(favCount.innerText) - 1,0)//0 or above, just to avoid looking silly
				}
				else{
					favCount.innerText = parseInt(favCount.innerText) + 1
				}
			};
			if(data.data.Staff.favourites === 0 && favCount[0].classList.contains("isFavourite")){//safe to assume
				favCount.innerText = data.data.Staff.favourites + 1
			}
			else{
				favCount.innerText = data.data.Staff.favourites
			}
		}
		else{
			setTimeout(function(){favCallback(data)},200)
		}
	};
	generalAPIcall(query,variables,favCallback,"hohStaffFavs" + variables.id,60*60*1000)
}
//end modules/staff.js
//begin modules/studio.js
function enhanceStudio(){//adds a favourite count to every studio page
	if(!location.pathname.match(/^\/studio(\/.*)?/)){
		return
	}
	let filterGroup = document.querySelector(".container.header");
	if(!filterGroup){
		setTimeout(enhanceStudio,200);//may take some time to load
		return;
	}
	let favCallback = function(data){
		if(!document.URL.match(/^https:\/\/anilist\.co\/studio\/.*/)){
			return
		}
		let favCount = document.querySelector(".favourite .count");
		if(favCount){
			favCount.parentNode.onclick = function(){
				if(favCount.parentNode.classList.contains("isFavourite")){
					favCount.innerText = Math.max(parseInt(favCount.innerText) - 1,0)//0 or above, just to avoid looking silly
				}
				else{
					favCount.innerText = parseInt(favCount.innerText) + 1
				}
			};
			if(data.data.Studio.favourites === 0 && favCount[0].classList.contains("isFavourite")){//safe to assume
				favCount.innerText = data.data.Studio.favourites + 1
			}
			else{
				favCount.innerText = data.data.Studio.favourites
			}
		}
		else{
			setTimeout(function(){favCallback(data)},200);
		}
	};
	const variables = {id: location.pathname.match(/\/studio\/(\d+)\/?/)[1]};
	generalAPIcall(
		`
query($id: Int!){
	Studio(id: $id){
		favourites
	}
}`,
		variables,favCallback,"hohStudioFavs" + variables.id,60*60*1000
	);
}
//end modules/studio.js
//begin modules/submenu.js
if(useScripts.CSSverticalNav && whoAmI && !useScripts.mobileFriendly){
	let addMouseover = function(){
		let navThingy = document.querySelector(`.nav .links .link[href^="/user/"]`);
		if(navThingy){
			navThingy.style.position = "relative";
			let hackContainer = create("div","subMenuContainer",false,false,"position:relative;width:100%;min-height:50px;z-index:134;display:inline-flex;");
			navThingy.parentNode.insertBefore(hackContainer,navThingy);
			hackContainer.appendChild(navThingy);
			let subMenu = create("div","hohSubMenu",false,hackContainer);
			let linkStats = create("a","hohSubMenuLink",translate("$submenu_stats"),subMenu);
			if(useScripts.mangaBrowse){
				linkStats.href = "/user/" + whoAmI + "/stats/manga/overview";
				cheapReload(linkStats,{path: "/user/" + whoAmI + "/stats/manga/overview"});
			}
			else{
				linkStats.href = "/user/" + whoAmI + "/stats/anime/overview";
				cheapReload(linkStats,{path: "/user/" + whoAmI + "/stats/anime/overview"});
			}
			[
				{
					text: "$submenu_social",
					href: "/user/" + whoAmI + "/social",
					vue: {path: "/user/" + whoAmI + "/social"}
				},
				{
					text: "$submenu_reviews",
					href: "/user/" + whoAmI + "/reviews",
					vue: {path: "/user/" + whoAmI + "/reviews"}
				},
				{
					text: "$submenu_favourites",
					href: "/user/" + whoAmI + "/favorites",
					vue: {path: "/user/" + whoAmI + "/favorites"}
				},
				{
					text: "$submenu_submissions",
					href: "/user/" + whoAmI + "/submissions",
					vue: {path: "/user/" + whoAmI + "/submissions"}
				}
			].forEach(link => {
				let element = create("a","hohSubMenuLink",translate(link.text),subMenu);
				element.href = link.href;
				if(link.vue){
					cheapReload(element,link.vue)
				}
			})
			hackContainer.onmouseenter = function(){
				subMenu.style.display = "inline"
			}
			hackContainer.onmouseleave = function(){
				subMenu.style.display = "none"
			}
		}
		else{
			setTimeout(addMouseover,500)
		}
	};addMouseover()
}
//end modules/submenu.js
//begin modules/termsFeed.js
exportModule({
	id: "termsFeed",
	description: "$terms_description",
	extendedDescription: `
Creates a new home page at the URL https://anilist.co/terms.

Why?
To give you an alternative if you have a crappy internet connection.
The Anilist UI is several megabytes, and also has plenty of images to load.
By contrast, this alternative feed only needs a couple of kilobytes to load.

In order to create status updates, post comments and like activities, you will have to SIGN IN (see bottom of the settings page).

If you use this feed, you may also be interested in the "Do not load images on the low bandwidth feed" setting.
	`,
	isDefault: true,
	importance: 5,
	categories: ["Feeds","Login"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return /^https:\/\/anilist\.co\/terms/.test(url)
	},
	code: function(){
let page = 1;
let searchParams = new URLSearchParams(location.search);
if(searchParams.get("page")){
	page = parseInt(searchParams.get("page"))
}
let date = searchParams.get("date");
let pageLocation = document.querySelector(".container");
pageLocation.parentNode.style.background = "rgb(39,44,56)";
pageLocation.parentNode.style.color = "rgb(159,173,189)";
let terms = create("div",["container","termsFeed"],false,pageLocation.parentNode,"max-width: 1100px;margin-left:170px;margin-right:170px;");
pageLocation.style.display = "none";
let policy = create("button",["hohButton","button"],translate("$terms_privacyPolicy"),terms,"font-size:1rem;color:initial;padding:3px;");
policy.title = translate("$terms_privacyPolicy_title");
policy.onclick = function(){
	pageLocation.style.display = "initial";
	terms.style.display = "none";
	document.title = "Anilist Terms"
};
if(!useScripts.accessToken){
	create("p",false,translate("$terms_signin"),terms);
	let loginURL = create("a",false,translate("$terms_signin_link"),terms);
	loginURL.href = authUrl;
	loginURL.style.color = "rgb(61,180,242)";
	return
}
document.title = "Anilist Feed";
let browseSettings = create("div",false,false,terms,"margin-top:10px;");
let onlyGlobal = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_global"),browseSettings,"margin-right:5px;");
let onlyStatus = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_text"),browseSettings,"margin-right:5px;");
let onlyReplies = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_replies"),browseSettings,"margin-right:5px;");
let onlyForum = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_forum"),browseSettings,"margin-right:5px;");
let onlyReviews = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_reviews"),browseSettings);
create("br",false,false,browseSettings);
create("br",false,false,browseSettings);
let onlyUser = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_user"),browseSettings,"margin-right:5px;");
let onlyUserInput = create("input",false,false,browseSettings,"background:rgb(31,35,45);border-width:0px;margin-left:20px;border-radius:3px;color:rgb(159,173,189);margin-right: 10px;padding:3px;");
let onlyMedia = createCheckbox(browseSettings);
create("span",false,translate("$terms_option_media"),browseSettings,"margin-right:5px;");
let onlyMediaResult = {id: 0,type: "ANIME"};
let onlyMediaInput = create("input",false,false,browseSettings,"background:rgb(31,35,45);border-width:0px;margin-left:20px;border-radius:3px;color:rgb(159,173,189);margin-right: 10px;padding:3px;");
let mediaDisplayResults = create("div",false,false,browseSettings,"margin-top:5px;");
let dataUsers = new Set([whoAmI]);
let dataMedia = new Set();
let dataUsersList = create("datalist","#userDatalist",false,browseSettings);
let dataMediaList = create("datalist","#userMedialist",false,browseSettings);
let onlyActivity = null;
onlyUserInput.setAttribute("list","userDatalist");
if(searchParams.get("user")){
	onlyUserInput.value = decodeURIComponent(searchParams.get("user"));
	onlyUser.checked = true
}
if(searchParams.get("activity")){
	onlyActivity = parseInt(searchParams.get("activity"))
}
onlyMediaInput.setAttribute("list","userMedialist");
let feed = create("div","hohFeed",false,terms);
let topNav = create("div",false,false,feed,"position:relative;min-height:60px;margin-bottom:15px;");
let loading = create("p",false,translate("$loading"),topNav);
let pageCount = create("p",false,translate("$page",1),topNav);
let statusInput = create("div",false,false,topNav);
let onlySpecificActivity = false;
let statusInputTitle = create("input",false,false,statusInput,"display:none;border-width: 1px;padding: 4px;border-radius: 2px;color: rgb(159, 173, 189);background: rgb(var(--color-foreground));");
statusInputTitle.placeholder = "Title";
let inputArea = create("textarea",false,false,statusInput,"width: 99%;border-width: 1px;padding: 4px;border-radius: 2px;color: rgb(159, 173, 189);resize: vertical;");
inputArea.rows = 3;
inputArea.placeholder = translate("$placeholder_status");
create("br",false,false,statusInput);
let cancelButton = create("button",["hohButton","button"],translate("$button_cancel"),statusInput,"background:rgb(31,35,45);display:none;color: rgb(159, 173, 189);");
let publishButton = create("button",["hohButton","button"],translate("$button_publish"),statusInput,"display:none;");
let previewArea = create("div",false,false,statusInput,"display:none;");
let topPrevious = create("button",["hohButton","button"],translate("$button_refresh"),topNav,"position:fixed;top:120px;left:calc(5% - 50px);z-index:50;");
let topNext = create("button",["hohButton","button"],translate("$button_next"),topNav,"position:fixed;top:120px;right:calc(5% - 50px);z-index:50;");
let feedContent = create("div",false,false,feed);
let notiLink = create("a",["link"],"",topNav,"position:fixed;top:10px;right:10px;color:rgb(var(--color-blue));text-decoration:none;background:rgb(var(--color-red));border-radius: 10px;min-width: 20px;text-align: center;color:white;cursor: pointer;");
let lastUpdated = 0;
let changeURL = function(){
	const baseState = location.protocol + "//" + location.host + location.pathname;
	let params = [];
	if(page !== 1){
		params.push("page=" + page)
	}
	if(onlyUser.checked && onlyUserInput.value.length){
		params.push("user=" + encodeURIComponent(onlyUserInput.value))
	}
	if(date){
		params.push("date=" + date)
	}
	if(params.length){
		params = "?" + params.join("&")
	}
	current = baseState + params;
	history.replaceState({},"",baseState + params)
};
let handleNotifications = function(data){
	if(data.data.Viewer){
		notiLink.innerText = data.data.Viewer.unreadNotificationCount;
		if(data.data.Viewer.unreadNotificationCount === 1){
			notiLink.title = "1 unread notification"
		}
		else if(data.data.Viewer.unreadNotificationCount){
			notiLink.title = data.data.Viewer.unreadNotificationCount + " unread notifications"
		}
		else{
			notiLink.title = "no unread notifications"
		}
	}
}
let likeify = function(likes,likeQuickView){
	likes.forEach(like => {
		dataUsers.add(like.name)
	})
	removeChildren(likeQuickView)
	if(likes.length === 0){ /*do nothing*/ }
	else if(likes.length === 1){
		create("span",false,likes[0].name,likeQuickView,`color: hsl(${Math.abs(hashCode(likes[0].name)) % 360},50%,50%)`)
	}
	else if(likes.length === 2){
		let name1 = create("span",false,likes[0].name.slice(0,(likes[0].name.length <= 6 ? likes[0].name.length : 4)),likeQuickView,`color: hsl(${Math.abs(hashCode(likes[0].name)) % 360},50%,50%)`);
		create("span",false," & ",likeQuickView);
		let name2 = create("span",false,likes[1].name.slice(0,(likes[1].name.length <= 6 ? likes[1].name.length : 4)),likeQuickView,`color: hsl(${Math.abs(hashCode(likes[1].name)) % 360},50%,50%)`);
		name1.onmouseover = function(){
			name1.innerText = likes[0].name
		}
		name2.onmouseover = function(){
			name2.innerText = likes[1].name
		}
	}
	else if(likes.length === 3){
		let name1 = create("span",false,likes[0].name.slice(0,(likes[0].name.length <= 5 ? likes[0].name.length : 3)),likeQuickView,`color: hsl(${Math.abs(hashCode(likes[0].name)) % 360},50%,50%)`);
		create("span",false,", ",likeQuickView);
		let name2 = create("span",false,likes[1].name.slice(0,(likes[1].name.length <= 5 ? likes[1].name.length : 3)),likeQuickView,`color: hsl(${Math.abs(hashCode(likes[1].name)) % 360},50%,50%)`);
		create("span",false," & ",likeQuickView);
		let name3 = create("span",false,likes[2].name.slice(0,(likes[2].name.length <= 5 ? likes[1].name.length : 3)),likeQuickView,`color: hsl(${Math.abs(hashCode(likes[2].name)) % 360},50%,50%)`);
		name1.onmouseover = function(){
			name1.innerText = likes[0].name
		}
		name2.onmouseover = function(){
			name2.innerText = likes[1].name
		}
		name3.onmouseover = function(){
			name3.innerText = likes[2].name
		}
	}
	else if(likes.length === 4){
		likes.forEach(like => {
			let name = create("span",false,like.name.slice(0,(like.name.length <= 3 ? like.name.length : 2)),likeQuickView,`color: hsl(${Math.abs(hashCode(like.name)) % 360},50%,50%)`);
			create("span",false,", ",likeQuickView);
			name.onmouseover = function(){
				name.innerText = like.name
			}
		});
		likeQuickView.lastChild.remove()
	}
	else if(likes.length === 5 || likes.length === 6){
		likes.forEach(like => {
			let name = create("span",false,like.name.slice(0,2),likeQuickView,`color: hsl(${Math.abs(hashCode(like.name)) % 360},50%,50%)`);
			create("span",false," ",likeQuickView);
			name.onmouseover = function(){
				name.innerText = like.name
			}
			name.onmouseout = function(){
				name.innerText = like.name.slice(0,2)
			}
		});
		likeQuickView.lastChild.remove()
	}
	else if(likes.length < 12){
		likes.forEach(like => {
			let name = create("span",false,like.name[0],likeQuickView,`color: hsl(${Math.abs(hashCode(like.name)) % 360},50%,50%)`);
			create("span",false," ",likeQuickView);
			name.onmouseover = function(){
				name.innerText = like.name
			}
			name.onmouseout = function(){
				name.innerText = like.name[0]
			}
		});
		likeQuickView.lastChild.remove()
	}
	else if(likes.length <= 20){
		likes.forEach(like => {
			let name = create("span",false,like.name[0],likeQuickView,`color: hsl(${Math.abs(hashCode(like.name)) % 360},50%,50%)`);
			name.onmouseover = function(){
				name.innerText = " " + like.name + " "
			}
			name.onmouseout = function(){
				name.innerText = like.name[0]
			}
		})
	}
}
let viewSingleActivity = function(id){
	loading.innerText = translate("$loading");
	authAPIcall(
`query($id: Int){
	Activity(id: $id){
		... on TextActivity{
			id
			type
			createdAt
			text
			user{name}
			likes{name}
			replies{
				id
				createdAt
				text
				user{name}
				likes{name}
			}
		}
		... on MessageActivity{
			id
			type
			createdAt
			text: message
			user: messenger{name}
			recipient{name}
			likes{name}
			replies{
				id
				createdAt
				text
				user{name}
				likes{name}
			}
		}
		... on ListActivity{
			id
			type
			createdAt
			user{name}
			likes{name}
			media{type id title{romaji}}
			progress
			status
			replies{
				id
				createdAt
				text
				user{name}
				likes{name}
			}
		}
	}
}`,
		{id: id},
		function(data){
			loading.innerText = "";
			if(!data){
				loading.innerText = translate("$error_connection");
				return
			}
			removeChildren(feedContent);
////
			let activity = data.data.Activity;
			let act = create("div","activity",false,feedContent);
			let diff = NOW() - (new Date(activity.createdAt * 1000)).valueOf();
			let time = create("span",["time","hohMonospace"],formatTime(Math.round(diff/1000),"short"),act,"width:50px;position:absolute;left:1px;top:2px;");
			time.title = (new Date(activity.createdAt * 1000)).toLocaleString();
			let content = create("div",false,false,act,"margin-left:60px;position:relative;");
			if(!activity.user){
				return
			}
			let user = create("a",["link","newTab"],activity.user.name,content);
			if(activity.user.name === whoAmI){
				user.classList.add("thisIsMe")
			}
			user.href = "/user/" + activity.user.name + "/";
			let actions = create("div","actions",false,content,"position:absolute;text-align:right;");
			let replyWrap = create("span",["action","hohReplies"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
			let replyCount = create("span","count",(activity.replies.length || activity.replyCount ? activity.replies.length || activity.replyCount : " "),replyWrap);
			let replyIcon = create("span",false,false,replyWrap);
			replyIcon.appendChild(svgAssets2.reply.cloneNode(true));
			replyWrap.style.cursor = "pointer";
			replyIcon.children[0].style.width = "13px";
			replyIcon.stylemarginLeft = "-2px";
			let likeWrap = create("span",["action","hohLikes"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
			likeWrap.title = activity.likes.map(a => a.name).join("\n");
			let likeCount = create("span","count",(activity.likes.length ? activity.likes.length : " "),likeWrap);
			let heart = create("span",false,"♥",likeWrap,"position:relative;");
			let likeQuickView = create("div","hohLikeQuickView",false,heart);
			likeWrap.style.cursor = "pointer";
			if(activity.likes.some(like => like.name === whoAmI)){
				likeWrap.classList.add("hohILikeThis")
			}
			likeify(activity.likes,likeQuickView);
			likeWrap.onclick = function(){
				authAPIcall(
					"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY){id}}",
					{id: activity.id},
					data => {}
				);
				if(likeWrap.classList.contains("hohILikeThis")){
					activity.likes.splice(activity.likes.findIndex(user => user.name === whoAmI),1);
					if(activity.likes.length === 0){
						likeCount.innerText = " "
					}
					else{
						likeCount.innerText = activity.likes.length
					}
				}
				else{
					activity.likes.push({name: whoAmI});
					likeCount.innerText = activity.likes.length
				}
				likeWrap.classList.toggle("hohILikeThis");
				likeWrap.title = activity.likes.map(a => a.name).join("\n");
				likeify(activity.likes,likeQuickView);
			};
			replyWrap.onclick = function(){
				if(act.querySelector(".replies")){
					act.lastChild.remove()
				}
				else{
					let createReplies = function(){
						let replies = create("div","replies",false,act);
						let statusInput;
						let inputArea;
						let cancelButton;
						let publishButton;
						let onlySpecificActivity = false;
						activity.replies.forEach(reply => {
							reply.text = makeHtml(reply.text);
							let rep = create("div","reply",false,replies);
							let ndiff = NOW() - (new Date(reply.createdAt * 1000)).valueOf();
							let time = create("span",["time","hohMonospace"],formatTime(Math.round(ndiff/1000),"short"),rep,"width:50px;position:absolute;left:1px;top:2px;");
							time.title = (new Date(activity.createdAt * 1000)).toLocaleString();
							let user = create("a",["link","newTab"],reply.user.name,rep,"margin-left:60px;position:absolute;");
							if(reply.user.name === whoAmI){
								user.classList.add("thisIsMe")
							}
							user.href = "/user/" + reply.user.name + "/";
							let text = create("div","status",false,rep,"padding-bottom:10px;margin-left:5px;max-width:100%;padding-top:10px;");
							if(useScripts.termsFeedNoImages && !activity.renderingPermission){
								let imgText = reply.text.replace(/<img.*?src=("|')(.*?)("|').*?>/g,img => {
									let link = img.match(/<img.*?src=("|')(.*?)("|').*?>/)[2];
									return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
								})
								text.innerHTML = DOMPurify.sanitize(imgText)//reason for inner HTML: preparsed sanitized HTML from the Anilist API
							}
							else{
								text.innerHTML = DOMPurify.sanitize(reply.text)//reason for inner HTML: preparsed sanitized HTML from the Anilist API
							}
							Array.from(text.querySelectorAll(".youtube")).forEach(ytLink => {
								create("a",["link","newTab"],"Youtube " + ytLink.id,ytLink)
									.href = "https://www.youtube.com/watch?v=" + ytLink.id
							});
							let actions = create("div","actions",false,rep,"position:absolute;text-align:right;right:4px;bottom:0px;");
							let likeWrap = create("span",["action","hohLikes"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
							likeWrap.title = reply.likes.map(a => a.name).join("\n");
							let likeCount = create("span","count",(reply.likes.length ? reply.likes.length : " "),likeWrap);
							let heart = create("span",false,"♥",likeWrap,"position:relative;");
							let likeQuickView = create("div","hohLikeQuickView",false,heart,"position:absolute;bottom:0px;left:30px;font-size:70%;white-space:nowrap;");
							likeWrap.style.cursor = "pointer";
							if(reply.likes.some(like => like.name === whoAmI)){
								likeWrap.classList.add("hohILikeThis");
							}
							likeify(reply.likes,likeQuickView);
							likeWrap.onclick = function(){
								authAPIcall(
									"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
									{id: reply.id},
									data => {}
								);
								if(likeWrap.classList.contains("hohILikeThis")){
									reply.likes.splice(reply.likes.findIndex(user => user.name === whoAmI),1);
									if(reply.likes.length === 0){
										likeCount.innerText = " ";
									}
									else{
										likeCount.innerText = reply.likes.length;
									}
								}
								else{
									reply.likes.push({name: whoAmI});
									likeCount.innerText = reply.likes.length;
								}
								likeWrap.classList.toggle("hohILikeThis");
								likeWrap.title = reply.likes.map(a => a.name).join("\n");
								likeify(reply.likes,likeQuickView);
							};
							if(reply.user.name === whoAmI){
								let edit = create("a",false,translate("$button_edit"),rep,"position:absolute;top:2px;right:40px;width:10px;cursor:pointer;font-size:small;color:inherit;");
								edit.onclick = function(){
									authAPIcall(
										`query($id: Int){
											ActivityReply(id: $id){
												text(asHtml: false)
											}
										}`,
										{id: reply.id},
										data => {
											if(!data){
												onlySpecificActivity = false;
											}
											inputArea.focus();
											onlySpecificActivity = reply.id;
											inputArea.value = data.data.ActivityReply.text;
										}
									)
								}
							}
						});
						statusInput = create("div",false,false,replies);
						inputArea = create("textarea",false,false,statusInput,"width: 99%;border-width: 1px;padding: 4px;border-radius: 2px;color: rgb(159, 173, 189);resize: vertical;");
						cancelButton = create("button",["hohButton","button"],translate("$button_cancel"),statusInput,"background:rgb(31,35,45);display:none;color: rgb(159, 173, 189);");
						publishButton = create("button",["hohButton","button"],translate("$button_publish"),statusInput,"display:none;");
						inputArea.placeholder = translate("$placeholder_reply");
						inputArea.onfocus = function(){
							cancelButton.style.display = "inline";
							publishButton.style.display = "inline";
						};
						cancelButton.onclick = function(){
							inputArea.value = "";
							cancelButton.style.display = "none";
							publishButton.style.display = "none";
							document.activeElement.blur();
						};
						publishButton.onclick = function(){
							if(onlySpecificActivity){
								loading.innerText = "Editing reply...";
								authAPIcall(
									`mutation($text: String,$id: Int){
										SaveActivityReply(text: $text,id: $id){
											id
											user{name}
											likes{name}
											text(asHtml: true)
											createdAt
										}
									}`,
									{text: emojiSanitize(inputArea.value),id: onlySpecificActivity},
									data => {
										loading.innerText = "";
										if(data){
											for(let j=0;j<activity.replies;j++){
												if(activity.replies[j].id === data.data.SaveActivityReply.id){
													activity.replies[j] = data.data.SaveActivityReply
												}
											}
											act.lastChild.remove();
											createReplies()
										}
									}
								);
								onlySpecificActivity = false
							}
							else{
								loading.innerText = translate("$publishingReply");
								authAPIcall(
									`mutation($text: String,$activityId: Int){
										SaveActivityReply(text: $text,activityId: $activityId){
											id
											user{name}
											likes{name}
											text(asHtml: true)
											createdAt
										}
									}`,
									{text: emojiSanitize(inputArea.value),activityId: activity.id},
									data => {
										loading.innerText = "";
										if(data){
											activity.replies.push(data.data.SaveActivityReply);
											replyCount.innerText = activity.replies.length;
											act.lastChild.remove();
											createReplies()
										}
									}
								)
							}
							inputArea.value = "";
							cancelButton.style.display = "none";
							publishButton.style.display = "none";
							document.activeElement.blur();
						};
					};createReplies()
				}
			};replyWrap.click();
			let status;
			if(activity.type === "TEXT" || activity.type === "MESSAGE"){
				status = create("div",false,false,content,"padding-bottom:10px;width:95%;overflow-wrap:anywhere;");
				activity.text = makeHtml(activity.text);
				if(useScripts.termsFeedNoImages){
					let imgCount = 0;
					let webmCount = 0;
					let imgText = activity.text.replace(/<img.*?src=("|')(.*?)("|').*?>/g,img => {
						let link = img.match(/<img.*?src=("|')(.*?)("|').*?>/)[2];
						imgCount++;
						return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
					}).replace(/<video.*?video>/g,video => {
						let link = video.match(/src=("|')(.*?)("|')/)[2];
						webmCount++;
						return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
					})
					status.innerHTML = DOMPurify.sanitize(imgText);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
					if(imgText !== activity.text){
						let render = create("a",false,"IMG",act,"position:absolute;top:2px;right:20px;cursor:pointer;");
						render.title = "load images";
						if(imgCount === 0 && webmCount){
							render.innerText = "WebM";
							render.title = "load webms"
						}
						else if(imgCount && webmCount){
							render.innerText = "IMG+WebM";
							render.title = "load images and webms"
						}
						render.onclick = () => {
							activity.renderingPermission = true;
							status.innerHTML = DOMPurify.sanitize(activity.text);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
							render.style.display = "none"
						}
					}
				}
				else{
					status.innerHTML = DOMPurify.sanitize(activity.text);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
				}
				Array.from(status.querySelectorAll(".youtube")).forEach(ytLink => {
					create("a",["link","newTab"],ytLink.id,ytLink)
						.href = ytLink.id
				});
				if(activity.user.name === whoAmI && (activity.type === "TEXT" || activity.type === "MESSAGE")){
					let edit = create("a",false,translate("$button_edit"),act,"position:absolute;top:2px;right:40px;width:10px;cursor:pointer;font-size:small;color:inherit;");
					if(useScripts.termsFeedNoImages){
						edit.style.right = "80px"
					}
					edit.onclick = function(){
						loading.innerText = "Loading activity " + activity.id + "...";
						if(terms.scrollIntoView){
							terms.scrollIntoView({"behavior": "smooth","block": "start"})
						}
						else{
							document.body.scrollTop = document.documentElement.scrollTop = 0
						}
						if(activity.type === "MESSAGE"){
							authAPIcall(
								`query($id: Int){
									Activity(id: $id){
										... on MessageActivity{
											text:message(asHtml: false)
										}
									}
								}`,
								{id: activity.id},
								data => {
									if(!data){
										onlySpecificActivity = false;
										loading.innerText = "Failed to load message";
									}
									inputArea.focus();
									onlySpecificActivity = activity.id;
									loading.innerText = "Editing message " + activity.id;
									inputArea.value = data.data.Activity.text;
								}
							)
						}
						else{
							authAPIcall(
								`query($id: Int){
									Activity(id: $id){
										... on TextActivity{
											text(asHtml: false)
										}
									}
								}`,
								{id: activity.id},
								data => {
									if(!data){
										onlySpecificActivity = false;
										loading.innerText = "Failed to load activity";
									}
									inputArea.focus();
									onlySpecificActivity = activity.id;
									loading.innerText = "Editing activity " + activity.id;
									inputArea.value = data.data.Activity.text;
								}
							)
						}
					}
				}
				act.classList.add("text");
				actions.style.right = "21px";
				actions.style.bottom = "4px";
			}
			else{
				status = create("span",false," " + activity.status + " ",content);
				if(activity.progress){
					status.innerText += " " + activity.progress + " of "
				}
				if(activity.media.type === "MANGA"){
					if(activity.status === "read chapter" && activity.progress){
						status.innerText = " " + translate("$listActivity_MreadChapter",activity.progress)
					}
					else if(activity.status === "reread chapter" && activity.progress){
						status.innerText = " " + translate("$listActivity_MrepeatingManga",activity.progress)
					}
					else if(activity.status === "dropped" && activity.progress){
						status.innerText = " " + translate("$listActivity_MdroppedManga",activity.progress)
					}
					else if(activity.status === "dropped"){
						status.innerText = " " + translate("$listActivity_droppedManga")
					}
					else if(activity.status === "completed"){
						status.innerText = " " + translate("$listActivity_completedManga")
					}
					else if(activity.status === "plans to read"){
						status.innerText = " " + translate("$listActivity_planningManga")
					}
					else if(activity.status === "paused reading"){
						status.innerText = " " + translate("$listActivity_pausedManga")
					}
					else{
						console.warn("Missing listActivity translation key for:",activity.status)
					}
				}
				else{
					if(activity.status === "watched episode" && activity.progress){
						status.innerText = " " + translate("$listActivity_MwatchedEpisode",activity.progress)
					}
					else if(activity.status === "rewatched episode" && activity.progress){
						status.innerText = " " + translate("$listActivity_MrepeatingAnime",activity.progress)
					}
					else if(activity.status === "dropped" && activity.progress){
						status.innerText = " " + translate("$listActivity_MdroppedAnime",activity.progress)
					}
					else if(activity.status === "dropped"){
						status.innerText = " " + translate("$listActivity_droppedAnime")
					}
					else if(activity.status === "completed"){
						status.innerText = " " + translate("$listActivity_completedAnime")
					}
					else if(activity.status === "plans to watch"){
						status.innerText = " " + translate("$listActivity_planningAnime")
					}
					else if(activity.status === "paused watching"){
						status.innerText = " " + translate("$listActivity_pausedAnime")
					}
					else{
						console.warn("Missing listActivity translation key for:",activity.status)
					}
				}
				let title = activity.media.title.romaji;
				if(useScripts.titleLanguage === "NATIVE" && activity.media.title.native){
					title = activity.media.title.native
				}
				else if(useScripts.titleLanguage === "ENGLISH" && activity.media.title.english){
					title = activity.media.title.english
				}
				dataMedia.add(title);
				title = titlePicker(activity.media);
				let media = create("a",["link","newTab"],title,content);
				media.href = "/" + activity.media.type.toLowerCase() + "/" + activity.media.id + "/" + safeURL(title) + "/";
				if(activity.media.type === "MANGA" && useScripts.CSSgreenManga){
					media.style.color = "rgb(var(--color-green))"
				}
				act.classList.add("list");
				actions.style.right = "21px";
				actions.style.top = "2px";
				if(useScripts.statusBorder){
					let blockerMap = {
						"plans": "PLANNING",
						"watched": "CURRENT",
						"read": "CURRENT",
						"completed": "COMPLETED",
						"paused": "PAUSED",
						"dropped": "DROPPED",
						"rewatched": "REPEATING",
						"reread": "REPEATING"
					};
					let status = blockerMap[
						Object.keys(blockerMap).find(
							key => activity.status.includes(key)
						)
					]
					if(status === "CURRENT"){
						//nothing
					}
					else if(status === "COMPLETED"){
						act.style.borderLeftWidth = "3px";
						act.style.marginLeft = "-2px";
						if(useScripts.CSSgreenManga && activity.media.type === "ANIME"){
							act.style.borderLeftColor = "rgb(var(--color-blue))";
						}
						else{
							act.style.borderLeftColor = "rgb(var(--color-green))";
						}
					}
					else{
						act.style.borderLeftWidth = "3px";
						act.style.marginLeft = "-2px";
						act.style.borderLeftColor = distributionColours[status]
					}
				}
			}
			let link = create("a",["link","newTab"],false,act,"position:absolute;top:2px;right:4px;width:10px;");
			link.appendChild(svgAssets2.link.cloneNode(true));
			link.href = "https://anilist.co/activity/" + activity.id + "/"
			dataUsers.add(activity.user.name);
			activity.replies.forEach(reply => {
				dataUsers.add(reply.user.name);
				(reply.text.match(/@(.*?)</g) || []).forEach(user => {
					dataUsers.add(user.slice(1,user.length-1))
				})
			})
////
		}
	)
}
//notiLink.href = "/notifications";
notiLink.onclick = function(){
	loading.innerText = translate("$loading");
	let renderNots = function(data){
		loading.innerText = "";
		removeChildren(feedContent);
		(data ? data.data.Page.notifications : []).forEach((notification,index) => {
			let noti = create("div","activity",false,feedContent);
			let diff = NOW() - (new Date(notification.createdAt * 1000)).valueOf();
			let time = create("span",["time","hohMonospace"],formatTime(Math.round(diff/1000),"short"),noti,"width:50px;position:absolute;left:1px;top:2px;");
			time.title = (new Date(notification.createdAt * 1000)).toLocaleString();
			let content = create("div",false,false,noti,"margin-left:60px;position:relative;");
			if(notification.user){
				let user = create("a",["link","newTab"],notification.user.name,content);
				if(notification.user.name === whoAmI){
					user.classList.add("thisIsMe")
				}
				user.href = "/user/" + notification.user.name + "/"
			}
			if(notification.type === "ACTIVITY_LIKE"){
				create("span",false," liked your ",content);
				let activityLink = create("span","ilink","activity",content);
				if(notification.activity.type === "TEXT"){
					activityLink.innerText = "status";
				}
				if(notification.activity.type === "MANGA_LIST"){
					activityLink.classList.add("manga")
				}
				activityLink.onclick = function(){
					viewSingleActivity(notification.activity.id)
				}
			}
			else if(notification.type === "ACTIVITY_REPLY_LIKE"){
				create("span",false," liked your ",content);
				let activityLink = create("span","ilink","reply",content);
				activityLink.onclick = function(){
					viewSingleActivity(notification.activity.id)
				}
			}
			else if(notification.type === "ACTIVITY_REPLY_SUBSCRIBED"){
				create("span",false," replied to subscribed ",content);
				let activityLink = create("span","ilink","activity",content);
				if(notification.activity.type === "TEXT"){
					activityLink.innerText = "status";
				}
				activityLink.onclick = function(){
					viewSingleActivity(notification.activity.id)
				}
			}
			else if(notification.type === "ACTIVITY_MESSAGE"){
				create("span",false," sent you a ",content);
				let activityLink = create("span","ilink","message",content);
				activityLink.onclick = function(){
					viewSingleActivity(notification.activityId)
				}
			}
			else if(notification.type === "ACTIVITY_REPLY"){
				let action = create("span",false," replied to your ",content);
				let activityLink = create("span","ilink","activity",content);
				if(notification.activity.type === "TEXT"){
					activityLink.innerText = "status";
				}
				else if(notification.activity.type === "MESSAGE"){
					action.innerText = " replied to a ";
					activityLink.innerText = "message";
				}
				activityLink.onclick = function(){
					viewSingleActivity(notification.activity.id)
				}
			}
			else if(notification.type === "RELATED_MEDIA_ADDITION"){
				create("span",false,"New media added: ",content);
				let mediaLink = create("span","ilink",notification.media.title.romaji,content);
				if(notification.media.type === "MANGA_LIST"){
					mediaLink.classList.add("manga")
				}
			}
			else if(notification.type === "MEDIA_DATA_CHANGE"){
				create("span",false,"MEDIA_DATA_CHANGE",content);
			}
			else if(notification.type === "ACTIVITY_MENTION"){
				create("span",false," mentioned you",content)
			}
			else if(notification.type === "FOLLOWING"){
				create("span",false," started following you",content)
			}
			else if(notification.type === "AIRING"){
				create("span",false,"Episode ",content);
				create("span",false,notification.episode,content);
				create("span",false," of ",content);
				let mediaLink = create("span","ilink",notification.media.title.romaji,content);
				create("span",false," aired",content);
			}
			else{
				noti.innerText = notification.type
			}
			if((index + 1) === data.data.Viewer.unreadNotificationCount){
				create("hr","divider",false,feedContent);
				noti.style.borderBottomWidth = "1px"
			}
		})
	}
	let callNots = function(){
		authAPIcall(
`
query{
	Viewer{
		unreadNotificationCount
	}
	Page(perPage: 25){
		notifications{
... on AiringNotification{type createdAt episode media{id title{native romaji english}}}
... on FollowingNotification{type createdAt user{name}}
... on ActivityMessageNotification{
	type createdAt user{name}
	activityId
}
... on ActivityMentionNotification{type createdAt user{name}}
... on ActivityReplyNotification{
	type createdAt user{name}
	activity{
... on TextActivity{id type}
... on ListActivity{id type progress}
... on MessageActivity{id type}
	}
}
... on ActivityReplySubscribedNotification{
	type createdAt user{name}
	activity{
... on TextActivity{
	id
	type
}
... on ListActivity{
	id
	type
	progress
}
	}
}
... on ActivityLikeNotification{
	type createdAt user{name}
	activity{
... on TextActivity{
	id
	type
}
... on ListActivity{
	id
	type
	progress
}
	}
}
... on ActivityReplyLikeNotification{
	type createdAt user{name}
	activity{
... on TextActivity{
	id
	type
}
... on MessageActivity{
	id
	type
}
... on ListActivity{
	id
	type
	progress
}
	}
}
... on MediaDataChangeNotification{type createdAt}
... on MediaMergeNotification{type createdAt}
... on MediaDeletionNotification{type createdAt}
... on ThreadCommentMentionNotification{type createdAt}
... on ThreadCommentReplyNotification{type createdAt}
... on ThreadCommentSubscribedNotification{type createdAt}
... on ThreadCommentLikeNotification{type createdAt}
... on ThreadLikeNotification{type createdAt}
... on RelatedMediaAdditionNotification{
	type createdAt
	media{id type title{romaji native english}}
}
		}
	}
}`,
			{},
			function(data){
				if(!data){
					loading.innerText = translate("$error_connection");
					return
				}
				notiLink.title = "no unread notifications"
				renderNots(data)
			}
		)
	};callNots();
}
let buildPage = function(activities,type,requestTime){
	if(requestTime < lastUpdated){
		return
	}
	lastUpdated = requestTime;
	loading.innerText = "";
	pageCount.innerText = translate("$page",page);
	if(page === 1){
		topPrevious.innerText = translate("$button_refresh")
	}
	else{
		topPrevious.innerText = translate("$button_previous")
	}
	removeChildren(feedContent)
	activities.forEach(activity => {
		if(type === "thread" && useScripts.hideAWC && (activity.user === "AnimeWatchingClub" || activity.user === "AWC")){
			return
		}
		let act = create("div","activity",false,feedContent);
		let diff = NOW() - (new Date(activity.createdAt * 1000)).valueOf();
		let time = create("span",["time","hohMonospace"],formatTime(Math.round(diff/1000),"short"),act,"width:50px;position:absolute;left:1px;top:2px;");
		time.title = (new Date(activity.createdAt * 1000)).toLocaleString();
		let content = create("div",false,false,act,"margin-left:60px;position:relative;");
		if(!activity.user){
			return
		}
		let user = create("a",["link","newTab"],activity.user.name,content);
		if(activity.user.name === whoAmI){
			user.classList.add("thisIsMe")
		}
		if(activity.type === "TEXT" && activity.media){
			create("a",false,"'s review of " + titlePicker(activity.media),content)
		}
		user.href = "/user/" + activity.user.name + "/";
		let actions = create("div","actions",false,content,"position:absolute;text-align:right;");
		let replyWrap = create("span",["action","hohReplies"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
		let replyCount = create("span","count",(activity.replies.length || activity.replyCount ? activity.replies.length || activity.replyCount : " "),replyWrap);
		let replyIcon = create("span",false,false,replyWrap);
		replyIcon.appendChild(svgAssets2.reply.cloneNode(true));
		replyWrap.style.cursor = "pointer";
		replyIcon.children[0].style.width = "13px";
		replyIcon.stylemarginLeft = "-2px";
		let likeWrap = create("span",["action","hohLikes"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
		likeWrap.title = activity.likes.map(a => a.name).join("\n");
		let likeCount = create("span","count",(activity.likes.length ? activity.likes.length : " "),likeWrap);
		let heart = create("span",false,"♥",likeWrap,"position:relative;");
		let likeQuickView = create("div","hohLikeQuickView",false,heart);
		if(type === "review"){
			heart.innerText = activity.rating + "/" + activity.ratingAmount
		}
		likeWrap.style.cursor = "pointer";
		if(activity.likes.some(like => like.name === whoAmI)){
			likeWrap.classList.add("hohILikeThis")
		}
		likeify(activity.likes,likeQuickView);
		likeWrap.onclick = function(){
			if(type === "review"){
				return
			}
			authAPIcall(
				"mutation($id:Int){ToggleLike(id:$id,type:" + type.toUpperCase() + "){id}}",
				{id: activity.id},
				data => {}
			);
			if(likeWrap.classList.contains("hohILikeThis")){
				activity.likes.splice(activity.likes.findIndex(user => user.name === whoAmI),1);
				if(activity.likes.length === 0){
					likeCount.innerText = " "
				}
				else{
					likeCount.innerText = activity.likes.length
				}
			}
			else{
				activity.likes.push({name: whoAmI});
				likeCount.innerText = activity.likes.length
			}
			likeWrap.classList.toggle("hohILikeThis");
			likeWrap.title = activity.likes.map(a => a.name).join("\n");
			likeify(activity.likes,likeQuickView);
		};
		replyWrap.onclick = function(){
			if(act.querySelector(".replies")){
				act.lastChild.remove()
			}
			else if(type === "thread"){
				window.location = "https://anilist.co/forum/thread/" + activity.id + "/";//remove when implemented
			}
			else{
				let createReplies = function(){
					let replies = create("div","replies",false,act);
					let statusInput;
					let inputArea;
					let cancelButton;
					let publishButton;
					let onlySpecificActivity = false;
					activity.replies.forEach(reply => {
						reply.text = makeHtml(reply.text);
						let rep = create("div","reply",false,replies);
						let ndiff = NOW() - (new Date(reply.createdAt * 1000)).valueOf();
						let time = create("span",["time","hohMonospace"],formatTime(Math.round(ndiff/1000),"short"),rep,"width:50px;position:absolute;left:1px;top:2px;");
						time.title = (new Date(activity.createdAt * 1000)).toLocaleString();
						let user = create("a",["link","newTab"],reply.user.name,rep,"margin-left:60px;position:absolute;");
						if(reply.user.name === whoAmI){
							user.classList.add("thisIsMe")
						}
						user.href = "/user/" + reply.user.name + "/";
						let text = create("div","status",false,rep,"padding-bottom:10px;margin-left:5px;max-width:100%;padding-top:10px;");
						if(useScripts.termsFeedNoImages && !activity.renderingPermission){
							let imgText = reply.text.replace(/<img.*?src=("|')(.*?)("|').*?>/g,img => {
								let link = img.match(/<img.*?src=("|')(.*?)("|').*?>/)[2];
								return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
							})
							text.innerHTML = DOMPurify.sanitize(imgText)//reason for inner HTML: preparsed sanitized HTML from the Anilist API
						}
						else{
							text.innerHTML = DOMPurify.sanitize(reply.text)//reason for inner HTML: preparsed sanitized HTML from the Anilist API
						}
						Array.from(text.querySelectorAll(".youtube")).forEach(ytLink => {
							create("a",["link","newTab"],"Youtube " + ytLink.id,ytLink)
								.href = "https://www.youtube.com/watch?v=" + ytLink.id
						});
						let actions = create("div","actions",false,rep,"position:absolute;text-align:right;right:4px;bottom:0px;");
						let likeWrap = create("span",["action","hohLikes"],false,actions,"display:inline-block;min-width:35px;margin-left:2px");
						likeWrap.title = reply.likes.map(a => a.name).join("\n");
						let likeCount = create("span","count",(reply.likes.length ? reply.likes.length : " "),likeWrap);
						let heart = create("span",false,"♥",likeWrap,"position:relative;");
						let likeQuickView = create("div","hohLikeQuickView",false,heart,"position:absolute;bottom:0px;left:30px;font-size:70%;white-space:nowrap;");
						likeWrap.style.cursor = "pointer";
						if(reply.likes.some(like => like.name === whoAmI)){
							likeWrap.classList.add("hohILikeThis");
						}
						likeify(reply.likes,likeQuickView);
						likeWrap.onclick = function(){
							authAPIcall(
								"mutation($id:Int){ToggleLike(id:$id,type:ACTIVITY_REPLY){id}}",
								{id: reply.id},
								data => {}
							);
							if(likeWrap.classList.contains("hohILikeThis")){
								reply.likes.splice(reply.likes.findIndex(user => user.name === whoAmI),1);
								if(reply.likes.length === 0){
									likeCount.innerText = " ";
								}
								else{
									likeCount.innerText = reply.likes.length;
								}
							}
							else{
								reply.likes.push({name: whoAmI});
								likeCount.innerText = reply.likes.length;
							}
							likeWrap.classList.toggle("hohILikeThis");
							likeWrap.title = reply.likes.map(a => a.name).join("\n");
							likeify(reply.likes,likeQuickView);
						};
						if(reply.user.name === whoAmI){
							let edit = create("a",false,translate("$button_edit"),rep,"position:absolute;top:2px;right:40px;width:10px;cursor:pointer;font-size:small;color:inherit;");
							edit.onclick = function(){
								authAPIcall(
									`query($id: Int){
										ActivityReply(id: $id){
											text(asHtml: false)
										}
									}`,
									{id: reply.id},
									data => {
										if(!data){
											onlySpecificActivity = false;
										}
										inputArea.focus();
										onlySpecificActivity = reply.id;
										inputArea.value = data.data.ActivityReply.text;
									}
								)
							}
						}
					});
					statusInput = create("div",false,false,replies);
					inputArea = create("textarea",false,false,statusInput,"width: 99%;border-width: 1px;padding: 4px;border-radius: 2px;color: rgb(159, 173, 189);resize: vertical;");
					cancelButton = create("button",["hohButton","button"],translate("$button_cancel"),statusInput,"background:rgb(31,35,45);display:none;color: rgb(159, 173, 189);");
					publishButton = create("button",["hohButton","button"],translate("$button_publish"),statusInput,"display:none;");
					inputArea.placeholder = translate("$placeholder_reply");
					inputArea.onfocus = function(){
						cancelButton.style.display = "inline";
						publishButton.style.display = "inline";
					};
					cancelButton.onclick = function(){
						inputArea.value = "";
						cancelButton.style.display = "none";
						publishButton.style.display = "none";
						document.activeElement.blur();
					};
					publishButton.onclick = function(){
						if(onlySpecificActivity){
							loading.innerText = "Editing reply...";
							authAPIcall(
								`mutation($text: String,$id: Int){
									SaveActivityReply(text: $text,id: $id){
										id
										user{name}
										likes{name}
										text(asHtml: true)
										createdAt
									}
								}`,
								{text: emojiSanitize(inputArea.value),id: onlySpecificActivity},
								data => {
									loading.innerText = "";
									if(data){
										for(let j=0;j<activity.replies;j++){
											if(activity.replies[j].id === data.data.SaveActivityReply.id){
												activity.replies[j] = data.data.SaveActivityReply
											}
										}
										act.lastChild.remove();
										createReplies()
									}
								}
							);
							onlySpecificActivity = false
						}
						else{
							loading.innerText = translate("$publishingReply");
							authAPIcall(
								`mutation($text: String,$activityId: Int){
									SaveActivityReply(text: $text,activityId: $activityId){
										id
										user{name}
										likes{name}
										text(asHtml: true)
										createdAt
									}
								}`,
								{text: emojiSanitize(inputArea.value),activityId: activity.id},
								data => {
									loading.innerText = "";
									if(data){
										activity.replies.push(data.data.SaveActivityReply);
										replyCount.innerText = activity.replies.length;
										act.lastChild.remove();
										createReplies()
									}
								}
							)
						}
						inputArea.value = "";
						cancelButton.style.display = "none";
						publishButton.style.display = "none";
						document.activeElement.blur();
					};
				};createReplies()
			}
		};
		let status;
		if(activity.type === "TEXT" || activity.type === "MESSAGE"){
			status = create("div",false,false,content,"padding-bottom:10px;width:95%;overflow-wrap:anywhere;");
			activity.text = makeHtml(activity.text);
			//activity.text = "<p>" + activity.text.replace(/\n\n/g,"</p><p>") + "</p>";//workaround for API bug
			if(useScripts.termsFeedNoImages){
				let imgCount = 0;
				let webmCount = 0;
				let imgText = activity.text.replace(/<img.*?src=("|')(.*?)("|').*?>/g,img => {
					let link = img.match(/<img.*?src=("|')(.*?)("|').*?>/)[2];
					imgCount++;
					return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
				}).replace(/<video.*?video>/g,video => {
					let link = video.match(/src=("|')(.*?)("|')/)[2];
					webmCount++;
					return "[<a href=\"" + link + "\">" + (link.length > 200 ? link.slice(0,200) + "…" : link) + "</a>]"
				})
				status.innerHTML = DOMPurify.sanitize(imgText);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
				if(imgText !== activity.text){
					let render = create("a",false,"IMG",act,"position:absolute;top:2px;right:20px;cursor:pointer;");
					render.title = "load images";
					if(imgCount === 0 && webmCount){
						render.innerText = "WebM";
						render.title = "load webms"
					}
					else if(imgCount && webmCount){
						render.innerText = "IMG+WebM";
						render.title = "load images and webms"
					}
					render.onclick = () => {
						activity.renderingPermission = true;
						status.innerHTML = DOMPurify.sanitize(activity.text);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
						render.style.display = "none"
					}
				}
			}
			else{
				status.innerHTML = DOMPurify.sanitize(activity.text);//reason for inner HTML: preparsed sanitized HTML from the Anilist API
			}
			Array.from(status.querySelectorAll(".youtube")).forEach(ytLink => {
				create("a",["link","newTab"],ytLink.id,ytLink)
					.href = ytLink.id
			});
			if(activity.user.name === whoAmI && (activity.type === "TEXT" || activity.type === "MESSAGE") && type !== "thread"){
				let edit = create("a",false,translate("$button_edit"),act,"position:absolute;top:2px;right:40px;width:10px;cursor:pointer;font-size:small;color:inherit;");
				if(useScripts.termsFeedNoImages){
					edit.style.right = "80px"
				}
				edit.onclick = function(){
					loading.innerText = "Loading activity " + activity.id + "...";
					if(terms.scrollIntoView){
						terms.scrollIntoView({"behavior": "smooth","block": "start"})
					}
					else{
						document.body.scrollTop = document.documentElement.scrollTop = 0
					}
					if(activity.type === "MESSAGE"){
						authAPIcall(
							`query($id: Int){
								Activity(id: $id){
									... on MessageActivity{
										text:message(asHtml: false)
									}
								}
							}`,
							{id: activity.id},
							data => {
								if(!data){
									onlySpecificActivity = false;
									loading.innerText = "Failed to load message";
								}
								inputArea.focus();
								onlySpecificActivity = activity.id;
								loading.innerText = "Editing message " + activity.id;
								inputArea.value = data.data.Activity.text;
							}
						)
					}
					else{
						authAPIcall(
							`query($id: Int){
								Activity(id: $id){
									... on TextActivity{
										text(asHtml: false)
									}
								}
							}`,
							{id: activity.id},
							data => {
								if(!data){
									onlySpecificActivity = false;
									loading.innerText = "Failed to load activity";
								}
								inputArea.focus();
								onlySpecificActivity = activity.id;
								loading.innerText = "Editing activity " + activity.id;
								inputArea.value = data.data.Activity.text;
							}
						)
					}
				}
			}
			act.classList.add("text");
			actions.style.right = "21px";
			actions.style.bottom = "4px";
		}
		else{
			status = create("span",false," " + activity.status + " ",content);
			if(activity.progress){
				status.innerText += " " + activity.progress + " of "
			}
			if(activity.media.type === "MANGA"){
				if(activity.status === "read chapter" && activity.progress){
					status.innerText = " " + translate("$listActivity_MreadChapter",activity.progress)
				}
				else if(activity.status === "reread chapter" && activity.progress){
					status.innerText = " " + translate("$listActivity_MrepeatingManga",activity.progress)
				}
				else if(activity.status === "dropped" && activity.progress){
					status.innerText = " " + translate("$listActivity_MdroppedManga",activity.progress)
				}
				else if(activity.status === "dropped"){
					status.innerText = " " + translate("$listActivity_droppedManga")
				}
				else if(activity.status === "completed"){
					status.innerText = " " + translate("$listActivity_completedManga")
				}
				else if(activity.status === "plans to read"){
					status.innerText = " " + translate("$listActivity_planningManga")
				}
				else if(activity.status === "paused reading"){
					status.innerText = " " + translate("$listActivity_pausedManga")
				}
				else{
					console.warn("Missing listActivity translation key for:",activity.status)
				}
			}
			else{
				if(activity.status === "watched episode" && activity.progress){
					status.innerText = " " + translate("$listActivity_MwatchedEpisode",activity.progress)
				}
				else if(activity.status === "rewatched episode" && activity.progress){
					status.innerText = " " + translate("$listActivity_MrepeatingAnime",activity.progress)
				}
				else if(activity.status === "dropped" && activity.progress){
					status.innerText = " " + translate("$listActivity_MdroppedAnime",activity.progress)
				}
				else if(activity.status === "dropped"){
					status.innerText = " " + translate("$listActivity_droppedAnime")
				}
				else if(activity.status === "completed"){
					status.innerText = " " + translate("$listActivity_completedAnime")
				}
				else if(activity.status === "plans to watch"){
					status.innerText = " " + translate("$listActivity_planningAnime")
				}
				else if(activity.status === "paused watching"){
					status.innerText = " " + translate("$listActivity_pausedAnime")
				}
				else{
					console.warn("Missing listActivity translation key for:",activity.status)
				}
			}
			let title = activity.media.title.romaji;
			if(useScripts.titleLanguage === "NATIVE" && activity.media.title.native){
				title = activity.media.title.native
			}
			else if(useScripts.titleLanguage === "ENGLISH" && activity.media.title.english){
				title = activity.media.title.english
			}
			dataMedia.add(title);
			title = titlePicker(activity.media);
			let media = create("a",["link","newTab"],title,content);
			media.href = "/" + activity.media.type.toLowerCase() + "/" + activity.media.id + "/" + safeURL(title) + "/";
			if(activity.media.type === "MANGA" && useScripts.CSSgreenManga){
				media.style.color = "rgb(var(--color-green))"
			}
			act.classList.add("list");
			actions.style.right = "21px";
			actions.style.top = "2px";
			if(useScripts.statusBorder){
				let blockerMap = {
					"plans": "PLANNING",
					"watched": "CURRENT",
					"read": "CURRENT",
					"completed": "COMPLETED",
					"paused": "PAUSED",
					"dropped": "DROPPED",
					"rewatched": "REPEATING",
					"reread": "REPEATING"
				};
				let status = blockerMap[
					Object.keys(blockerMap).find(
						key => activity.status.includes(key)
					)
				]
				if(status === "CURRENT"){
					//nothing
				}
				else if(status === "COMPLETED"){
					act.style.borderLeftWidth = "3px";
					act.style.marginLeft = "-2px";
					if(useScripts.CSSgreenManga && activity.media.type === "ANIME"){
						act.style.borderLeftColor = "rgb(var(--color-blue))";
					}
					else{
						act.style.borderLeftColor = "rgb(var(--color-green))";
					}
				}
				else{
					act.style.borderLeftWidth = "3px";
					act.style.marginLeft = "-2px";
					act.style.borderLeftColor = distributionColours[status]
				}
			}
		}
		let link = create("a",["link","newTab"],false,act,"position:absolute;top:2px;right:4px;width:10px;");
		link.appendChild(svgAssets2.link.cloneNode(true));
		if(type === "thread"){
			link.href = "https://anilist.co/forum/thread/" + activity.id + "/"
		}
		else{
			link.href = "https://anilist.co/" + type + "/" + activity.id + "/"
		}
		if(activity.user.name === whoAmI){
			let deleteActivity = create("span","hohDeleteActivity",svgAssets.cross,act);
			deleteActivity.title = "Delete";
			deleteActivity.onclick = function(){
				authAPIcall(
					"mutation($id: Int){Delete" + capitalize(type) + "(id: $id){deleted}}",
					{id: activity.id},
					function(data){
						if(data.data.DeleteActivity.deleted){
							act.style.display = "none"
						}
					}
				)
			}
		}
		dataUsers.add(activity.user.name);
		activity.replies.forEach(reply => {
			dataUsers.add(reply.user.name);
			(reply.text.match(/@(.*?)</g) || []).forEach(user => {
				dataUsers.add(user.slice(1,user.length-1))
			})
		})
	});
	if(terms.scrollIntoView){
		terms.scrollIntoView({"behavior": "smooth","block": "start"})
	}
	else{
		document.body.scrollTop = document.documentElement.scrollTop = 0
	}
	removeChildren(dataUsersList)
	dataUsers.forEach(user => {
		create("option",false,false,dataUsersList)
			.value = user
	});
	removeChildren(dataMediaList)
	dataMedia.forEach(media => {
		create("option",false,false,dataMediaList)
			.value = media
	})
};
let requestPage = function(npage,userID){
	page = npage;
	changeURL();
	let types = [];
	if(!onlyUser.checked || date){
		types.push("MESSAGE")
	}
	if(onlyStatus.checked){
		types.push("ANIME_LIST","MANGA_LIST")
	}
	let specificUser = onlyUserInput.value || whoAmI;
	if(onlyUser.checked && !userID){
		generalAPIcall("query($name:String){User(name:$name){id}}",{name: specificUser},function(data){
			if(data){
				requestPage(npage,data.data.User.id)
			}
			else{
				loading.innerText = "Not Found";
				deleteCacheItem("hohIDlookup" + specificUser.toLowerCase());
				if(!onlyUserInput.value){
					requestPage(npage)
				}
			}
		},"hohIDlookup" + specificUser.toLowerCase());
		return;
	}
	let requestTime = NOW();
	if(onlyForum.checked){
		authAPIcall(
			`
query($page: Int){
Page(page: $page){
	threads(sort:REPLIED_AT_DESC${(onlyUser.checked ? ",userId: " + userID : "")}${onlyMedia.checked && onlyMediaResult.id ? ",mediaCategoryId: " + onlyMediaResult.id : ""}){
		id
		createdAt
		user{name}
		text:body
		likes{name}
		title
		replyCount
	}
}
Viewer{unreadNotificationCount}
}`,
			{page: npage},
			function(data){
				if(!data){
					loading.innerText = translate("$error_connection");
					return
				}
				buildPage(data.data.Page.threads.map(thread => {
					thread.type = "TEXT";
					thread.replies = [];
					thread.text = "<h2>" + thread.title + "</h2>" + thread.text;
					return thread
				}).filter(thread => thread.replyCount || !onlyReplies.checked),"thread",requestTime);
				handleNotifications(data)
			}
		)
	}
	else if(onlyReviews.checked){
		authAPIcall(
			`
query($page: Int){
Page(page: $page,perPage: 20){
	reviews(sort:CREATED_AT_DESC${(onlyUser.checked ? ",userId: " + userID : "")}${onlyMedia.checked && onlyMediaResult.id ? ",mediaId: " + onlyMediaResult.id : ""}){
		id
		createdAt
		user{name}
		media{
			id
			type
			title{romaji native english}
		}
		summary
		body
		rating
		ratingAmount
	}
}
Viewer{unreadNotificationCount}
}`,
			{page: npage},
			function(data){
				if(!data){
					loading.innerText = translate("$error_connection");
					return
				}
				buildPage(data.data.Page.reviews.map(review => {
					review.type = "TEXT";
					review.likes = [];
					review.replies = [{
						id: review.id,
						user: review.user,
						likes: [],
						text: review.body,
						createdAt: review.createdAt
					}];
					review.text = review.summary;
					return review
				}),"review",requestTime);
				handleNotifications(data)
			}
		)
	}
	else{
		authAPIcall(
			`
query($page: Int,$types: [ActivityType]){
Page(page: $page){
	activities(${(onlyUser.checked || onlyGlobal.checked ? "" : "isFollowing: true,")}sort: ID_DESC,type_not_in: $types${(onlyReplies.checked ? ",hasReplies: true" : "")}${(onlyUser.checked ? ",userId: " + userID : "")}${(onlyGlobal.checked ? ",hasRepliesOrTypeText: true" : "")}${onlyMedia.checked && onlyMediaResult.id ? ",mediaId: " + onlyMediaResult.id : ""}${date ? ",createdAt_greater: " + ((new Date(date)).valueOf()/1000) + ",createdAt_lesser: " + ((new Date(date)).valueOf()/1000 + 24*60*60) : ""}){
		... on MessageActivity{
			id
			type
			createdAt
			user:messenger{name}
			text:message
			likes{name}
			replies{
				id
				user{name}
				likes{name}
				text
				createdAt
			}
		}
		... on TextActivity{
			id
			type
			createdAt
			user{name}
			text
			likes{name}
			replies{
				id
				user{name}
				likes{name}
				text
				createdAt
			}
		}
		... on ListActivity{
			id
			type
			createdAt
			user{name}
			status
			progress
			media{
				id
				type
				title{romaji native english}
			}
			likes{name}
			replies{
				id
				user{name}
				likes{name}
				text
				createdAt
			}
		}
	}
}
Viewer{unreadNotificationCount}
}`,
			{page: npage,types:types},
			function(data){
				if(!data){
					loading.innerText = translate("$error_connection");
					return
				}
				buildPage(data.data.Page.activities,"activity",requestTime);
				handleNotifications(data)
			}
		)
	}
};
requestPage(page);
let setInputs = function(){
	statusInputTitle.style.display = "none";
	if(onlyReviews.checked){
		inputArea.placeholder = "Writing reviews not supported yet...";
		publishButton.innerText = translate("$button_publish")
	}
	else if(onlyForum.checked){
		inputArea.placeholder = translate("$placeholder_forum");
		statusInputTitle.style.display = "block";
		publishButton.innerText = translate("$button_publish")
	}
	else if(onlyUser.checked && onlyUserInput.value && onlyUserInput.value.toLowerCase() !== whoAmI.toLowerCase()){
		inputArea.placeholder = translate("$placeholder_message");
		publishButton.innerText = "Send"
	}
	else{
		inputArea.placeholder = translate("$placeholder_status");
		publishButton.innerText = translate("$button_publish")
	}
};
topPrevious.onclick = function(){
	loading.innerText = translate("$loading");
	if(page === 1){
		requestPage(1)
	}
	else{
		requestPage(page - 1)
	}
};
topNext.onclick = function(){
	loading.innerText = translate("$loading");
	requestPage(page + 1)
};
onlyGlobal.onchange = function(){
	loading.innerText = translate("$loading");
	statusInputTitle.style.display = "none";
	inputArea.placeholder = translate("$placeholder_status");
	onlyUser.checked = false;
	onlyForum.checked = false;
	onlyReviews.checked = false;
	requestPage(1)
};
onlyStatus.onchange = function(){
	loading.innerText = translate("$loading");
	onlyForum.checked = false;
	onlyReviews.checked = false;
	onlyMedia.checked = false;
	requestPage(1)
};
onlyReplies.onchange = function(){
	loading.innerText = translate("$loading");
	onlyReviews.checked = false;
	requestPage(1)
};
onlyUser.onchange = function(){
	setInputs();
	loading.innerText = translate("$loading");
	onlyGlobal.checked = false;
	requestPage(1)
};
onlyForum.onchange = function(){
	setInputs();
	loading.innerText = translate("$loading");
	onlyGlobal.checked = false;
	onlyStatus.checked = false;
	onlyReviews.checked = false;
	requestPage(1)
};
onlyMedia.onchange = function(){
	setInputs();
	loading.innerText = translate("$loading");
	requestPage(1)
};
onlyReviews.onchange = function(){
	setInputs();
	onlyGlobal.checked = false;
	onlyStatus.checked = false;
	onlyForum.checked = false;
	onlyReplies.checked = false;
	loading.innerText = translate("$loading");
	requestPage(1)
}
let oldOnlyUser = "";
onlyUserInput.onfocus = function(){
	oldOnlyUser = onlyUserInput.value
};
let oldOnlyMedia = "";
onlyMediaInput.onfocus = function(){
	oldOnlyMedia = onlyMediaInput.value
};
onlyMediaInput.onblur = function(){
	if(onlyMediaInput.value === oldOnlyMedia){
		return
	}
	if(onlyMediaInput.value === ""){
		removeChildren(mediaDisplayResults)
		onlyMediaResult.id = false
	}
	else{
		if(!mediaDisplayResults.childElementCount){
			create("span",false,translate("$searching"),mediaDisplayResults);
		}
		generalAPIcall(`
			query($search: String){
				Page(page:1,perPage:5){
					media(search:$search,sort:SEARCH_MATCH){
						title{romaji native english}
						id
						type
					}
				}
			}`,
			{search: onlyMediaInput.value},
			function(data){
				removeChildren(mediaDisplayResults)
				data.data.Page.media.forEach((media,index) => {
					let result = create("div",["hohSearchResult",media.type.toLowerCase()],false,mediaDisplayResults);
					let title = create("span",false,titlePicker(media),result);
					if(useScripts.accessToken){
						let editButton = create("span","termsFeedEdit","edit",result);
						editButton.onclick = function(){
							event.stopPropagation();
							event.preventDefault();
							authAPIcall(`
								query($id: Int,$userName: String){
									MediaList(
										userName: $userName,
										mediaId: $id
									){
										progress
										score
										status
										id
									}
								}`,
								{id: media.id,userName: whoAmI},
								function(entry,paras,errors){
									if(!entry && errors.errors[0].message !== "Not Found."){
										console.log(errors);
										return
									}
									let editor = createDisplayBox("width:600px;height:500px;top:100px;left:220px",titlePicker(media));
									let progressLabel = create("p",false,translate("$preview_progress"),editor);
									let progressInput = create("input","hohInput",false,editor);
									progressInput.type = "number";
									progressInput.min = 0;
									if(entry && entry.data.MediaList.progress){
										progressInput.value = entry.data.MediaList.progress
									}
									else{
										progressInput.value = 0
									}

									create("hr",false,false,editor);

									let saveButton = create("button","hohButton","Save",editor);
									saveButton.onclick = function(){
										if(entry){
											authAPIcall(
												`mutation($progress: Int,$id: Int){
													SaveMediaListEntry(progress: $progress,id:$id){id}
												}`,
												{id: entry.data.MediaList.id, progress: parseInt(progressInput.value)},
												data => {}
											)
										}
										else{
											authAPIcall(
												`mutation($progress: Int,$id: Int){
													SaveMediaListEntry(progress: $progress,mediaId:$id){id}
												}`,
												{id: media.id, progress: parseInt(progressInput.value)},
												data => {}
											)
										}
									}
								}
							)
						}
					}
					if(index === 0){
						result.classList.add("selected");
						onlyMediaResult.id = media.id;
						onlyMediaResult.type = media.type
					}
					result.onclick = function(){
						mediaDisplayResults.querySelector(".selected").classList.toggle("selected");
						result.classList.add("selected");
						onlyMediaResult.id = media.id;
						onlyMediaResult.type = media.type;
						onlyMedia.checked = true;
						onlyStatus.checked = false;
						loading.innerText = translate("$loading");
						requestPage(1)
					}
				});
				if(data.data.Page.media.length){
					onlyMedia.checked = true;
					onlyStatus.checked = false;
					loading.innerText = translate("$loading");
					requestPage(1)
				}
				else{
					create("span",false,translate("$noResults"),mediaDisplayResults);
					onlyMediaResult.id = false
				}
			}
		)
	}
};
onlyUserInput.onblur = function(){
	if(onlyForum.checked){
		inputArea.placeholder = translate("$placeholder_forum");
		publishButton.innerText = translate("$button_publish")
	}
	else if(
		(onlyUser.checked && onlyUserInput.value && onlyUserInput.value.toLowerCase() !== whoAmI.toLowerCase())
		|| (oldOnlyUser !== onlyUserInput.value && onlyUserInput.value !== "")
	){
		inputArea.placeholder = translate("$placeholder_message");
		publishButton.innerText = "Send"
	}
	else{
		inputArea.placeholder = translate("$placeholder_status");
		publishButton.innerText = translate("$button_publish")
	}
	if(oldOnlyUser !== onlyUserInput.value && onlyUserInput.value !== ""){
		loading.innerText = translate("$loading");
		onlyUser.checked = true;
		requestPage(1)
	}
	else if(onlyUser.checked && oldOnlyUser !== onlyUserInput.value){
		loading.innerText = translate("$loading");
		requestPage(1)
	}
};
onlyUserInput.addEventListener("keyup",function(event){
	if(event.key === "Enter"){
		onlyUserInput.blur()
	}
});
onlyMediaInput.addEventListener("keyup",function(event){
	if(event.key === "Enter"){
		onlyMediaInput.blur()
	}
});
inputArea.onfocus = function(){
	cancelButton.style.display = "inline";
	publishButton.style.display = "inline";
	previewArea.style.display = "inline"
};
inputArea.oninput = function(){
	previewArea.innerHTML = DOMPurify.sanitize(makeHtml(inputArea.value))
}
cancelButton.onclick = function(){
	inputArea.value = "";
	inputArea.rows = 3;
	inputArea.style.height = "unset";
	previewArea.innerText = "";
	cancelButton.style.display = "none";
	publishButton.style.display = "none";
	previewArea.style.display = "none";
	loading.innerText = "";
	onlySpecificActivity = false;
	document.activeElement.blur()
};
publishButton.onclick = function(){
	if(onlyForum.checked){
		alert(translate("$notImplemented"));
		//loading.innerText = "Publishing forum post...";
		return
	}
	else if(onlyReviews.checked){
		alert(translate("$notImplemented"));
		//loading.innerText = "Publishing review...";
		return
	}
	else if(onlySpecificActivity){
		loading.innerText = "Publishing...";
		let mutation;
		if(onlyUser.checked && onlyUserInput.value && onlyUserInput.value.toLowerCase() !== whoAmI.toLowerCase()){
			mutation = "mutation($text: String,$id: Int){SaveMessageActivity(id: $id,message: $text){id}}"
		}
		else{
			mutation = "mutation($text: String,$id: Int){SaveTextActivity(id: $id,text: $text){id}}"
		}
		authAPIcall(
			mutation,
			{text: inputArea.value,id: onlySpecificActivity},
			function(data){
				onlySpecificActivity = false;
				requestPage(1)
			}
		)
	}
	else if(onlyUser.checked && onlyUserInput.value && onlyUserInput.value.toLowerCase() !== whoAmI.toLowerCase()){
		loading.innerText = "Sending Message...";
		generalAPIcall("query($name:String){User(name:$name){id}}",{name: onlyUserInput.value},function(data){
			if(data){
				authAPIcall(
					"mutation($text: String,$recipientId: Int){SaveMessageActivity(message: $text,recipientId: $recipientId){id}}",
					{
						text: emojiSanitize(inputArea.value),
						recipientId: data.data.User.id
					},
					function(data){
						requestPage(1)
					}
				)
			}
			else{
				loading.innerText = "Not Found"
			}
		},"hohIDlookup" + onlyUserInput.value.toLowerCase())
	}
	else{
		loading.innerText = "Publishing...";
		authAPIcall(
			"mutation($text: String){SaveTextActivity(text: $text){id}}",
			{text: emojiSanitize(inputArea.value)},
			function(data){
				requestPage(1)
			}
		)
	}
	inputArea.value = "";
	previewArea.innerText = "";
	cancelButton.style.display = "none";
	publishButton.style.display = "none";
	document.activeElement.blur()
};
let sideBarContent = create("div","sidebar",false,feed,"position:absolute;left:20px;top:200px;max-width:150px;");
let buildPreview = function(data){
	if(!data){
		return
	}
	removeChildren(sideBarContent)
	let mediaLists = data.data.Page.mediaList.map(mediaList => {
		if(aliases.has(mediaList.media.id)){
			mediaList.media.title.userPreferred = aliases.get(mediaList.media.id)
		}
		return mediaList
	});
	mediaLists.slice(0,20).forEach(mediaList => {
		let mediaEntry = create("div",false,false,sideBarContent,"border-bottom: solid;border-bottom-width: 1px;margin-bottom: 10px;border-radius: 3px;padding: 2px;");
		create("a","link",mediaList.media.title.userPreferred,mediaEntry,"min-height:40px;display:inline-block;")
			.href = "/anime/" + mediaList.media.id + "/" + safeURL(mediaList.media.title.userPreferred);
		let progress = create("div",false,false,mediaEntry,"font-size: small;");
		create("span",false,translate("$preview_progress") + " ",progress);
		let number = create("span",false,mediaList.progress + (mediaList.media.episodes ? "/" + mediaList.media.episodes : ""),progress);
		let plusProgress = create("span",false,"+",progress,"padding-left:5px;padding-right:5px;cursor:pointer;");
		let isBlocked = false;
		plusProgress.onclick = function(e){
			if(isBlocked){
				return
			}
			if(mediaList.media.episodes){
				if(mediaList.progress < mediaList.media.episodes){
					mediaList.progress++;
					number.innerText = mediaList.progress + (mediaList.media.episodes ? "/" + mediaList.media.episodes : "");
					isBlocked = true;
					setTimeout(function(){
						isBlocked = false;
					},300);
					if(mediaList.progress === mediaList.media.episodes){
						plusProgress.innerText = "";
						if(mediaList.status === "REWATCHING"){//don't overwrite the existing end date
							authAPIcall(
								`mutation($progress: Int,$id: Int){
									SaveMediaListEntry(progress: $progress,id:$id,status:COMPLETED){id}
								}`,
								{id: mediaList.id,progress: mediaList.progress},
								data => {}
							)
						}
						else{
							authAPIcall(
								`mutation($progress: Int,$id: Int,$date:FuzzyDateInput){
									SaveMediaListEntry(progress: $progress,id:$id,status:COMPLETED,completedAt:$date){id}
								}`,
								{
									id: mediaList.id,
									progress: mediaList.progress,
									date: {
										year: (new Date()).getUTCFullYear(),
										month: (new Date()).getUTCMonth() + 1,
										day: (new Date()).getUTCDate(),
									}
								},
								data => {}
							)
						}
						mediaEntry.style.backgroundColor = "rgba(0,200,0,0.1)"
					}
					else{
						authAPIcall(
							`mutation($progress: Int,$id: Int){
								SaveMediaListEntry(progress: $progress,id:$id){id}
							}`,
							{id: mediaList.id,progress: mediaList.progress},
							data => {}
						)
					}
					localStorage.setItem("hohListPreview",JSON.stringify(data))
				}
			}
			else{
				mediaList.progress++;
				number.innerText = mediaList.progress + (mediaList.media.episodes ? "/" + mediaList.media.episodes : "");
				isBlocked = true;
				setTimeout(function(){
					isBlocked = false;
				},300);
				authAPIcall(
					`mutation($progress: Int,$id: Int){
						SaveMediaListEntry(progress: $progress,id:$id){id}
					}`,
					{id: mediaList.id,progress: mediaList.progress},
					data => {}
				);
				localStorage.setItem("hohListPreview",JSON.stringify(data))
			}
			e.stopPropagation();
			e.preventDefault();
			return false
		}
	})
};
authAPIcall(
	`query($name: String){
		Page(page:1){
			mediaList(type:ANIME,status_in:[CURRENT,REPEATING],userName:$name,sort:UPDATED_TIME_DESC){
				id
				priority
				scoreRaw: score(format: POINT_100)
				progress
				status
				media{
					id
					episodes
					coverImage{large color}
					title{userPreferred}
					nextAiringEpisode{episode timeUntilAiring}
				}
			}
		}
	}`,{name: whoAmI},function(data){
		localStorage.setItem("hohListPreview",JSON.stringify(data));
		buildPreview(data,true)
	}
);
buildPreview(JSON.parse(localStorage.getItem("hohListPreview")),false)
}
})
//end modules/termsFeed.js
//begin modules/tweets.js
exportModule({
	id: "tweets",
	description: "$setting_tweets",
	extendedDescription: `
This works by runnig Twitter's official embedding script. But since loading external code is not allowed for Firefox addons, this setting will only work in userscript mode.
Be adviced that Twitter embedding displays NSFW content no differently than other content.
	`,
	isDefault: false,
	categories: ["Feeds"],
	visible: true,
	boneless_disabled: true
})

let tweetLoop = setInterval(function(){
	if(useScripts.tweets){
		document.querySelectorAll(
			`.markdown a[href^="https://twitter.com/"][href*="/status/"]`
		).forEach(tweet => {
			if(tweet.classList.contains("hohEmbedded")){
				return
			}
			let tweetMatch = tweet.href.match(/^https:\/\/twitter\.com\/(.+?)\/status\/\d+/)
			if(!tweetMatch || tweet.href !== tweet.innerText){
				return
			}
			tweet.classList.add("hohEmbedded");
			let tweetBlockQuote = create("blockquote",false,false,tweet);
			tweetBlockQuote.classList.add("twitter-tweet");
			if(document.body.classList.contains("site-theme-dark")){
				tweetBlockQuote.setAttribute("data-theme","dark")
			}
			let tweetBlockQuoteInner = create("p",false,false,tweetBlockQuote);
			tweetBlockQuoteInner.setAttribute("lang","en");
			tweetBlockQuoteInner.setAttribute("dir","ltr");
			let tweetBlockQuoteInnerInner = create("a","hohEmbedded","Loading tweet by " + tweetMatch[1] + "...",tweetBlockQuoteInner)
				.href = tweet.href;
			if(window.GM_xmlhttpRequest){
				/*
					Only fetch external script if running in userscript mode (window.GM_xmlhttpRequest is only available inside a userscript manager)
					This is not allowed for Firefox addons, even if this setting is disabled by default.
					Hence this check
				*/
				if(document.getElementById("hohTwitterEmbed") && window.twttr){
					window.twttr.widgets.load(tweet)
				}
				else{
					let script = document.createElement("script");
					script.setAttribute("src","https://platform.twitter.com/widgets.js");
					script.setAttribute("async","");
					script.id = "hohTwitterEmbed";
					document.head.appendChild(script)
				}
			}
		})
	}
},400);
//end modules/tweets.js
//begin modules/twoColumnFeed.js
exportModule({
	id: "twoColumnFeed",
	description: "$twoColumnFeed_description",
	isDefault: false,
	importance: 0,
	categories: ["Feeds"],
	visible: true,
	css: `
.home .activity-feed{
	grid-template-columns: repeat(2,1fr);
	display: grid;
	grid-column-gap: 15px;
}
.home .activity-feed .activity-entry.activity-text{
	grid-column: 1/3;
}
.home .activity-feed .activity-entry{
	margin-bottom: 15px;
}
`
})

if(useScripts.twoColumnFeed && !useScripts.CSSverticalNav){
	moreStyle.textContent += `
.home{
	margin-left: -15px;
	margin-right: -15px;
}
@media(min-width: 1540px){
	.home{
		margin-left: -95px;
		margin-right: -95px;
	}
}
@media(min-width:1040px) and (max-width:1540px){
	.home{
		margin-left: -45px;
		margin-right: -45px;
	}
}
@media(min-width:760px) and (max-width:1040px){
	.home{
		margin-left: -25px;
		margin-right: -25px;
	}
}
`
}
//end modules/twoColumnFeed.js
//begin modules/unicodifier.js
exportModule({
	id: "unicodifier",
	description: "$module_unicodifier_description",
	extendedDescription: "$module_unicodifier_extendedDescription",
	isDefault: true,
	importance: 0,
	categories: ["Feeds","Forum"],
	visible: true
})

setInterval(function(){
	Array.from(document.querySelectorAll(".activity-edit textarea.el-textarea__inner,.editor textarea.el-textarea__inner")).forEach(editor => {
		if(editor.value){
			editor.value = emojiSanitize(editor.value);
			editor.dispatchEvent(new Event("input",{bubbles: false}))
		}
	})
},2000)
//end modules/unicodifier.js
//begin modules/videoMimeTypeFixer.js
exportModule({
	id: "videoMimeTypeFixer",
	description: "Detect video mime type by file extension [you probably don't need this]",
	extendedDescription: `
Anilist by default serves all video as "video/webm".
However, it's common to use non-webm video, as brower support is common.
But some browsers don't autodetect the proper mime type. This module adds a mime type based on the file extension, which may help if the video won't play otherwise.
	`,
	isDefault: false,
	categories: ["Feeds"],
	visible: true
})

if(useScripts.videoMimeTypeFixer){
	setInterval(function(){
		document.querySelectorAll('source[src$=".av1"][type="video/webm"]').forEach(video => {
			video.setAttribute("type","video/av1")
		})
		document.querySelectorAll('source[src$=".mp4"][type="video/webm"]').forEach(video => {
			video.setAttribute("type","video/mp4")
		})
	},2000)
}
//end modules/videoMimeTypeFixer.js
//begin modules/viewAdvancedScores.js
function viewAdvancedScores(url){
	let URLstuff = url.match(/^https:\/\/anilist\.co\/user\/(.+)\/(anime|manga)list\/?/);
	let name = decodeURIComponent(URLstuff[1]);
	generalAPIcall(
		`query($name:String!){
			User(name:$name){
				mediaListOptions{
					animeList{advancedScoringEnabled}
					mangaList{advancedScoringEnabled}
				}
			}
		}`,
		{name: name},function(data){
		if(
			!(
				(URLstuff[2] === "anime" && data.data.User.mediaListOptions.animeList.advancedScoringEnabled)
				|| (URLstuff[2] === "manga" && data.data.User.mediaListOptions.mangaList.advancedScoringEnabled)
			)
		){
			return
		}
		generalAPIcall(
			`query($name:String!,$listType:MediaType){
				MediaListCollection(userName:$name,type:$listType){
					lists{
						entries{mediaId advancedScores}
					}
				}
			}`,
			{name: name,listType: URLstuff[2].toUpperCase()},
			function(data2){
				let list = new Map(returnList(data2,true).map(a => [a.mediaId,a.advancedScores]));
				let finder = function(){
					if(!document.URL.match(/^https:\/\/anilist\.co\/user\/(.+)\/(anime|manga)list\/?/)){
						return
					}
					document.querySelectorAll(
						".list-entries .entry .title > a:not(.hohAdvanced)"
					).forEach(function(entry){
						entry.classList.add("hohAdvanced");
						let key = parseInt(entry.href.match(/\/(\d+)\//)[1]);
						let dollar = create("span",["hohAdvancedDollar","noselect"],"$",entry.parentNode);
						let advanced = list.get(key);
						let reasonable = Object.keys(advanced).map(
							key => [key,advanced[key]]
						).filter(
							a => a[1]
						);
						dollar.title = reasonable.map(
							a => a[0] + ": " + a[1]
						).join("\n");
						if(!reasonable.length){
							dollar.style.display = "none"
						}
					});
					setTimeout(finder,1000);
				};finder();
			}
		)
	})
}
//end modules/viewAdvancedScores.js
//begin modules/webmResize.js
exportModule({
	id: "webmResize",
	description: "Resize videos with a width in the URL hash (like #220 or #40%)",
	isDefault: true,
	categories: ["Feeds"],
	visible: true
})

if(useScripts.webmResize){
	setInterval(function(){
		document.querySelectorAll("source").forEach(video => {
			let hashMatch = (video.src || "").match(/#(image)?(\d+(\.\d+)?%?)$/);
			if(hashMatch && !video.parentNode.width){
				video.parentNode.setAttribute("width",hashMatch[2])
			}
			if(video.src.match(/#image\d*(\.\d+)?%?$/)){
				video.parentNode.removeAttribute("controls")
			}
		})
	},500)
}
//end modules/webmResize.js
//begin modules/yearStepper.js
exportModule({
	id: "yearStepper",
	description: "Add buttons to step the year slider up and down",
	isDefault: true,
	importance: 0,
	categories: ["Lists"],
	visible: true,
	urlMatch: function(url,oldUrl){
		return url.match(/\/user\/.*\/(anime|manga)list/)
	},
	code: function(){
		let yearStepper = function(){
			if(!location.pathname.match(/\/user\/.*\/(anime|manga)list/)){
				return
			}
			let slider = document.querySelector(".el-slider");
			if(!slider){
				setTimeout(yearStepper,200);
				return
			}
			const maxYear = parseInt(slider.getAttribute("aria-valuemax"));
			const minYear = parseInt(slider.getAttribute("aria-valuemin"));
			const yearRange = maxYear - minYear;
			let clickSlider = function(year){//thanks, mator!
				let runway = slider.children[0];
				let r = runway.getBoundingClientRect();
				const x = r.left + r.width * ((year - minYear) / yearRange);
				const y = r.top + r.height / 2;
				runway.dispatchEvent(new MouseEvent("click",{
					clientX: x,
					clientY: y
				}))
			};
			let adjuster = function(delta){
				let heading = slider.previousElementSibling;
				if(heading.children.length === 0){
					if(delta === -1){
						clickSlider(maxYear)
					}
					else{
						clickSlider(minYear)
					}
				}
				else{
					let current = parseInt(heading.children[0].innerText);
					clickSlider(current + delta)
				}
			};
			if(document.querySelector(".hohStepper")){
				return
			}
			slider.style.position = "relative";
			let decButton = create("span","hohStepper","<",slider,"left:-27px;font-size:200%;top:0px;");
			let incButton = create("span","hohStepper",">",slider,"right:-27px;font-size:200%;top:0px;");
			decButton.onclick = function(){
				adjuster(-1)
			};
			incButton.onclick = function(){
				adjuster(1)
			}
		};yearStepper()
	},
	css: `
.hohStepper{
	cursor: pointer;
	position: absolute;
	opacity: 0.5;
}
.el-slider:hover .hohStepper{
	opacity: 1;
}`
})
//end modules/yearStepper.js
//begin modules/youtubeFullscreen.js
exportModule({
	id: "youtubeFullscreen",
	description: "Enable fullscreen button on youtube videos",
	isDefault: false,
	categories: ["Feeds"],
	visible: true
})

if(useScripts.youtubeFullscreen){
	setInterval(function(){
		document.querySelectorAll(".youtube iframe").forEach(video => {
			if(!video.hasAttribute("allowfullscreen")){
				video.setAttribute("allowfullscreen","allowfullscreen");
				video.setAttribute("frameborder","0");
				video.setAttribute("src",video.getAttribute("src").replace("autohide=1","autohide=0"))
			}
		})
	},1000)
}
//end modules/youtubeFullscreen.js

//create your own module
//make a javascript file, called yourModule.js, in the directory "modules"
//include the following code:

exportModule({
	id: "howto",//an unique identified for your module
	description: "what your module does",
	extendedDescription: `
A more detailed description of what your module does. (optional)

This appears when people click the "more info" icon (🛈) on the settings page.
	`,
	isDefault: false,
	importance: 0,//a number, which determines the order of the settings page. Higher numbers are more important. Leave it as 0 if unsure.
	categories: [],//what categories your module belongs in
	//Notifications, Feeds, Forum, Lists, Profiles, Stats, Media, Navigation, Browse, Script, Login, Newly Added
	visible: false,//if the module should be visible in the settings (REMEMBER TO CHANGE THIS TO TRUE!)
	urlMatch: function(url,oldUrl){//a function that returns true when on the parts of the site you want it to run. url is the current url, oldUrl is the previous page
		//example: return url === "https://anilist.co/reviews"
		return false;
	},
	code: function(){
		//your code goes here
	},
	css: ""//css rules you need
})

//your module can also have extra code and utility functions

})()
//wanna translate Automail? https://github.com/hohMiyazawa/Automail/issues/69
//Automail built at 1652949645